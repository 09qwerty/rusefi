###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:46 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\TIMv1\icu_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\TIMv1\icu_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\i #
#                       cu_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ic #
#                       u_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\TIMv1\icu_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          /*
     17             Concepts and parts of this file have been contributed by Fabio Utzig and
     18             Xo Wang.
     19           */
     20          
     21          /**
     22           * @file    STM32/icu_lld.c
     23           * @brief   STM32 ICU subsystem low level driver header.
     24           *
     25           * @addtogroup ICU
     26           * @{
     27           */
     28          
     29          #include "ch.h"
     30          #include "hal.h"
     31          
     32          #if HAL_USE_ICU || defined(__DOXYGEN__)
     33          
     34          /*===========================================================================*/
     35          /* Driver local definitions.                                                 */
     36          /*===========================================================================*/
     37          
     38          /*===========================================================================*/
     39          /* Driver exported variables.                                                */
     40          /*===========================================================================*/
     41          
     42          /**
     43           * @brief   ICUD1 driver identifier.
     44           * @note    The driver ICUD1 allocates the complex timer TIM1 when enabled.
     45           */
     46          #if STM32_ICU_USE_TIM1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     47          ICUDriver ICUD1;
   \                     ICUD1:
   \   00000000                      DS8 24
     48          #endif
     49          
     50          /**
     51           * @brief   ICUD2 driver identifier.
     52           * @note    The driver ICUD1 allocates the timer TIM2 when enabled.
     53           */
     54          #if STM32_ICU_USE_TIM2 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     55          ICUDriver ICUD2;
   \                     ICUD2:
   \   00000000                      DS8 24
     56          #endif
     57          
     58          /**
     59           * @brief   ICUD3 driver identifier.
     60           * @note    The driver ICUD1 allocates the timer TIM3 when enabled.
     61           */
     62          #if STM32_ICU_USE_TIM3 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     63          ICUDriver ICUD3;
   \                     ICUD3:
   \   00000000                      DS8 24
     64          #endif
     65          
     66          /**
     67           * @brief   ICUD4 driver identifier.
     68           * @note    The driver ICUD4 allocates the timer TIM4 when enabled.
     69           */
     70          #if STM32_ICU_USE_TIM4 || defined(__DOXYGEN__)
     71          ICUDriver ICUD4;
     72          #endif
     73          
     74          /**
     75           * @brief   ICUD5 driver identifier.
     76           * @note    The driver ICUD5 allocates the timer TIM5 when enabled.
     77           */
     78          #if STM32_ICU_USE_TIM5 || defined(__DOXYGEN__)
     79          ICUDriver ICUD5;
     80          #endif
     81          
     82          /**
     83           * @brief   ICUD8 driver identifier.
     84           * @note    The driver ICUD8 allocates the timer TIM8 when enabled.
     85           */
     86          #if STM32_ICU_USE_TIM8 || defined(__DOXYGEN__)
     87          ICUDriver ICUD8;
     88          #endif
     89          
     90          /**
     91           * @brief   ICUD9 driver identifier.
     92           * @note    The driver ICUD9 allocates the timer TIM9 when enabled.
     93           */
     94          #if STM32_ICU_USE_TIM9 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     95          ICUDriver ICUD9;
   \                     ICUD9:
   \   00000000                      DS8 24
     96          #endif
     97          
     98          /*===========================================================================*/
     99          /* Driver local variables and types.                                         */
    100          /*===========================================================================*/
    101          
    102          /*===========================================================================*/
    103          /* Driver local functions.                                                   */
    104          /*===========================================================================*/
    105          
    106          /**
    107           * @brief   Shared IRQ handler.
    108           *
    109           * @param[in] icup      pointer to the @p ICUDriver object
    110           */

   \                                 In section .text, align 2, keep-with-next
    111          static void icu_lld_serve_interrupt(ICUDriver *icup) {
   \                     icu_lld_serve_interrupt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    112            uint16_t sr;
    113          
    114            sr  = icup->tim->SR;
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0005             MOVS     R5,R0
    115            sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4005             ANDS     R5,R0,R5
    116            icup->tim->SR = ~sr;
   \   00000012   0x68E0             LDR      R0,[R4, #+12]
   \   00000014   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   0x43E9             MVNS     R1,R5
   \   00000018   0x6101             STR      R1,[R0, #+16]
    117            if (icup->config->channel == ICU_CHANNEL_1) {
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x7D00             LDRB     R0,[R0, #+20]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD118             BNE.N    ??icu_lld_serve_interrupt_0
    118              if ((sr & STM32_TIM_SR_CC1IF) != 0)
   \   00000022   0x07A8             LSLS     R0,R5,#+30
   \   00000024   0xD50A             BPL.N    ??icu_lld_serve_interrupt_1
    119                _icu_isr_invoke_period_cb(icup);
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E03             CMP      R6,#+3
   \   00000032   0xD003             BEQ.N    ??icu_lld_serve_interrupt_1
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x6861             LDR      R1,[R4, #+4]
   \   00000038   0x68C9             LDR      R1,[R1, #+12]
   \   0000003A   0x4788             BLX      R1
    120              if ((sr & STM32_TIM_SR_CC2IF) != 0)
   \                     ??icu_lld_serve_interrupt_1:
   \   0000003C   0x0768             LSLS     R0,R5,#+29
   \   0000003E   0xD521             BPL.N    ??icu_lld_serve_interrupt_2
    121                _icu_isr_invoke_width_cb(icup);
   \   00000040   0x7820             LDRB     R0,[R4, #+0]
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0xD01E             BEQ.N    ??icu_lld_serve_interrupt_2
   \   00000046   0x2005             MOVS     R0,#+5
   \   00000048   0x7020             STRB     R0,[R4, #+0]
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x6861             LDR      R1,[R4, #+4]
   \   0000004E   0x6889             LDR      R1,[R1, #+8]
   \   00000050   0x4788             BLX      R1
   \   00000052   0xE017             B.N      ??icu_lld_serve_interrupt_2
    122            } else {
    123              if ((sr & STM32_TIM_SR_CC1IF) != 0)
   \                     ??icu_lld_serve_interrupt_0:
   \   00000054   0x07A8             LSLS     R0,R5,#+30
   \   00000056   0xD508             BPL.N    ??icu_lld_serve_interrupt_3
    124                _icu_isr_invoke_width_cb(icup);
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x2803             CMP      R0,#+3
   \   0000005C   0xD005             BEQ.N    ??icu_lld_serve_interrupt_3
   \   0000005E   0x2005             MOVS     R0,#+5
   \   00000060   0x7020             STRB     R0,[R4, #+0]
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x6861             LDR      R1,[R4, #+4]
   \   00000066   0x6889             LDR      R1,[R1, #+8]
   \   00000068   0x4788             BLX      R1
    125              if ((sr & STM32_TIM_SR_CC2IF) != 0)
   \                     ??icu_lld_serve_interrupt_3:
   \   0000006A   0x0768             LSLS     R0,R5,#+29
   \   0000006C   0xD50A             BPL.N    ??icu_lld_serve_interrupt_2
    126                _icu_isr_invoke_period_cb(icup);
   \   0000006E   0x7820             LDRB     R0,[R4, #+0]
   \   00000070   0x0006             MOVS     R6,R0
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x7020             STRB     R0,[R4, #+0]
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E03             CMP      R6,#+3
   \   0000007A   0xD003             BEQ.N    ??icu_lld_serve_interrupt_2
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x6861             LDR      R1,[R4, #+4]
   \   00000080   0x68C9             LDR      R1,[R1, #+12]
   \   00000082   0x4788             BLX      R1
    127            }
    128            if ((sr & STM32_TIM_SR_UIF) != 0)
   \                     ??icu_lld_serve_interrupt_2:
   \   00000084   0x07E8             LSLS     R0,R5,#+31
   \   00000086   0xD503             BPL.N    ??icu_lld_serve_interrupt_4
    129              _icu_isr_invoke_overflow_cb(icup);
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x6861             LDR      R1,[R4, #+4]
   \   0000008C   0x6909             LDR      R1,[R1, #+16]
   \   0000008E   0x4788             BLX      R1
    130          }
   \                     ??icu_lld_serve_interrupt_4:
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
    131          
    132          /*===========================================================================*/
    133          /* Driver interrupt handlers.                                                */
    134          /*===========================================================================*/
    135          
    136          #if STM32_ICU_USE_TIM1
    137          #if !defined(STM32_TIM1_UP_HANDLER)
    138          #error "STM32_TIM1_UP_HANDLER not defined"
    139          #endif
    140          /**
    141           * @brief   TIM1 compare interrupt handler.
    142           * @note    It is assumed that the various sources are only activated if the
    143           *          associated callback pointer is not equal to @p NULL in order to not
    144           *          perform an extra check in a potentially critical interrupt handler.
    145           *
    146           * @isr
    147           */

   \                                 In section .text, align 2, keep-with-next
    148          CH_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
   \                     VectorA4:
   \   00000000   0xB580             PUSH     {R7,LR}
    149          
    150            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    151          
    152            icu_lld_serve_interrupt(&ICUD1);
   \   00000006   0x....             LDR.N    R0,??DataTable7
   \   00000008   0x.... 0x....      BL       icu_lld_serve_interrupt
    153          
    154            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    155          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    156          
    157          #if !defined(STM32_TIM1_CC_HANDLER)
    158          #error "STM32_TIM1_CC_HANDLER not defined"
    159          #endif
    160          /**
    161           * @brief   TIM1 compare interrupt handler.
    162           * @note    It is assumed that the various sources are only activated if the
    163           *          associated callback pointer is not equal to @p NULL in order to not
    164           *          perform an extra check in a potentially critical interrupt handler.
    165           *
    166           * @isr
    167           */

   \                                 In section .text, align 2, keep-with-next
    168          CH_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
   \                     VectorAC:
   \   00000000   0xB580             PUSH     {R7,LR}
    169          
    170            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    171          
    172            icu_lld_serve_interrupt(&ICUD1);
   \   00000006   0x....             LDR.N    R0,??DataTable7
   \   00000008   0x.... 0x....      BL       icu_lld_serve_interrupt
    173          
    174            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    175          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    176          #endif /* STM32_ICU_USE_TIM1 */
    177          
    178          #if STM32_ICU_USE_TIM2
    179          #if !defined(STM32_TIM2_HANDLER)
    180          #error "STM32_TIM2_HANDLER not defined"
    181          #endif
    182          /**
    183           * @brief   TIM2 interrupt handler.
    184           * @note    It is assumed that the various sources are only activated if the
    185           *          associated callback pointer is not equal to @p NULL in order to not
    186           *          perform an extra check in a potentially critical interrupt handler.
    187           *
    188           * @isr
    189           */

   \                                 In section .text, align 2, keep-with-next
    190          CH_IRQ_HANDLER(STM32_TIM2_HANDLER) {
   \                     VectorB0:
   \   00000000   0xB580             PUSH     {R7,LR}
    191          
    192            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    193          
    194            icu_lld_serve_interrupt(&ICUD2);
   \   00000006   0x....             LDR.N    R0,??DataTable7_1
   \   00000008   0x.... 0x....      BL       icu_lld_serve_interrupt
    195          
    196            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    197          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    198          #endif /* STM32_ICU_USE_TIM2 */
    199          
    200          #if STM32_ICU_USE_TIM3
    201          #if !defined(STM32_TIM3_HANDLER)
    202          #error "STM32_TIM3_HANDLER not defined"
    203          #endif
    204          /**
    205           * @brief   TIM3 interrupt handler.
    206           * @note    It is assumed that the various sources are only activated if the
    207           *          associated callback pointer is not equal to @p NULL in order to not
    208           *          perform an extra check in a potentially critical interrupt handler.
    209           *
    210           * @isr
    211           */

   \                                 In section .text, align 2, keep-with-next
    212          CH_IRQ_HANDLER(STM32_TIM3_HANDLER) {
   \                     VectorB4:
   \   00000000   0xB580             PUSH     {R7,LR}
    213          
    214            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    215          
    216            icu_lld_serve_interrupt(&ICUD3);
   \   00000006   0x....             LDR.N    R0,??DataTable7_2
   \   00000008   0x.... 0x....      BL       icu_lld_serve_interrupt
    217          
    218            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    219          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    220          #endif /* STM32_ICU_USE_TIM3 */
    221          
    222          #if STM32_ICU_USE_TIM4
    223          #if !defined(STM32_TIM4_HANDLER)
    224          #error "STM32_TIM4_HANDLER not defined"
    225          #endif
    226          /**
    227           * @brief   TIM4 interrupt handler.
    228           * @note    It is assumed that the various sources are only activated if the
    229           *          associated callback pointer is not equal to @p NULL in order to not
    230           *          perform an extra check in a potentially critical interrupt handler.
    231           *
    232           * @isr
    233           */
    234          CH_IRQ_HANDLER(STM32_TIM4_HANDLER) {
    235          
    236            CH_IRQ_PROLOGUE();
    237          
    238            icu_lld_serve_interrupt(&ICUD4);
    239          
    240            CH_IRQ_EPILOGUE();
    241          }
    242          #endif /* STM32_ICU_USE_TIM4 */
    243          
    244          #if STM32_ICU_USE_TIM5
    245          #if !defined(STM32_TIM5_HANDLER)
    246          #error "STM32_TIM5_HANDLER not defined"
    247          #endif
    248          /**
    249           * @brief   TIM5 interrupt handler.
    250           * @note    It is assumed that the various sources are only activated if the
    251           *          associated callback pointer is not equal to @p NULL in order to not
    252           *          perform an extra check in a potentially critical interrupt handler.
    253           *
    254           * @isr
    255           */
    256          CH_IRQ_HANDLER(STM32_TIM5_HANDLER) {
    257          
    258            CH_IRQ_PROLOGUE();
    259          
    260            icu_lld_serve_interrupt(&ICUD5);
    261          
    262            CH_IRQ_EPILOGUE();
    263          }
    264          #endif /* STM32_ICU_USE_TIM5 */
    265          
    266          #if STM32_ICU_USE_TIM8
    267          #if !defined(STM32_TIM8_UP_HANDLER)
    268          #error "STM32_TIM8_UP_HANDLER not defined"
    269          #endif
    270          /**
    271           * @brief   TIM8 compare interrupt handler.
    272           * @note    It is assumed that the various sources are only activated if the
    273           *          associated callback pointer is not equal to @p NULL in order to not
    274           *          perform an extra check in a potentially critical interrupt handler.
    275           *
    276           * @isr
    277           */
    278          CH_IRQ_HANDLER(STM32_TIM8_UP_HANDLER) {
    279          
    280            CH_IRQ_PROLOGUE();
    281          
    282            icu_lld_serve_interrupt(&ICUD8);
    283          
    284            CH_IRQ_EPILOGUE();
    285          }
    286          
    287          #if !defined(STM32_TIM8_CC_HANDLER)
    288          #error "STM32_TIM8_CC_HANDLER not defined"
    289          #endif
    290          /**
    291           * @brief   TIM8 compare interrupt handler.
    292           * @note    It is assumed that the various sources are only activated if the
    293           *          associated callback pointer is not equal to @p NULL in order to not
    294           *          perform an extra check in a potentially critical interrupt handler.
    295           *
    296           * @isr
    297           */
    298          CH_IRQ_HANDLER(STM32_TIM8_CC_HANDLER) {
    299          
    300            CH_IRQ_PROLOGUE();
    301          
    302            icu_lld_serve_interrupt(&ICUD8);
    303          
    304            CH_IRQ_EPILOGUE();
    305          }
    306          #endif /* STM32_ICU_USE_TIM8 */
    307          
    308          #if STM32_ICU_USE_TIM9
    309          #if !defined(STM32_TIM9_HANDLER)
    310          #error "STM32_TIM9_HANDLER not defined"
    311          #endif
    312          /**
    313           * @brief   TIM9 interrupt handler.
    314           * @note    It is assumed that the various sources are only activated if the
    315           *          associated callback pointer is not equal to @p NULL in order to not
    316           *          perform an extra check in a potentially critical interrupt handler.
    317           *
    318           * @isr
    319           */

   \                                 In section .text, align 2, keep-with-next
    320          CH_IRQ_HANDLER(STM32_TIM9_HANDLER) {
   \                     VectorA0:
   \   00000000   0xB580             PUSH     {R7,LR}
    321          
    322            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    323          
    324            icu_lld_serve_interrupt(&ICUD9);
   \   00000006   0x....             LDR.N    R0,??DataTable7_3
   \   00000008   0x.... 0x....      BL       icu_lld_serve_interrupt
    325          
    326            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    327          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    328          #endif /* STM32_ICU_USE_TIM9 */
    329          
    330          /*===========================================================================*/
    331          /* Driver exported functions.                                                */
    332          /*===========================================================================*/
    333          
    334          /**
    335           * @brief   Low level ICU driver initialization.
    336           *
    337           * @notapi
    338           */

   \                                 In section .text, align 2, keep-with-next
    339          void icu_lld_init(void) {
   \                     icu_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    340          
    341          #if STM32_ICU_USE_TIM1
    342            /* Driver initialization.*/
    343            icuObjectInit(&ICUD1);
   \   00000002   0x....             LDR.N    R0,??DataTable7
   \   00000004   0x.... 0x....      BL       icuObjectInit
    344            ICUD1.tim = STM32_TIM1;
   \   00000008   0x....             LDR.N    R0,??DataTable7
   \   0000000A   0x....             LDR.N    R1,??DataTable7_4  ;; 0x40010000
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    345          #endif
    346          
    347          #if STM32_ICU_USE_TIM2
    348            /* Driver initialization.*/
    349            icuObjectInit(&ICUD2);
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1
   \   00000010   0x.... 0x....      BL       icuObjectInit
    350            ICUD2.tim = STM32_TIM2;
   \   00000014   0x....             LDR.N    R0,??DataTable7_1
   \   00000016   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
    351          #endif
    352          
    353          #if STM32_ICU_USE_TIM3
    354            /* Driver initialization.*/
    355            icuObjectInit(&ICUD3);
   \   0000001C   0x....             LDR.N    R0,??DataTable7_2
   \   0000001E   0x.... 0x....      BL       icuObjectInit
    356            ICUD3.tim = STM32_TIM3;
   \   00000022   0x....             LDR.N    R0,??DataTable7_2
   \   00000024   0x....             LDR.N    R1,??DataTable7_5  ;; 0x40000400
   \   00000026   0x60C1             STR      R1,[R0, #+12]
    357          #endif
    358          
    359          #if STM32_ICU_USE_TIM4
    360            /* Driver initialization.*/
    361            icuObjectInit(&ICUD4);
    362            ICUD4.tim = STM32_TIM4;
    363          #endif
    364          
    365          #if STM32_ICU_USE_TIM5
    366            /* Driver initialization.*/
    367            icuObjectInit(&ICUD5);
    368            ICUD5.tim = STM32_TIM5;
    369          #endif
    370          
    371          #if STM32_ICU_USE_TIM8
    372            /* Driver initialization.*/
    373            icuObjectInit(&ICUD8);
    374            ICUD8.tim = STM32_TIM8;
    375          #endif
    376          
    377          #if STM32_ICU_USE_TIM9
    378            /* Driver initialization.*/
    379            icuObjectInit(&ICUD9);
   \   00000028   0x....             LDR.N    R0,??DataTable7_3
   \   0000002A   0x.... 0x....      BL       icuObjectInit
    380            ICUD9.tim = STM32_TIM9;
   \   0000002E   0x....             LDR.N    R0,??DataTable7_3
   \   00000030   0x....             LDR.N    R1,??DataTable7_6  ;; 0x40014000
   \   00000032   0x60C1             STR      R1,[R0, #+12]
    381          #endif
    382          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    383          
    384          /**
    385           * @brief   Configures and activates the ICU peripheral.
    386           *
    387           * @param[in] icup      pointer to the @p ICUDriver object
    388           *
    389           * @notapi
    390           */

   \                                 In section .text, align 2, keep-with-next
    391          void icu_lld_start(ICUDriver *icup) {
   \                     icu_lld_start:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    392            uint32_t psc;
    393          
    394            chDbgAssert((icup->config->channel == ICU_CHANNEL_1) ||
    395                        (icup->config->channel == ICU_CHANNEL_2),
    396                        "icu_lld_start(), #1", "invalid input");
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x7D00             LDRB     R0,[R0, #+20]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??icu_lld_start_0
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD002             BEQ.N    ??icu_lld_start_0
   \   00000014   0x....             LDR.N    R0,??DataTable7_7
   \   00000016   0x.... 0x....      BL       chDbgPanic
    397          
    398            if (icup->state == ICU_STOP) {
   \                     ??icu_lld_start_0:
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD164             BNE.N    ??icu_lld_start_1
    399              /* Clock activation and timer reset.*/
    400          #if STM32_ICU_USE_TIM1
    401              if (&ICUD1 == icup) {
   \   00000020   0x....             LDR.N    R0,??DataTable7
   \   00000022   0x42A0             CMP      R0,R4
   \   00000024   0xD118             BNE.N    ??icu_lld_start_2
    402                rccEnableTIM1(FALSE);
   \   00000026   0x....             LDR.N    R0,??DataTable7_8  ;; 0x40023844
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002E   0x....             LDR.N    R1,??DataTable7_8  ;; 0x40023844
   \   00000030   0x6008             STR      R0,[R1, #+0]
    403                rccResetTIM1();
   \   00000032   0x....             LDR.N    R0,??DataTable7_9  ;; 0x40023824
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0x....             LDR.N    R1,??DataTable7_9  ;; 0x40023824
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   \   0000003E   0x....             LDR.N    R0,??DataTable7_9  ;; 0x40023824
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6001             STR      R1,[R0, #+0]
    404                nvicEnableVector(STM32_TIM1_UP_NUMBER,
    405                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM1_IRQ_PRIORITY));
   \   00000044   0x2130             MOVS     R1,#+48
   \   00000046   0x2019             MOVS     R0,#+25
   \   00000048   0x.... 0x....      BL       nvicEnableVector
    406                nvicEnableVector(STM32_TIM1_CC_NUMBER,
    407                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM1_IRQ_PRIORITY));
   \   0000004C   0x2130             MOVS     R1,#+48
   \   0000004E   0x201B             MOVS     R0,#+27
   \   00000050   0x.... 0x....      BL       nvicEnableVector
    408          #if defined(STM32_TIM1CLK)
    409                icup->clock = STM32_TIM1CLK;
    410          #else
    411                icup->clock = STM32_TIMCLK2;
   \   00000054   0x....             LDR.N    R0,??DataTable7_10  ;; 0xa037a00
   \   00000056   0x60A0             STR      R0,[R4, #+8]
    412          #endif
    413              }
    414          #endif
    415          #if STM32_ICU_USE_TIM2
    416              if (&ICUD2 == icup) {
   \                     ??icu_lld_start_2:
   \   00000058   0x....             LDR.N    R0,??DataTable7_1
   \   0000005A   0x42A0             CMP      R0,R4
   \   0000005C   0xD114             BNE.N    ??icu_lld_start_3
    417                rccEnableTIM2(FALSE);
   \   0000005E   0x....             LDR.N    R0,??DataTable7_11  ;; 0x40023840
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x....             LDR.N    R1,??DataTable7_11  ;; 0x40023840
   \   00000068   0x6008             STR      R0,[R1, #+0]
    418                rccResetTIM2();
   \   0000006A   0x....             LDR.N    R0,??DataTable7_12  ;; 0x40023820
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000072   0x....             LDR.N    R1,??DataTable7_12  ;; 0x40023820
   \   00000074   0x6008             STR      R0,[R1, #+0]
   \   00000076   0x....             LDR.N    R0,??DataTable7_12  ;; 0x40023820
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    419                nvicEnableVector(STM32_TIM2_NUMBER,
    420                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM2_IRQ_PRIORITY));
   \   0000007C   0x2130             MOVS     R1,#+48
   \   0000007E   0x201C             MOVS     R0,#+28
   \   00000080   0x.... 0x....      BL       nvicEnableVector
    421                icup->clock = STM32_TIMCLK1;
   \   00000084   0x....             LDR.N    R0,??DataTable7_13  ;; 0x501bd00
   \   00000086   0x60A0             STR      R0,[R4, #+8]
    422              }
    423          #endif
    424          #if STM32_ICU_USE_TIM3
    425              if (&ICUD3 == icup) {
   \                     ??icu_lld_start_3:
   \   00000088   0x....             LDR.N    R0,??DataTable7_2
   \   0000008A   0x42A0             CMP      R0,R4
   \   0000008C   0xD114             BNE.N    ??icu_lld_start_4
    426                rccEnableTIM3(FALSE);
   \   0000008E   0x....             LDR.N    R0,??DataTable7_11  ;; 0x40023840
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000096   0x....             LDR.N    R1,??DataTable7_11  ;; 0x40023840
   \   00000098   0x6008             STR      R0,[R1, #+0]
    427                rccResetTIM3();
   \   0000009A   0x....             LDR.N    R0,??DataTable7_12  ;; 0x40023820
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000A2   0x....             LDR.N    R1,??DataTable7_12  ;; 0x40023820
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   \   000000A6   0x....             LDR.N    R0,??DataTable7_12  ;; 0x40023820
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x6001             STR      R1,[R0, #+0]
    428                nvicEnableVector(STM32_TIM3_NUMBER,
    429                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM3_IRQ_PRIORITY));
   \   000000AC   0x2130             MOVS     R1,#+48
   \   000000AE   0x201D             MOVS     R0,#+29
   \   000000B0   0x.... 0x....      BL       nvicEnableVector
    430                icup->clock = STM32_TIMCLK1;
   \   000000B4   0x....             LDR.N    R0,??DataTable7_13  ;; 0x501bd00
   \   000000B6   0x60A0             STR      R0,[R4, #+8]
    431              }
    432          #endif
    433          #if STM32_ICU_USE_TIM4
    434              if (&ICUD4 == icup) {
    435                rccEnableTIM4(FALSE);
    436                rccResetTIM4();
    437                nvicEnableVector(STM32_TIM4_NUMBER,
    438                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM4_IRQ_PRIORITY));
    439                icup->clock = STM32_TIMCLK1;
    440              }
    441          #endif
    442          #if STM32_ICU_USE_TIM5
    443              if (&ICUD5 == icup) {
    444                rccEnableTIM5(FALSE);
    445                rccResetTIM5();
    446                nvicEnableVector(STM32_TIM5_NUMBER,
    447                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM5_IRQ_PRIORITY));
    448                icup->clock = STM32_TIMCLK1;
    449              }
    450          #endif
    451          #if STM32_ICU_USE_TIM8
    452              if (&ICUD8 == icup) {
    453                rccEnableTIM8(FALSE);
    454                rccResetTIM8();
    455                nvicEnableVector(STM32_TIM8_UP_NUMBER,
    456                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM8_IRQ_PRIORITY));
    457                nvicEnableVector(STM32_TIM8_CC_NUMBER,
    458                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM8_IRQ_PRIORITY));
    459          #if defined(STM32_TIM8CLK)
    460                icup->clock = STM32_TIM8CLK;
    461          #else
    462                icup->clock = STM32_TIMCLK2;
    463          #endif
    464              }
    465          #endif
    466          #if STM32_ICU_USE_TIM9
    467              if (&ICUD9 == icup) {
   \                     ??icu_lld_start_4:
   \   000000B8   0x....             LDR.N    R0,??DataTable7_3
   \   000000BA   0x42A0             CMP      R0,R4
   \   000000BC   0xD121             BNE.N    ??icu_lld_start_5
    468                rccEnableTIM9(FALSE);
   \   000000BE   0x....             LDR.N    R0,??DataTable7_8  ;; 0x40023844
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000C6   0x....             LDR.N    R1,??DataTable7_8  ;; 0x40023844
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    469                rccResetTIM9();
   \   000000CA   0x....             LDR.N    R0,??DataTable7_9  ;; 0x40023824
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000D2   0x....             LDR.N    R1,??DataTable7_9  ;; 0x40023824
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   \   000000D6   0x....             LDR.N    R0,??DataTable7_9  ;; 0x40023824
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x6001             STR      R1,[R0, #+0]
    470                nvicEnableVector(STM32_TIM9_NUMBER,
    471                                 CORTEX_PRIORITY_MASK(STM32_ICU_TIM9_IRQ_PRIORITY));
   \   000000DC   0x2130             MOVS     R1,#+48
   \   000000DE   0x2018             MOVS     R0,#+24
   \   000000E0   0x.... 0x....      BL       nvicEnableVector
    472                icup->clock = STM32_TIMCLK2;
   \   000000E4   0x....             LDR.N    R0,??DataTable7_10  ;; 0xa037a00
   \   000000E6   0x60A0             STR      R0,[R4, #+8]
   \   000000E8   0xE00B             B.N      ??icu_lld_start_5
    473              }
    474          #endif
    475            }
    476            else {
    477              /* Driver re-configuration scenario, it must be stopped first.*/
    478              icup->tim->CR1    = 0;                  /* Timer disabled.              */
   \                     ??icu_lld_start_1:
   \   000000EA   0x68E0             LDR      R0,[R4, #+12]
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x6001             STR      R1,[R0, #+0]
    479              icup->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
   \   000000F0   0x68E0             LDR      R0,[R4, #+12]
   \   000000F2   0x2100             MOVS     R1,#+0
   \   000000F4   0x6341             STR      R1,[R0, #+52]
    480              icup->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
   \   000000F6   0x68E0             LDR      R0,[R4, #+12]
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x6381             STR      R1,[R0, #+56]
    481              icup->tim->CNT    = 0;                  /* Counter reset to zero.       */
   \   000000FC   0x68E0             LDR      R0,[R4, #+12]
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x6241             STR      R1,[R0, #+36]
    482            }
    483          
    484            /* Timer configuration.*/
    485            icup->tim->SR   = 0;                     /* Clear eventual pending IRQs. */
   \                     ??icu_lld_start_5:
   \   00000102   0x68E0             LDR      R0,[R4, #+12]
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x6101             STR      R1,[R0, #+16]
    486            icup->tim->DIER = icup->config->dier &   /* DMA-related DIER settings.   */
    487                                ~STM32_TIM_DIER_IRQ_MASK;
   \   00000108   0x6860             LDR      R0,[R4, #+4]
   \   0000010A   0x6980             LDR      R0,[R0, #+24]
   \   0000010C   0x0A00             LSRS     R0,R0,#+8
   \   0000010E   0x0200             LSLS     R0,R0,#+8
   \   00000110   0x68E1             LDR      R1,[R4, #+12]
   \   00000112   0x60C8             STR      R0,[R1, #+12]
    488            psc = (icup->clock / icup->config->frequency) - 1;
   \   00000114   0x68A0             LDR      R0,[R4, #+8]
   \   00000116   0x6861             LDR      R1,[R4, #+4]
   \   00000118   0x6849             LDR      R1,[R1, #+4]
   \   0000011A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000011E   0x1E40             SUBS     R0,R0,#+1
   \   00000120   0x0005             MOVS     R5,R0
    489            chDbgAssert((psc <= 0xFFFF) &&
    490                        ((psc + 1) * icup->config->frequency) == icup->clock,
    491                        "icu_lld_start(), #1", "invalid frequency");
   \   00000122   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000126   0xD206             BCS.N    ??icu_lld_start_6
   \   00000128   0x1C68             ADDS     R0,R5,#+1
   \   0000012A   0x6861             LDR      R1,[R4, #+4]
   \   0000012C   0x6849             LDR      R1,[R1, #+4]
   \   0000012E   0x4348             MULS     R0,R1,R0
   \   00000130   0x68A1             LDR      R1,[R4, #+8]
   \   00000132   0x4288             CMP      R0,R1
   \   00000134   0xD002             BEQ.N    ??icu_lld_start_7
   \                     ??icu_lld_start_6:
   \   00000136   0x....             LDR.N    R0,??DataTable7_7
   \   00000138   0x.... 0x....      BL       chDbgPanic
    492            icup->tim->PSC  = (uint16_t)psc;
   \                     ??icu_lld_start_7:
   \   0000013C   0x68E0             LDR      R0,[R4, #+12]
   \   0000013E   0x0029             MOVS     R1,R5
   \   00000140   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000142   0x6281             STR      R1,[R0, #+40]
    493            icup->tim->ARR  = 0xFFFF;
   \   00000144   0x68E0             LDR      R0,[R4, #+12]
   \   00000146   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000014A   0x62C1             STR      R1,[R0, #+44]
    494          
    495            if (icup->config->channel == ICU_CHANNEL_1) {
   \   0000014C   0x6860             LDR      R0,[R4, #+4]
   \   0000014E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD118             BNE.N    ??icu_lld_start_8
    496              /* Selected input 1.
    497                 CCMR1_CC1S = 01 = CH1 Input on TI1.
    498                 CCMR1_CC2S = 10 = CH2 Input on TI1.*/
    499              icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
   \   00000154   0x68E0             LDR      R0,[R4, #+12]
   \   00000156   0xF240 0x2101      MOVW     R1,#+513
   \   0000015A   0x6181             STR      R1,[R0, #+24]
    500          
    501              /* SMCR_TS  = 101, input is TI1FP1.
    502                 SMCR_SMS = 100, reset on rising edge.*/
    503              icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
   \   0000015C   0x68E0             LDR      R0,[R4, #+12]
   \   0000015E   0x2154             MOVS     R1,#+84
   \   00000160   0x6081             STR      R1,[R0, #+8]
    504          
    505              /* The CCER settings depend on the selected trigger mode.
    506                 ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
    507                 ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    508              if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
   \   00000162   0x6860             LDR      R0,[R4, #+4]
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD103             BNE.N    ??icu_lld_start_9
    509                icup->tim->CCER = STM32_TIM_CCER_CC1E |
    510                                  STM32_TIM_CCER_CC2E | STM32_TIM_CCER_CC2P;
   \   0000016A   0x68E0             LDR      R0,[R4, #+12]
   \   0000016C   0x2131             MOVS     R1,#+49
   \   0000016E   0x6201             STR      R1,[R0, #+32]
   \   00000170   0xE002             B.N      ??icu_lld_start_10
    511              else
    512                icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
    513                                  STM32_TIM_CCER_CC2E;
   \                     ??icu_lld_start_9:
   \   00000172   0x68E0             LDR      R0,[R4, #+12]
   \   00000174   0x2113             MOVS     R1,#+19
   \   00000176   0x6201             STR      R1,[R0, #+32]
    514          
    515              /* Direct pointers to the capture registers in order to make reading
    516                 data faster from within callbacks.*/
    517              icup->wccrp = &icup->tim->CCR[1];
   \                     ??icu_lld_start_10:
   \   00000178   0x68E0             LDR      R0,[R4, #+12]
   \   0000017A   0x3038             ADDS     R0,R0,#+56
   \   0000017C   0x6120             STR      R0,[R4, #+16]
    518              icup->pccrp = &icup->tim->CCR[0];
   \   0000017E   0x68E0             LDR      R0,[R4, #+12]
   \   00000180   0x3034             ADDS     R0,R0,#+52
   \   00000182   0x6160             STR      R0,[R4, #+20]
   \   00000184   0xE017             B.N      ??icu_lld_start_11
    519            } else {
    520              /* Selected input 2.
    521                 CCMR1_CC1S = 10 = CH1 Input on TI2.
    522                 CCMR1_CC2S = 01 = CH2 Input on TI2.*/
    523              icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
   \                     ??icu_lld_start_8:
   \   00000186   0x68E0             LDR      R0,[R4, #+12]
   \   00000188   0xF44F 0x7181      MOV      R1,#+258
   \   0000018C   0x6181             STR      R1,[R0, #+24]
    524          
    525              /* SMCR_TS  = 110, input is TI2FP2.
    526                 SMCR_SMS = 100, reset on rising edge.*/
    527              icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
   \   0000018E   0x68E0             LDR      R0,[R4, #+12]
   \   00000190   0x2164             MOVS     R1,#+100
   \   00000192   0x6081             STR      R1,[R0, #+8]
    528          
    529              /* The CCER settings depend on the selected trigger mode.
    530                 ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
    531                 ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    532              if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
   \   00000194   0x6860             LDR      R0,[R4, #+4]
   \   00000196   0x7800             LDRB     R0,[R0, #+0]
   \   00000198   0x2800             CMP      R0,#+0
   \   0000019A   0xD103             BNE.N    ??icu_lld_start_12
    533                icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
    534                                  STM32_TIM_CCER_CC2E;
   \   0000019C   0x68E0             LDR      R0,[R4, #+12]
   \   0000019E   0x2113             MOVS     R1,#+19
   \   000001A0   0x6201             STR      R1,[R0, #+32]
   \   000001A2   0xE002             B.N      ??icu_lld_start_13
    535              else
    536                icup->tim->CCER = STM32_TIM_CCER_CC1E |
    537                                  STM32_TIM_CCER_CC2E | STM32_TIM_CCER_CC2P;
   \                     ??icu_lld_start_12:
   \   000001A4   0x68E0             LDR      R0,[R4, #+12]
   \   000001A6   0x2131             MOVS     R1,#+49
   \   000001A8   0x6201             STR      R1,[R0, #+32]
    538          
    539              /* Direct pointers to the capture registers in order to make reading
    540                 data faster from within callbacks.*/
    541              icup->wccrp = &icup->tim->CCR[0];
   \                     ??icu_lld_start_13:
   \   000001AA   0x68E0             LDR      R0,[R4, #+12]
   \   000001AC   0x3034             ADDS     R0,R0,#+52
   \   000001AE   0x6120             STR      R0,[R4, #+16]
    542              icup->pccrp = &icup->tim->CCR[1];
   \   000001B0   0x68E0             LDR      R0,[R4, #+12]
   \   000001B2   0x3038             ADDS     R0,R0,#+56
   \   000001B4   0x6160             STR      R0,[R4, #+20]
    543            }
    544          }
   \                     ??icu_lld_start_11:
   \   000001B6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    545          
    546          /**
    547           * @brief   Deactivates the ICU peripheral.
    548           *
    549           * @param[in] icup      pointer to the @p ICUDriver object
    550           *
    551           * @notapi
    552           */

   \                                 In section .text, align 2, keep-with-next
    553          void icu_lld_stop(ICUDriver *icup) {
   \                     icu_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    554          
    555            if (icup->state == ICU_READY) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD13B             BNE.N    ??icu_lld_stop_0
    556              /* Clock deactivation.*/
    557              icup->tim->CR1  = 0;                    /* Timer disabled.              */
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    558              icup->tim->DIER = 0;                    /* All IRQs disabled.           */
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x60C1             STR      R1,[R0, #+12]
    559              icup->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6101             STR      R1,[R0, #+16]
    560          
    561          #if STM32_ICU_USE_TIM1
    562              if (&ICUD1 == icup) {
   \   0000001C   0x....             LDR.N    R0,??DataTable7
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD10B             BNE.N    ??icu_lld_stop_1
    563                nvicDisableVector(STM32_TIM1_UP_NUMBER);
   \   00000022   0x2019             MOVS     R0,#+25
   \   00000024   0x.... 0x....      BL       nvicDisableVector
    564                nvicDisableVector(STM32_TIM1_CC_NUMBER);
   \   00000028   0x201B             MOVS     R0,#+27
   \   0000002A   0x.... 0x....      BL       nvicDisableVector
    565                rccDisableTIM1(FALSE);
   \   0000002E   0x....             LDR.N    R0,??DataTable7_8  ;; 0x40023844
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0x0040             LSLS     R0,R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable7_8  ;; 0x40023844
   \   00000038   0x6008             STR      R0,[R1, #+0]
    566              }
    567          #endif
    568          #if STM32_ICU_USE_TIM2
    569              if (&ICUD2 == icup) {
   \                     ??icu_lld_stop_1:
   \   0000003A   0x....             LDR.N    R0,??DataTable7_1
   \   0000003C   0x42A0             CMP      R0,R4
   \   0000003E   0xD108             BNE.N    ??icu_lld_stop_2
    570                nvicDisableVector(STM32_TIM2_NUMBER);
   \   00000040   0x201C             MOVS     R0,#+28
   \   00000042   0x.... 0x....      BL       nvicDisableVector
    571                rccDisableTIM2(FALSE);
   \   00000046   0x....             LDR.N    R0,??DataTable7_11  ;; 0x40023840
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x0840             LSRS     R0,R0,#+1
   \   0000004C   0x0040             LSLS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable7_11  ;; 0x40023840
   \   00000050   0x6008             STR      R0,[R1, #+0]
    572              }
    573          #endif
    574          #if STM32_ICU_USE_TIM3
    575              if (&ICUD3 == icup) {
   \                     ??icu_lld_stop_2:
   \   00000052   0x....             LDR.N    R0,??DataTable7_2
   \   00000054   0x42A0             CMP      R0,R4
   \   00000056   0xD108             BNE.N    ??icu_lld_stop_3
    576                nvicDisableVector(STM32_TIM3_NUMBER);
   \   00000058   0x201D             MOVS     R0,#+29
   \   0000005A   0x.... 0x....      BL       nvicDisableVector
    577                rccDisableTIM3(FALSE);
   \   0000005E   0x....             LDR.N    R0,??DataTable7_11  ;; 0x40023840
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000066   0x....             LDR.N    R1,??DataTable7_11  ;; 0x40023840
   \   00000068   0x6008             STR      R0,[R1, #+0]
    578              }
    579          #endif
    580          #if STM32_ICU_USE_TIM4
    581              if (&ICUD4 == icup) {
    582                nvicDisableVector(STM32_TIM4_NUMBER);
    583                rccDisableTIM4(FALSE);
    584              }
    585          #endif
    586          #if STM32_ICU_USE_TIM5
    587              if (&ICUD5 == icup) {
    588                nvicDisableVector(STM32_TIM5_NUMBER);
    589                rccDisableTIM5(FALSE);
    590              }
    591          #endif
    592          #if STM32_ICU_USE_TIM8
    593              if (&ICUD8 == icup) {
    594                nvicDisableVector(STM32_TIM8_UP_NUMBER);
    595                nvicDisableVector(STM32_TIM8_CC_NUMBER);
    596                rccDisableTIM8(FALSE);
    597              }
    598          #endif
    599          #if STM32_ICU_USE_TIM9
    600              if (&ICUD9 == icup) {
   \                     ??icu_lld_stop_3:
   \   0000006A   0x....             LDR.N    R0,??DataTable7_3
   \   0000006C   0x42A0             CMP      R0,R4
   \   0000006E   0xD108             BNE.N    ??icu_lld_stop_0
    601                nvicDisableVector(STM32_TIM9_NUMBER);
   \   00000070   0x2018             MOVS     R0,#+24
   \   00000072   0x.... 0x....      BL       nvicDisableVector
    602                rccDisableTIM9(FALSE);
   \   00000076   0x....             LDR.N    R0,??DataTable7_8  ;; 0x40023844
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   0000007E   0x....             LDR.N    R1,??DataTable7_8  ;; 0x40023844
   \   00000080   0x6008             STR      R0,[R1, #+0]
    603              }
    604          #endif
    605            }
    606          }
   \                     ??icu_lld_stop_0:
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    607          
    608          /**
    609           * @brief   Enables the input capture.
    610           *
    611           * @param[in] icup      pointer to the @p ICUDriver object
    612           *
    613           * @notapi
    614           */

   \                                 In section .text, align 2, keep-with-next
    615          void icu_lld_enable(ICUDriver *icup) {
    616          
    617            icup->tim->EGR |= STM32_TIM_EGR_UG;
   \                     icu_lld_enable:
   \   00000000   0x68C1             LDR      R1,[R0, #+12]
   \   00000002   0x6949             LDR      R1,[R1, #+20]
   \   00000004   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000008   0x68C2             LDR      R2,[R0, #+12]
   \   0000000A   0x6151             STR      R1,[R2, #+20]
    618            icup->tim->SR = 0;                        /* Clear pending IRQs (if any). */
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x610A             STR      R2,[R1, #+16]
    619            if (icup->config->channel == ICU_CHANNEL_1) {
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x7D09             LDRB     R1,[R1, #+20]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD114             BNE.N    ??icu_lld_enable_0
    620              if (icup->config->period_cb != NULL)
   \   0000001A   0x6841             LDR      R1,[R0, #+4]
   \   0000001C   0x68C9             LDR      R1,[R1, #+12]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD005             BEQ.N    ??icu_lld_enable_1
    621                icup->tim->DIER |= STM32_TIM_DIER_CC1IE;
   \   00000022   0x68C1             LDR      R1,[R0, #+12]
   \   00000024   0x68C9             LDR      R1,[R1, #+12]
   \   00000026   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000002A   0x68C2             LDR      R2,[R0, #+12]
   \   0000002C   0x60D1             STR      R1,[R2, #+12]
    622              if (icup->config->width_cb != NULL)
   \                     ??icu_lld_enable_1:
   \   0000002E   0x6841             LDR      R1,[R0, #+4]
   \   00000030   0x6889             LDR      R1,[R1, #+8]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD01A             BEQ.N    ??icu_lld_enable_2
    623                icup->tim->DIER |= STM32_TIM_DIER_CC2IE;
   \   00000036   0x68C1             LDR      R1,[R0, #+12]
   \   00000038   0x68C9             LDR      R1,[R1, #+12]
   \   0000003A   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   0000003E   0x68C2             LDR      R2,[R0, #+12]
   \   00000040   0x60D1             STR      R1,[R2, #+12]
   \   00000042   0xE013             B.N      ??icu_lld_enable_2
    624            } else {
    625              if (icup->config->width_cb != NULL)
   \                     ??icu_lld_enable_0:
   \   00000044   0x6841             LDR      R1,[R0, #+4]
   \   00000046   0x6889             LDR      R1,[R1, #+8]
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0xD005             BEQ.N    ??icu_lld_enable_3
    626                icup->tim->DIER |= STM32_TIM_DIER_CC1IE;
   \   0000004C   0x68C1             LDR      R1,[R0, #+12]
   \   0000004E   0x68C9             LDR      R1,[R1, #+12]
   \   00000050   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000054   0x68C2             LDR      R2,[R0, #+12]
   \   00000056   0x60D1             STR      R1,[R2, #+12]
    627              if (icup->config->period_cb != NULL)
   \                     ??icu_lld_enable_3:
   \   00000058   0x6841             LDR      R1,[R0, #+4]
   \   0000005A   0x68C9             LDR      R1,[R1, #+12]
   \   0000005C   0x2900             CMP      R1,#+0
   \   0000005E   0xD005             BEQ.N    ??icu_lld_enable_2
    628                icup->tim->DIER |= STM32_TIM_DIER_CC2IE;
   \   00000060   0x68C1             LDR      R1,[R0, #+12]
   \   00000062   0x68C9             LDR      R1,[R1, #+12]
   \   00000064   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000068   0x68C2             LDR      R2,[R0, #+12]
   \   0000006A   0x60D1             STR      R1,[R2, #+12]
    629            }
    630            if (icup->config->overflow_cb != NULL)
   \                     ??icu_lld_enable_2:
   \   0000006C   0x6841             LDR      R1,[R0, #+4]
   \   0000006E   0x6909             LDR      R1,[R1, #+16]
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xD005             BEQ.N    ??icu_lld_enable_4
    631              icup->tim->DIER |= STM32_TIM_DIER_UIE;
   \   00000074   0x68C1             LDR      R1,[R0, #+12]
   \   00000076   0x68C9             LDR      R1,[R1, #+12]
   \   00000078   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000007C   0x68C2             LDR      R2,[R0, #+12]
   \   0000007E   0x60D1             STR      R1,[R2, #+12]
    632            icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
   \                     ??icu_lld_enable_4:
   \   00000080   0x68C1             LDR      R1,[R0, #+12]
   \   00000082   0x2205             MOVS     R2,#+5
   \   00000084   0x600A             STR      R2,[R1, #+0]
    633          }
   \   00000086   0x4770             BX       LR               ;; return
    634          
    635          /**
    636           * @brief   Disables the input capture.
    637           *
    638           * @param[in] icup      pointer to the @p ICUDriver object
    639           *
    640           * @notapi
    641           */

   \                                 In section .text, align 2, keep-with-next
    642          void icu_lld_disable(ICUDriver *icup) {
    643          
    644            icup->tim->CR1   = 0;                     /* Initially stopped.           */
   \                     icu_lld_disable:
   \   00000000   0x68C1             LDR      R1,[R0, #+12]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x600A             STR      R2,[R1, #+0]
    645            icup->tim->SR    = 0;                     /* Clear pending IRQs (if any). */
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x610A             STR      R2,[R1, #+16]
    646          
    647            /* All interrupts disabled.*/
    648            icup->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x68C9             LDR      R1,[R1, #+12]
   \   00000010   0x0A09             LSRS     R1,R1,#+8
   \   00000012   0x0209             LSLS     R1,R1,#+8
   \   00000014   0x68C2             LDR      R2,[R0, #+12]
   \   00000016   0x60D1             STR      R1,[R2, #+12]
    649          }
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ICUD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     ICUD2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     ICUD3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     ICUD9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     `?<Constant "icu_lld_start(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x0A037A00         DC32     0xa037a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x0501BD00         DC32     0x501bd00

   \                                 In section .rodata, align 4
   \                     `?<Constant "icu_lld_start(), #1">`:
   \   00000000   0x69 0x63          DC8 "icu_lld_start(), #1"
   \              0x75 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
    650          
    651          #endif /* HAL_USE_ICU */
    652          
    653          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   VectorA0
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> icu_lld_serve_interrupt
       8   VectorA4
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> icu_lld_serve_interrupt
       8   VectorAC
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> icu_lld_serve_interrupt
       8   VectorB0
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> icu_lld_serve_interrupt
       8   VectorB4
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> icu_lld_serve_interrupt
       0   icu_lld_disable
       0   icu_lld_enable
       8   icu_lld_init
         8   -> icuObjectInit
      16   icu_lld_serve_interrupt
        16   -- Indirect call
      16   icu_lld_start
        16   -> chDbgPanic
        16   -> nvicEnableVector
       8   icu_lld_stop
         8   -> nvicDisableVector


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "icu_lld_start(), #1">
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      24  ICUD1
      24  ICUD2
      24  ICUD3
      24  ICUD9
      22  VectorA0
      22  VectorA4
      22  VectorAC
      22  VectorB0
      22  VectorB4
      26  icu_lld_disable
     136  icu_lld_enable
      54  icu_lld_init
     146  icu_lld_serve_interrupt
     440  icu_lld_start
     132  icu_lld_stop

 
    96 bytes in section .bss
    20 bytes in section .rodata
 1 100 bytes in section .text
 
 1 100 bytes of CODE  memory
    20 bytes of CONST memory
    96 bytes of DATA  memory

Errors: none
Warnings: none
