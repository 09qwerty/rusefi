###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:41 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\i2c.c                                              #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\i2c.c -lCN F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\Obj\ --no_cse --no_unroll --no_inline  #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\i #
#                       2c.lst                                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\i2 #
#                       c.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\i2c.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          /*
     28             Concepts and parts of this file have been contributed by Uladzimir Pylinsky
     29             aka barthess.
     30           */
     31          
     32          /**
     33           * @file    i2c.c
     34           * @brief   I2C Driver code.
     35           *
     36           * @addtogroup I2C
     37           * @{
     38           */
     39          #include "ch.h"
     40          #include "hal.h"
     41          
     42          #if HAL_USE_I2C || defined(__DOXYGEN__)
     43          
     44          /*===========================================================================*/
     45          /* Driver local definitions.                                                 */
     46          /*===========================================================================*/
     47          
     48          /*===========================================================================*/
     49          /* Driver exported variables.                                                */
     50          /*===========================================================================*/
     51          
     52          /*===========================================================================*/
     53          /* Driver local variables and types.                                         */
     54          /*===========================================================================*/
     55          
     56          /*===========================================================================*/
     57          /* Driver local functions.                                                   */
     58          /*===========================================================================*/
     59          
     60          /*===========================================================================*/
     61          /* Driver exported functions.                                                */
     62          /*===========================================================================*/
     63          
     64          /**
     65           * @brief   I2C Driver initialization.
     66           * @note    This function is implicitly invoked by @p halInit(), there is
     67           *          no need to explicitly initialize the driver.
     68           *
     69           * @init
     70           */

   \                                 In section .text, align 2, keep-with-next
     71          void i2cInit(void) {
   \                     i2cInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     72            i2c_lld_init();
   \   00000002   0x.... 0x....      BL       i2c_lld_init
     73          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
     74          
     75          /**
     76           * @brief   Initializes the standard part of a @p I2CDriver structure.
     77           *
     78           * @param[out] i2cp     pointer to the @p I2CDriver object
     79           *
     80           * @init
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          void i2cObjectInit(I2CDriver *i2cp) {
   \                     i2cObjectInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     83          
     84            i2cp->state  = I2C_STOP;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x7020             STRB     R0,[R4, #+0]
     85            i2cp->config = NULL;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6060             STR      R0,[R4, #+4]
     86          
     87          #if I2C_USE_MUTUAL_EXCLUSION
     88          #if CH_USE_MUTEXES
     89            chMtxInit(&i2cp->mutex);
   \   0000000C   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000010   0x.... 0x....      BL       chMtxInit
     90          #else
     91            chSemInit(&i2cp->semaphore, 1);
     92          #endif /* CH_USE_MUTEXES */
     93          #endif /* I2C_USE_MUTUAL_EXCLUSION */
     94          
     95          #if defined(I2C_DRIVER_EXT_INIT_HOOK)
     96            I2C_DRIVER_EXT_INIT_HOOK(i2cp);
     97          #endif
     98          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
     99          
    100          /**
    101           * @brief   Configures and activates the I2C peripheral.
    102           *
    103           * @param[in] i2cp      pointer to the @p I2CDriver object
    104           * @param[in] config    pointer to the @p I2CConfig object
    105           *
    106           * @api
    107           */

   \                                 In section .text, align 2, keep-with-next
    108          void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
   \                     i2cStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    109          
    110            chDbgCheck((i2cp != NULL) && (config != NULL), "i2cStart");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??i2cStart_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD104             BNE.N    ??i2cStart_1
   \                     ??i2cStart_0:
   \   0000000E   0x226E             MOVS     R2,#+110
   \   00000010   0x....             LDR.N    R1,??DataTable6
   \   00000012   0x....             LDR.N    R0,??DataTable6_1
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    111            chDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    112                        (i2cp->state == I2C_LOCKED),
    113                        "i2cStart(), #1",
    114                        "invalid state");
   \                     ??i2cStart_1:
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD008             BEQ.N    ??i2cStart_2
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD005             BEQ.N    ??i2cStart_2
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2805             CMP      R0,#+5
   \   00000028   0xD002             BEQ.N    ??i2cStart_2
   \   0000002A   0x....             LDR.N    R0,??DataTable6_2
   \   0000002C   0x.... 0x....      BL       chDbgPanic
    115          
    116            chSysLock();
   \                     ??i2cStart_2:
   \   00000030   0x2020             MOVS     R0,#+32
   \   00000032   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000036   0x.... 0x....      BL       dbg_check_lock
    117            i2cp->config = config;
   \   0000003A   0x6065             STR      R5,[R4, #+4]
    118            i2c_lld_start(i2cp);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       i2c_lld_start
    119            i2cp->state = I2C_READY;
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x7020             STRB     R0,[R4, #+0]
    120            chSysUnlock();
   \   00000046   0x.... 0x....      BL       dbg_check_unlock
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF380 0x8811      MSR      BASEPRI,R0
    121          }
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    122          
    123          /**
    124           * @brief   Deactivates the I2C peripheral.
    125           *
    126           * @param[in] i2cp      pointer to the @p I2CDriver object
    127           *
    128           * @api
    129           */

   \                                 In section .text, align 2, keep-with-next
    130          void i2cStop(I2CDriver *i2cp) {
   \                     i2cStop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    131          
    132            chDbgCheck(i2cp != NULL, "i2cStop");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??i2cStop_0
   \   00000008   0x2284             MOVS     R2,#+132
   \   0000000A   0x....             LDR.N    R1,??DataTable6
   \   0000000C   0x....             LDR.N    R0,??DataTable6_3
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    133            chDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
    134                        (i2cp->state == I2C_LOCKED),
    135                        "i2cStop(), #1",
    136                        "invalid state");
   \                     ??i2cStop_0:
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD008             BEQ.N    ??i2cStop_1
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD005             BEQ.N    ??i2cStop_1
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xD002             BEQ.N    ??i2cStop_1
   \   00000024   0x....             LDR.N    R0,??DataTable6_4
   \   00000026   0x.... 0x....      BL       chDbgPanic
    137          
    138            chSysLock();
   \                     ??i2cStop_1:
   \   0000002A   0x2020             MOVS     R0,#+32
   \   0000002C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000030   0x.... 0x....      BL       dbg_check_lock
    139            i2c_lld_stop(i2cp);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       i2c_lld_stop
    140            i2cp->state = I2C_STOP;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7020             STRB     R0,[R4, #+0]
    141            chSysUnlock();
   \   0000003E   0x.... 0x....      BL       dbg_check_unlock
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF380 0x8811      MSR      BASEPRI,R0
    142          }
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    143          
    144          /**
    145           * @brief   Returns the errors mask associated to the previous operation.
    146           *
    147           * @param[in] i2cp      pointer to the @p I2CDriver object
    148           * @return              The errors mask.
    149           *
    150           * @api
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          i2cflags_t i2cGetErrors(I2CDriver *i2cp) {
   \                     i2cGetErrors:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    153          
    154            chDbgCheck(i2cp != NULL, "i2cGetErrors");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??i2cGetErrors_0
   \   00000008   0x229A             MOVS     R2,#+154
   \   0000000A   0x....             LDR.N    R1,??DataTable6
   \   0000000C   0x....             LDR.N    R0,??DataTable6_5
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    155          
    156            return i2c_lld_get_errors(i2cp);
   \                     ??i2cGetErrors_0:
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    157          }
    158          
    159          /**
    160           * @brief   Sends data via the I2C bus.
    161           * @details Function designed to realize "read-through-write" transfer
    162           *          paradigm. If you want transmit data without any further read,
    163           *          than set @b rxbytes field to 0.
    164           *
    165           * @param[in] i2cp      pointer to the @p I2CDriver object
    166           * @param[in] addr      slave device address (7 bits) without R/W bit
    167           * @param[in] txbuf     pointer to transmit buffer
    168           * @param[in] txbytes   number of bytes to be transmitted
    169           * @param[out] rxbuf    pointer to receive buffer
    170           * @param[in] rxbytes   number of bytes to be received, set it to 0 if
    171           *                      you want transmit only
    172           * @param[in] timeout   the number of ticks before the operation timeouts,
    173           *                      the following special values are allowed:
    174           *                      - @a TIME_INFINITE no timeout.
    175           *                      .
    176           *
    177           * @return              The operation status.
    178           * @retval RDY_OK       if the function succeeded.
    179           * @retval RDY_RESET    if one or more I2C errors occurred, the errors can
    180           *                      be retrieved using @p i2cGetErrors().
    181           * @retval RDY_TIMEOUT  if a timeout occurred before operation end.
    182           *
    183           * @api
    184           */

   \                                 In section .text, align 2, keep-with-next
    185          msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
    186                                         i2caddr_t addr,
    187                                         const uint8_t *txbuf,
    188                                         size_t txbytes,
    189                                         uint8_t *rxbuf,
    190                                         size_t rxbytes,
    191                                         systime_t timeout) {
   \                     i2cMasterTransmitTimeout:
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000010   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \   00000014   0xF8DD 0xA038      LDR      R10,[SP, #+56]
    192            msg_t rdymsg;
    193          
    194            chDbgCheck((i2cp != NULL) && (addr != 0) &&
    195                       (txbytes > 0) && (txbuf != NULL) &&
    196                       ((rxbytes == 0) || ((rxbytes > 0) && (rxbuf != NULL))) &&
    197                       (timeout != TIME_IMMEDIATE),
    198                       "i2cMasterTransmitTimeout");
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD012             BEQ.N    ??i2cMasterTransmitTimeout_0
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD00F             BEQ.N    ??i2cMasterTransmitTimeout_0
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD00D             BEQ.N    ??i2cMasterTransmitTimeout_0
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD00B             BEQ.N    ??i2cMasterTransmitTimeout_0
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD005             BEQ.N    ??i2cMasterTransmitTimeout_1
   \   00000030   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000034   0xD005             BEQ.N    ??i2cMasterTransmitTimeout_0
   \   00000036   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003A   0xD002             BEQ.N    ??i2cMasterTransmitTimeout_0
   \                     ??i2cMasterTransmitTimeout_1:
   \   0000003C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000040   0xD104             BNE.N    ??i2cMasterTransmitTimeout_2
   \                     ??i2cMasterTransmitTimeout_0:
   \   00000042   0x22C6             MOVS     R2,#+198
   \   00000044   0x....             LDR.N    R1,??DataTable6
   \   00000046   0x....             LDR.N    R0,??DataTable6_6
   \   00000048   0x.... 0x....      BL       chDbgPanic3
    199          
    200            chDbgAssert(i2cp->state == I2C_READY,
    201                        "i2cMasterTransmitTimeout(), #1", "not ready");
   \                     ??i2cMasterTransmitTimeout_2:
   \   0000004C   0x7820             LDRB     R0,[R4, #+0]
   \   0000004E   0x2802             CMP      R0,#+2
   \   00000050   0xD002             BEQ.N    ??i2cMasterTransmitTimeout_3
   \   00000052   0x....             LDR.N    R0,??DataTable6_7
   \   00000054   0x.... 0x....      BL       chDbgPanic
    202          
    203            chSysLock();
   \                     ??i2cMasterTransmitTimeout_3:
   \   00000058   0x2020             MOVS     R0,#+32
   \   0000005A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000005E   0x.... 0x....      BL       dbg_check_lock
    204            i2cp->errors = I2CD_NO_ERROR;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x60A0             STR      R0,[R4, #+8]
    205            i2cp->state = I2C_ACTIVE_TX;
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x7020             STRB     R0,[R4, #+0]
    206            rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
    207                                                     rxbuf, rxbytes, timeout);
   \   0000006A   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \   0000006E   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   00000072   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000076   0x003B             MOVS     R3,R7
   \   00000078   0x0032             MOVS     R2,R6
   \   0000007A   0x0029             MOVS     R1,R5
   \   0000007C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       i2c_lld_master_transmit_timeout
   \   00000084   0x4683             MOV      R11,R0
    208            if (rdymsg == RDY_TIMEOUT)
   \   00000086   0xF11B 0x0F01      CMN      R11,#+1
   \   0000008A   0xD102             BNE.N    ??i2cMasterTransmitTimeout_4
    209              i2cp->state = I2C_LOCKED;
   \   0000008C   0x2005             MOVS     R0,#+5
   \   0000008E   0x7020             STRB     R0,[R4, #+0]
   \   00000090   0xE001             B.N      ??i2cMasterTransmitTimeout_5
    210            else
    211              i2cp->state = I2C_READY;
   \                     ??i2cMasterTransmitTimeout_4:
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0x7020             STRB     R0,[R4, #+0]
    212            chSysUnlock();
   \                     ??i2cMasterTransmitTimeout_5:
   \   00000096   0x.... 0x....      BL       dbg_check_unlock
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF380 0x8811      MSR      BASEPRI,R0
    213            return rdymsg;
   \   000000A0   0x4658             MOV      R0,R11
   \   000000A2   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    214          }
    215          
    216          /**
    217           * @brief   Receives data from the I2C bus.
    218           *
    219           * @param[in] i2cp      pointer to the @p I2CDriver object
    220           * @param[in] addr      slave device address (7 bits) without R/W bit
    221           * @param[out] rxbuf    pointer to receive buffer
    222           * @param[in] rxbytes   number of bytes to be received
    223           * @param[in] timeout   the number of ticks before the operation timeouts,
    224           *                      the following special values are allowed:
    225           *                      - @a TIME_INFINITE no timeout.
    226           *                      .
    227           *
    228           * @return              The operation status.
    229           * @retval RDY_OK       if the function succeeded.
    230           * @retval RDY_RESET    if one or more I2C errors occurred, the errors can
    231           *                      be retrieved using @p i2cGetErrors().
    232           * @retval RDY_TIMEOUT  if a timeout occurred before operation end.
    233           *
    234           * @api
    235           */

   \                                 In section .text, align 2, keep-with-next
    236          msg_t i2cMasterReceiveTimeout(I2CDriver *i2cp,
    237                                        i2caddr_t addr,
    238                                        uint8_t *rxbuf,
    239                                        size_t rxbytes,
    240                                        systime_t timeout){
   \                     i2cMasterReceiveTimeout:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    241          
    242            msg_t rdymsg;
    243          
    244            chDbgCheck((i2cp != NULL) && (addr != 0) &&
    245                       (rxbytes > 0) && (rxbuf != NULL) &&
    246                       (timeout != TIME_IMMEDIATE),
    247                       "i2cMasterReceiveTimeout");
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD009             BEQ.N    ??i2cMasterReceiveTimeout_0
   \   00000014   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD006             BEQ.N    ??i2cMasterReceiveTimeout_0
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD004             BEQ.N    ??i2cMasterReceiveTimeout_0
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD002             BEQ.N    ??i2cMasterReceiveTimeout_0
   \   00000022   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000026   0xD104             BNE.N    ??i2cMasterReceiveTimeout_1
   \                     ??i2cMasterReceiveTimeout_0:
   \   00000028   0x22F7             MOVS     R2,#+247
   \   0000002A   0x....             LDR.N    R1,??DataTable6
   \   0000002C   0x....             LDR.N    R0,??DataTable6_8
   \   0000002E   0x.... 0x....      BL       chDbgPanic3
    248          
    249            chDbgAssert(i2cp->state == I2C_READY,
    250                        "i2cMasterReceive(), #1", "not ready");
   \                     ??i2cMasterReceiveTimeout_1:
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD002             BEQ.N    ??i2cMasterReceiveTimeout_2
   \   00000038   0x....             LDR.N    R0,??DataTable6_9
   \   0000003A   0x.... 0x....      BL       chDbgPanic
    251          
    252            chSysLock();
   \                     ??i2cMasterReceiveTimeout_2:
   \   0000003E   0x2020             MOVS     R0,#+32
   \   00000040   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000044   0x.... 0x....      BL       dbg_check_lock
    253            i2cp->errors = I2CD_NO_ERROR;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
    254            i2cp->state = I2C_ACTIVE_RX;
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
    255            rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
   \   00000050   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000054   0x003B             MOVS     R3,R7
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0x0029             MOVS     R1,R5
   \   0000005A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       i2c_lld_master_receive_timeout
   \   00000062   0x4681             MOV      R9,R0
    256            if (rdymsg == RDY_TIMEOUT)
   \   00000064   0xF119 0x0F01      CMN      R9,#+1
   \   00000068   0xD102             BNE.N    ??i2cMasterReceiveTimeout_3
    257              i2cp->state = I2C_LOCKED;
   \   0000006A   0x2005             MOVS     R0,#+5
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
   \   0000006E   0xE001             B.N      ??i2cMasterReceiveTimeout_4
    258            else
    259              i2cp->state = I2C_READY;
   \                     ??i2cMasterReceiveTimeout_3:
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0x7020             STRB     R0,[R4, #+0]
    260            chSysUnlock();
   \                     ??i2cMasterReceiveTimeout_4:
   \   00000074   0x.... 0x....      BL       dbg_check_unlock
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF380 0x8811      MSR      BASEPRI,R0
    261            return rdymsg;
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    262          }
    263          
    264          #if I2C_USE_MUTUAL_EXCLUSION || defined(__DOXYGEN__)
    265          /**
    266           * @brief   Gains exclusive access to the I2C bus.
    267           * @details This function tries to gain ownership to the I2C bus, if the bus
    268           *          is already being used then the invoking thread is queued.
    269           * @pre     In order to use this function the option @p I2C_USE_MUTUAL_EXCLUSION
    270           *          must be enabled.
    271           *
    272           * @param[in] i2cp      pointer to the @p I2CDriver object
    273           *
    274           * @api
    275           */

   \                                 In section .text, align 2, keep-with-next
    276          void i2cAcquireBus(I2CDriver *i2cp) {
   \                     i2cAcquireBus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    277          
    278            chDbgCheck(i2cp != NULL, "i2cAcquireBus");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??i2cAcquireBus_0
   \   00000008   0xF44F 0x728B      MOV      R2,#+278
   \   0000000C   0x....             LDR.N    R1,??DataTable6
   \   0000000E   0x....             LDR.N    R0,??DataTable6_10
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    279          
    280          #if CH_USE_MUTEXES
    281            chMtxLock(&i2cp->mutex);
   \                     ??i2cAcquireBus_0:
   \   00000014   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000018   0x.... 0x....      BL       chMtxLock
    282          #elif CH_USE_SEMAPHORES
    283            chSemWait(&i2cp->semaphore);
    284          #endif
    285          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    286          
    287          /**
    288           * @brief   Releases exclusive access to the I2C bus.
    289           * @pre     In order to use this function the option @p I2C_USE_MUTUAL_EXCLUSION
    290           *          must be enabled.
    291           *
    292           * @param[in] i2cp      pointer to the @p I2CDriver object
    293           *
    294           * @api
    295           */

   \                                 In section .text, align 2, keep-with-next
    296          void i2cReleaseBus(I2CDriver *i2cp) {
   \                     i2cReleaseBus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    297          
    298            chDbgCheck(i2cp != NULL, "i2cReleaseBus");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??i2cReleaseBus_0
   \   00000008   0xF44F 0x7295      MOV      R2,#+298
   \   0000000C   0x....             LDR.N    R1,??DataTable6
   \   0000000E   0x....             LDR.N    R0,??DataTable6_11
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    299          
    300          #if CH_USE_MUTEXES
    301            chMtxUnlock();
   \                     ??i2cReleaseBus_0:
   \   00000014   0x.... 0x....      BL       chMtxUnlock
    302          #elif CH_USE_SEMAPHORES
    303            chSemSignal(&i2cp->semaphore);
    304          #endif
    305          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     `?<Constant "i2cStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     `?<Constant "i2cStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cGetErrors\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cMasterTransmitTim...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     `?<Constant "i2cMasterTransmitTime...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cMasterReceiveTime...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     `?<Constant "i2cMasterReceive(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cAcquireBus\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     `?<Constant "\\"i2cReleaseBus\\"()">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cStart\\"()">`:
   \   00000000   0x22 0x69          DC8 "\"i2cStart\"()"
   \              0x32 0x63    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x69 0x32          DC8 69H, 32H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2cStart(), #1">`:
   \   00000000   0x69 0x32          DC8 "i2cStart(), #1"
   \              0x63 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cStop\\"()">`:
   \   00000000   0x22 0x69          DC8 "\"i2cStop\"()"
   \              0x32 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2cStop(), #1">`:
   \   00000000   0x69 0x32          DC8 "i2cStop(), #1"
   \              0x63 0x53    
   \              0x74 0x6F    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cGetErrors\\"()">`:
   \   00000000   0x22 0x69          DC8 "\"i2cGetErrors\"()"
   \              0x32 0x63    
   \              0x47 0x65    
   \              0x74 0x45    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x73 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cMasterTransmitTim...">`:
   \   00000000   0x22 0x69          DC8 "\"i2cMasterTransmitTimeout\"()"
   \              0x32 0x63    
   \              0x4D 0x61    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x6F 0x75    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2cMasterTransmitTime...">`:
   \   00000000   0x69 0x32          DC8 "i2cMasterTransmitTimeout(), #1"
   \              0x63 0x4D    
   \              0x61 0x73    
   \              0x74 0x65    
   \              0x72 0x54    
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x6D 0x69    
   \              0x74 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cMasterReceiveTime...">`:
   \   00000000   0x22 0x69          DC8 "\"i2cMasterReceiveTimeout\"()"
   \              0x32 0x63    
   \              0x4D 0x61    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x52 0x65    
   \              0x63 0x65    
   \              0x69 0x76    
   \              0x65 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2cMasterReceive(), #1">`:
   \   00000000   0x69 0x32          DC8 "i2cMasterReceive(), #1"
   \              0x63 0x4D    
   \              0x61 0x73    
   \              0x74 0x65    
   \              0x72 0x52    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cAcquireBus\\"()">`:
   \   00000000   0x22 0x69          DC8 "\"i2cAcquireBus\"()"
   \              0x32 0x63    
   \              0x41 0x63    
   \              0x71 0x75    
   \              0x69 0x72    
   \              0x65 0x42    
   \              0x75 0x73    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2cReleaseBus\\"()">`:
   \   00000000   0x22 0x69          DC8 "\"i2cReleaseBus\"()"
   \              0x32 0x63    
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \              0x65 0x42    
   \              0x75 0x73    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
    306          #endif /* I2C_USE_MUTUAL_EXCLUSION */
    307          
    308          #endif /* HAL_USE_I2C */
    309          
    310          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   i2cAcquireBus
         8   -> chDbgPanic3
         8   -> chMtxLock
       8   i2cGetErrors
         8   -> chDbgPanic3
       8   i2cInit
         8   -> i2c_lld_init
      32   i2cMasterReceiveTimeout
        32   -> chDbgPanic
        32   -> chDbgPanic3
        32   -> dbg_check_lock
        32   -> dbg_check_unlock
        32   -> i2c_lld_master_receive_timeout
      48   i2cMasterTransmitTimeout
        48   -> chDbgPanic
        48   -> chDbgPanic3
        48   -> dbg_check_lock
        48   -> dbg_check_unlock
        48   -> i2c_lld_master_transmit_timeout
       8   i2cObjectInit
         8   -> chMtxInit
       8   i2cReleaseBus
         8   -> chDbgPanic3
         8   -> chMtxUnlock
      16   i2cStart
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
        16   -> i2c_lld_start
       8   i2cStop
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
         8   -> i2c_lld_stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      64  ?<Constant "F:\\stuff\\rusefi_sourc...">
      20  ?<Constant "\"i2cAcquireBus\"()">
      20  ?<Constant "\"i2cGetErrors\"()">
      28  ?<Constant "\"i2cMasterReceiveTime...">
      32  ?<Constant "\"i2cMasterTransmitTim...">
      20  ?<Constant "\"i2cReleaseBus\"()">
      16  ?<Constant "\"i2cStart\"()">
      12  ?<Constant "\"i2cStop\"()">
      24  ?<Constant "i2cMasterReceive(), #1">
      32  ?<Constant "i2cMasterTransmitTime...">
      16  ?<Constant "i2cStart(), #1">
      16  ?<Constant "i2cStop(), #1">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      30  i2cAcquireBus
      22  i2cGetErrors
       8  i2cInit
     132  i2cMasterReceiveTimeout
     166  i2cMasterTransmitTimeout
      22  i2cObjectInit
      26  i2cReleaseBus
      82  i2cStart
      74  i2cStop

 
 300 bytes in section .rodata
 610 bytes in section .text
 
 610 bytes of CODE  memory
 300 bytes of CONST memory

Errors: none
Warnings: none
