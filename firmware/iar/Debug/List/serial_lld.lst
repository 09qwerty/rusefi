###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:44 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\USARTv1\serial_lld.c                   #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\USARTv1\serial_lld.c -lCN              #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\s #
#                       erial_lld.lst                                         #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\se #
#                       rial_lld.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\USARTv1\serial_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/USARTv1/serial_lld.c
     19           * @brief   STM32 low level serial driver code.
     20           *
     21           * @addtogroup SERIAL
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_SERIAL || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          /*===========================================================================*/
     35          /* Driver exported variables.                                                */
     36          /*===========================================================================*/
     37          
     38          /** @brief USART1 serial driver identifier.*/
     39          #if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     40          SerialDriver SD1;
   \                     SD1:
   \   00000000                      DS8 120
     41          #endif
     42          
     43          /** @brief USART2 serial driver identifier.*/
     44          #if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     45          SerialDriver SD2;
   \                     SD2:
   \   00000000                      DS8 120
     46          #endif
     47          
     48          /** @brief USART3 serial driver identifier.*/
     49          #if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     50          SerialDriver SD3;
   \                     SD3:
   \   00000000                      DS8 120
     51          #endif
     52          
     53          /** @brief UART4 serial driver identifier.*/
     54          #if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
     55          SerialDriver SD4;
     56          #endif
     57          
     58          /** @brief UART5 serial driver identifier.*/
     59          #if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
     60          SerialDriver SD5;
     61          #endif
     62          
     63          /** @brief USART6 serial driver identifier.*/
     64          #if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
     65          SerialDriver SD6;
     66          #endif
     67          
     68          /*===========================================================================*/
     69          /* Driver local variables and types.                                         */
     70          /*===========================================================================*/
     71          
     72          /** @brief Driver default configuration.*/

   \                                 In section .rodata, align 4
     73          static const SerialConfig default_config =
   \                     default_config:
   \   00000000   0x00009600         DC32 38400
   \   00000004   0x0000 0x4000      DC16 0, 16384, 0
   \              0x0000       
   \   0000000A   0x00 0x00          DC8 0, 0
     74          {
     75            SERIAL_DEFAULT_BITRATE,
     76            0,
     77            USART_CR2_STOP1_BITS | USART_CR2_LINEN,
     78            0
     79          };
     80          
     81          /*===========================================================================*/
     82          /* Driver local functions.                                                   */
     83          /*===========================================================================*/
     84          
     85          /**
     86           * @brief   USART initialization.
     87           * @details This function must be invoked with interrupts disabled.
     88           *
     89           * @param[in] sdp       pointer to a @p SerialDriver object
     90           * @param[in] config    the architecture-dependent serial driver configuration
     91           */

   \                                 In section .text, align 2, keep-with-next
     92          static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
   \                     usart_init:
   \   00000000   0xB410             PUSH     {R4}
     93            USART_TypeDef *u = sdp->usart;
   \   00000002   0x6F42             LDR      R2,[R0, #+116]
     94          
     95            /* Baud rate setting.*/
     96          #if STM32_HAS_USART6
     97            if ((sdp->usart == USART1) || (sdp->usart == USART6))
   \   00000004   0x6F43             LDR      R3,[R0, #+116]
   \   00000006   0x....             LDR.N    R4,??DataTable9  ;; 0x40011000
   \   00000008   0x42A3             CMP      R3,R4
   \   0000000A   0xD003             BEQ.N    ??usart_init_0
   \   0000000C   0x6F43             LDR      R3,[R0, #+116]
   \   0000000E   0x....             LDR.N    R4,??DataTable9_1  ;; 0x40011400
   \   00000010   0x42A3             CMP      R3,R4
   \   00000012   0xD105             BNE.N    ??usart_init_1
     98          #else
     99            if (sdp->usart == USART1)
    100          #endif
    101              u->BRR = STM32_PCLK2 / config->speed;
   \                     ??usart_init_0:
   \   00000014   0x....             LDR.N    R3,??DataTable9_2  ;; 0x501bd00
   \   00000016   0x680C             LDR      R4,[R1, #+0]
   \   00000018   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   0000001C   0x8113             STRH     R3,[R2, #+8]
   \   0000001E   0xE004             B.N      ??usart_init_2
    102            else
    103              u->BRR = STM32_PCLK1 / config->speed;
   \                     ??usart_init_1:
   \   00000020   0x....             LDR.N    R3,??DataTable9_3  ;; 0x280de80
   \   00000022   0x680C             LDR      R4,[R1, #+0]
   \   00000024   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   00000028   0x8113             STRH     R3,[R2, #+8]
    104          
    105            /* Note that some bits are enforced.*/
    106            u->CR2 = config->cr2 | USART_CR2_LBDIE;
   \                     ??usart_init_2:
   \   0000002A   0x88CB             LDRH     R3,[R1, #+6]
   \   0000002C   0xF053 0x0340      ORRS     R3,R3,#0x40
   \   00000030   0x8213             STRH     R3,[R2, #+16]
    107            u->CR3 = config->cr3 | USART_CR3_EIE;
   \   00000032   0x890B             LDRH     R3,[R1, #+8]
   \   00000034   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000038   0x8293             STRH     R3,[R2, #+20]
    108            u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
    109                                   USART_CR1_RXNEIE | USART_CR1_TE |
    110                                   USART_CR1_RE;
   \   0000003A   0x888B             LDRH     R3,[R1, #+4]
   \   0000003C   0xF443 0x5304      ORR      R3,R3,#0x2100
   \   00000040   0xF053 0x032C      ORRS     R3,R3,#0x2C
   \   00000044   0x8193             STRH     R3,[R2, #+12]
    111            u->SR = 0;
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x8013             STRH     R3,[R2, #+0]
    112            (void)u->SR;  /* SR reset step 1.*/
   \   0000004A   0x8813             LDRH     R3,[R2, #+0]
    113            (void)u->DR;  /* SR reset step 2.*/
   \   0000004C   0x8894             LDRH     R4,[R2, #+4]
    114          }
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x4770             BX       LR               ;; return
    115          
    116          /**
    117           * @brief   USART de-initialization.
    118           * @details This function must be invoked with interrupts disabled.
    119           *
    120           * @param[in] u         pointer to an USART I/O block
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          static void usart_deinit(USART_TypeDef *u) {
    123          
    124            u->CR1 = 0;
   \                     usart_deinit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8181             STRH     R1,[R0, #+12]
    125            u->CR2 = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8201             STRH     R1,[R0, #+16]
    126            u->CR3 = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8281             STRH     R1,[R0, #+20]
    127          }
   \   0000000C   0x4770             BX       LR               ;; return
    128          
    129          /**
    130           * @brief   Error handling routine.
    131           *
    132           * @param[in] sdp       pointer to a @p SerialDriver object
    133           * @param[in] sr        USART SR register value
    134           */

   \                                 In section .text, align 2, keep-with-next
    135          static void set_error(SerialDriver *sdp, uint16_t sr) {
   \                     set_error:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    136            flagsmask_t sts = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    137          
    138            if (sr & USART_SR_ORE)
   \   00000008   0x0728             LSLS     R0,R5,#+28
   \   0000000A   0xD501             BPL.N    ??set_error_0
    139              sts |= SD_OVERRUN_ERROR;
   \   0000000C   0xF056 0x0680      ORRS     R6,R6,#0x80
    140            if (sr & USART_SR_PE)
   \                     ??set_error_0:
   \   00000010   0x07E8             LSLS     R0,R5,#+31
   \   00000012   0xD501             BPL.N    ??set_error_1
    141              sts |= SD_PARITY_ERROR;
   \   00000014   0xF056 0x0620      ORRS     R6,R6,#0x20
    142            if (sr & USART_SR_FE)
   \                     ??set_error_1:
   \   00000018   0x07A8             LSLS     R0,R5,#+30
   \   0000001A   0xD501             BPL.N    ??set_error_2
    143              sts |= SD_FRAMING_ERROR;
   \   0000001C   0xF056 0x0640      ORRS     R6,R6,#0x40
    144            if (sr & USART_SR_NE)
   \                     ??set_error_2:
   \   00000020   0x0768             LSLS     R0,R5,#+29
   \   00000022   0xD501             BPL.N    ??set_error_3
    145              sts |= SD_NOISE_ERROR;
   \   00000024   0xF456 0x7680      ORRS     R6,R6,#0x100
    146            chnAddFlagsI(sdp, sts);
   \                     ??set_error_3:
   \   00000028   0x0031             MOVS     R1,R6
   \   0000002A   0x1D20             ADDS     R0,R4,#+4
   \   0000002C   0x.... 0x....      BL       chEvtBroadcastFlagsI
    147          }
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    148          
    149          /**
    150           * @brief   Common IRQ handler.
    151           *
    152           * @param[in] sdp       communication channel associated to the USART
    153           */

   \                                 In section .text, align 2, keep-with-next
    154          static void serve_interrupt(SerialDriver *sdp) {
   \                     serve_interrupt:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    155            USART_TypeDef *u = sdp->usart;
   \   00000006   0x6F65             LDR      R5,[R4, #+116]
    156            uint16_t cr1 = u->CR1;
   \   00000008   0x89AE             LDRH     R6,[R5, #+12]
    157            uint16_t sr = u->SR;
   \   0000000A   0x882F             LDRH     R7,[R5, #+0]
    158          
    159            /* Special case, LIN break detection.*/
    160            if (sr & USART_SR_LBD) {
   \   0000000C   0x05F8             LSLS     R0,R7,#+23
   \   0000000E   0xD511             BPL.N    ??serve_interrupt_0
    161              chSysLockFromIsr();
   \   00000010   0x2020             MOVS     R0,#+32
   \   00000012   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000016   0x.... 0x....      BL       dbg_check_lock_from_isr
    162              chnAddFlagsI(sdp, SD_BREAK_DETECTED);
   \   0000001A   0xF44F 0x7100      MOV      R1,#+512
   \   0000001E   0x1D20             ADDS     R0,R4,#+4
   \   00000020   0x.... 0x....      BL       chEvtBroadcastFlagsI
    163              chSysUnlockFromIsr();
   \   00000024   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF380 0x8811      MSR      BASEPRI,R0
    164              u->SR = ~USART_SR_LBD;
   \   0000002E   0xF64F 0x60FF      MOVW     R0,#+65279
   \   00000032   0x8028             STRH     R0,[R5, #+0]
    165            }
    166          
    167            /* Data available.*/
    168            chSysLockFromIsr();
   \                     ??serve_interrupt_0:
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000003A   0x.... 0x....      BL       dbg_check_lock_from_isr
    169            while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
    170                         USART_SR_PE)) {
   \                     ??serve_interrupt_1:
   \   0000003E   0x202F             MOVS     R0,#+47
   \   00000040   0x4207             TST      R7,R0
   \   00000042   0xD013             BEQ.N    ??serve_interrupt_2
    171              uint8_t b;
    172          
    173              /* Error condition detection.*/
    174              if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
   \   00000044   0x200F             MOVS     R0,#+15
   \   00000046   0x4207             TST      R7,R0
   \   00000048   0xD004             BEQ.N    ??serve_interrupt_3
    175                set_error(sdp, sr);
   \   0000004A   0x0039             MOVS     R1,R7
   \   0000004C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       set_error
    176              b = u->DR;
   \                     ??serve_interrupt_3:
   \   00000054   0x88A8             LDRH     R0,[R5, #+4]
   \   00000056   0x4680             MOV      R8,R0
    177              if (sr & USART_SR_RXNE)
   \   00000058   0x06B8             LSLS     R0,R7,#+26
   \   0000005A   0xD504             BPL.N    ??serve_interrupt_4
    178                sdIncomingDataI(sdp, b);
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       sdIncomingDataI
    179              sr = u->SR;
   \                     ??serve_interrupt_4:
   \   00000066   0x8828             LDRH     R0,[R5, #+0]
   \   00000068   0x0007             MOVS     R7,R0
   \   0000006A   0xE7E8             B.N      ??serve_interrupt_1
    180            }
    181            chSysUnlockFromIsr();
   \                     ??serve_interrupt_2:
   \   0000006C   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF380 0x8811      MSR      BASEPRI,R0
    182          
    183            /* Transmission buffer empty.*/
    184            if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
   \   00000076   0x0630             LSLS     R0,R6,#+24
   \   00000078   0xD520             BPL.N    ??serve_interrupt_5
   \   0000007A   0x0638             LSLS     R0,R7,#+24
   \   0000007C   0xD51E             BPL.N    ??serve_interrupt_5
    185              msg_t b;
    186              chSysLockFromIsr();
   \   0000007E   0x2020             MOVS     R0,#+32
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000084   0x.... 0x....      BL       dbg_check_lock_from_isr
    187              b = chOQGetI(&sdp->oqueue);
   \   00000088   0xF114 0x0030      ADDS     R0,R4,#+48
   \   0000008C   0x.... 0x....      BL       chOQGetI
   \   00000090   0x4680             MOV      R8,R0
    188              if (b < Q_OK) {
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD50A             BPL.N    ??serve_interrupt_6
    189                chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
   \   00000098   0x2108             MOVS     R1,#+8
   \   0000009A   0x1D20             ADDS     R0,R4,#+4
   \   0000009C   0x.... 0x....      BL       chEvtBroadcastFlagsI
    190                u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
   \   000000A0   0xF64F 0x707F      MOVW     R0,#+65407
   \   000000A4   0x4030             ANDS     R0,R0,R6
   \   000000A6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000AA   0x81A8             STRH     R0,[R5, #+12]
   \   000000AC   0xE001             B.N      ??serve_interrupt_7
    191              }
    192              else
    193                u->DR = b;
   \                     ??serve_interrupt_6:
   \   000000AE   0xF8A5 0x8004      STRH     R8,[R5, #+4]
    194              chSysUnlockFromIsr();
   \                     ??serve_interrupt_7:
   \   000000B2   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF380 0x8811      MSR      BASEPRI,R0
    195            }
    196          
    197            /* Physical transmission end.*/
    198            if (sr & USART_SR_TC) {
   \                     ??serve_interrupt_5:
   \   000000BC   0x0678             LSLS     R0,R7,#+25
   \   000000BE   0xD521             BPL.N    ??serve_interrupt_8
    199              chSysLockFromIsr();
   \   000000C0   0x2020             MOVS     R0,#+32
   \   000000C2   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000C6   0x.... 0x....      BL       dbg_check_lock_from_isr
    200              if (chOQIsEmptyI(&sdp->oqueue))
   \   000000CA   0x6C60             LDR      R0,[R4, #+68]
   \   000000CC   0x6CA1             LDR      R1,[R4, #+72]
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD104             BNE.N    ??serve_interrupt_9
   \   000000D2   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD001             BEQ.N    ??serve_interrupt_9
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE000             B.N      ??serve_interrupt_10
   \                     ??serve_interrupt_9:
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??serve_interrupt_10:
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD003             BEQ.N    ??serve_interrupt_11
    201                chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
   \   000000E4   0x2110             MOVS     R1,#+16
   \   000000E6   0x1D20             ADDS     R0,R4,#+4
   \   000000E8   0x.... 0x....      BL       chEvtBroadcastFlagsI
    202              u->CR1 = cr1 & ~USART_CR1_TCIE;
   \                     ??serve_interrupt_11:
   \   000000EC   0xF64F 0x70BF      MOVW     R0,#+65471
   \   000000F0   0x4030             ANDS     R0,R0,R6
   \   000000F2   0x81A8             STRH     R0,[R5, #+12]
    203              u->SR = ~USART_SR_TC;
   \   000000F4   0xF64F 0x70BF      MOVW     R0,#+65471
   \   000000F8   0x8028             STRH     R0,[R5, #+0]
    204              chSysUnlockFromIsr();
   \   000000FA   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF380 0x8811      MSR      BASEPRI,R0
    205            }
    206          }
   \                     ??serve_interrupt_8:
   \   00000104   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    207          
    208          #if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    209          static void notify1(GenericQueue *qp) {
    210          
    211            (void)qp;
    212            USART1->CR1 |= USART_CR1_TXEIE;
   \                     notify1:
   \   00000000   0x....             LDR.N    R1,??DataTable9_4  ;; 0x4001100c
   \   00000002   0x8809             LDRH     R1,[R1, #+0]
   \   00000004   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000008   0x....             LDR.N    R2,??DataTable9_4  ;; 0x4001100c
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    213          }
   \   0000000C   0x4770             BX       LR               ;; return
    214          #endif
    215          
    216          #if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    217          static void notify2(GenericQueue *qp) {
    218          
    219            (void)qp;
    220            USART2->CR1 |= USART_CR1_TXEIE;
   \                     notify2:
   \   00000000   0x....             LDR.N    R1,??DataTable9_5  ;; 0x4000440c
   \   00000002   0x8809             LDRH     R1,[R1, #+0]
   \   00000004   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000008   0x....             LDR.N    R2,??DataTable9_5  ;; 0x4000440c
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    221          }
   \   0000000C   0x4770             BX       LR               ;; return
    222          #endif
    223          
    224          #if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    225          static void notify3(GenericQueue *qp) {
    226          
    227            (void)qp;
    228            USART3->CR1 |= USART_CR1_TXEIE;
   \                     notify3:
   \   00000000   0x....             LDR.N    R1,??DataTable9_6  ;; 0x4000480c
   \   00000002   0x8809             LDRH     R1,[R1, #+0]
   \   00000004   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000008   0x....             LDR.N    R2,??DataTable9_6  ;; 0x4000480c
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    229          }
   \   0000000C   0x4770             BX       LR               ;; return
    230          #endif
    231          
    232          #if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
    233          static void notify4(GenericQueue *qp) {
    234          
    235            (void)qp;
    236            UART4->CR1 |= USART_CR1_TXEIE;
    237          }
    238          #endif
    239          
    240          #if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
    241          static void notify5(GenericQueue *qp) {
    242          
    243            (void)qp;
    244            UART5->CR1 |= USART_CR1_TXEIE;
    245          }
    246          #endif
    247          
    248          #if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
    249          static void notify6(GenericQueue *qp) {
    250          
    251            (void)qp;
    252            USART6->CR1 |= USART_CR1_TXEIE;
    253          }
    254          #endif
    255          
    256          /*===========================================================================*/
    257          /* Driver interrupt handlers.                                                */
    258          /*===========================================================================*/
    259          
    260          #if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
    261          #if !defined(STM32_USART1_HANDLER)
    262          #error "STM32_USART1_HANDLER not defined"
    263          #endif
    264          /**
    265           * @brief   USART1 interrupt handler.
    266           *
    267           * @isr
    268           */

   \                                 In section .text, align 2, keep-with-next
    269          CH_IRQ_HANDLER(STM32_USART1_HANDLER) {
   \                     VectorD4:
   \   00000000   0xB580             PUSH     {R7,LR}
    270          
    271            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    272          
    273            serve_interrupt(&SD1);
   \   00000006   0x....             LDR.N    R0,??DataTable9_7
   \   00000008   0x.... 0x....      BL       serve_interrupt
    274          
    275            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    276          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    277          #endif
    278          
    279          #if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
    280          #if !defined(STM32_USART2_HANDLER)
    281          #error "STM32_USART2_HANDLER not defined"
    282          #endif
    283          /**
    284           * @brief   USART2 interrupt handler.
    285           *
    286           * @isr
    287           */

   \                                 In section .text, align 2, keep-with-next
    288          CH_IRQ_HANDLER(STM32_USART2_HANDLER) {
   \                     VectorD8:
   \   00000000   0xB580             PUSH     {R7,LR}
    289          
    290            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    291          
    292            serve_interrupt(&SD2);
   \   00000006   0x....             LDR.N    R0,??DataTable9_8
   \   00000008   0x.... 0x....      BL       serve_interrupt
    293          
    294            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    295          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    296          #endif
    297          
    298          #if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
    299          #if !defined(STM32_USART3_HANDLER)
    300          #error "STM32_USART3_HANDLER not defined"
    301          #endif
    302          /**
    303           * @brief   USART3 interrupt handler.
    304           *
    305           * @isr
    306           */

   \                                 In section .text, align 2, keep-with-next
    307          CH_IRQ_HANDLER(STM32_USART3_HANDLER) {
   \                     VectorDC:
   \   00000000   0xB580             PUSH     {R7,LR}
    308          
    309            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    310          
    311            serve_interrupt(&SD3);
   \   00000006   0x....             LDR.N    R0,??DataTable9_9
   \   00000008   0x.... 0x....      BL       serve_interrupt
    312          
    313            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    314          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    315          #endif
    316          
    317          #if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
    318          #if !defined(STM32_UART4_HANDLER)
    319          #error "STM32_UART4_HANDLER not defined"
    320          #endif
    321          /**
    322           * @brief   UART4 interrupt handler.
    323           *
    324           * @isr
    325           */
    326          CH_IRQ_HANDLER(STM32_UART4_HANDLER) {
    327          
    328            CH_IRQ_PROLOGUE();
    329          
    330            serve_interrupt(&SD4);
    331          
    332            CH_IRQ_EPILOGUE();
    333          }
    334          #endif
    335          
    336          #if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
    337          #if !defined(STM32_UART5_HANDLER)
    338          #error "STM32_UART5_HANDLER not defined"
    339          #endif
    340          /**
    341           * @brief   UART5 interrupt handler.
    342           *
    343           * @isr
    344           */
    345          CH_IRQ_HANDLER(STM32_UART5_HANDLER) {
    346          
    347            CH_IRQ_PROLOGUE();
    348          
    349            serve_interrupt(&SD5);
    350          
    351            CH_IRQ_EPILOGUE();
    352          }
    353          #endif
    354          
    355          #if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
    356          #if !defined(STM32_USART6_HANDLER)
    357          #error "STM32_USART6_HANDLER not defined"
    358          #endif
    359          /**
    360           * @brief   USART1 interrupt handler.
    361           *
    362           * @isr
    363           */
    364          CH_IRQ_HANDLER(STM32_USART6_HANDLER) {
    365          
    366            CH_IRQ_PROLOGUE();
    367          
    368            serve_interrupt(&SD6);
    369          
    370            CH_IRQ_EPILOGUE();
    371          }
    372          #endif
    373          
    374          /*===========================================================================*/
    375          /* Driver exported functions.                                                */
    376          /*===========================================================================*/
    377          
    378          /**
    379           * @brief   Low level serial driver initialization.
    380           *
    381           * @notapi
    382           */

   \                                 In section .text, align 2, keep-with-next
    383          void sd_lld_init(void) {
   \                     sd_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    384          
    385          #if STM32_SERIAL_USE_USART1
    386            sdObjectInit(&SD1, NULL, notify1);
   \   00000002   0x....             LDR.N    R2,??DataTable9_10
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable9_7
   \   00000008   0x.... 0x....      BL       sdObjectInit
    387            SD1.usart = USART1;
   \   0000000C   0x....             LDR.N    R0,??DataTable9_7
   \   0000000E   0x....             LDR.N    R1,??DataTable9  ;; 0x40011000
   \   00000010   0x6741             STR      R1,[R0, #+116]
    388          #endif
    389          
    390          #if STM32_SERIAL_USE_USART2
    391            sdObjectInit(&SD2, NULL, notify2);
   \   00000012   0x....             LDR.N    R2,??DataTable9_11
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R0,??DataTable9_8
   \   00000018   0x.... 0x....      BL       sdObjectInit
    392            SD2.usart = USART2;
   \   0000001C   0x....             LDR.N    R0,??DataTable9_8
   \   0000001E   0x....             LDR.N    R1,??DataTable9_12  ;; 0x40004400
   \   00000020   0x6741             STR      R1,[R0, #+116]
    393          #endif
    394          
    395          #if STM32_SERIAL_USE_USART3
    396            sdObjectInit(&SD3, NULL, notify3);
   \   00000022   0x....             LDR.N    R2,??DataTable9_13
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x....             LDR.N    R0,??DataTable9_9
   \   00000028   0x.... 0x....      BL       sdObjectInit
    397            SD3.usart = USART3;
   \   0000002C   0x....             LDR.N    R0,??DataTable9_9
   \   0000002E   0x....             LDR.N    R1,??DataTable9_14  ;; 0x40004800
   \   00000030   0x6741             STR      R1,[R0, #+116]
    398          #endif
    399          
    400          #if STM32_SERIAL_USE_UART4
    401            sdObjectInit(&SD4, NULL, notify4);
    402            SD4.usart = UART4;
    403          #endif
    404          
    405          #if STM32_SERIAL_USE_UART5
    406            sdObjectInit(&SD5, NULL, notify5);
    407            SD5.usart = UART5;
    408          #endif
    409          
    410          #if STM32_SERIAL_USE_USART6
    411            sdObjectInit(&SD6, NULL, notify6);
    412            SD6.usart = USART6;
    413          #endif
    414          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    415          
    416          /**
    417           * @brief   Low level serial driver configuration and (re)start.
    418           *
    419           * @param[in] sdp       pointer to a @p SerialDriver object
    420           * @param[in] config    the architecture-dependent serial driver configuration.
    421           *                      If this parameter is set to @p NULL then a default
    422           *                      configuration is used.
    423           *
    424           * @notapi
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
   \                     sd_lld_start:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    427          
    428            if (config == NULL)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE.N    ??sd_lld_start_0
    429              config = &default_config;
   \   0000000A   0x....             LDR.N    R0,??DataTable9_15
   \   0000000C   0x0005             MOVS     R5,R0
    430          
    431            if (sdp->state == SD_STOP) {
   \                     ??sd_lld_start_0:
   \   0000000E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD126             BNE.N    ??sd_lld_start_1
    432          #if STM32_SERIAL_USE_USART1
    433              if (&SD1 == sdp) {
   \   00000014   0x....             LDR.N    R0,??DataTable9_7
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD109             BNE.N    ??sd_lld_start_2
    434                rccEnableUSART1(FALSE);
   \   0000001A   0x....             LDR.N    R0,??DataTable9_16  ;; 0x40023844
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000022   0x....             LDR.N    R1,??DataTable9_16  ;; 0x40023844
   \   00000024   0x6008             STR      R0,[R1, #+0]
    435                nvicEnableVector(STM32_USART1_NUMBER,
    436                                 CORTEX_PRIORITY_MASK(STM32_SERIAL_USART1_PRIORITY));
   \   00000026   0x21C0             MOVS     R1,#+192
   \   00000028   0x2025             MOVS     R0,#+37
   \   0000002A   0x.... 0x....      BL       nvicEnableVector
    437              }
    438          #endif
    439          #if STM32_SERIAL_USE_USART2
    440              if (&SD2 == sdp) {
   \                     ??sd_lld_start_2:
   \   0000002E   0x....             LDR.N    R0,??DataTable9_8
   \   00000030   0x42A0             CMP      R0,R4
   \   00000032   0xD109             BNE.N    ??sd_lld_start_3
    441                rccEnableUSART2(FALSE);
   \   00000034   0x....             LDR.N    R0,??DataTable9_17  ;; 0x40023840
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   0000003C   0x....             LDR.N    R1,??DataTable9_17  ;; 0x40023840
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    442                nvicEnableVector(STM32_USART2_NUMBER,
    443                                 CORTEX_PRIORITY_MASK(STM32_SERIAL_USART2_PRIORITY));
   \   00000040   0x21C0             MOVS     R1,#+192
   \   00000042   0x2026             MOVS     R0,#+38
   \   00000044   0x.... 0x....      BL       nvicEnableVector
    444              }
    445          #endif
    446          #if STM32_SERIAL_USE_USART3
    447              if (&SD3 == sdp) {
   \                     ??sd_lld_start_3:
   \   00000048   0x....             LDR.N    R0,??DataTable9_9
   \   0000004A   0x42A0             CMP      R0,R4
   \   0000004C   0xD109             BNE.N    ??sd_lld_start_1
    448                rccEnableUSART3(FALSE);
   \   0000004E   0x....             LDR.N    R0,??DataTable9_17  ;; 0x40023840
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   00000056   0x....             LDR.N    R1,??DataTable9_17  ;; 0x40023840
   \   00000058   0x6008             STR      R0,[R1, #+0]
    449                nvicEnableVector(STM32_USART3_NUMBER,
    450                                 CORTEX_PRIORITY_MASK(STM32_SERIAL_USART3_PRIORITY));
   \   0000005A   0x21C0             MOVS     R1,#+192
   \   0000005C   0x2027             MOVS     R0,#+39
   \   0000005E   0x.... 0x....      BL       nvicEnableVector
    451              }
    452          #endif
    453          #if STM32_SERIAL_USE_UART4
    454              if (&SD4 == sdp) {
    455                rccEnableUART4(FALSE);
    456                nvicEnableVector(STM32_UART4_NUMBER,
    457                                 CORTEX_PRIORITY_MASK(STM32_SERIAL_UART4_PRIORITY));
    458              }
    459          #endif
    460          #if STM32_SERIAL_USE_UART5
    461              if (&SD5 == sdp) {
    462                rccEnableUART5(FALSE);
    463                nvicEnableVector(STM32_UART5_NUMBER,
    464                                 CORTEX_PRIORITY_MASK(STM32_SERIAL_UART5_PRIORITY));
    465              }
    466          #endif
    467          #if STM32_SERIAL_USE_USART6
    468              if (&SD6 == sdp) {
    469                rccEnableUSART6(FALSE);
    470                nvicEnableVector(STM32_USART6_NUMBER,
    471                                 CORTEX_PRIORITY_MASK(STM32_SERIAL_USART6_PRIORITY));
    472              }
    473          #endif
    474            }
    475            usart_init(sdp, config);
   \                     ??sd_lld_start_1:
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       usart_init
    476          }
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    477          
    478          /**
    479           * @brief   Low level serial driver stop.
    480           * @details De-initializes the USART, stops the associated clock, resets the
    481           *          interrupt vector.
    482           *
    483           * @param[in] sdp       pointer to a @p SerialDriver object
    484           *
    485           * @notapi
    486           */

   \                                 In section .text, align 2, keep-with-next
    487          void sd_lld_stop(SerialDriver *sdp) {
   \                     sd_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    488          
    489            if (sdp->state == SD_READY) {
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD129             BNE.N    ??sd_lld_stop_0
    490              usart_deinit(sdp->usart);
   \   0000000A   0x6F60             LDR      R0,[R4, #+116]
   \   0000000C   0x.... 0x....      BL       usart_deinit
    491          #if STM32_SERIAL_USE_USART1
    492              if (&SD1 == sdp) {
   \   00000010   0x....             LDR.N    R0,??DataTable9_7
   \   00000012   0x42A0             CMP      R0,R4
   \   00000014   0xD109             BNE.N    ??sd_lld_stop_1
    493                rccDisableUSART1(FALSE);
   \   00000016   0x....             LDR.N    R0,??DataTable9_16  ;; 0x40023844
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000001E   0x....             LDR.N    R1,??DataTable9_16  ;; 0x40023844
   \   00000020   0x6008             STR      R0,[R1, #+0]
    494                nvicDisableVector(STM32_USART1_NUMBER);
   \   00000022   0x2025             MOVS     R0,#+37
   \   00000024   0x.... 0x....      BL       nvicDisableVector
    495                return;
   \   00000028   0xE019             B.N      ??sd_lld_stop_2
    496              }
    497          #endif
    498          #if STM32_SERIAL_USE_USART2
    499              if (&SD2 == sdp) {
   \                     ??sd_lld_stop_1:
   \   0000002A   0x....             LDR.N    R0,??DataTable9_8
   \   0000002C   0x42A0             CMP      R0,R4
   \   0000002E   0xD109             BNE.N    ??sd_lld_stop_3
    500                rccDisableUSART2(FALSE);
   \   00000030   0x....             LDR.N    R0,??DataTable9_17  ;; 0x40023840
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000038   0x....             LDR.N    R1,??DataTable9_17  ;; 0x40023840
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    501                nvicDisableVector(STM32_USART2_NUMBER);
   \   0000003C   0x2026             MOVS     R0,#+38
   \   0000003E   0x.... 0x....      BL       nvicDisableVector
    502                return;
   \   00000042   0xE00C             B.N      ??sd_lld_stop_2
    503              }
    504          #endif
    505          #if STM32_SERIAL_USE_USART3
    506              if (&SD3 == sdp) {
   \                     ??sd_lld_stop_3:
   \   00000044   0x....             LDR.N    R0,??DataTable9_9
   \   00000046   0x42A0             CMP      R0,R4
   \   00000048   0xD109             BNE.N    ??sd_lld_stop_0
    507                rccDisableUSART3(FALSE);
   \   0000004A   0x....             LDR.N    R0,??DataTable9_17  ;; 0x40023840
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000052   0x....             LDR.N    R1,??DataTable9_17  ;; 0x40023840
   \   00000054   0x6008             STR      R0,[R1, #+0]
    508                nvicDisableVector(STM32_USART3_NUMBER);
   \   00000056   0x2027             MOVS     R0,#+39
   \   00000058   0x.... 0x....      BL       nvicDisableVector
    509                return;
   \   0000005C   0xE7FF             B.N      ??sd_lld_stop_2
    510              }
    511          #endif
    512          #if STM32_SERIAL_USE_UART4
    513              if (&SD4 == sdp) {
    514                rccDisableUART4(FALSE);
    515                nvicDisableVector(STM32_UART4_NUMBER);
    516                return;
    517              }
    518          #endif
    519          #if STM32_SERIAL_USE_UART5
    520              if (&SD5 == sdp) {
    521                rccDisableUART5(FALSE);
    522                nvicDisableVector(STM32_UART5_NUMBER);
    523                return;
    524              }
    525          #endif
    526          #if STM32_SERIAL_USE_USART6
    527              if (&SD6 == sdp) {
    528                rccDisableUSART6(FALSE);
    529                nvicDisableVector(STM32_USART6_NUMBER);
    530                return;
    531              }
    532          #endif
    533            }
    534          }
   \                     ??sd_lld_stop_0:
   \                     ??sd_lld_stop_2:
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x0501BD00         DC32     0x501bd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x0280DE80         DC32     0x280de80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x4001100C         DC32     0x4001100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4000440C         DC32     0x4000440c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x4000480C         DC32     0x4000480c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     SD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     SD2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     SD3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     notify1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     notify2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     notify3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     default_config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x40023840         DC32     0x40023840
    535          
    536          #endif /* HAL_USE_SERIAL */
    537          
    538          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   VectorD4
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> serve_interrupt
       8   VectorD8
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> serve_interrupt
       8   VectorDC
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> serve_interrupt
       0   notify1
       0   notify2
       0   notify3
       8   sd_lld_init
         8   -> sdObjectInit
      16   sd_lld_start
        16   -> nvicEnableVector
        16   -> usart_init
       8   sd_lld_stop
         8   -> nvicDisableVector
         8   -> usart_deinit
      24   serve_interrupt
        24   -> chEvtBroadcastFlagsI
        24   -> chOQGetI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> sdIncomingDataI
        24   -> set_error
      16   set_error
        16   -> chEvtBroadcastFlagsI
       0   usart_deinit
       4   usart_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     120  SD1
     120  SD2
     120  SD3
      22  VectorD4
      22  VectorD8
      22  VectorDC
      12  default_config
      14  notify1
      14  notify2
      14  notify3
      52  sd_lld_init
     108  sd_lld_start
      96  sd_lld_stop
     264  serve_interrupt
      50  set_error
      14  usart_deinit
      82  usart_init

 
 360 bytes in section .bss
  12 bytes in section .rodata
 846 bytes in section .text
 
 846 bytes of CODE  memory
  12 bytes of CONST memory
 360 bytes of DATA  memory

Errors: none
Warnings: none
