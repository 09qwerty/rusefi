###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:41 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chheap.c                                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chheap.c -lCN F:\stuff\rusefi_sourceforge\firmw #
#                       are\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\List\ -o                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hheap.lst                                             #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       heap.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chheap.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chheap.c
     30           * @brief   Heaps code.
     31           *
     32           * @addtogroup heaps
     33           * @details Heap Allocator related APIs.
     34           *          <h2>Operation mode</h2>
     35           *          The heap allocator implements a first-fit strategy and its APIs
     36           *          are functionally equivalent to the usual @p malloc() and @p free()
     37           *          library functions. The main difference is that the OS heap APIs
     38           *          are guaranteed to be thread safe.<br>
     39           *          By enabling the @p CH_USE_MALLOC_HEAP option the heap manager
     40           *          will use the runtime-provided @p malloc() and @p free() as
     41           *          back end for the heap APIs instead of the system provided
     42           *          allocator.
     43           * @pre     In order to use the heap APIs the @p CH_USE_HEAP option must
     44           *          be enabled in @p chconf.h.
     45           * @{
     46           */
     47          
     48          #include "ch.h"
     49          
     50          #if CH_USE_HEAP || defined(__DOXYGEN__)
     51          
     52          #if !CH_USE_MALLOC_HEAP || defined(__DOXYGEN__)
     53          
     54          /*
     55           * Defaults on the best synchronization mechanism available.
     56           */
     57          #if CH_USE_MUTEXES || defined(__DOXYGEN__)
     58          #define H_LOCK(h)       chMtxLock(&(h)->h_mtx)
     59          #define H_UNLOCK(h)     chMtxUnlock()
     60          #else
     61          #define H_LOCK(h)       chSemWait(&(h)->h_sem)
     62          #define H_UNLOCK(h)     chSemSignal(&(h)->h_sem)
     63          #endif
     64          
     65          /**
     66           * @brief   Default heap descriptor.
     67           */

   \                                 In section .bss, align 8
     68          static MemoryHeap default_heap;
   \                     default_heap:
   \   00000000                      DS8 32
     69          
     70          /**
     71           * @brief   Initializes the default heap.
     72           *
     73           * @notapi
     74           */

   \                                 In section .text, align 2, keep-with-next
     75          void _heap_init(void) {
   \                     _heap_init:
   \   00000000   0xB580             PUSH     {R7,LR}
     76            default_heap.h_provider = chCoreAlloc;
   \   00000002   0x....             LDR.N    R0,??DataTable4
   \   00000004   0x....             LDR.N    R1,??DataTable4_1
   \   00000006   0x6001             STR      R1,[R0, #+0]
     77            default_heap.h_free.h.u.next = (union heap_header *)NULL;
   \   00000008   0x....             LDR.N    R0,??DataTable4
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6081             STR      R1,[R0, #+8]
     78            default_heap.h_free.h.size = 0;
   \   0000000E   0x....             LDR.N    R0,??DataTable4
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
     79          #if CH_USE_MUTEXES || defined(__DOXYGEN__)
     80            chMtxInit(&default_heap.h_mtx);
   \   00000014   0x....             LDR.N    R0,??DataTable4_2
   \   00000016   0x.... 0x....      BL       chMtxInit
     81          #else
     82            chSemInit(&default_heap.h_sem, 1);
     83          #endif
     84          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
     85          
     86          /**
     87           * @brief   Initializes a memory heap from a static memory area.
     88           * @pre     Both the heap buffer base and the heap size must be aligned to
     89           *          the @p stkalign_t type size.
     90           * @pre     In order to use this function the option @p CH_USE_MALLOC_HEAP
     91           *          must be disabled.
     92           *
     93           * @param[out] heapp    pointer to the memory heap descriptor to be initialized
     94           * @param[in] buf       heap buffer base
     95           * @param[in] size      heap size
     96           *
     97           * @init
     98           */

   \                                 In section .text, align 2, keep-with-next
     99          void chHeapInit(MemoryHeap *heapp, void *buf, size_t size) {
   \                     chHeapInit:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    100            union heap_header *hp;
    101          
    102            chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size), "chHeapInit");
   \   00000008   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??chHeapInit_0
   \   00000010   0xF016 0x0F07      TST      R6,#0x7
   \   00000014   0xD004             BEQ.N    ??chHeapInit_1
   \                     ??chHeapInit_0:
   \   00000016   0x2266             MOVS     R2,#+102
   \   00000018   0x....             LDR.N    R1,??DataTable4_3
   \   0000001A   0x....             LDR.N    R0,??DataTable4_4
   \   0000001C   0x.... 0x....      BL       chDbgPanic3
    103          
    104            heapp->h_provider = (memgetfunc_t)NULL;
   \                     ??chHeapInit_1:
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6020             STR      R0,[R4, #+0]
    105            heapp->h_free.h.u.next = hp = buf;
   \   00000024   0x002F             MOVS     R7,R5
   \   00000026   0x60A5             STR      R5,[R4, #+8]
    106            heapp->h_free.h.size = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x60E0             STR      R0,[R4, #+12]
    107            hp->h.u.next = NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6038             STR      R0,[R7, #+0]
    108            hp->h.size = size - sizeof(union heap_header);
   \   00000030   0xF1B6 0x0008      SUBS     R0,R6,#+8
   \   00000034   0x6078             STR      R0,[R7, #+4]
    109          #if CH_USE_MUTEXES || defined(__DOXYGEN__)
    110            chMtxInit(&heapp->h_mtx);
   \   00000036   0xF114 0x0010      ADDS     R0,R4,#+16
   \   0000003A   0x.... 0x....      BL       chMtxInit
    111          #else
    112            chSemInit(&heapp->h_sem, 1);
    113          #endif
    114          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    115          
    116          /**
    117           * @brief   Allocates a block of memory from the heap by using the first-fit
    118           *          algorithm.
    119           * @details The allocated block is guaranteed to be properly aligned for a
    120           *          pointer data type (@p stkalign_t).
    121           *
    122           * @param[in] heapp     pointer to a heap descriptor or @p NULL in order to
    123           *                      access the default heap.
    124           * @param[in] size      the size of the block to be allocated. Note that the
    125           *                      allocated block may be a bit bigger than the requested
    126           *                      size for alignment and fragmentation reasons.
    127           * @return              A pointer to the allocated block.
    128           * @retval NULL         if the block cannot be allocated.
    129           *
    130           * @api
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
   \                     chHeapAlloc:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
    133            union heap_header *qp, *hp, *fp;
    134          
    135            if (heapp == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??chHeapAlloc_0
    136              heapp = &default_heap;
   \   0000000C   0x....             LDR.N    R0,??DataTable4
   \   0000000E   0x0004             MOVS     R4,R0
    137          
    138            size = MEM_ALIGN_NEXT(size);
   \                     ??chHeapAlloc_0:
   \   00000010   0xF118 0x0007      ADDS     R0,R8,#+7
   \   00000014   0xEA5F 0x08D0      LSRS     R8,R0,#+3
   \   00000018   0xEA5F 0x08C8      LSLS     R8,R8,#+3
    139            qp = &heapp->h_free;
   \   0000001C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000020   0x0005             MOVS     R5,R0
    140            H_LOCK(heapp);
   \   00000022   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000026   0x.... 0x....      BL       chMtxLock
    141          
    142            while (qp->h.u.next != NULL) {
   \                     ??chHeapAlloc_1:
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD022             BEQ.N    ??chHeapAlloc_2
    143              hp = qp->h.u.next;
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x0006             MOVS     R6,R0
    144              if (hp->h.size >= size) {
   \   00000034   0x6870             LDR      R0,[R6, #+4]
   \   00000036   0x4540             CMP      R0,R8
   \   00000038   0xD31B             BCC.N    ??chHeapAlloc_3
    145                if (hp->h.size < size + sizeof(union heap_header)) {
   \   0000003A   0x6870             LDR      R0,[R6, #+4]
   \   0000003C   0xF118 0x0108      ADDS     R1,R8,#+8
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD202             BCS.N    ??chHeapAlloc_4
    146                  /* Gets the whole block even if it is slightly bigger than the
    147                     requested size because the fragment would be too small to be
    148                     useful.*/
    149                  qp->h.u.next = hp->h.u.next;
   \   00000044   0x6830             LDR      R0,[R6, #+0]
   \   00000046   0x6028             STR      R0,[R5, #+0]
   \   00000048   0xE00D             B.N      ??chHeapAlloc_5
    150                }
    151                else {
    152                  /* Block bigger enough, must split it.*/
    153                  fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
   \                     ??chHeapAlloc_4:
   \   0000004A   0xEB18 0x0006      ADDS     R0,R8,R6
   \   0000004E   0x3008             ADDS     R0,R0,#+8
   \   00000050   0x0007             MOVS     R7,R0
    154                  fp->h.u.next = hp->h.u.next;
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0x6038             STR      R0,[R7, #+0]
    155                  fp->h.size = hp->h.size - sizeof(union heap_header) - size;
   \   00000056   0x6870             LDR      R0,[R6, #+4]
   \   00000058   0x3808             SUBS     R0,R0,#+8
   \   0000005A   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   0000005E   0x6078             STR      R0,[R7, #+4]
    156                  qp->h.u.next = fp;
   \   00000060   0x602F             STR      R7,[R5, #+0]
    157                  hp->h.size = size;
   \   00000062   0xF8C6 0x8004      STR      R8,[R6, #+4]
    158                }
    159                hp->h.u.heap = heapp;
   \                     ??chHeapAlloc_5:
   \   00000066   0x6034             STR      R4,[R6, #+0]
    160          
    161                H_UNLOCK(heapp);
   \   00000068   0x.... 0x....      BL       chMtxUnlock
    162                return (void *)(hp + 1);
   \   0000006C   0xF116 0x0008      ADDS     R0,R6,#+8
   \   00000070   0xE014             B.N      ??chHeapAlloc_6
    163              }
    164              qp = hp;
   \                     ??chHeapAlloc_3:
   \   00000072   0x0035             MOVS     R5,R6
   \   00000074   0xE7D9             B.N      ??chHeapAlloc_1
    165            }
    166          
    167            H_UNLOCK(heapp);
   \                     ??chHeapAlloc_2:
   \   00000076   0x.... 0x....      BL       chMtxUnlock
    168          
    169            /* More memory is required, tries to get it from the associated provider
    170               else fails.*/
    171            if (heapp->h_provider) {
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD00C             BEQ.N    ??chHeapAlloc_7
    172              hp = heapp->h_provider(size + sizeof(union heap_header));
   \   00000080   0xF118 0x0008      ADDS     R0,R8,#+8
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x4788             BLX      R1
   \   00000088   0x0006             MOVS     R6,R0
    173              if (hp != NULL) {
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD005             BEQ.N    ??chHeapAlloc_7
    174                hp->h.u.heap = heapp;
   \   0000008E   0x6034             STR      R4,[R6, #+0]
    175                hp->h.size = size;
   \   00000090   0xF8C6 0x8004      STR      R8,[R6, #+4]
    176                hp++;
   \   00000094   0x3608             ADDS     R6,R6,#+8
    177                return (void *)hp;
   \   00000096   0x0030             MOVS     R0,R6
   \   00000098   0xE000             B.N      ??chHeapAlloc_6
    178              }
    179            }
    180            return NULL;
   \                     ??chHeapAlloc_7:
   \   0000009A   0x2000             MOVS     R0,#+0
   \                     ??chHeapAlloc_6:
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    181          }
    182          
    183          #define LIMIT(p) (union heap_header *)((uint8_t *)(p) + \
    184                                                  sizeof(union heap_header) + \
    185                                                  (p)->h.size)
    186          
    187          /**
    188           * @brief   Frees a previously allocated memory block.
    189           *
    190           * @param[in] p         pointer to the memory block to be freed
    191           *
    192           * @api
    193           */

   \                                 In section .text, align 2, keep-with-next
    194          void chHeapFree(void *p) {
   \                     chHeapFree:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    195            union heap_header *qp, *hp;
    196            MemoryHeap *heapp;
    197          
    198            chDbgCheck(p != NULL, "chHeapFree");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??chHeapFree_0
   \   00000008   0x22C6             MOVS     R2,#+198
   \   0000000A   0x....             LDR.N    R1,??DataTable4_3
   \   0000000C   0x....             LDR.N    R0,??DataTable4_5
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    199          
    200            hp = (union heap_header *)p - 1;
   \                     ??chHeapFree_0:
   \   00000012   0xF1B4 0x0008      SUBS     R0,R4,#+8
   \   00000016   0x0006             MOVS     R6,R0
    201            heapp = hp->h.u.heap;
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0x0007             MOVS     R7,R0
    202            qp = &heapp->h_free;
   \   0000001C   0xF117 0x0008      ADDS     R0,R7,#+8
   \   00000020   0x0005             MOVS     R5,R0
    203            H_LOCK(heapp);
   \   00000022   0xF117 0x0010      ADDS     R0,R7,#+16
   \   00000026   0x.... 0x....      BL       chMtxLock
    204          
    205            while (TRUE) {
    206              chDbgAssert((hp < qp) || (hp >= LIMIT(qp)),
    207                          "chHeapFree(), #1",
    208                          "within free block");
   \                     ??chHeapFree_1:
   \   0000002A   0x42AE             CMP      R6,R5
   \   0000002C   0xD307             BCC.N    ??chHeapFree_2
   \   0000002E   0x6868             LDR      R0,[R5, #+4]
   \   00000030   0x1940             ADDS     R0,R0,R5
   \   00000032   0x3008             ADDS     R0,R0,#+8
   \   00000034   0x4286             CMP      R6,R0
   \   00000036   0xD202             BCS.N    ??chHeapFree_2
   \   00000038   0x....             LDR.N    R0,??DataTable4_6
   \   0000003A   0x.... 0x....      BL       chDbgPanic
    209          
    210              if (((qp == &heapp->h_free) || (hp > qp)) &&
    211                  ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
   \                     ??chHeapFree_2:
   \   0000003E   0xF117 0x0008      ADDS     R0,R7,#+8
   \   00000042   0x4285             CMP      R5,R0
   \   00000044   0xD001             BEQ.N    ??chHeapFree_3
   \   00000046   0x42B5             CMP      R5,R6
   \   00000048   0xD226             BCS.N    ??chHeapFree_4
   \                     ??chHeapFree_3:
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??chHeapFree_5
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x4286             CMP      R6,R0
   \   00000054   0xD220             BCS.N    ??chHeapFree_4
    212                /* Insertion after qp.*/
    213                hp->h.u.next = qp->h.u.next;
   \                     ??chHeapFree_5:
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0x6030             STR      R0,[R6, #+0]
    214                qp->h.u.next = hp;
   \   0000005A   0x602E             STR      R6,[R5, #+0]
    215                /* Verifies if the newly inserted block should be merged.*/
    216                if (LIMIT(hp) == hp->h.u.next) {
   \   0000005C   0x6870             LDR      R0,[R6, #+4]
   \   0000005E   0x1980             ADDS     R0,R0,R6
   \   00000060   0x3008             ADDS     R0,R0,#+8
   \   00000062   0x6831             LDR      R1,[R6, #+0]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD108             BNE.N    ??chHeapFree_6
    217                  /* Merge with the next block.*/
    218                  hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
   \   00000068   0x6870             LDR      R0,[R6, #+4]
   \   0000006A   0x6831             LDR      R1,[R6, #+0]
   \   0000006C   0x6849             LDR      R1,[R1, #+4]
   \   0000006E   0x3108             ADDS     R1,R1,#+8
   \   00000070   0x1808             ADDS     R0,R1,R0
   \   00000072   0x6070             STR      R0,[R6, #+4]
    219                  hp->h.u.next = hp->h.u.next->h.u.next;
   \   00000074   0x6830             LDR      R0,[R6, #+0]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x6030             STR      R0,[R6, #+0]
    220                }
    221                if ((LIMIT(qp) == hp)) {
   \                     ??chHeapFree_6:
   \   0000007A   0x6868             LDR      R0,[R5, #+4]
   \   0000007C   0x1940             ADDS     R0,R0,R5
   \   0000007E   0x3008             ADDS     R0,R0,#+8
   \   00000080   0x42B0             CMP      R0,R6
   \   00000082   0xD106             BNE.N    ??chHeapFree_7
    222                  /* Merge with the previous block.*/
    223                  qp->h.size += hp->h.size + sizeof(union heap_header);
   \   00000084   0x6868             LDR      R0,[R5, #+4]
   \   00000086   0x6871             LDR      R1,[R6, #+4]
   \   00000088   0x3108             ADDS     R1,R1,#+8
   \   0000008A   0x1808             ADDS     R0,R1,R0
   \   0000008C   0x6068             STR      R0,[R5, #+4]
    224                  qp->h.u.next = hp->h.u.next;
   \   0000008E   0x6830             LDR      R0,[R6, #+0]
   \   00000090   0x6028             STR      R0,[R5, #+0]
    225                }
    226                break;
    227              }
    228              qp = qp->h.u.next;
    229            }
    230          
    231            H_UNLOCK(heapp);
   \                     ??chHeapFree_7:
   \   00000092   0x.... 0x....      BL       chMtxUnlock
    232            return;
   \   00000096   0xE001             B.N      ??chHeapFree_8
   \                     ??chHeapFree_4:
   \   00000098   0x682D             LDR      R5,[R5, #+0]
   \   0000009A   0xE7C6             B.N      ??chHeapFree_1
   \                     ??chHeapFree_8:
   \   0000009C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    233          }
    234          
    235          /**
    236           * @brief   Reports the heap status.
    237           * @note    This function is meant to be used in the test suite, it should
    238           *          not be really useful for the application code.
    239           * @note    This function is not implemented when the @p CH_USE_MALLOC_HEAP
    240           *          configuration option is used (it always returns zero).
    241           *
    242           * @param[in] heapp     pointer to a heap descriptor or @p NULL in order to
    243           *                      access the default heap.
    244           * @param[in] sizep     pointer to a variable that will receive the total
    245           *                      fragmented free space
    246           * @return              The number of fragments in the heap.
    247           *
    248           * @api
    249           */

   \                                 In section .text, align 2, keep-with-next
    250          size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
   \                     chHeapStatus:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    251            union heap_header *qp;
    252            size_t n, sz;
    253          
    254            if (heapp == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??chHeapStatus_0
    255              heapp = &default_heap;
   \   0000000C   0x....             LDR.N    R0,??DataTable4
   \   0000000E   0x0004             MOVS     R4,R0
    256          
    257            H_LOCK(heapp);
   \                     ??chHeapStatus_0:
   \   00000010   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000014   0x.... 0x....      BL       chMtxLock
    258          
    259            sz = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4680             MOV      R8,R0
    260            for (n = 0, qp = &heapp->h_free; qp->h.u.next; n++, qp = qp->h.u.next)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0007             MOVS     R7,R0
   \   00000020   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000024   0x0006             MOVS     R6,R0
   \                     ??chHeapStatus_1:
   \   00000026   0x6830             LDR      R0,[R6, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD006             BEQ.N    ??chHeapStatus_2
    261              sz += qp->h.u.next->h.size;
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0xEB10 0x0808      ADDS     R8,R0,R8
   \   00000034   0x1C7F             ADDS     R7,R7,#+1
   \   00000036   0x6836             LDR      R6,[R6, #+0]
   \   00000038   0xE7F5             B.N      ??chHeapStatus_1
    262            if (sizep)
   \                     ??chHeapStatus_2:
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD001             BEQ.N    ??chHeapStatus_3
    263              *sizep = sz;
   \   0000003E   0xF8C5 0x8000      STR      R8,[R5, #+0]
    264          
    265            H_UNLOCK(heapp);
   \                     ??chHeapStatus_3:
   \   00000042   0x.... 0x....      BL       chMtxUnlock
    266            return n;
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    267          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     default_heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     chCoreAlloc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     default_heap+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     `?<Constant "\\"chHeapInit\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     `?<Constant "\\"chHeapFree\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     `?<Constant "chHeapFree(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chHeapInit\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chHeapInit\"()"
   \              0x68 0x48    
   \              0x65 0x61    
   \              0x70 0x49    
   \              0x6E 0x69    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x6B 0x65          DC8 6BH, 65H, 72H, 6EH, 65H, 6CH, 5CH, 73H
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x5C 0x73    
   \   00000038   0x72 0x63          DC8 72H, 63H, 5CH, 63H, 68H, 68H, 65H, 61H
   \              0x5C 0x63    
   \              0x68 0x68    
   \              0x65 0x61    
   \   00000040   0x70 0x2E          DC8 70H, 2EH, 63H, 0
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chHeapFree\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chHeapFree\"()"
   \              0x68 0x48    
   \              0x65 0x61    
   \              0x70 0x46    
   \              0x72 0x65    
   \              0x65 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chHeapFree(), #1">`:
   \   00000000   0x63 0x68          DC8 "chHeapFree(), #1"
   \              0x48 0x65    
   \              0x61 0x70    
   \              0x46 0x72    
   \              0x65 0x65    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    268          
    269          #else /* CH_USE_MALLOC_HEAP */
    270          
    271          #include <stdlib.h>
    272          
    273          #if CH_USE_MUTEXES
    274          #define H_LOCK()        chMtxLock(&hmtx)
    275          #define H_UNLOCK()      chMtxUnlock()
    276          static Mutex            hmtx;
    277          #elif CH_USE_SEMAPHORES
    278          #define H_LOCK()        chSemWait(&hsem)
    279          #define H_UNLOCK()      chSemSignal(&hsem)
    280          static Semaphore        hsem;
    281          #endif
    282          
    283          void _heap_init(void) {
    284          
    285          #if CH_USE_MUTEXES
    286            chMtxInit(&hmtx);
    287          #else
    288            chSemInit(&hsem, 1);
    289          #endif
    290          }
    291          
    292          void *chHeapAlloc(MemoryHeap *heapp, size_t size) {
    293            void *p;
    294          
    295            chDbgCheck(heapp == NULL, "chHeapAlloc");
    296          
    297            H_LOCK();
    298            p = malloc(size);
    299            H_UNLOCK();
    300            return p;
    301          }
    302          
    303          void chHeapFree(void *p) {
    304          
    305            chDbgCheck(p != NULL, "chHeapFree");
    306          
    307            H_LOCK();
    308            free(p);
    309            H_UNLOCK();
    310          }
    311          
    312          size_t chHeapStatus(MemoryHeap *heapp, size_t *sizep) {
    313          
    314            chDbgCheck(heapp == NULL, "chHeapStatus");
    315          
    316            if (sizep)
    317              *sizep = 0;
    318            return 0;
    319          }
    320          
    321          #endif /* CH_USE_MALLOC_HEAP */
    322          
    323          #endif /* CH_USE_HEAP */
    324          
    325          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _heap_init
         8   -> chMtxInit
      24   chHeapAlloc
        24   -- Indirect call
        24   -> chMtxLock
        24   -> chMtxUnlock
      24   chHeapFree
        24   -> chDbgPanic
        24   -> chDbgPanic3
        24   -> chMtxLock
        24   -> chMtxUnlock
      24   chHeapInit
        24   -> chDbgPanic3
        24   -> chMtxInit
      24   chHeapStatus
        24   -> chMtxLock
        24   -> chMtxUnlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "F:\\stuff\\rusefi_sourc...">
      16  ?<Constant "\"chHeapFree\"()">
      16  ?<Constant "\"chHeapInit\"()">
      20  ?<Constant "chHeapFree(), #1">
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
      28  _heap_init
     160  chHeapAlloc
     158  chHeapFree
      64  chHeapInit
      76  chHeapStatus
      32  default_heap

 
  32 bytes in section .bss
 120 bytes in section .rodata
 514 bytes in section .text
 
 514 bytes of CODE  memory
 120 bytes of CONST memory
  32 bytes of DATA  memory

Errors: none
Warnings: none
