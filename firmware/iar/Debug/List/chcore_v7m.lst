###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:16 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\ports #
#                       \IAR\ARMCMx\chcore_v7m.c                              #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\ports #
#                       \IAR\ARMCMx\chcore_v7m.c -lCN                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hcore_v7m.lst                                         #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       core_v7m.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\ports\IAR\ARMCMx\chcore_v7m.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    IAR/ARMCMx/chcore_v7m.c
     30           * @brief   ARMv7-M architecture port code.
     31           *
     32           * @addtogroup IAR_ARMCMx_V7M_CORE
     33           * @{
     34           */
     35          
     36          #include "ch.h"
     37          
     38          /*===========================================================================*/
     39          /* Port interrupt handlers.                                                  */
     40          /*===========================================================================*/
     41          
     42          /**
     43           * @brief   System Timer vector.
     44           * @details This interrupt is used as system tick.
     45           * @note    The timer must be initialized in the startup code.
     46           */

   \                                 In section .text, align 2, keep-with-next
     47          CH_IRQ_HANDLER(SysTickVector) {
   \                     SysTickVector:
   \   00000000   0xB580             PUSH     {R7,LR}
     48          
     49            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
     50          
     51            chSysLockFromIsr();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock_from_isr
     52            chSysTimerHandlerI();
   \   00000010   0x.... 0x....      BL       chSysTimerHandlerI
     53            chSysUnlockFromIsr();
   \   00000014   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF380 0x8811      MSR      BASEPRI,R0
     54          
     55            CH_IRQ_EPILOGUE();
   \   0000001E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000022   0x.... 0x....      BL       _port_irq_epilogue
     56          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
     57          
     58          #if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
     59          /**
     60           * @brief   SVC vector.
     61           * @details The SVC vector is used for exception mode re-entering after a
     62           *          context switch.
     63           * @note    The PendSV vector is only used in advanced kernel mode.
     64           */

   \                                 In section .text, align 2, keep-with-next
     65          void SVCallVector(void) {
     66            struct extctx *ctxp;
     67          
     68          #if CORTEX_USE_FPU
     69            /* Enforcing unstacking of the FP part of the context.*/
     70            SCB_FPCCR &= ~FPCCR_LSPACT;
   \                     SVCallVector:
   \   00000000   0x....             LDR.N    R1,??DataTable2  ;; 0xe000ef34
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x....             LDR.N    R2,??DataTable2  ;; 0xe000ef34
   \   0000000A   0x6011             STR      R1,[R2, #+0]
     71          #endif
     72          
     73            /* Current PSP value.*/
     74            ctxp = (struct extctx *)__get_PSP();
   \   0000000C   0xF3EF 0x8109      MRS      R1,PSP
   \   00000010   0x0008             MOVS     R0,R1
     75          
     76            /* Discarding the current exception context and positioning the stack to
     77               point to the real one.*/
     78            ctxp++;
   \   00000012   0x3068             ADDS     R0,R0,#+104
     79          
     80            /* Restoring real position of the original stack frame.*/
     81            __set_PSP((unsigned long)ctxp);
   \   00000014   0xF380 0x8809      MSR      PSP,R0
     82            port_unlock_from_isr();
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xF381 0x8811      MSR      BASEPRI,R1
     83          }
   \   0000001E   0x4770             BX       LR               ;; return
     84          #endif /* !CORTEX_SIMPLIFIED_PRIORITY */
     85          
     86          #if CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
     87          /**
     88           * @brief   PendSV vector.
     89           * @details The PendSV vector is used for exception mode re-entering after a
     90           *          context switch.
     91           * @note    The PendSV vector is only used in compact kernel mode.
     92           */
     93          void PendSVVector(void) {
     94            struct extctx *ctxp;
     95          
     96          #if CORTEX_USE_FPU
     97            /* Enforcing unstacking of the FP part of the context.*/
     98            SCB_FPCCR &= ~FPCCR_LSPACT;
     99          #endif
    100          
    101            /* Current PSP value.*/
    102            ctxp = (struct extctx *)__get_PSP();
    103          
    104            /* Discarding the current exception context and positioning the stack to
    105               point to the real one.*/
    106            ctxp++;
    107          
    108            /* Restoring real position of the original stack frame.*/
    109            __set_PSP((unsigned long)ctxp);
    110          }
    111          #endif /* CORTEX_SIMPLIFIED_PRIORITY */
    112          
    113          /*===========================================================================*/
    114          /* Port exported functions.                                                  */
    115          /*===========================================================================*/
    116          
    117          /**
    118           * @brief   Port-related initialization code.
    119           */

   \                                 In section .text, align 2, keep-with-next
    120          void _port_init(void) {
   \                     _port_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    121          
    122            /* Initialization of the vector table and priority related settings.*/
    123            SCB_VTOR = CORTEX_VTOR_INIT;
   \   00000002   0x....             LDR.N    R0,??DataTable2_1  ;; 0xe000ed08
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
    124            SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
   \   00000008   0x....             LDR.N    R0,??DataTable2_2  ;; 0xe000ed0c
   \   0000000A   0x....             LDR.N    R1,??DataTable2_3  ;; 0x5fa0300
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    125          
    126          #if CORTEX_USE_FPU
    127            {
    128              /* Initializing the FPU context save in lazy mode.*/
    129              SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
   \   0000000E   0x....             LDR.N    R0,??DataTable2  ;; 0xe000ef34
   \   00000010   0xF05F 0x4140      MOVS     R1,#-1073741824
   \   00000014   0x6001             STR      R1,[R0, #+0]
    130          
    131              /* CP10 and CP11 set to full access.*/
    132              SCB_CPACR |= 0x00F00000;
   \   00000016   0x....             LDR.N    R0,??DataTable2_4  ;; 0xe000ed88
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF450 0x0070      ORRS     R0,R0,#0xF00000
   \   0000001E   0x....             LDR.N    R1,??DataTable2_4  ;; 0xe000ed88
   \   00000020   0x6008             STR      R0,[R1, #+0]
    133          
    134              /* Enables FPU context save/restore on exception entry/exit (FPCA bit).*/
    135              __set_CONTROL(__get_CONTROL() | 4);
   \   00000022   0xF3EF 0x8014      MRS      R0,CONTROL
   \   00000026   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002A   0xF380 0x8814      MSR      CONTROL,R0
    136          
    137              /* FPSCR and FPDSCR initially zero.*/
    138              __set_FPSCR(0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xEEE1 0x0A10      VMSR     FPSCR,R0
    139              SCB_FPDSCR = 0;
   \   00000034   0x....             LDR.N    R0,??DataTable2_5  ;; 0xe000ef3c
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6001             STR      R1,[R0, #+0]
    140            }
    141          #endif
    142          
    143            /* Initialization of the system vectors used by the port.*/
    144            nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    145              CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
   \   0000003A   0x2110             MOVS     R1,#+16
   \   0000003C   0x2007             MOVS     R0,#+7
   \   0000003E   0x.... 0x....      BL       nvicSetSystemHandlerPriority
    146            nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    147              CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
   \   00000042   0x2120             MOVS     R1,#+32
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0x.... 0x....      BL       nvicSetSystemHandlerPriority
    148            nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    149              CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
   \   0000004A   0x2160             MOVS     R1,#+96
   \   0000004C   0x200B             MOVS     R0,#+11
   \   0000004E   0x.... 0x....      BL       nvicSetSystemHandlerPriority
    150          }
   \   00000052   0xBD01             POP      {R0,PC}          ;; return
    151          
    152          /**
    153           * @brief   Exception exit redirection to _port_switch_from_isr().
    154           */

   \                                 In section .text, align 2, keep-with-next
    155          void _port_irq_epilogue(void) {
    156          
    157            port_lock_from_isr();
   \                     _port_irq_epilogue:
   \   00000000   0x2020             MOVS     R0,#+32
   \   00000002   0xF380 0x8811      MSR      BASEPRI,R0
    158            if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
   \   00000006   0x....             LDR.N    R0,??DataTable2_6  ;; 0xe000ed04
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0500             LSLS     R0,R0,#+20
   \   0000000C   0xD534             BPL.N    ??_port_irq_epilogue_0
    159              struct extctx *ctxp;
    160          
    161          #if CORTEX_USE_FPU
    162              /* Enforcing a lazy FPU state save. Note, it goes in the original
    163                 context because the FPCAR register has not been modified.*/
    164              (void)__get_FPSCR();
   \   0000000E   0xEEF1 0x1A10      VMRS     R1,FPSCR
    165          #endif
    166          
    167              /* Current PSP value.*/
    168              ctxp = (struct extctx *)__get_PSP();
   \   00000012   0xF3EF 0x8209      MRS      R2,PSP
   \   00000016   0x0010             MOVS     R0,R2
    169          
    170              /* Adding an artificial exception return context, there is no need to
    171                 populate it fully.*/
    172              ctxp--;
   \   00000018   0x3868             SUBS     R0,R0,#+104
    173              ctxp->xpsr = (regarm_t)0x01000000;
   \   0000001A   0xF05F 0x7280      MOVS     R2,#+16777216
   \   0000001E   0x61C2             STR      R2,[R0, #+28]
    174          #if CORTEX_USE_FPU
    175              ctxp->fpscr = (regarm_t)SCB_FPDSCR;
   \   00000020   0x....             LDR.N    R2,??DataTable2_5  ;; 0xe000ef3c
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x6602             STR      R2,[R0, #+96]
    176          #endif
    177              __set_PSP((unsigned long)ctxp);
   \   00000026   0xF380 0x8809      MSR      PSP,R0
    178          
    179              /* The exit sequence is different depending on if a preemption is
    180                 required or not.*/
    181              if (chSchIsPreemptionRequired()) {
   \   0000002A   0x....             LDR.N    R2,??DataTable2_7
   \   0000002C   0x6992             LDR      R2,[R2, #+24]
   \   0000002E   0xF892 0x2022      LDRB     R2,[R2, #+34]
   \   00000032   0x2A00             CMP      R2,#+0
   \   00000034   0xD00C             BEQ.N    ??_port_irq_epilogue_1
   \   00000036   0x....             LDR.N    R1,??DataTable2_7
   \   00000038   0x6989             LDR      R1,[R1, #+24]
   \   0000003A   0x6889             LDR      R1,[R1, #+8]
   \   0000003C   0x....             LDR.N    R2,??DataTable2_7
   \   0000003E   0x6812             LDR      R2,[R2, #+0]
   \   00000040   0x6892             LDR      R2,[R2, #+8]
   \   00000042   0x4291             CMP      R1,R2
   \   00000044   0xD201             BCS.N    ??_port_irq_epilogue_2
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xE000             B.N      ??_port_irq_epilogue_3
   \                     ??_port_irq_epilogue_2:
   \   0000004A   0x2100             MOVS     R1,#+0
   \                     ??_port_irq_epilogue_3:
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0xE00B             B.N      ??_port_irq_epilogue_4
   \                     ??_port_irq_epilogue_1:
   \   00000050   0x....             LDR.N    R1,??DataTable2_7
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x6889             LDR      R1,[R1, #+8]
   \   00000056   0x....             LDR.N    R2,??DataTable2_7
   \   00000058   0x6992             LDR      R2,[R2, #+24]
   \   0000005A   0x6892             LDR      R2,[R2, #+8]
   \   0000005C   0x4291             CMP      R1,R2
   \   0000005E   0xD301             BCC.N    ??_port_irq_epilogue_5
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0xE000             B.N      ??_port_irq_epilogue_6
   \                     ??_port_irq_epilogue_5:
   \   00000064   0x2100             MOVS     R1,#+0
   \                     ??_port_irq_epilogue_6:
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \                     ??_port_irq_epilogue_4:
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD002             BEQ.N    ??_port_irq_epilogue_7
    182                /* Preemption is required we need to enforce a context switch.*/
    183                ctxp->pc = (regarm_t)_port_switch_from_isr;
   \   0000006C   0x....             LDR.N    R1,??DataTable2_8
   \   0000006E   0x6181             STR      R1,[R0, #+24]
   \   00000070   0xE001             B.N      ??_port_irq_epilogue_8
    184              }
    185              else {
    186                /* Preemption not required, we just need to exit the exception
    187                   atomically.*/
    188                ctxp->pc = (regarm_t)_port_exit_from_isr;
   \                     ??_port_irq_epilogue_7:
   \   00000072   0x....             LDR.N    R1,??DataTable2_9
   \   00000074   0x6181             STR      R1,[R0, #+24]
    189              }
    190          
    191              /* Note, returning without unlocking is intentional, this is done in
    192                 order to keep the rest of the context switch atomic.*/
    193              return;
   \                     ??_port_irq_epilogue_8:
   \   00000076   0xE002             B.N      ??_port_irq_epilogue_9
    194            }
    195            port_unlock_from_isr();
   \                     ??_port_irq_epilogue_0:
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF380 0x8811      MSR      BASEPRI,R0
    196          }
   \                     ??_port_irq_epilogue_9:
   \   0000007E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0xE000EF34         DC32     0xe000ef34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x05FA0300         DC32     0x5fa0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0xE000ED88         DC32     0xe000ed88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0xE000EF3C         DC32     0xe000ef3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     _port_switch_from_isr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x........         DC32     _port_exit_from_isr
    197          
    198          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SVCallVector
       8   SysTickVector
         8   -> _port_irq_epilogue
         8   -> chSysTimerHandlerI
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> dbg_check_lock_from_isr
         8   -> dbg_check_unlock_from_isr
       8   _port_init
         8   -> nvicSetSystemHandlerPriority
       0   _port_irq_epilogue


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      32  SVCallVector
      40  SysTickVector
      84  _port_init
     128  _port_irq_epilogue

 
 324 bytes in section .text
 
 324 bytes of CODE memory

Errors: none
Warnings: none
