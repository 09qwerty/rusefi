###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:26 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32F4xx\hal_lld.c                          #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32F4xx\hal_lld.c -lCN                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\h #
#                       al_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ha #
#                       l_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32F4xx\hal_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32F4xx/hal_lld.c
     19           * @brief   STM32F4xx/STM32F2xx HAL subsystem low level driver source.
     20           *
     21           * @addtogroup HAL
     22           * @{
     23           */
     24          
     25          /* TODO: LSEBYP like in F3.*/
     26          
     27          #include "ch.h"
     28          #include "hal.h"
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          /*===========================================================================*/
     35          /* Driver exported variables.                                                */
     36          /*===========================================================================*/
     37          
     38          /*===========================================================================*/
     39          /* Driver local variables and types.                                         */
     40          /*===========================================================================*/
     41          
     42          /*===========================================================================*/
     43          /* Driver local functions.                                                   */
     44          /*===========================================================================*/
     45          
     46          /**
     47           * @brief   Initializes the backup domain.
     48           * @note    WARNING! Changing clock source impossible without resetting
     49           *          of the whole BKP domain.
     50           */

   \                                 In section .text, align 2, keep-with-next
     51          static void hal_lld_backup_domain_init(void) {
     52          
     53            /* Backup domain access enabled and left open.*/
     54            PWR->CR |= PWR_CR_DBP;
   \                     hal_lld_backup_domain_init:
   \   00000000   0x....             LDR.N    R0,??DataTable2  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000008   0x....             LDR.N    R1,??DataTable2  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     55          
     56            /* Reset BKP domain if different clock source selected.*/
     57            if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
   \   0000000C   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40023870
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF410 0x7040      ANDS     R0,R0,#0x300
   \   00000014   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000018   0xD006             BEQ.N    ??hal_lld_backup_domain_init_0
     58              /* Backup domain reset.*/
     59              RCC->BDCR = RCC_BDCR_BDRST;
   \   0000001A   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40023870
   \   0000001C   0xF45F 0x3180      MOVS     R1,#+65536
   \   00000020   0x6001             STR      R1,[R0, #+0]
     60              RCC->BDCR = 0;
   \   00000022   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40023870
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6001             STR      R1,[R0, #+0]
     61            }
     62          
     63          #if STM32_LSE_ENABLED
     64          #if defined(STM32_LSE_BYPASS)
     65            /* LSE Bypass.*/
     66            RCC->BDCR |= RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
     67          #else
     68            /* No LSE Bypass.*/
     69            RCC->BDCR |= RCC_BDCR_LSEON;
   \                     ??hal_lld_backup_domain_init_0:
   \   00000028   0x....             LDR.N    R0,??DataTable2_1  ;; 0x40023870
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000030   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40023870
   \   00000032   0x6008             STR      R0,[R1, #+0]
     70          #endif
     71            int waitCounter = 0;
   \   00000034   0x2000             MOVS     R0,#+0
     72            while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0 && ++waitCounter <LSE_TIMEOUT)
   \                     ??hal_lld_backup_domain_init_1:
   \   00000036   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40023870
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x0789             LSLS     R1,R1,#+30
   \   0000003C   0xD403             BMI.N    ??hal_lld_backup_domain_init_2
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x....             LDR.N    R1,??DataTable2_2  ;; 0xf4240
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xDBF7             BLT.N    ??hal_lld_backup_domain_init_1
     73              ;                                       /* Waits until LSE is stable.   */
     74          #endif /* STM32_LSE_ENABLED */
     75          
     76          #if HAL_USE_RTC
     77            /* If the backup domain hasn't been initialized yet then proceed with
     78               initialization.*/
     79            if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
   \                     ??hal_lld_backup_domain_init_2:
   \   00000046   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40023870
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x0409             LSLS     R1,R1,#+16
   \   0000004C   0xD40B             BMI.N    ??hal_lld_backup_domain_init_3
     80              /* Selects clock source.*/
     81              RCC->BDCR |= STM32_RTCSEL;
   \   0000004E   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40023870
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   00000056   0x....             LDR.N    R2,??DataTable2_1  ;; 0x40023870
   \   00000058   0x6011             STR      R1,[R2, #+0]
     82          
     83              /* RTC clock enabled.*/
     84              RCC->BDCR |= RCC_BDCR_RTCEN;
   \   0000005A   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40023870
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0xF451 0x4100      ORRS     R1,R1,#0x8000
   \   00000062   0x....             LDR.N    R2,??DataTable2_1  ;; 0x40023870
   \   00000064   0x6011             STR      R1,[R2, #+0]
     85            }
     86          #endif /* HAL_USE_RTC */
     87          
     88          #if STM32_BKPRAM_ENABLE
     89            rccEnableBKPSRAM(false);
     90          
     91            PWR->CSR |= PWR_CSR_BRE;
     92            while ((PWR->CSR & PWR_CSR_BRR) == 0)
     93              ;                                /* Waits until the regulator is stable */
     94          #else
     95            PWR->CSR &= ~PWR_CSR_BRE;
   \                     ??hal_lld_backup_domain_init_3:
   \   00000066   0x....             LDR.N    R1,??DataTable2_3  ;; 0x40007004
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0xF431 0x7100      BICS     R1,R1,#0x200
   \   0000006E   0x....             LDR.N    R2,??DataTable2_3  ;; 0x40007004
   \   00000070   0x6011             STR      R1,[R2, #+0]
     96          #endif /* STM32_BKPRAM_ENABLE */
     97          }
   \   00000072   0x4770             BX       LR               ;; return
     98          
     99          /*===========================================================================*/
    100          /* Driver interrupt handlers.                                                */
    101          /*===========================================================================*/
    102          
    103          /*===========================================================================*/
    104          /* Driver exported functions.                                                */
    105          /*===========================================================================*/
    106          
    107          /**
    108           * @brief   Low level HAL driver initialization.
    109           *
    110           * @notapi
    111           */

   \                                 In section .text, align 2, keep-with-next
    112          void hal_lld_init(void) {
   \                     hal_lld_init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    113          
    114            /* Reset of all peripherals. AHB3 is not reseted because it could have
    115               been initialized in the board initialization file (board.c).*/
    116            rccResetAHB1(~0);
   \   00000002   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023810
   \   00000004   0x6804             LDR      R4,[R0, #+0]
   \   00000006   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023810
   \   00000008   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023810
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6001             STR      R1,[R0, #+0]
    117            rccResetAHB2(~0);
   \   00000014   0x....             LDR.N    R0,??DataTable2_5  ;; 0x40023814
   \   00000016   0x6805             LDR      R5,[R0, #+0]
   \   00000018   0x....             LDR.N    R0,??DataTable2_5  ;; 0x40023814
   \   0000001A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   \   00000020   0x....             LDR.N    R0,??DataTable2_5  ;; 0x40023814
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6001             STR      R1,[R0, #+0]
    118            rccResetAPB1(~RCC_APB1RSTR_PWRRST);
   \   00000026   0x....             LDR.N    R0,??DataTable2_6  ;; 0x40023820
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF070 0x5080      ORNS     R0,R0,#+268435456
   \   0000002E   0x....             LDR.N    R1,??DataTable2_6  ;; 0x40023820
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0x....             LDR.N    R0,??DataTable2_6  ;; 0x40023820
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6001             STR      R1,[R0, #+0]
    119            rccResetAPB2(~0);
   \   00000038   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023824
   \   0000003A   0x6806             LDR      R6,[R0, #+0]
   \   0000003C   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023824
   \   0000003E   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000042   0x6001             STR      R1,[R0, #+0]
   \   00000044   0x....             LDR.N    R0,??DataTable2_7  ;; 0x40023824
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x6001             STR      R1,[R0, #+0]
    120          
    121            /* SysTick initialization using the system clock.*/
    122            SysTick->LOAD = STM32_HCLK / CH_FREQUENCY - 1;
   \   0000004A   0x....             LDR.N    R0,??DataTable2_8  ;; 0xe000e014
   \   0000004C   0x....             LDR.N    R1,??DataTable2_9  ;; 0x2903f
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    123            SysTick->VAL = 0;
   \   00000050   0x....             LDR.N    R0,??DataTable2_10  ;; 0xe000e018
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x6001             STR      R1,[R0, #+0]
    124            SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
    125                            SysTick_CTRL_ENABLE_Msk |
    126                            SysTick_CTRL_TICKINT_Msk;
   \   00000056   0x....             LDR.N    R0,??DataTable2_11  ;; 0xe000e010
   \   00000058   0x2107             MOVS     R1,#+7
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    127          
    128            /* DWT cycle counter enable.*/
    129            SCS_DEMCR |= SCS_DEMCR_TRCENA;
   \   0000005C   0x....             LDR.N    R0,??DataTable2_12  ;; 0xe000edfc
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000064   0x....             LDR.N    R1,??DataTable2_12  ;; 0xe000edfc
   \   00000066   0x6008             STR      R0,[R1, #+0]
    130            DWT_CTRL  |= DWT_CTRL_CYCCNTENA;
   \   00000068   0x....             LDR.N    R0,??DataTable2_13  ;; 0xe0001000
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000070   0x....             LDR.N    R1,??DataTable2_13  ;; 0xe0001000
   \   00000072   0x6008             STR      R0,[R1, #+0]
    131          
    132            /* PWR clock enabled.*/
    133            rccEnablePWRInterface(FALSE);
   \   00000074   0x....             LDR.N    R0,??DataTable2_14  ;; 0x40023840
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000007C   0x....             LDR.N    R1,??DataTable2_14  ;; 0x40023840
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    134          
    135            /* Initializes the backup domain.*/
    136            hal_lld_backup_domain_init();
   \   00000080   0x.... 0x....      BL       hal_lld_backup_domain_init
    137          
    138          #if defined(STM32_DMA_REQUIRED)
    139            dmaInit();
   \   00000084   0x.... 0x....      BL       dmaInit
    140          #endif
    141          
    142            /* Programmable voltage detector enable.*/
    143          #if STM32_PVD_ENABLE
    144            PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
    145          #endif /* STM32_PVD_ENABLE */
    146          }
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
    147          
    148          /**
    149           * @brief   STM32F2xx clocks and PLL initialization.
    150           * @note    All the involved constants come from the file @p board.h.
    151           * @note    This function should be invoked just after the system reset.
    152           *
    153           * @special
    154           */

   \                                 In section .text, align 2, keep-with-next
    155          void stm32_clock_init(void) {
    156          
    157          #if !STM32_NO_INIT
    158            /* PWR clock enable.*/
    159            RCC->APB1ENR = RCC_APB1ENR_PWREN;
   \                     stm32_clock_init:
   \   00000000   0x....             LDR.N    R0,??DataTable2_14  ;; 0x40023840
   \   00000002   0xF05F 0x5180      MOVS     R1,#+268435456
   \   00000006   0x6001             STR      R1,[R0, #+0]
    160          
    161            /* PWR initialization.*/
    162          #if defined(STM32F4XX) || defined(__DOXYGEN__)
    163            PWR->CR = STM32_VOS;
   \   00000008   0x....             LDR.N    R0,??DataTable2  ;; 0x40007000
   \   0000000A   0xF44F 0x4140      MOV      R1,#+49152
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    164          #else
    165            PWR->CR = 0;
    166          #endif
    167          
    168            /* HSI setup, it enforces the reset situation in order to handle possible
    169               problems with JTAG probes and re-initializations.*/
    170            RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
   \   00000010   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x....             LDR.N    R1,??DataTable2_15  ;; 0x40023800
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    171            while (!(RCC->CR & RCC_CR_HSIRDY))
   \                     ??stm32_clock_init_0:
   \   0000001C   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0780             LSLS     R0,R0,#+30
   \   00000022   0xD5FB             BPL.N    ??stm32_clock_init_0
    172              ;                                       /* Wait until HSI is stable.    */
    173          
    174            /* HSI is selected as new source without touching the other fields in
    175               CFGR. Clearing the register has to be postponed after HSI is the
    176               new source.*/
    177            RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
   \   00000024   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0880             LSRS     R0,R0,#+2
   \   0000002A   0x0080             LSLS     R0,R0,#+2
   \   0000002C   0x....             LDR.N    R1,??DataTable2_16  ;; 0x40023808
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    178            RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
   \   00000030   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   00000032   0x....             LDR.N    R1,??DataTable2_16  ;; 0x40023808
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x6001             STR      R1,[R0, #+0]
    179            while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
   \                     ??stm32_clock_init_1:
   \   00000038   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF010 0x0F0C      TST      R0,#0xC
   \   00000040   0xD1FA             BNE.N    ??stm32_clock_init_1
    180              ;                                       /* Wait until HSI is selected.  */
    181          
    182            /* Registers finally cleared to reset values.*/
    183            RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
   \   00000042   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF010 0x00F9      ANDS     R0,R0,#0xF9
   \   0000004A   0x....             LDR.N    R1,??DataTable2_15  ;; 0x40023800
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    184            RCC->CFGR = 0;                            /* CFGR reset value.            */
   \   0000004E   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x6001             STR      R1,[R0, #+0]
    185          
    186          #if STM32_HSE_ENABLED
    187            /* HSE activation.*/
    188          #if defined(STM32_HSE_BYPASS)
    189            /* HSE Bypass.*/
    190            RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
    191          #else
    192            /* No HSE Bypass.*/
    193            RCC->CR |= RCC_CR_HSEON;
   \   00000054   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000005C   0x....             LDR.N    R1,??DataTable2_15  ;; 0x40023800
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    194          #endif
    195            while ((RCC->CR & RCC_CR_HSERDY) == 0)
   \                     ??stm32_clock_init_2:
   \   00000060   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x0380             LSLS     R0,R0,#+14
   \   00000066   0xD5FB             BPL.N    ??stm32_clock_init_2
    196              ;                           /* Waits until HSE is stable.               */
    197          #endif
    198          
    199          #if STM32_LSI_ENABLED
    200            /* LSI activation.*/
    201            RCC->CSR |= RCC_CSR_LSION;
   \   00000068   0x....             LDR.N    R0,??DataTable2_17  ;; 0x40023874
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000070   0x....             LDR.N    R1,??DataTable2_17  ;; 0x40023874
   \   00000072   0x6008             STR      R0,[R1, #+0]
    202            while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
   \                     ??stm32_clock_init_3:
   \   00000074   0x....             LDR.N    R0,??DataTable2_17  ;; 0x40023874
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x0780             LSLS     R0,R0,#+30
   \   0000007A   0xD5FB             BPL.N    ??stm32_clock_init_3
    203              ;                           /* Waits until LSI is stable.               */
    204          #endif
    205          
    206          #if STM32_ACTIVATE_PLL
    207            /* PLL activation.*/
    208            RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
    209                           STM32_PLLM;
   \   0000007C   0x....             LDR.N    R0,??DataTable2_18  ;; 0x40023804
   \   0000007E   0x....             LDR.N    R1,??DataTable2_19  ;; 0x7405408
   \   00000080   0x6001             STR      R1,[R0, #+0]
    210            RCC->CR |= RCC_CR_PLLON;
   \   00000082   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   0000008A   0x....             LDR.N    R1,??DataTable2_15  ;; 0x40023800
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    211          
    212            /* Synchronization with voltage regulator stabilization.*/
    213          #if defined(STM32F4XX)
    214            while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
   \                     ??stm32_clock_init_4:
   \   0000008E   0x....             LDR.N    R0,??DataTable2_3  ;; 0x40007004
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x0440             LSLS     R0,R0,#+17
   \   00000094   0xD5FB             BPL.N    ??stm32_clock_init_4
    215              ;                           /* Waits until power regulator is stable.   */
    216          
    217          #if STM32_OVERDRIVE_REQUIRED
    218            /* Overdrive activation performed after activating the PLL in order to save
    219               time as recommended in RM in "Entering Over-drive mode" paragraph.*/
    220            PWR->CR |= PWR_CR_ODEN;
    221            while (!(PWR->CSR & PWR_CSR_ODRDY))
    222                ;
    223            PWR->CR |= PWR_CR_ODSWEN;
    224            while (!(PWR->CSR & PWR_CSR_ODSWRDY))
    225                ;
    226          #endif /* STM32_OVERDRIVE_REQUIRED */
    227          #endif /* defined(STM32F4XX) */
    228          
    229            /* Waiting for PLL lock.*/
    230            while (!(RCC->CR & RCC_CR_PLLRDY))
   \                     ??stm32_clock_init_5:
   \   00000096   0x....             LDR.N    R0,??DataTable2_15  ;; 0x40023800
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x0180             LSLS     R0,R0,#+6
   \   0000009C   0xD5FB             BPL.N    ??stm32_clock_init_5
    231              ;
    232          #endif /* STM32_OVERDRIVE_REQUIRED */
    233          
    234          #if STM32_ACTIVATE_PLLI2S
    235            /* PLLI2S activation.*/
    236            RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN;
    237            RCC->CR |= RCC_CR_PLLI2SON;
    238          
    239            /* Waiting for PLL lock.*/
    240            while (!(RCC->CR & RCC_CR_PLLI2SRDY))
    241              ;
    242          #endif
    243          
    244            /* Other clock-related settings (dividers, MCO etc).*/
    245            RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
    246                        STM32_RTCPRE | STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
   \   0000009E   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   000000A0   0x....             LDR.N    R1,??DataTable2_20  ;; 0x38089400
   \   000000A2   0x6001             STR      R1,[R0, #+0]
    247          
    248            /* Flash setup.*/
    249          #if defined(STM32_USE_REVISION_A_FIX)
    250            /* Some old revisions of F4x MCUs randomly crashes with compiler
    251               optimizations enabled AND flash caches enabled. */
    252            if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
    253              FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
    254            else
    255              FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    256                           FLASH_ACR_DCEN | STM32_FLASHBITS;
    257          #else
    258            FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
    259                         FLASH_ACR_DCEN | STM32_FLASHBITS;
   \   000000A4   0x....             LDR.N    R0,??DataTable2_21  ;; 0x40023c00
   \   000000A6   0xF240 0x7105      MOVW     R1,#+1797
   \   000000AA   0x6001             STR      R1,[R0, #+0]
    260          #endif
    261          
    262            /* Switching to the configured clock source if it is different from MSI.*/
    263          #if (STM32_SW != STM32_SW_HSI)
    264            RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
   \   000000AC   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000B4   0x....             LDR.N    R1,??DataTable2_16  ;; 0x40023808
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    265            while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
   \                     ??stm32_clock_init_6:
   \   000000B8   0x....             LDR.N    R0,??DataTable2_16  ;; 0x40023808
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000000C0   0x2808             CMP      R0,#+8
   \   000000C2   0xD1F9             BNE.N    ??stm32_clock_init_6
    266              ;
    267          #endif
    268          #endif /* STM32_NO_INIT */
    269          
    270            /* SYSCFG clock enabled here because it is a multi-functional unit shared
    271               among multiple drivers.*/
    272            rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
   \   000000C4   0x....             LDR.N    R0,??DataTable2_22  ;; 0x40023844
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   000000CC   0x....             LDR.N    R1,??DataTable2_22  ;; 0x40023844
   \   000000CE   0x6008             STR      R0,[R1, #+0]
   \   000000D0   0x....             LDR.N    R0,??DataTable2_23  ;; 0x40023864
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   000000D8   0x....             LDR.N    R1,??DataTable2_23  ;; 0x40023864
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    273          }
   \   000000DC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40023870         DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40023810         DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0xE000E014         DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x0002903F         DC32     0x2903f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0xE000E018         DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0xE000EDFC         DC32     0xe000edfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0xE0001000         DC32     0xe0001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_17:
   \   00000000   0x40023874         DC32     0x40023874

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_18:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_19:
   \   00000000   0x07405408         DC32     0x7405408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_20:
   \   00000000   0x38089400         DC32     0x38089400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_21:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_22:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_23:
   \   00000000   0x40023864         DC32     0x40023864
    274          
    275          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   hal_lld_backup_domain_init
      16   hal_lld_init
        16   -> dmaInit
        16   -> hal_lld_backup_domain_init
       0   stm32_clock_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_18
       4  ??DataTable2_19
       4  ??DataTable2_2
       4  ??DataTable2_20
       4  ??DataTable2_21
       4  ??DataTable2_22
       4  ??DataTable2_23
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     116  hal_lld_backup_domain_init
     138  hal_lld_init
     222  stm32_clock_init

 
 572 bytes in section .text
 
 572 bytes of CODE memory

Errors: none
Warnings: none
