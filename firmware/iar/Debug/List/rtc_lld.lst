###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:00 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\RTCv2\rtc_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\RTCv2\rtc_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\r #
#                       tc_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\rt #
#                       c_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\RTCv2\rtc_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          /*
     17             Concepts and parts of this file have been contributed by Uladzimir Pylinsky
     18             aka barthess.
     19           */
     20          
     21          /**
     22           * @file    STM32/RTCv2/rtc_lld.c
     23           * @brief   RTC low level driver.
     24           *
     25           * @addtogroup RTC
     26           * @{
     27           */
     28          
     29          #include "ch.h"
     30          #include "hal.h"
     31          
     32          #if HAL_USE_RTC || defined(__DOXYGEN__)
     33          
     34          /*===========================================================================*/
     35          /* Driver local definitions.                                                 */
     36          /*===========================================================================*/
     37          
     38          /*===========================================================================*/
     39          /* Driver exported variables.                                                */
     40          /*===========================================================================*/
     41          
     42          /**
     43           * @brief RTC driver identifier.
     44           */

   \                                 In section .bss, align 4
     45          RTCDriver RTCD1;
   \                     RTCD1:
   \   00000000                      DS8 4
     46          
     47          /*===========================================================================*/
     48          /* Driver local variables and types.                                         */
     49          /*===========================================================================*/
     50          
     51          /*===========================================================================*/
     52          /* Driver local functions.                                                   */
     53          /*===========================================================================*/
     54          
     55          /**
     56           * @brief   Wait for synchronization of RTC registers with APB1 bus.
     57           * @details This function must be invoked before trying to read RTC registers.
     58           *
     59           * @notapi
     60           */
     61          #define rtc_lld_apb1_sync() {                                                \
     62              int counter = 0;                                                         \
     63          	while ((RTCD1.id_rtc->ISR & RTC_ISR_RSF) == 0 && ++counter <LSE_TIMEOUT);\
     64          	}
     65          
     66          /**
     67           * @brief   Beginning of configuration procedure.
     68           *
     69           * @notapi
     70           */
     71          #define rtc_lld_enter_init() {                                              \
     72            RTCD1.id_rtc->ISR |= RTC_ISR_INIT;                                        \
     73            int counter = 0;                                                          \
     74            while ((RTCD1.id_rtc->ISR & RTC_ISR_INITF) == 0 && ++counter <LSE_TIMEOUT)\
     75              ;                                                                       \
     76          }
     77          
     78          /**
     79           * @brief   Finalizing of configuration procedure.
     80           *
     81           * @notapi
     82           */
     83          #define rtc_lld_exit_init() {RTCD1.id_rtc->ISR &= ~RTC_ISR_INIT;}
     84          
     85          /*===========================================================================*/
     86          /* Driver interrupt handlers.                                                */
     87          /*===========================================================================*/
     88          
     89          /*===========================================================================*/
     90          /* Driver exported functions.                                                */
     91          /*===========================================================================*/
     92          
     93          /**
     94           * @brief   Enable access to registers.
     95           *
     96           * @api
     97           */

   \                                 In section .text, align 2, keep-with-next
     98          void rtc_lld_init(void){
     99            RTCD1.id_rtc = RTC;
   \                     rtc_lld_init:
   \   00000000   0x....             LDR.N    R1,??DataTable3
   \   00000002   0x....             LDR.N    R2,??DataTable3_1  ;; 0x40002800
   \   00000004   0x600A             STR      R2,[R1, #+0]
    100          
    101            /* Asynchronous part of preloader. Set it to maximum value. */
    102            uint32_t prediv_a = 0x7F;
   \   00000006   0x217F             MOVS     R1,#+127
    103          
    104            /* Disable write protection. */
    105            RTCD1.id_rtc->WPR = 0xCA;
   \   00000008   0x....             LDR.N    R2,??DataTable3
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x23CA             MOVS     R3,#+202
   \   0000000E   0x6253             STR      R3,[R2, #+36]
    106            RTCD1.id_rtc->WPR = 0x53;
   \   00000010   0x....             LDR.N    R2,??DataTable3
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x2353             MOVS     R3,#+83
   \   00000016   0x6253             STR      R3,[R2, #+36]
    107          
    108            /* If calendar not init yet. */
    109            if (!(RTC->ISR & RTC_ISR_INITS)){
   \   00000018   0x....             LDR.N    R2,??DataTable3_2  ;; 0x4000280c
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x06D2             LSLS     R2,R2,#+27
   \   0000001E   0xD42A             BMI.N    ??rtc_lld_init_0
    110              rtc_lld_enter_init();
   \   00000020   0x....             LDR.N    R2,??DataTable3
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x68D2             LDR      R2,[R2, #+12]
   \   00000026   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   0000002A   0x....             LDR.N    R3,??DataTable3
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x60DA             STR      R2,[R3, #+12]
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x0010             MOVS     R0,R2
   \                     ??rtc_lld_init_1:
   \   00000034   0x....             LDR.N    R2,??DataTable3
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x68D2             LDR      R2,[R2, #+12]
   \   0000003A   0x0652             LSLS     R2,R2,#+25
   \   0000003C   0xD403             BMI.N    ??rtc_lld_init_2
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x....             LDR.N    R2,??DataTable3_3  ;; 0xf4240
   \   00000042   0x4290             CMP      R0,R2
   \   00000044   0xDBF6             BLT.N    ??rtc_lld_init_1
    111          
    112              /* Prescaler register must be written in two SEPARATE writes. */
    113              prediv_a = (prediv_a << 16) |
    114                          (((STM32_RTCCLK / (prediv_a + 1)) - 1) & 0x7FFF);
   \                     ??rtc_lld_init_2:
   \   00000046   0xF44F 0x4000      MOV      R0,#+32768
   \   0000004A   0x1C4A             ADDS     R2,R1,#+1
   \   0000004C   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   00000054   0x0C40             LSRS     R0,R0,#+17
   \   00000056   0xEA50 0x4101      ORRS     R1,R0,R1, LSL #+16
    115              RTCD1.id_rtc->PRER = prediv_a;
   \   0000005A   0x....             LDR.N    R0,??DataTable3
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x6101             STR      R1,[R0, #+16]
    116              RTCD1.id_rtc->PRER = prediv_a;
   \   00000060   0x....             LDR.N    R0,??DataTable3
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6101             STR      R1,[R0, #+16]
    117              rtc_lld_exit_init();
   \   00000066   0x....             LDR.N    R0,??DataTable3
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000070   0x....             LDR.N    R2,??DataTable3
   \   00000072   0x6812             LDR      R2,[R2, #+0]
   \   00000074   0x60D0             STR      R0,[R2, #+12]
    118            }
    119          }
   \                     ??rtc_lld_init_0:
   \   00000076   0x4770             BX       LR               ;; return
    120          
    121          /**
    122           * @brief   Set current time.
    123           * @note    Fractional part will be silently ignored. There is no possibility
    124           *          to set it on STM32 platform.
    125           *
    126           * @param[in] rtcp      pointer to RTC driver structure
    127           * @param[in] timespec  pointer to a @p RTCTime structure
    128           *
    129           * @api
    130           */

   \                                 In section .text, align 2, keep-with-next
    131          void rtc_lld_set_time(RTCDriver *rtcp, const RTCTime *timespec) {
   \                     rtc_lld_set_time:
   \   00000000   0xB410             PUSH     {R4}
    132            (void)rtcp;
    133          
    134            rtc_lld_enter_init();
   \   00000002   0x....             LDR.N    R3,??DataTable3
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x68DB             LDR      R3,[R3, #+12]
   \   00000008   0xF053 0x0380      ORRS     R3,R3,#0x80
   \   0000000C   0x....             LDR.N    R4,??DataTable3
   \   0000000E   0x6824             LDR      R4,[R4, #+0]
   \   00000010   0x60E3             STR      R3,[R4, #+12]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x001A             MOVS     R2,R3
   \                     ??rtc_lld_set_time_0:
   \   00000016   0x....             LDR.N    R3,??DataTable3
   \   00000018   0x681B             LDR      R3,[R3, #+0]
   \   0000001A   0x68DB             LDR      R3,[R3, #+12]
   \   0000001C   0x065B             LSLS     R3,R3,#+25
   \   0000001E   0xD403             BMI.N    ??rtc_lld_set_time_1
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \   00000022   0x....             LDR.N    R3,??DataTable3_3  ;; 0xf4240
   \   00000024   0x429A             CMP      R2,R3
   \   00000026   0xDBF6             BLT.N    ??rtc_lld_set_time_0
    135            if (timespec->h12)
   \                     ??rtc_lld_set_time_1:
   \   00000028   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD008             BEQ.N    ??rtc_lld_set_time_2
    136              RTCD1.id_rtc->CR |= RTC_CR_FMT;
   \   0000002E   0x....             LDR.N    R2,??DataTable3
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0x6892             LDR      R2,[R2, #+8]
   \   00000034   0xF052 0x0240      ORRS     R2,R2,#0x40
   \   00000038   0x....             LDR.N    R3,??DataTable3
   \   0000003A   0x681B             LDR      R3,[R3, #+0]
   \   0000003C   0x609A             STR      R2,[R3, #+8]
   \   0000003E   0xE007             B.N      ??rtc_lld_set_time_3
    137            else
    138              RTCD1.id_rtc->CR &= ~RTC_CR_FMT;
   \                     ??rtc_lld_set_time_2:
   \   00000040   0x....             LDR.N    R2,??DataTable3
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x6892             LDR      R2,[R2, #+8]
   \   00000046   0xF032 0x0240      BICS     R2,R2,#0x40
   \   0000004A   0x....             LDR.N    R3,??DataTable3
   \   0000004C   0x681B             LDR      R3,[R3, #+0]
   \   0000004E   0x609A             STR      R2,[R3, #+8]
    139            RTCD1.id_rtc->TR = timespec->tv_time;
   \                     ??rtc_lld_set_time_3:
   \   00000050   0x684A             LDR      R2,[R1, #+4]
   \   00000052   0x....             LDR.N    R3,??DataTable3
   \   00000054   0x681B             LDR      R3,[R3, #+0]
   \   00000056   0x601A             STR      R2,[R3, #+0]
    140            RTCD1.id_rtc->DR = timespec->tv_date;
   \   00000058   0x....             LDR.N    R2,??DataTable3
   \   0000005A   0x6812             LDR      R2,[R2, #+0]
   \   0000005C   0x680B             LDR      R3,[R1, #+0]
   \   0000005E   0x6053             STR      R3,[R2, #+4]
    141            rtc_lld_exit_init();
   \   00000060   0x....             LDR.N    R2,??DataTable3
   \   00000062   0x6812             LDR      R2,[R2, #+0]
   \   00000064   0x68D2             LDR      R2,[R2, #+12]
   \   00000066   0xF032 0x0280      BICS     R2,R2,#0x80
   \   0000006A   0x....             LDR.N    R3,??DataTable3
   \   0000006C   0x681B             LDR      R3,[R3, #+0]
   \   0000006E   0x60DA             STR      R2,[R3, #+12]
    142          }
   \   00000070   0xBC10             POP      {R4}
   \   00000072   0x4770             BX       LR               ;; return
    143          
    144          /**
    145           * @brief   Get current time.
    146           *
    147           * @param[in] rtcp      pointer to RTC driver structure
    148           * @param[out] timespec pointer to a @p RTCTime structure
    149           *
    150           * @api
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          void rtc_lld_get_time(RTCDriver *rtcp, RTCTime *timespec) {
   \                     rtc_lld_get_time:
   \   00000000   0xB410             PUSH     {R4}
    153            (void)rtcp;
    154          
    155            rtc_lld_apb1_sync();
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x001A             MOVS     R2,R3
   \                     ??rtc_lld_get_time_0:
   \   00000006   0x....             LDR.N    R3,??DataTable3
   \   00000008   0x681B             LDR      R3,[R3, #+0]
   \   0000000A   0x68DB             LDR      R3,[R3, #+12]
   \   0000000C   0x069B             LSLS     R3,R3,#+26
   \   0000000E   0xD403             BMI.N    ??rtc_lld_get_time_1
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \   00000012   0x....             LDR.N    R3,??DataTable3_3  ;; 0xf4240
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xDBF6             BLT.N    ??rtc_lld_get_time_0
    156          
    157          #if STM32_RTC_HAS_SUBSECONDS
    158            {
    159              uint32_t prer = RTCD1.id_rtc->PRER & 0x7FFF;
   \                     ??rtc_lld_get_time_1:
   \   00000018   0x....             LDR.N    R2,??DataTable3
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x6912             LDR      R2,[R2, #+16]
   \   0000001E   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000020   0x0C52             LSRS     R2,R2,#+17
    160              uint32_t ssr  = RTCD1.id_rtc->SSR;
   \   00000022   0x....             LDR.N    R3,??DataTable3
   \   00000024   0x681B             LDR      R3,[R3, #+0]
   \   00000026   0x6A9B             LDR      R3,[R3, #+40]
    161              timespec->tv_msec = (1000 * (prer - ssr)) / (prer + 1);
   \   00000028   0x1AD3             SUBS     R3,R2,R3
   \   0000002A   0xF44F 0x747A      MOV      R4,#+1000
   \   0000002E   0x4363             MULS     R3,R4,R3
   \   00000030   0x1C52             ADDS     R2,R2,#+1
   \   00000032   0xFBB3 0xF2F2      UDIV     R2,R3,R2
   \   00000036   0x60CA             STR      R2,[R1, #+12]
    162            }
    163          #endif /* STM32_RTC_HAS_SUBSECONDS */
    164            timespec->tv_time = RTCD1.id_rtc->TR;
   \   00000038   0x....             LDR.N    R2,??DataTable3
   \   0000003A   0x6812             LDR      R2,[R2, #+0]
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0x604A             STR      R2,[R1, #+4]
    165            timespec->tv_date = RTCD1.id_rtc->DR;
   \   00000040   0x....             LDR.N    R2,??DataTable3
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x6852             LDR      R2,[R2, #+4]
   \   00000046   0x600A             STR      R2,[R1, #+0]
    166          }
   \   00000048   0xBC10             POP      {R4}
   \   0000004A   0x4770             BX       LR               ;; return
    167          
    168          /**
    169           * @brief     Set alarm time.
    170           *
    171           * @note      Default value after BKP domain reset for both comparators is 0.
    172           * @note      Function does not performs any checks of alarm time validity.
    173           *
    174           * @param[in] rtcp      pointer to RTC driver structure
    175           * @param[in] alarm     alarm identifier starting from zero
    176           * @param[in] alarmspec pointer to a @p RTCAlarm structure
    177           *
    178           * @api
    179           */

   \                                 In section .text, align 2, keep-with-next
    180          void rtc_lld_set_alarm(RTCDriver *rtcp,
    181                                 rtcalarm_t alarm,
    182                                 const RTCAlarm *alarmspec) {
   \                     rtc_lld_set_alarm:
   \   00000000   0xB410             PUSH     {R4}
    183          
    184            if (alarm == 0) {
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD128             BNE.N    ??rtc_lld_set_alarm_0
    185              if (alarmspec != NULL){
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD019             BEQ.N    ??rtc_lld_set_alarm_1
    186                rtcp->id_rtc->CR &= ~RTC_CR_ALRAE;
   \   0000000A   0x6803             LDR      R3,[R0, #+0]
   \   0000000C   0x689B             LDR      R3,[R3, #+8]
   \   0000000E   0xF433 0x7380      BICS     R3,R3,#0x100
   \   00000012   0x6804             LDR      R4,[R0, #+0]
   \   00000014   0x60A3             STR      R3,[R4, #+8]
    187                while(!(rtcp->id_rtc->ISR & RTC_ISR_ALRAWF))
   \                     ??rtc_lld_set_alarm_2:
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x68DB             LDR      R3,[R3, #+12]
   \   0000001A   0x07DB             LSLS     R3,R3,#+31
   \   0000001C   0xD5FB             BPL.N    ??rtc_lld_set_alarm_2
    188                  ;
    189                rtcp->id_rtc->ALRMAR = alarmspec->tv_datetime;
   \   0000001E   0x6803             LDR      R3,[R0, #+0]
   \   00000020   0x6814             LDR      R4,[R2, #+0]
   \   00000022   0x61DC             STR      R4,[R3, #+28]
    190                rtcp->id_rtc->CR |= RTC_CR_ALRAE;
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689B             LDR      R3,[R3, #+8]
   \   00000028   0xF453 0x7380      ORRS     R3,R3,#0x100
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x60A3             STR      R3,[R4, #+8]
    191                rtcp->id_rtc->CR |= RTC_CR_ALRAIE;
   \   00000030   0x6803             LDR      R3,[R0, #+0]
   \   00000032   0x689B             LDR      R3,[R3, #+8]
   \   00000034   0xF453 0x5380      ORRS     R3,R3,#0x1000
   \   00000038   0x6804             LDR      R4,[R0, #+0]
   \   0000003A   0x60A3             STR      R3,[R4, #+8]
   \   0000003C   0xE034             B.N      ??rtc_lld_set_alarm_3
    192              }
    193              else {
    194                rtcp->id_rtc->CR &= ~RTC_CR_ALRAIE;
   \                     ??rtc_lld_set_alarm_1:
   \   0000003E   0x6803             LDR      R3,[R0, #+0]
   \   00000040   0x689B             LDR      R3,[R3, #+8]
   \   00000042   0xF433 0x5380      BICS     R3,R3,#0x1000
   \   00000046   0x6804             LDR      R4,[R0, #+0]
   \   00000048   0x60A3             STR      R3,[R4, #+8]
    195                rtcp->id_rtc->CR &= ~RTC_CR_ALRAE;
   \   0000004A   0x6803             LDR      R3,[R0, #+0]
   \   0000004C   0x689B             LDR      R3,[R3, #+8]
   \   0000004E   0xF433 0x7380      BICS     R3,R3,#0x100
   \   00000052   0x6804             LDR      R4,[R0, #+0]
   \   00000054   0x60A3             STR      R3,[R4, #+8]
   \   00000056   0xE027             B.N      ??rtc_lld_set_alarm_3
    196              }
    197            }
    198          #if RTC_ALARMS == 2
    199            else{
    200              if (alarmspec != NULL){
   \                     ??rtc_lld_set_alarm_0:
   \   00000058   0x2A00             CMP      R2,#+0
   \   0000005A   0xD019             BEQ.N    ??rtc_lld_set_alarm_4
    201                rtcp->id_rtc->CR &= ~RTC_CR_ALRBE;
   \   0000005C   0x6803             LDR      R3,[R0, #+0]
   \   0000005E   0x689B             LDR      R3,[R3, #+8]
   \   00000060   0xF433 0x7300      BICS     R3,R3,#0x200
   \   00000064   0x6804             LDR      R4,[R0, #+0]
   \   00000066   0x60A3             STR      R3,[R4, #+8]
    202                while(!(rtcp->id_rtc->ISR & RTC_ISR_ALRBWF))
   \                     ??rtc_lld_set_alarm_5:
   \   00000068   0x6803             LDR      R3,[R0, #+0]
   \   0000006A   0x68DB             LDR      R3,[R3, #+12]
   \   0000006C   0x079B             LSLS     R3,R3,#+30
   \   0000006E   0xD5FB             BPL.N    ??rtc_lld_set_alarm_5
    203                  ;
    204                rtcp->id_rtc->ALRMBR = alarmspec->tv_datetime;
   \   00000070   0x6803             LDR      R3,[R0, #+0]
   \   00000072   0x6814             LDR      R4,[R2, #+0]
   \   00000074   0x621C             STR      R4,[R3, #+32]
    205                rtcp->id_rtc->CR |= RTC_CR_ALRBE;
   \   00000076   0x6803             LDR      R3,[R0, #+0]
   \   00000078   0x689B             LDR      R3,[R3, #+8]
   \   0000007A   0xF453 0x7300      ORRS     R3,R3,#0x200
   \   0000007E   0x6804             LDR      R4,[R0, #+0]
   \   00000080   0x60A3             STR      R3,[R4, #+8]
    206                rtcp->id_rtc->CR |= RTC_CR_ALRBIE;
   \   00000082   0x6803             LDR      R3,[R0, #+0]
   \   00000084   0x689B             LDR      R3,[R3, #+8]
   \   00000086   0xF453 0x5300      ORRS     R3,R3,#0x2000
   \   0000008A   0x6804             LDR      R4,[R0, #+0]
   \   0000008C   0x60A3             STR      R3,[R4, #+8]
   \   0000008E   0xE00B             B.N      ??rtc_lld_set_alarm_3
    207              }
    208              else {
    209                rtcp->id_rtc->CR &= ~RTC_CR_ALRBIE;
   \                     ??rtc_lld_set_alarm_4:
   \   00000090   0x6803             LDR      R3,[R0, #+0]
   \   00000092   0x689B             LDR      R3,[R3, #+8]
   \   00000094   0xF433 0x5300      BICS     R3,R3,#0x2000
   \   00000098   0x6804             LDR      R4,[R0, #+0]
   \   0000009A   0x60A3             STR      R3,[R4, #+8]
    210                rtcp->id_rtc->CR &= ~RTC_CR_ALRBE;
   \   0000009C   0x6803             LDR      R3,[R0, #+0]
   \   0000009E   0x689B             LDR      R3,[R3, #+8]
   \   000000A0   0xF433 0x7300      BICS     R3,R3,#0x200
   \   000000A4   0x6804             LDR      R4,[R0, #+0]
   \   000000A6   0x60A3             STR      R3,[R4, #+8]
    211              }
    212            }
    213          #endif /* RTC_ALARMS == 2 */
    214          }
   \                     ??rtc_lld_set_alarm_3:
   \   000000A8   0xBC10             POP      {R4}
   \   000000AA   0x4770             BX       LR               ;; return
    215          
    216          /**
    217           * @brief   Get alarm time.
    218           *
    219           * @param[in] rtcp       pointer to RTC driver structure
    220           * @param[in] alarm      alarm identifier starting from zero
    221           * @param[out] alarmspec pointer to a @p RTCAlarm structure
    222           *
    223           * @api
    224           */

   \                                 In section .text, align 2, keep-with-next
    225          void rtc_lld_get_alarm(RTCDriver *rtcp,
    226                                 rtcalarm_t alarm,
    227                                 RTCAlarm *alarmspec) {
    228          
    229            if (alarm == 0)
   \                     rtc_lld_get_alarm:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD103             BNE.N    ??rtc_lld_get_alarm_0
    230              alarmspec->tv_datetime = rtcp->id_rtc->ALRMAR;
   \   00000004   0x6803             LDR      R3,[R0, #+0]
   \   00000006   0x69DB             LDR      R3,[R3, #+28]
   \   00000008   0x6013             STR      R3,[R2, #+0]
   \   0000000A   0xE002             B.N      ??rtc_lld_get_alarm_1
    231          #if RTC_ALARMS == 2
    232            else
    233              alarmspec->tv_datetime = rtcp->id_rtc->ALRMBR;
   \                     ??rtc_lld_get_alarm_0:
   \   0000000C   0x6803             LDR      R3,[R0, #+0]
   \   0000000E   0x6A1B             LDR      R3,[R3, #+32]
   \   00000010   0x6013             STR      R3,[R2, #+0]
    234          #endif
    235          }
   \                     ??rtc_lld_get_alarm_1:
   \   00000012   0x4770             BX       LR               ;; return
    236          
    237          /**
    238           * @brief     Sets time of periodic wakeup.
    239           *
    240           * @note      Default value after BKP domain reset is 0x0000FFFF
    241           *
    242           * @param[in] rtcp       pointer to RTC driver structure
    243           * @param[in] wakeupspec pointer to a @p RTCWakeup structure
    244           *
    245           * @api
    246           */
    247          #if RTC_HAS_PERIODIC_WAKEUPS

   \                                 In section .text, align 2, keep-with-next
    248          void rtcSetPeriodicWakeup_v2(RTCDriver *rtcp, const RTCWakeup *wakeupspec) {
   \                     rtcSetPeriodicWakeup_v2:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    249          
    250            if (wakeupspec != NULL){
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD028             BEQ.N    ??rtcSetPeriodicWakeup_v2_0
    251              chDbgCheck((wakeupspec->wakeup != 0x30000),
    252                         "rtc_lld_set_periodic_wakeup, forbidden combination");
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000010   0xD104             BNE.N    ??rtcSetPeriodicWakeup_v2_1
   \   00000012   0x22FC             MOVS     R2,#+252
   \   00000014   0x....             LDR.N    R1,??DataTable3_4
   \   00000016   0x....             LDR.N    R0,??DataTable3_5
   \   00000018   0x.... 0x....      BL       chDbgPanic3
    253          
    254              rtcp->id_rtc->CR &= ~RTC_CR_WUTE;
   \                     ??rtcSetPeriodicWakeup_v2_1:
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6880             LDR      R0,[R0, #+8]
   \   00000020   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6088             STR      R0,[R1, #+8]
    255              while(!(rtcp->id_rtc->ISR & RTC_ISR_WUTWF))
   \                     ??rtcSetPeriodicWakeup_v2_2:
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x0740             LSLS     R0,R0,#+29
   \   0000002E   0xD5FB             BPL.N    ??rtcSetPeriodicWakeup_v2_2
    256                ;
    257              rtcp->id_rtc->WUTR = wakeupspec->wakeup & 0xFFFF;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6829             LDR      R1,[R5, #+0]
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0x6141             STR      R1,[R0, #+20]
    258              rtcp->id_rtc->CR   = (wakeupspec->wakeup >> 16) & 0x7;
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0xF3C0 0x4002      UBFX     R0,R0,#+16,#+3
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x6088             STR      R0,[R1, #+8]
    259              rtcp->id_rtc->CR |= RTC_CR_WUTIE;
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6880             LDR      R0,[R0, #+8]
   \   00000046   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6088             STR      R0,[R1, #+8]
    260              rtcp->id_rtc->CR |= RTC_CR_WUTE;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6088             STR      R0,[R1, #+8]
   \   0000005A   0xE00B             B.N      ??rtcSetPeriodicWakeup_v2_3
    261            }
    262            else {
    263              rtcp->id_rtc->CR &= ~RTC_CR_WUTIE;
   \                     ??rtcSetPeriodicWakeup_v2_0:
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6880             LDR      R0,[R0, #+8]
   \   00000060   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6088             STR      R0,[R1, #+8]
    264              rtcp->id_rtc->CR &= ~RTC_CR_WUTE;
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6880             LDR      R0,[R0, #+8]
   \   0000006C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6088             STR      R0,[R1, #+8]
    265            }
    266          }
   \                     ??rtcSetPeriodicWakeup_v2_3:
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    267          #endif /* RTC_HAS_PERIODIC_WAKEUPS */
    268          
    269          /**
    270           * @brief     Gets time of periodic wakeup.
    271           *
    272           * @note      Default value after BKP domain reset is 0x0000FFFF
    273           *
    274           * @param[in] rtcp        pointer to RTC driver structure
    275           * @param[out] wakeupspec pointer to a @p RTCWakeup structure
    276           *
    277           * @api
    278           */
    279          #if RTC_HAS_PERIODIC_WAKEUPS

   \                                 In section .text, align 2, keep-with-next
    280          void rtcGetPeriodicWakeup_v2(RTCDriver *rtcp, RTCWakeup *wakeupspec) {
    281          
    282            wakeupspec->wakeup  = 0;
   \                     rtcGetPeriodicWakeup_v2:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x600A             STR      R2,[R1, #+0]
    283            wakeupspec->wakeup |= rtcp->id_rtc->WUTR;
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x695B             LDR      R3,[R3, #+20]
   \   0000000A   0x431A             ORRS     R2,R3,R2
   \   0000000C   0x600A             STR      R2,[R1, #+0]
    284            wakeupspec->wakeup |= (((uint32_t)rtcp->id_rtc->CR) & 0x7) << 16;
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x6803             LDR      R3,[R0, #+0]
   \   00000012   0x689B             LDR      R3,[R3, #+8]
   \   00000014   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000018   0xEA52 0x4203      ORRS     R2,R2,R3, LSL #+16
   \   0000001C   0x600A             STR      R2,[R1, #+0]
    285          }
   \   0000001E   0x4770             BX       LR               ;; return
    286          #endif /* RTC_HAS_PERIODIC_WAKEUPS */
    287          
    288          /**
    289           * @brief   Get current time in format suitable for usage in FatFS.
    290           *
    291           * @param[in] rtcp      pointer to RTC driver structure
    292           * @return              FAT time value.
    293           *
    294           * @api
    295           */

   \                                 In section .text, align 2, keep-with-next
    296          uint32_t rtc_lld_get_time_fat(RTCDriver *rtcp) {
   \                     rtc_lld_get_time_fat:
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    297            uint32_t fattime;
    298            RTCTime timespec;
    299            uint32_t tv_time;
    300            uint32_t tv_date;
    301            uint32_t v;
    302          
    303            chSysLock();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock
    304            rtcGetTimeI(rtcp, &timespec);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       rtc_lld_get_time
    305            chSysUnlock();
   \   00000018   0x.... 0x....      BL       dbg_check_unlock
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF380 0x8811      MSR      BASEPRI,R0
    306          
    307            tv_time = timespec.tv_time;
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0x0006             MOVS     R6,R0
    308            tv_date = timespec.tv_date;
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x0007             MOVS     R7,R0
    309          
    310            v =  (tv_time & RTC_TR_SU) >> RTC_TR_SU_OFFSET;
   \   0000002A   0xF016 0x000F      ANDS     R0,R6,#0xF
   \   0000002E   0x4680             MOV      R8,R0
    311            v += ((tv_time & RTC_TR_ST) >> RTC_TR_ST_OFFSET) * 10;
   \   00000030   0xF3C6 0x1002      UBFX     R0,R6,#+4,#+3
   \   00000034   0x210A             MOVS     R1,#+10
   \   00000036   0xFB01 0x8800      MLA      R8,R1,R0,R8
    312            fattime  = v >> 1;
   \   0000003A   0xEA5F 0x0058      LSRS     R0,R8,#+1
   \   0000003E   0x0005             MOVS     R5,R0
    313          
    314            v =  (tv_time & RTC_TR_MNU) >> RTC_TR_MNU_OFFSET;
   \   00000040   0xF3C6 0x2003      UBFX     R0,R6,#+8,#+4
   \   00000044   0x4680             MOV      R8,R0
    315            v += ((tv_time & RTC_TR_MNT) >> RTC_TR_MNT_OFFSET) * 10;
   \   00000046   0xF3C6 0x3002      UBFX     R0,R6,#+12,#+3
   \   0000004A   0x210A             MOVS     R1,#+10
   \   0000004C   0xFB01 0x8800      MLA      R8,R1,R0,R8
    316            fattime |= v << 5;
   \   00000050   0xEA55 0x1548      ORRS     R5,R5,R8, LSL #+5
    317          
    318            v =  (tv_time & RTC_TR_HU) >> RTC_TR_HU_OFFSET;
   \   00000054   0xF3C6 0x4003      UBFX     R0,R6,#+16,#+4
   \   00000058   0x4680             MOV      R8,R0
    319            v += ((tv_time & RTC_TR_HT) >> RTC_TR_HT_OFFSET) * 10;
   \   0000005A   0xF3C6 0x5001      UBFX     R0,R6,#+20,#+2
   \   0000005E   0x210A             MOVS     R1,#+10
   \   00000060   0xFB01 0x8800      MLA      R8,R1,R0,R8
    320            v += 12 * ((tv_time & RTC_TR_PM) >> RTC_TR_PM_OFFSET);
   \   00000064   0xF3C6 0x5080      UBFX     R0,R6,#+22,#+1
   \   00000068   0x210C             MOVS     R1,#+12
   \   0000006A   0xFB01 0x8800      MLA      R8,R1,R0,R8
    321            fattime |= v << 11;
   \   0000006E   0xEA55 0x25C8      ORRS     R5,R5,R8, LSL #+11
    322          
    323            v =  (tv_date & RTC_DR_DU) >> RTC_DR_DU_OFFSET;
   \   00000072   0xF017 0x000F      ANDS     R0,R7,#0xF
   \   00000076   0x4680             MOV      R8,R0
    324            v += ((tv_date & RTC_DR_DT) >> RTC_DR_DT_OFFSET) * 10;
   \   00000078   0xF3C7 0x1001      UBFX     R0,R7,#+4,#+2
   \   0000007C   0x210A             MOVS     R1,#+10
   \   0000007E   0xFB01 0x8800      MLA      R8,R1,R0,R8
    325            fattime |= v << 16;
   \   00000082   0xEA55 0x4508      ORRS     R5,R5,R8, LSL #+16
    326          
    327            v =  (tv_date & RTC_DR_MU) >> RTC_DR_MU_OFFSET;
   \   00000086   0xF3C7 0x2003      UBFX     R0,R7,#+8,#+4
   \   0000008A   0x4680             MOV      R8,R0
    328            v += ((tv_date & RTC_DR_MT) >> RTC_DR_MT_OFFSET) * 10;
   \   0000008C   0xF3C7 0x3000      UBFX     R0,R7,#+12,#+1
   \   00000090   0x210A             MOVS     R1,#+10
   \   00000092   0xFB01 0x8800      MLA      R8,R1,R0,R8
    329            fattime |= v << 21;
   \   00000096   0xEA55 0x5548      ORRS     R5,R5,R8, LSL #+21
    330          
    331            v =  (tv_date & RTC_DR_YU) >> RTC_DR_YU_OFFSET;
   \   0000009A   0xF3C7 0x4003      UBFX     R0,R7,#+16,#+4
   \   0000009E   0x4680             MOV      R8,R0
    332            v += ((tv_date & RTC_DR_YT) >> RTC_DR_YT_OFFSET) * 10;
   \   000000A0   0xF3C7 0x5003      UBFX     R0,R7,#+20,#+4
   \   000000A4   0x210A             MOVS     R1,#+10
   \   000000A6   0xFB01 0x8800      MLA      R8,R1,R0,R8
    333            v += 2000 - 1900 - 80;
   \   000000AA   0xF118 0x0814      ADDS     R8,R8,#+20
    334            fattime |= v << 25;
   \   000000AE   0xEA55 0x6548      ORRS     R5,R5,R8, LSL #+25
    335          
    336            return fattime;
   \   000000B2   0x0028             MOVS     R0,R5
   \   000000B4   0xB004             ADD      SP,SP,#+16
   \   000000B6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    337          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     RTCD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40002800         DC32     0x40002800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     `?<Constant "\\"rtc_lld_set_periodic...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"rtc_lld_set_periodic...">`:
   \   00000000   0x22 0x72          DC8 22H, 72H, 74H, 63H, 5FH, 6CH, 6CH, 64H
   \              0x74 0x63    
   \              0x5F 0x6C    
   \              0x6C 0x64    
   \   00000008   0x5F 0x73          DC8 5FH, 73H, 65H, 74H, 5FH, 70H, 65H, 72H
   \              0x65 0x74    
   \              0x5F 0x70    
   \              0x65 0x72    
   \   00000010   0x69 0x6F          DC8 69H, 6FH, 64H, 69H, 63H, 5FH, 77H, 61H
   \              0x64 0x69    
   \              0x63 0x5F    
   \              0x77 0x61    
   \   00000018   0x6B 0x65          DC8 6BH, 65H, 75H, 70H, 2CH, 20H, 66H, 6FH
   \              0x75 0x70    
   \              0x2C 0x20    
   \              0x66 0x6F    
   \   00000020   0x72 0x62          DC8 72H, 62H, 69H, 64H, 64H, 65H, 6EH, 20H
   \              0x69 0x64    
   \              0x64 0x65    
   \              0x6E 0x20    
   \   00000028   0x63 0x6F          DC8 63H, 6FH, 6DH, 62H, 69H, 6EH, 61H, 74H
   \              0x6D 0x62    
   \              0x69 0x6E    
   \              0x61 0x74    
   \   00000030   0x69 0x6F          DC8 69H, 6FH, 6EH, 22H, 28H, 29H, 0
   \              0x6E 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000037   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 70H, 6CH, 61H, 74H
   \              0x6C 0x5C    
   \              0x70 0x6C    
   \              0x61 0x74    
   \   00000038   0x66 0x6F          DC8 66H, 6FH, 72H, 6DH, 73H, 5CH, 53H, 54H
   \              0x72 0x6D    
   \              0x73 0x5C    
   \              0x53 0x54    
   \   00000040   0x4D 0x33          DC8 4DH, 33H, 32H, 5CH, 52H, 54H, 43H, 76H
   \              0x32 0x5C    
   \              0x52 0x54    
   \              0x43 0x76    
   \   00000048   0x32 0x5C          DC8 32H, 5CH, 72H, 74H, 63H, 5FH, 6CH, 6CH
   \              0x72 0x74    
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \   00000050   0x64 0x2E          DC8 64H, 2EH, 63H, 0
   \              0x63 0x00    
    338          
    339          #endif /* HAL_USE_RTC */
    340          
    341          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   rtcGetPeriodicWakeup_v2
      16   rtcSetPeriodicWakeup_v2
        16   -> chDbgPanic3
       0   rtc_lld_get_alarm
       4   rtc_lld_get_time
      40   rtc_lld_get_time_fat
        40   -> dbg_check_lock
        40   -> dbg_check_unlock
        40   -> rtc_lld_get_time
       0   rtc_lld_init
       4   rtc_lld_set_alarm
       4   rtc_lld_set_time


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      84  ?<Constant "F:\\stuff\\rusefi_sourc...">
      56  ?<Constant "\"rtc_lld_set_periodic...">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  RTCD1
      32  rtcGetPeriodicWakeup_v2
     118  rtcSetPeriodicWakeup_v2
      20  rtc_lld_get_alarm
      76  rtc_lld_get_time
     186  rtc_lld_get_time_fat
     120  rtc_lld_init
     172  rtc_lld_set_alarm
     116  rtc_lld_set_time

 
   4 bytes in section .bss
 140 bytes in section .rodata
 864 bytes in section .text
 
 864 bytes of CODE  memory
 140 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
