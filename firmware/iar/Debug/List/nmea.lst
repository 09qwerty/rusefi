###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:45 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\algo #
#                       \nmea.c                                               #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\algo #
#                       \nmea.c -lCN F:\stuff\rusefi_sourceforge\firmware\iar #
#                       \Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmware #
#                       \iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firmw #
#                       are\iar\Debug\Obj\ --no_cse --no_unroll --no_inline   #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\n #
#                       mea.lst                                               #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\nm #
#                       ea.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\algo\nmea.c
      1          /**
      2           * @date Dec 20, 2013
      3           *
      4           * @author Andrey Belomutskiy, (c) 2012-2015
      5           * @author Kot_dnz
      6           *
      7           * This file is part of rusEfi - see http://rusefi.com
      8           *
      9           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     10           * the GNU General Public License as published by the Free Software Foundation; either
     11           * version 3 of the License, or (at your option) any later version.
     12           *
     13           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     14           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15           * GNU General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU General Public License along with this program.
     18           * If not, see <http://www.gnu.org/licenses/>.
     19           *
     20           * see #testGpsParser
     21           */
     22          #include <math.h>
     23          #include <time.h>
     24          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char const *, int)
   \                     strchr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __iar_Strchr
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strrchr(char const *, int)
   \                     strrchr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __iar_Strrchr
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char const *, char const *)
   \                     strstr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __iar_Strstr
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     25          #include "nmea.h"
     26          

   \                                 In section .text, align 2, keep-with-next
     27          long hex2int(char *a, int len) {
   \                     hex2int:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
     28          	int i;
     29          	long val = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     30          
     31          	for (i = 0; i < len; i++)
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x0023             MOVS     R3,R4
   \                     ??hex2int_0:
   \   0000000A   0x428B             CMP      R3,R1
   \   0000000C   0xDA1B             BGE.N    ??hex2int_1
     32          		if (a[i] <= 57)
   \   0000000E   0x5C9C             LDRB     R4,[R3, R2]
   \   00000010   0x2C3A             CMP      R4,#+58
   \   00000012   0xDA0B             BGE.N    ??hex2int_2
     33          			val += (a[i] - 48) * (1 << (4 * (len - 1 - i))); // it's number
   \   00000014   0x5C9C             LDRB     R4,[R3, R2]
   \   00000016   0x3C30             SUBS     R4,R4,#+48
   \   00000018   0x2501             MOVS     R5,#+1
   \   0000001A   0x000E             MOVS     R6,R1
   \   0000001C   0x1E76             SUBS     R6,R6,#+1
   \   0000001E   0x1AF6             SUBS     R6,R6,R3
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x00B6             LSLS     R6,R6,#+2
   \   00000024   0x40B5             LSLS     R5,R5,R6
   \   00000026   0xFB05 0x0004      MLA      R0,R5,R4,R0
   \   0000002A   0xE00A             B.N      ??hex2int_3
     34          		else
     35          			val += (a[i] - 87) * (1 << (4 * (len - 1 - i))); // it's a-f -> work only with low case hex
   \                     ??hex2int_2:
   \   0000002C   0x5C9C             LDRB     R4,[R3, R2]
   \   0000002E   0x3C57             SUBS     R4,R4,#+87
   \   00000030   0x2501             MOVS     R5,#+1
   \   00000032   0x000E             MOVS     R6,R1
   \   00000034   0x1E76             SUBS     R6,R6,#+1
   \   00000036   0x1AF6             SUBS     R6,R6,R3
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x00B6             LSLS     R6,R6,#+2
   \   0000003C   0x40B5             LSLS     R5,R5,R6
   \   0000003E   0xFB05 0x0004      MLA      R0,R5,R4,R0
   \                     ??hex2int_3:
   \   00000042   0x1C5B             ADDS     R3,R3,#+1
   \   00000044   0xE7E1             B.N      ??hex2int_0
     36          	return val;
   \                     ??hex2int_1:
   \   00000046   0xBC70             POP      {R4-R6}
   \   00000048   0x4770             BX       LR               ;; return
     37          }
     38          

   \                                 In section .text, align 2, keep-with-next
     39          int str2int(char *a, int len) {
   \                     str2int:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
     40          	 int i = 0,  k = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2000             MOVS     R0,#+0
     41          	while (i<len) {
   \                     ??str2int_0:
   \   00000008   0x428B             CMP      R3,R1
   \   0000000A   0xDA09             BGE.N    ??str2int_1
     42          		k = (k<<3)+(k<<1)+(*a)-'0';
   \   0000000C   0x0044             LSLS     R4,R0,#+1
   \   0000000E   0xEB14 0x00C0      ADDS     R0,R4,R0, LSL #+3
   \   00000012   0x7814             LDRB     R4,[R2, #+0]
   \   00000014   0xFA50 0xF084      UXTAB    R0,R0,R4
   \   00000018   0x3830             SUBS     R0,R0,#+48
     43          		a++;
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
     44          		i++;
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \   0000001E   0xE7F3             B.N      ??str2int_0
     45          	}
     46          	return k;
   \                     ??str2int_1:
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
     47          }
     48          

   \                                 In section .text, align 4, keep-with-next
     49          float gps_deg_dec(float deg_point) {
   \                     gps_deg_dec:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B08      VPUSH    {D8-D11}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0xEEB0 0x9A40      VMOV.F32 S18,S0
     50          	double ddeg;
     51          	double sec = modf(deg_point, &ddeg) * 60;
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x0004             MOVS     R4,R0
   \   00000010   0xEE19 0x0A10      VMOV     R0,S18
   \   00000014   0x.... 0x....      BL       __aeabi_f2d
   \   00000018   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       modf
   \   00000022   0xEC53 0x2B10      VMOV     R2,R3,D0
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable1  ;; 0x404e0000
   \   0000002C   0x.... 0x....      BL       __aeabi_dmul
   \   00000030   0xEC41 0x0B18      VMOV     D8,R0,R1
     52          	int deg = (int) (ddeg / 100);
   \   00000034   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x.... 0x....      LDR.W    R3,??DataTable1_1  ;; 0x40590000
   \   0000003E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000042   0x.... 0x....      BL       __aeabi_d2iz
   \   00000046   0x0004             MOVS     R4,R0
     53          	int min = (int) (deg_point - (deg * 100));
   \   00000048   0x2064             MOVS     R0,#+100
   \   0000004A   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000004E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000052   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000056   0xEE39 0x0A40      VSUB.F32 S0,S18,S0
   \   0000005A   0xEEFD 0x9AC0      VCVT.S32.F32 S19,S0
     54          
     55          	float absdlat = round(deg * 1000000.);
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_i2d
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0x.... 0x....      LDR.W    R3,??DataTable1_2  ;; 0x412e8480
   \   0000006A   0x.... 0x....      BL       __aeabi_dmul
   \   0000006E   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000072   0x.... 0x....      BL       round
   \   00000076   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   0000007A   0x.... 0x....      BL       __aeabi_d2f
   \   0000007E   0xEE0A 0x0A10      VMOV     S20,R0
     56          	float absmlat = round(min * 1000000.);
   \   00000082   0xEE19 0x0A90      VMOV     R0,S19
   \   00000086   0x.... 0x....      BL       __aeabi_i2d
   \   0000008A   0x2200             MOVS     R2,#+0
   \   0000008C   0x.... 0x....      LDR.W    R3,??DataTable1_2  ;; 0x412e8480
   \   00000090   0x.... 0x....      BL       __aeabi_dmul
   \   00000094   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000098   0x.... 0x....      BL       round
   \   0000009C   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   000000A0   0x.... 0x....      BL       __aeabi_d2f
   \   000000A4   0xEE0A 0x0A90      VMOV     S21,R0
     57          	float absslat = round(sec * 1000000.);
   \   000000A8   0xEC53 0x2B18      VMOV     R2,R3,D8
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable1_2  ;; 0x412e8480
   \   000000B2   0x.... 0x....      BL       __aeabi_dmul
   \   000000B6   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   000000BA   0x.... 0x....      BL       round
   \   000000BE   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   000000C2   0x.... 0x....      BL       __aeabi_d2f
   \   000000C6   0xEE0B 0x0A10      VMOV     S22,R0
     58          
     59          	return round(absdlat + (absmlat / 60) + (absslat / 3600)) / 1000000;
   \   000000CA   0xED9F 0x....      VLDR.W   S0,??DataTable0  ;; 0x42700000
   \   000000CE   0xEE8A 0x0A80      VDIV.F32 S0,S21,S0
   \   000000D2   0xEE30 0x0A0A      VADD.F32 S0,S0,S20
   \   000000D6   0xEDDF 0x....      VLDR.W   S1,??DataTable0_1  ;; 0x45610000
   \   000000DA   0xEECB 0x0A20      VDIV.F32 S1,S22,S1
   \   000000DE   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   000000E2   0xEE10 0x0A10      VMOV     R0,S0
   \   000000E6   0x.... 0x....      BL       __aeabi_f2d
   \   000000EA   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   000000EE   0x.... 0x....      BL       round
   \   000000F2   0xEC51 0x0B10      VMOV     R0,R1,D0
   \   000000F6   0x2200             MOVS     R2,#+0
   \   000000F8   0x.... 0x....      LDR.W    R3,??DataTable1_2  ;; 0x412e8480
   \   000000FC   0x.... 0x....      BL       __aeabi_ddiv
   \   00000100   0x.... 0x....      BL       __aeabi_d2f
   \   00000104   0xEE00 0x0A10      VMOV     S0,R0
   \   00000108   0xB002             ADD      SP,SP,#+8
   \   0000010A   0xECBD 0x8B08      VPOP     {D8-D11}
   \   0000010E   0xBD10             POP      {R4,PC}          ;; return
     60          }
     61          
     62          // Convert lat e lon to decimals (from deg)

   \                                 In section .text, align 2, keep-with-next
     63          void gps_convert_deg_to_dec(float *latitude, char ns, float *longitude, char we) {
   \                     gps_convert_deg_to_dec:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
     64          	float lat = (ns == 'N') ? *latitude : -1 * (*latitude);
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D4E             CMP      R5,#+78
   \   00000012   0xD102             BNE.N    ??gps_convert_deg_to_dec_0
   \   00000014   0xED94 0x8A00      VLDR     S16,[R4, #0]
   \   00000018   0xE005             B.N      ??gps_convert_deg_to_dec_1
   \                     ??gps_convert_deg_to_dec_0:
   \   0000001A   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   0000001E   0xEEFF 0x0A00      VMOV.F32 S1,#-1.0
   \   00000022   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
     65          	float lon = (we == 'E') ? *longitude : -1 * (*longitude);
   \                     ??gps_convert_deg_to_dec_1:
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F45             CMP      R7,#+69
   \   0000002A   0xD102             BNE.N    ??gps_convert_deg_to_dec_2
   \   0000002C   0xEDD6 0x8A00      VLDR     S17,[R6, #0]
   \   00000030   0xE005             B.N      ??gps_convert_deg_to_dec_3
   \                     ??gps_convert_deg_to_dec_2:
   \   00000032   0xED96 0x0A00      VLDR     S0,[R6, #0]
   \   00000036   0xEEFF 0x0A00      VMOV.F32 S1,#-1.0
   \   0000003A   0xEE60 0x8A20      VMUL.F32 S17,S0,S1
     66          
     67          	*latitude = gps_deg_dec(lat);
   \                     ??gps_convert_deg_to_dec_3:
   \   0000003E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000042   0x.... 0x....      BL       gps_deg_dec
   \   00000046   0xED84 0x0A00      VSTR     S0,[R4, #0]
     68          	*longitude = gps_deg_dec(lon);
   \   0000004A   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000004E   0x.... 0x....      BL       gps_deg_dec
   \   00000052   0xED86 0x0A00      VSTR     S0,[R6, #0]
     69          }
   \   00000056   0xECBD 0x8B02      VPOP     {D8}
   \   0000005A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     70          
     71          // in string collect all char till comma and convert to float

   \                                 In section .text, align 2, keep-with-next
     72          int str_till_comma(char *a, char *dStr) {
   \                     str_till_comma:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     73          
     74          	int i = 0, sLen = strlen(a);
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       strlen
   \   0000000E   0x0001             MOVS     R1,R0
     75          	if (sLen > GPS_MAX_STRING)
   \   00000010   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000014   0xDD02             BLE.N    ??str_till_comma_0
     76          		sLen = GPS_MAX_STRING;
   \   00000016   0xF44F 0x7080      MOV      R0,#+256
   \   0000001A   0x0001             MOVS     R1,R0
     77          
     78          	while (a[i] != 44 && i < sLen) {	// while not comma or end
   \                     ??str_till_comma_0:
   \   0000001C   0x5D30             LDRB     R0,[R6, R4]
   \   0000001E   0x282C             CMP      R0,#+44
   \   00000020   0xD005             BEQ.N    ??str_till_comma_1
   \   00000022   0x428E             CMP      R6,R1
   \   00000024   0xDA03             BGE.N    ??str_till_comma_1
     79          		dStr[i] = a[i];
   \   00000026   0x5D30             LDRB     R0,[R6, R4]
   \   00000028   0x5570             STRB     R0,[R6, R5]
     80          		i++;
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0xE7F6             B.N      ??str_till_comma_0
     81          	}
     82          	dStr[i] = '\0';
   \                     ??str_till_comma_1:
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x5570             STRB     R0,[R6, R5]
     83          	return i;
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
     84          }
     85          
     86          /*
     87          GxGGA - name code
     88          Parameter	Value	Unit	Description
     89          UTC					hhmmss.sss	Universal time coordinated
     90          Lat					ddmm.mmmm	Latitude
     91          Northing Indicator			N=North, S=South
     92          Lon					dddmm.mmmm	Longitude
     93          Easting Indicator			E=East, W=West
     94          Status				0			0=Invalid, 1=2D/3D, 2=DGPS, 6=Dead Reckoning
     95          SVs Used			00			Number of SVs used for Navigation
     96          HDOP				99.99		Horizontal Dilution of Precision
     97          Alt (MSL)			m	Altitude (above means sea level)
     98          Unit				M=Meters
     99          Geoid Sep.			m			Geoid Separation = Alt(HAE) - Alt(MSL)
    100          Unit				M=Meters
    101          Age of DGPS Corr	s			Age of Differential Corrections
    102          DGPS Ref Station				ID of DGPS Reference Station
    103          */

   \                                 In section .text, align 2, keep-with-next
    104          void nmea_parse_gpgga(char *nmea, loc_t *loc) {
   \                     nmea_parse_gpgga:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C0             SUB      SP,SP,#+256
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    105          	char *p = nmea;
   \   00000008   0x0026             MOVS     R6,R4
    106          	char dStr[GPS_MAX_STRING];
    107          
    108          	p = strchr(p, ',') + 1; 				//skip time - we read date&time if Valid in GxRMC
   \   0000000A   0x212C             MOVS     R1,#+44
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x.... 0x....      BL       strchr
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x0006             MOVS     R6,R0
    109          
    110          	p = strchr(p, ',') + 1;					// in p string started with searching address
   \   00000016   0x212C             MOVS     R1,#+44
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       strchr
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x0006             MOVS     R6,R0
    111          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       str_till_comma
    112          	if(strlen(p) == 0) return;				// if no data in field - empty data - we return
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0x.... 0x....      BL       strlen
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD075             BEQ.N    ??nmea_parse_gpgga_0
    113          	
    114          	loc->latitude = atoff(dStr);				// fulfil data
   \                     ??nmea_parse_gpgga_1:
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       atoff
   \   0000003A   0xED85 0x0A00      VSTR     S0,[R5, #0]
    115          
    116          	p = strchr(p, ',') + 1;					// see above
   \   0000003E   0x212C             MOVS     R1,#+44
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       strchr
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x0006             MOVS     R6,R0
    117          	switch (p[0]) {
   \   0000004A   0x7830             LDRB     R0,[R6, #+0]
   \   0000004C   0x282C             CMP      R0,#+44
   \   0000004E   0xD00C             BEQ.N    ??nmea_parse_gpgga_2
   \   00000050   0x284E             CMP      R0,#+78
   \   00000052   0xD002             BEQ.N    ??nmea_parse_gpgga_3
   \   00000054   0x2853             CMP      R0,#+83
   \   00000056   0xD004             BEQ.N    ??nmea_parse_gpgga_4
   \   00000058   0xE00A             B.N      ??nmea_parse_gpgga_5
    118          	case 'N':
    119          		loc->lat = 'N';
   \                     ??nmea_parse_gpgga_3:
   \   0000005A   0x204E             MOVS     R0,#+78
   \   0000005C   0xF885 0x004C      STRB     R0,[R5, #+76]
    120          		break;
   \   00000060   0xE006             B.N      ??nmea_parse_gpgga_5
    121          	case 'S':
    122          		loc->lat = 'S';
   \                     ??nmea_parse_gpgga_4:
   \   00000062   0x2053             MOVS     R0,#+83
   \   00000064   0xF885 0x004C      STRB     R0,[R5, #+76]
    123          		break;
   \   00000068   0xE002             B.N      ??nmea_parse_gpgga_5
    124          	case ',':
    125          		loc->lat = '\0';
   \                     ??nmea_parse_gpgga_2:
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF885 0x004C      STRB     R0,[R5, #+76]
    126          		break;
    127          	}
    128          
    129          	p = strchr(p, ',') + 1;
   \                     ??nmea_parse_gpgga_5:
   \   00000070   0x212C             MOVS     R1,#+44
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       strchr
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x0006             MOVS     R6,R0
    130          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0x.... 0x....      BL       str_till_comma
    131          	loc->longitude = atoff(dStr);
   \   00000084   0xA800             ADD      R0,SP,#+0
   \   00000086   0x.... 0x....      BL       atoff
   \   0000008A   0xED85 0x0A01      VSTR     S0,[R5, #+4]
    132          
    133          	p = strchr(p, ',') + 1;
   \   0000008E   0x212C             MOVS     R1,#+44
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0x.... 0x....      BL       strchr
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0x0006             MOVS     R6,R0
    134          	switch (p[0]) {
   \   0000009A   0x7830             LDRB     R0,[R6, #+0]
   \   0000009C   0x282C             CMP      R0,#+44
   \   0000009E   0xD00B             BEQ.N    ??nmea_parse_gpgga_6
   \   000000A0   0x2845             CMP      R0,#+69
   \   000000A2   0xD005             BEQ.N    ??nmea_parse_gpgga_7
   \   000000A4   0x2857             CMP      R0,#+87
   \   000000A6   0xD10A             BNE.N    ??nmea_parse_gpgga_8
    135          	case 'W':
    136          		loc->lon = 'W';
   \                     ??nmea_parse_gpgga_9:
   \   000000A8   0x2057             MOVS     R0,#+87
   \   000000AA   0xF885 0x004D      STRB     R0,[R5, #+77]
    137          		break;
   \   000000AE   0xE006             B.N      ??nmea_parse_gpgga_8
    138          	case 'E':
    139          		loc->lon = 'E';
   \                     ??nmea_parse_gpgga_7:
   \   000000B0   0x2045             MOVS     R0,#+69
   \   000000B2   0xF885 0x004D      STRB     R0,[R5, #+77]
    140          		break;
   \   000000B6   0xE002             B.N      ??nmea_parse_gpgga_8
    141          	case ',':
    142          		loc->lon = '\0';
   \                     ??nmea_parse_gpgga_6:
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF885 0x004D      STRB     R0,[R5, #+77]
    143          		break;
    144          	}
    145          
    146          	p = strchr(p, ',') + 1;
   \                     ??nmea_parse_gpgga_8:
   \   000000BE   0x212C             MOVS     R1,#+44
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0x.... 0x....      BL       strchr
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x0006             MOVS     R6,R0
    147          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0x.... 0x....      BL       str_till_comma
    148          	loc->quality = atoi(dStr);
   \   000000D2   0xA800             ADD      R0,SP,#+0
   \   000000D4   0x.... 0x....      BL       atoi
   \   000000D8   0x6468             STR      R0,[R5, #+68]
    149          
    150          	p = strchr(p, ',') + 1;
   \   000000DA   0x212C             MOVS     R1,#+44
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0x.... 0x....      BL       strchr
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0x0006             MOVS     R6,R0
    151          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   000000E6   0xA900             ADD      R1,SP,#+0
   \   000000E8   0x0030             MOVS     R0,R6
   \   000000EA   0x.... 0x....      BL       str_till_comma
    152          	loc->satellites = atoi(dStr);
   \   000000EE   0xA800             ADD      R0,SP,#+0
   \   000000F0   0x.... 0x....      BL       atoi
   \   000000F4   0x64A8             STR      R0,[R5, #+72]
    153          
    154          	p = strchr(p, ',') + 1;
   \   000000F6   0x212C             MOVS     R1,#+44
   \   000000F8   0x0030             MOVS     R0,R6
   \   000000FA   0x.... 0x....      BL       strchr
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x0006             MOVS     R6,R0
    155          
    156          	p = strchr(p, ',') + 1;
   \   00000102   0x212C             MOVS     R1,#+44
   \   00000104   0x0030             MOVS     R0,R6
   \   00000106   0x.... 0x....      BL       strchr
   \   0000010A   0x1C40             ADDS     R0,R0,#+1
   \   0000010C   0x0006             MOVS     R6,R0
    157          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   0000010E   0xA900             ADD      R1,SP,#+0
   \   00000110   0x0030             MOVS     R0,R6
   \   00000112   0x.... 0x....      BL       str_till_comma
    158          	loc->altitude = atoff(dStr);
   \   00000116   0xA800             ADD      R0,SP,#+0
   \   00000118   0x.... 0x....      BL       atoff
   \   0000011C   0xED85 0x0A03      VSTR     S0,[R5, #+12]
    159          }
   \                     ??nmea_parse_gpgga_0:
   \   00000120   0xB040             ADD      SP,SP,#+256
   \   00000122   0xBD70             POP      {R4-R6,PC}       ;; return
    160          
    161          /*
    162          GxRMC - nmea code
    163          Parameter	Value		Unit			Description
    164          UTC						hhmmss.sss		Universal time coordinated
    165          Status		V		A=Valid, V=Invalid
    166          Lat			ddmm.mmmm					Latitude
    167          Northing Indicator			N=North, S=South
    168          Lon			dddmm.mmmm					Longitude
    169          Easting Indicator			E=East, W=West
    170          SOG						nots			Speed Over Ground
    171          COG (true)				°				Course Over Ground (true)
    172          Date					ddmmyy			Universal time coordinated
    173          Magnetic Variation		°				Magnetic Variation
    174          Magnetic Variation			E=East,W=West
    175          Mode Indicator	N		A=Autonomous, D=Differential, E=Dead Reckoning, N=None
    176          Navigational Status			S=Safe C=Caution U=Unsafe V=Not valid
    177          
    178          */

   \                                 In section .text, align 2, keep-with-next
    179          void nmea_parse_gprmc(char *nmea, loc_t *loc) {
   \                     nmea_parse_gprmc:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0CC             SUB      SP,SP,#+304
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    180          	char *p = nmea;
   \   00000008   0x0026             MOVS     R6,R4
    181          	char dStr[GPS_MAX_STRING];
    182          	struct tm timp;
    183          
    184          	p = strchr(p, ',') + 1; 				//read time
   \   0000000A   0x212C             MOVS     R1,#+44
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x.... 0x....      BL       strchr
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x0006             MOVS     R6,R0
    185          	str_till_comma(p, dStr);
   \   00000016   0xA90B             ADD      R1,SP,#+44
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       str_till_comma
    186          	if(strlen(dStr) > 5){
   \   0000001E   0xA80B             ADD      R0,SP,#+44
   \   00000020   0x.... 0x....      BL       strlen
   \   00000024   0x2806             CMP      R0,#+6
   \   00000026   0xD30F             BCC.N    ??nmea_parse_gprmc_0
    187          		timp.tm_hour = str2int(dStr,2);
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0xA80B             ADD      R0,SP,#+44
   \   0000002C   0x.... 0x....      BL       str2int
   \   00000030   0x9002             STR      R0,[SP, #+8]
    188          		timp.tm_min  = str2int(dStr+2,2);
   \   00000032   0x2102             MOVS     R1,#+2
   \   00000034   0xF10D 0x002E      ADD      R0,SP,#+46
   \   00000038   0x.... 0x....      BL       str2int
   \   0000003C   0x9001             STR      R0,[SP, #+4]
    189          		timp.tm_sec  = str2int(dStr+4,2);
   \   0000003E   0x2102             MOVS     R1,#+2
   \   00000040   0xA80C             ADD      R0,SP,#+48
   \   00000042   0x.... 0x....      BL       str2int
   \   00000046   0x9000             STR      R0,[SP, #+0]
    190          	}
    191          	
    192          	p = strchr(p, ',') + 1; 				//read field Valid status
   \                     ??nmea_parse_gprmc_0:
   \   00000048   0x212C             MOVS     R1,#+44
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0x.... 0x....      BL       strchr
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x0006             MOVS     R6,R0
    193          	str_till_comma(p, dStr);
   \   00000054   0xA90B             ADD      R1,SP,#+44
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       str_till_comma
    194          
    195          	if(dStr[0] == 'V') {					// if field is invalid
   \   0000005C   0xF89D 0x002C      LDRB     R0,[SP, #+44]
   \   00000060   0x2856             CMP      R0,#+86
   \   00000062   0xD102             BNE.N    ??nmea_parse_gprmc_1
    196          		loc->quality = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x6468             STR      R0,[R5, #+68]
    197          		return;
   \   00000068   0xE097             B.N      ??nmea_parse_gprmc_2
    198          	}
    199          	
    200          	loc->quality = 4;						// this is declaration that last receive field VALID
   \                     ??nmea_parse_gprmc_1:
   \   0000006A   0x2004             MOVS     R0,#+4
   \   0000006C   0x6468             STR      R0,[R5, #+68]
    201          	
    202          	p = strchr(p, ',') + 1;					// latitude
   \   0000006E   0x212C             MOVS     R1,#+44
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0x.... 0x....      BL       strchr
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0x0006             MOVS     R6,R0
    203          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   0000007A   0xA90B             ADD      R1,SP,#+44
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0x.... 0x....      BL       str_till_comma
    204          	loc->latitude = atoff(dStr);
   \   00000082   0xA80B             ADD      R0,SP,#+44
   \   00000084   0x.... 0x....      BL       atoff
   \   00000088   0xED85 0x0A00      VSTR     S0,[R5, #0]
    205          
    206          	p = strchr(p, ',') + 1;
   \   0000008C   0x212C             MOVS     R1,#+44
   \   0000008E   0x0030             MOVS     R0,R6
   \   00000090   0x.... 0x....      BL       strchr
   \   00000094   0x1C40             ADDS     R0,R0,#+1
   \   00000096   0x0006             MOVS     R6,R0
    207          	switch (p[0]) {
   \   00000098   0x7830             LDRB     R0,[R6, #+0]
   \   0000009A   0x282C             CMP      R0,#+44
   \   0000009C   0xD00C             BEQ.N    ??nmea_parse_gprmc_3
   \   0000009E   0x284E             CMP      R0,#+78
   \   000000A0   0xD002             BEQ.N    ??nmea_parse_gprmc_4
   \   000000A2   0x2853             CMP      R0,#+83
   \   000000A4   0xD004             BEQ.N    ??nmea_parse_gprmc_5
   \   000000A6   0xE00A             B.N      ??nmea_parse_gprmc_6
    208          	case 'N':
    209          		loc->lat = 'N';
   \                     ??nmea_parse_gprmc_4:
   \   000000A8   0x204E             MOVS     R0,#+78
   \   000000AA   0xF885 0x004C      STRB     R0,[R5, #+76]
    210          		break;
   \   000000AE   0xE006             B.N      ??nmea_parse_gprmc_6
    211          	case 'S':
    212          		loc->lat = 'S';
   \                     ??nmea_parse_gprmc_5:
   \   000000B0   0x2053             MOVS     R0,#+83
   \   000000B2   0xF885 0x004C      STRB     R0,[R5, #+76]
    213          		break;
   \   000000B6   0xE002             B.N      ??nmea_parse_gprmc_6
    214          	case ',':
    215          		loc->lat = '\0';
   \                     ??nmea_parse_gprmc_3:
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF885 0x004C      STRB     R0,[R5, #+76]
    216          		break;
    217          	}
    218          
    219          	p = strchr(p, ',') + 1; 				// longitude
   \                     ??nmea_parse_gprmc_6:
   \   000000BE   0x212C             MOVS     R1,#+44
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0x.... 0x....      BL       strchr
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x0006             MOVS     R6,R0
    220          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   000000CA   0xA90B             ADD      R1,SP,#+44
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0x.... 0x....      BL       str_till_comma
    221          	loc->longitude = atoff(dStr);
   \   000000D2   0xA80B             ADD      R0,SP,#+44
   \   000000D4   0x.... 0x....      BL       atoff
   \   000000D8   0xED85 0x0A01      VSTR     S0,[R5, #+4]
    222          
    223          	p = strchr(p, ',') + 1;
   \   000000DC   0x212C             MOVS     R1,#+44
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0x.... 0x....      BL       strchr
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x0006             MOVS     R6,R0
    224          	switch (p[0]) {
   \   000000E8   0x7830             LDRB     R0,[R6, #+0]
   \   000000EA   0x282C             CMP      R0,#+44
   \   000000EC   0xD00B             BEQ.N    ??nmea_parse_gprmc_7
   \   000000EE   0x2845             CMP      R0,#+69
   \   000000F0   0xD005             BEQ.N    ??nmea_parse_gprmc_8
   \   000000F2   0x2857             CMP      R0,#+87
   \   000000F4   0xD10A             BNE.N    ??nmea_parse_gprmc_9
    225          	case 'W':
    226          		loc->lon = 'W';
   \                     ??nmea_parse_gprmc_10:
   \   000000F6   0x2057             MOVS     R0,#+87
   \   000000F8   0xF885 0x004D      STRB     R0,[R5, #+77]
    227          		break;
   \   000000FC   0xE006             B.N      ??nmea_parse_gprmc_9
    228          	case 'E':
    229          		loc->lon = 'E';
   \                     ??nmea_parse_gprmc_8:
   \   000000FE   0x2045             MOVS     R0,#+69
   \   00000100   0xF885 0x004D      STRB     R0,[R5, #+77]
    230          		break;
   \   00000104   0xE002             B.N      ??nmea_parse_gprmc_9
    231          	case ',':
    232          		loc->lon = '\0';
   \                     ??nmea_parse_gprmc_7:
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xF885 0x004D      STRB     R0,[R5, #+77]
    233          		break;
    234          	}
    235          
    236          	p = strchr(p, ',') + 1;
   \                     ??nmea_parse_gprmc_9:
   \   0000010C   0x212C             MOVS     R1,#+44
   \   0000010E   0x0030             MOVS     R0,R6
   \   00000110   0x.... 0x....      BL       strchr
   \   00000114   0x1C40             ADDS     R0,R0,#+1
   \   00000116   0x0006             MOVS     R6,R0
    237          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   00000118   0xA90B             ADD      R1,SP,#+44
   \   0000011A   0x0030             MOVS     R0,R6
   \   0000011C   0x.... 0x....      BL       str_till_comma
    238          	loc->speed = atoff(dStr);
   \   00000120   0xA80B             ADD      R0,SP,#+44
   \   00000122   0x.... 0x....      BL       atoff
   \   00000126   0xED85 0x0A02      VSTR     S0,[R5, #+8]
    239          	
    240          	p = strchr(p, ',') + 1;
   \   0000012A   0x212C             MOVS     R1,#+44
   \   0000012C   0x0030             MOVS     R0,R6
   \   0000012E   0x.... 0x....      BL       strchr
   \   00000132   0x1C40             ADDS     R0,R0,#+1
   \   00000134   0x0006             MOVS     R6,R0
    241          	str_till_comma(p, dStr);				// str to float till comma saved modified string
   \   00000136   0xA90B             ADD      R1,SP,#+44
   \   00000138   0x0030             MOVS     R0,R6
   \   0000013A   0x.... 0x....      BL       str_till_comma
    242          	loc->course = atoff(dStr);
   \   0000013E   0xA80B             ADD      R0,SP,#+44
   \   00000140   0x.... 0x....      BL       atoff
   \   00000144   0xED85 0x0A04      VSTR     S0,[R5, #+16]
    243          
    244          	p = strchr(p, ',') + 1; 				//read date
   \   00000148   0x212C             MOVS     R1,#+44
   \   0000014A   0x0030             MOVS     R0,R6
   \   0000014C   0x.... 0x....      BL       strchr
   \   00000150   0x1C40             ADDS     R0,R0,#+1
   \   00000152   0x0006             MOVS     R6,R0
    245          	str_till_comma(p, dStr);
   \   00000154   0xA90B             ADD      R1,SP,#+44
   \   00000156   0x0030             MOVS     R0,R6
   \   00000158   0x.... 0x....      BL       str_till_comma
    246          	if(strlen(dStr) > 5){
   \   0000015C   0xA80B             ADD      R0,SP,#+44
   \   0000015E   0x.... 0x....      BL       strlen
   \   00000162   0x2806             CMP      R0,#+6
   \   00000164   0xD310             BCC.N    ??nmea_parse_gprmc_11
    247          		timp.tm_mday = str2int(dStr,2);
   \   00000166   0x2102             MOVS     R1,#+2
   \   00000168   0xA80B             ADD      R0,SP,#+44
   \   0000016A   0x.... 0x....      BL       str2int
   \   0000016E   0x9003             STR      R0,[SP, #+12]
    248          		timp.tm_mon  = str2int(dStr+2,2);
   \   00000170   0x2102             MOVS     R1,#+2
   \   00000172   0xF10D 0x002E      ADD      R0,SP,#+46
   \   00000176   0x.... 0x....      BL       str2int
   \   0000017A   0x9004             STR      R0,[SP, #+16]
    249          		timp.tm_year = str2int(dStr+4,2)+100;	// we receive -200, but standard wait -1900 = add correction
   \   0000017C   0x2102             MOVS     R1,#+2
   \   0000017E   0xA80C             ADD      R0,SP,#+48
   \   00000180   0x.... 0x....      BL       str2int
   \   00000184   0x3064             ADDS     R0,R0,#+100
   \   00000186   0x9005             STR      R0,[SP, #+20]
    250          	}
    251          
    252          	if( timp.tm_year > 0 ) {				// check if date field is valid  
   \                     ??nmea_parse_gprmc_11:
   \   00000188   0x9805             LDR      R0,[SP, #+20]
   \   0000018A   0x2801             CMP      R0,#+1
   \   0000018C   0xDB05             BLT.N    ??nmea_parse_gprmc_12
    253          		memcpy(&loc->GPStm, &timp, sizeof(timp));
   \   0000018E   0x222C             MOVS     R2,#+44
   \   00000190   0xA900             ADD      R1,SP,#+0
   \   00000192   0xF115 0x0014      ADDS     R0,R5,#+20
   \   00000196   0x.... 0x....      BL       memcpy
    254          	}
    255          }
   \                     ??nmea_parse_gprmc_12:
   \                     ??nmea_parse_gprmc_2:
   \   0000019A   0xB04C             ADD      SP,SP,#+304
   \   0000019C   0xBD70             POP      {R4-R6,PC}       ;; return
    256          
    257          /**
    258           * Get the message type (GPGGA, GPRMC, etc..)
    259           *
    260           * This function filters out also wrong packages (invalid checksum)
    261           *
    262           * @param message The NMEA message
    263           * @return The type of message if it is valid
    264           */

   \                                 In section .text, align 2, keep-with-next
    265          nmea_message_type nmea_get_message_type(const char *message) {
   \                     nmea_get_message_type:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266          	int checksum = nmea_valid_checksum(message);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       nmea_valid_checksum
   \   0000000A   0x0005             MOVS     R5,R0
    267          	if (checksum != _EMPTY) {
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD002             BEQ.N    ??nmea_get_message_type_0
    268          		return checksum;
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xE010             B.N      ??nmea_get_message_type_1
    269          	}
    270          
    271          	if (strstr(message, NMEA_GPGGA_STR) != NULL) {
   \                     ??nmea_get_message_type_0:
   \   00000016   0x....             LDR.N    R1,??DataTable1_3
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       strstr
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??nmea_get_message_type_2
    272          		return NMEA_GPGGA;
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE008             B.N      ??nmea_get_message_type_1
    273          	}
    274          
    275          	if (strstr(message, NMEA_GPRMC_STR) != NULL) {
   \                     ??nmea_get_message_type_2:
   \   00000026   0x....             LDR.N    R1,??DataTable1_4
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       strstr
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??nmea_get_message_type_3
    276          		return NMEA_GPRMC;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B.N      ??nmea_get_message_type_1
    277          	}
    278          
    279          	return NMEA_UNKNOWN;
   \                     ??nmea_get_message_type_3:
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??nmea_get_message_type_1:
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    280          }
    281          

   \                                 In section .text, align 2, keep-with-next
    282          int nmea_valid_checksum(const char *message) {
   \                     nmea_valid_checksum:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    283          	char p;
    284          	int sum = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    285          	char *starPtr = strrchr(message, '*');
   \   00000008   0x212A             MOVS     R1,#+42
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       strrchr
   \   00000010   0x0007             MOVS     R7,R0
    286          	if (starPtr == NULL)
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD101             BNE.N    ??nmea_valid_checksum_0
    287          		return NMEA_CHECKSUM_ERR;
   \   00000016   0x2080             MOVS     R0,#+128
   \   00000018   0xE015             B.N      ??nmea_valid_checksum_1
    288          	char *int_message = starPtr + 1;
   \                     ??nmea_valid_checksum_0:
   \   0000001A   0xF117 0x0801      ADDS     R8,R7,#+1
    289          	long checksum = hex2int(int_message, 2);
   \   0000001E   0x2102             MOVS     R1,#+2
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x.... 0x....      BL       hex2int
   \   00000026   0x0001             MOVS     R1,R0
    290          
    291          	++message;
   \   00000028   0x1C64             ADDS     R4,R4,#+1
    292          	while ((p = *message++) != '*') {
   \                     ??nmea_valid_checksum_2:
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \   0000002E   0x0005             MOVS     R5,R0
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x282A             CMP      R0,#+42
   \   00000034   0xD002             BEQ.N    ??nmea_valid_checksum_3
    293          		sum ^= p;
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x406E             EORS     R6,R5,R6
   \   0000003A   0xE7F6             B.N      ??nmea_valid_checksum_2
    294          	}
    295          
    296          	if (sum != checksum) {
   \                     ??nmea_valid_checksum_3:
   \   0000003C   0x428E             CMP      R6,R1
   \   0000003E   0xD001             BEQ.N    ??nmea_valid_checksum_4
    297          		return NMEA_CHECKSUM_ERR;
   \   00000040   0x2080             MOVS     R0,#+128
   \   00000042   0xE000             B.N      ??nmea_valid_checksum_1
    298          	}
    299          	return _EMPTY;
   \                     ??nmea_valid_checksum_4:
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??nmea_valid_checksum_1:
   \   00000046   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    300          }
    301          
    302          // Compute the GPS location using decimal scale

   \                                 In section .text, align 2, keep-with-next
    303          void gps_location(loc_t *coord, char *buffer) {
   \                     gps_location:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    304          
    305          	coord->type = nmea_get_message_type(buffer);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       nmea_get_message_type
   \   0000000C   0xF884 0x0040      STRB     R0,[R4, #+64]
    306          
    307          	switch (coord->type) {
   \   00000010   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD015             BEQ.N    ??gps_location_0
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD001             BEQ.N    ??gps_location_1
   \   0000001C   0xD30D             BCC.N    ??gps_location_2
   \   0000001E   0xE011             B.N      ??gps_location_3
    308          	case NMEA_GPGGA:
    309          		nmea_parse_gpgga(buffer, coord);
   \                     ??gps_location_1:
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       nmea_parse_gpgga
    310          		gps_convert_deg_to_dec(&(coord->latitude), coord->lat, &(coord->longitude), coord->lon);
   \   00000028   0xF894 0x304D      LDRB     R3,[R4, #+77]
   \   0000002C   0x1D22             ADDS     R2,R4,#+4
   \   0000002E   0xF894 0x104C      LDRB     R1,[R4, #+76]
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       gps_convert_deg_to_dec
    311          		break;
   \   00000038   0xE004             B.N      ??gps_location_3
    312          	case NMEA_GPRMC:
    313          		nmea_parse_gprmc(buffer, coord);
   \                     ??gps_location_2:
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       nmea_parse_gprmc
    314          		break;
   \   00000042   0xE7FF             B.N      ??gps_location_3
    315          	case NMEA_UNKNOWN:
    316          		// unknown message type
    317          		break;
    318          	}
    319          
    320          }
   \                     ??gps_location_0:
   \                     ??gps_location_3:
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x45610000         DC32     0x45610000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x404E0000         DC32     0x404e0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40590000         DC32     0x40590000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     `?<Constant "$GPGGA">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     `?<Constant "$GPRMC">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "$GPGGA">`:
   \   00000000   0x24 0x47          DC8 "$GPGGA"
   \              0x50 0x47    
   \              0x47 0x41    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "$GPRMC">`:
   \   00000000   0x24 0x47          DC8 "$GPRMC"
   \              0x50 0x52    
   \              0x4D 0x43    
   \              0x00         
   \   00000007   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   gps_convert_deg_to_dec
        32   -> gps_deg_dec
      48   gps_deg_dec
        48   -> __aeabi_d2f
        48   -> __aeabi_d2iz
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_i2d
        48   -> modf
        48   -> round
      16   gps_location
        16   -> gps_convert_deg_to_dec
        16   -> nmea_get_message_type
        16   -> nmea_parse_gpgga
        16   -> nmea_parse_gprmc
      12   hex2int
      16   memcpy
        16   -> __aeabi_memcpy
      16   nmea_get_message_type
        16   -> nmea_valid_checksum
        16   -> strstr
     272   nmea_parse_gpgga
       272   -> atoff
       272   -> atoi
       272   -> str_till_comma
       272   -> strchr
       272   -> strlen
     320   nmea_parse_gprmc
       320   -> atoff
       320   -> memcpy
       320   -> str2int
       320   -> str_till_comma
       320   -> strchr
       320   -> strlen
      24   nmea_valid_checksum
        24   -> hex2int
        24   -> strrchr
       4   str2int
      16   str_till_comma
        16   -> strlen
      16   strchr
        16   -> __iar_Strchr
      16   strrchr
        16   -> __iar_Strrchr
      16   strstr
        16   -> __iar_Strstr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "$GPGGA">
       8  ?<Constant "$GPRMC">
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
      92  gps_convert_deg_to_dec
     272  gps_deg_dec
      70  gps_location
      74  hex2int
      22  memcpy
      58  nmea_get_message_type
     292  nmea_parse_gpgga
     414  nmea_parse_gprmc
      74  nmea_valid_checksum
      36  str2int
      54  str_till_comma
      16  strchr
      16  strrchr
      16  strstr

 
    16 bytes in section .rodata
 1 534 bytes in section .text
 
 1 464 bytes of CODE  memory (+ 70 bytes shared)
    16 bytes of CONST memory

Errors: none
Warnings: 2
