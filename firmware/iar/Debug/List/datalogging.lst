###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:29 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\util\datalogging #
#                       .cpp                                                  #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\util\datalogging #
#                       .cpp -lCN F:\stuff\rusefi_sourceforge\firmware\iar\De #
#                       bug\List\ -lA F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\Debug\List\ -o F:\stuff\rusefi_sourceforge\firmware #
#                       \iar\Debug\Obj\ --no_cse --no_unroll --no_inline      #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\d #
#                       atalogging.lst                                        #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\da #
#                       talogging.o                                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\util\datalogging.cpp
      1          /**
      2           * @file    datalogging.cpp
      3           * @brief   Buffered console output stream code
      4           *
      5           * Here we have a memory buffer and method related to
      6           * printing messages into this buffer. The purpose of the
      7           * buffer is to allow fast, non-blocking, thread-safe logging.
      8           *
      9           * The idea is that each interrupt handler would have it's own logging buffer. You can add
     10           * stuff into this buffer without any locking since it's you own buffer, and once you get
     11           * the whole message you invoke the scheduleLogging() method which appends your local content
     12           * into the global logging buffer, from which it is later dispatched to the console by our
     13           * main console thread.
     14           *
     15           * @date Feb 25, 2013
     16           * @author Andrey Belomutskiy, (c) 2012-2015
     17           *
     18           * This file is part of rusEfi - see http://rusefi.com
     19           *
     20           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     21           * the GNU General Public License as published by the Free Software Foundation; either
     22           * version 3 of the License, or (at your option) any later version.
     23           *
     24           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     25           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     26           * GNU General Public License for more details.
     27           *
     28           * You should have received a copy of the GNU General Public License along with this program.
     29           * If not, see <http://www.gnu.org/licenses/>.
     30           *
     31           */
     32          
     33          #include <stdbool.h>
     34          #include "main.h"
     35          
     36          #if ! EFI_UNIT_TEST || defined(__DOXYGEN__)
     37          #include "chprintf.h"
     38          #include "chmtx.h"
     39          #include "memstreams.h"
     40          #include "console_io.h"
     41          #include "rfiutil.h"
     42          #include "loggingcentral.h"
     43          
     44          // we use this magic constant to make sure it's not just a random non-zero int in memory
     45          #define MAGIC_LOGGING_FLAG 45234441
     46          

   \                                 In section .bss, align 4
     47          static MemoryStream intermediateLoggingBuffer;
   \                     intermediateLoggingBuffer:
   \   00000000                      DS8 20

   \                                 In section .ccm, align 4
     48          static uint8_t intermediateLoggingBufferData[INTERMEDIATE_LOGGING_BUFFER_SIZE] CCM_OPTIONAL;
   \                     intermediateLoggingBufferData:
   \   00000000                      DS8 2000
     49          //todo define max-printf-buffer

   \                                 In section .bss, align 1
     50          static bool_t intermediateLoggingBufferInited = false;
   \                     intermediateLoggingBufferInited:
   \   00000000                      DS8 1
     51          
     52          /**
     53           * @returns true if data does not fit into this buffer
     54           */

   \                                 In section .text, align 2, keep-with-next
     55          static INLINE bool_t validateBuffer(Logging *logging, uint32_t extraLen) {
   \                     _Z14validateBufferP7Loggingj:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     56          	if (logging->buffer == NULL) {
   \   00000006   0x6AE0             LDR      R0,[R4, #+44]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD106             BNE.N    ??validateBuffer_0
     57          		firmwareError("Logging not initialized: %s", logging->name);
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000012   0x.... 0x....      BL       firmwareError
     58          		return true;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00F             B.N      ??validateBuffer_1
     59          	}
     60          
     61          	if (remainingSize(logging) < extraLen + 1) {
   \                     ??validateBuffer_0:
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       remainingSize
   \   00000020   0x1C69             ADDS     R1,R5,#+1
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD208             BCS.N    ??validateBuffer_2
     62          #if EFI_PROD_CODE
     63          		warning(OBD_PCM_Processor_Fault, "output overflow %s", logging->name);
   \   00000026   0x6822             LDR      R2,[R4, #+0]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000002C   0xF240 0x205E      MOVW     R0,#+606
   \   00000030   0x.... 0x....      BL       warning
     64          #endif
     65          		return true;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE000             B.N      ??validateBuffer_1
     66          	}
     67          	return false;
   \                     ??validateBuffer_2:
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??validateBuffer_1:
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     68          }
     69          

   \                                 In section .text, align 2, keep-with-next
     70          void append(Logging *logging, const char *text) {
   \                     append:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     71          	efiAssertVoid(text != NULL, "append NULL");
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD104             BNE.N    ??append_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   0000000E   0x.... 0x....      BL       firmwareError
   \   00000012   0xE012             B.N      ??append_1
     72          	uint32_t extraLen = efiStrlen(text);
   \                     ??append_0:
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       efiStrlen
   \   0000001A   0x0006             MOVS     R6,R0
     73          	bool_t isError = validateBuffer(logging, extraLen);
   \   0000001C   0x0031             MOVS     R1,R6
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       _Z14validateBufferP7Loggingj
   \   00000024   0x0007             MOVS     R7,R0
     74          	if (isError) {
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xD106             BNE.N    ??append_1
     75          		return;
     76          	}
     77          	strcpy(logging->linePointer, text);
   \                     ??append_2:
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0x6B20             LDR      R0,[R4, #+48]
   \   00000030   0x.... 0x....      BL       strcpy
     78          	/**
     79          	 * And now we are pointing at the zero char at the end of the buffer again
     80          	 */
     81          	logging->linePointer += extraLen;
   \   00000034   0x6B20             LDR      R0,[R4, #+48]
   \   00000036   0x1830             ADDS     R0,R6,R0
   \   00000038   0x6320             STR      R0,[R4, #+48]
     82          }
   \                     ??append_1:
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     83          
     84          /**
     85           * @note This method if fast because it does not validate much, be sure what you are doing
     86           */

   \                                 In section .text, align 2, keep-with-next
     87          void appendFast(Logging *logging, const char *text) {
   \                     appendFast:
   \   00000000   0xB410             PUSH     {R4}
     88          //  todo: fix this implementation? this would be a one-pass implementation instead of a two-pass
     89          //	char c;
     90          //	char *s = (char *) text;
     91          //	do {
     92          //		c = *s++;
     93          //		*logging->linePointer++ = c;
     94          //	} while (c != '\0');
     95          	register char *s;
     96          	for (s = (char *) text; *s; ++s)
   \   00000002   0x000A             MOVS     R2,R1
   \                     ??appendFast_0:
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD001             BEQ.N    ??appendFast_1
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0xE7FA             B.N      ??appendFast_0
     97          		;
     98          	int extraLen = (s - text);
   \                     ??appendFast_1:
   \   0000000E   0x1A53             SUBS     R3,R2,R1
     99          
    100          	s = logging->linePointer;
   \   00000010   0x6B04             LDR      R4,[R0, #+48]
   \   00000012   0x0022             MOVS     R2,R4
    101          	while ((*s++ = *text++) != 0)
   \                     ??appendFast_2:
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x7014             STRB     R4,[R2, #+0]
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD1F8             BNE.N    ??appendFast_2
    102          		;
    103          
    104          //	strcpy(logging->linePointer, text);
    105          	logging->linePointer += extraLen;
   \   00000022   0x6B04             LDR      R4,[R0, #+48]
   \   00000024   0x191C             ADDS     R4,R3,R4
   \   00000026   0x6304             STR      R4,[R0, #+48]
    106          }
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    107          

   \                                 In section .text, align 2, keep-with-next
    108          static void vappendPrintfI(Logging *logging, const char *fmt, va_list arg) {
   \                     _Z14vappendPrintfIP7LoggingPKc8_VA_LIST:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    109          	intermediateLoggingBuffer.eos = 0; // reset
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    110          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#1b");
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x.... 0x....      BL       getRemainingStack
   \   0000001A   0x2881             CMP      R0,#+129
   \   0000001C   0xDA04             BGE.N    ??vappendPrintfI_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000022   0x.... 0x....      BL       firmwareError
   \   00000026   0xE00E             B.N      ??vappendPrintfI_1
    111          	chvprintf((BaseSequentialStream *) &intermediateLoggingBuffer, fmt, arg);
   \                     ??vappendPrintfI_0:
   \   00000028   0x0032             MOVS     R2,R6
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x....             LDR.N    R0,??DataTable16_5
   \   0000002E   0x.... 0x....      BL       chvprintf
    112          	intermediateLoggingBuffer.buffer[intermediateLoggingBuffer.eos] = 0; // need to terminate explicitly
   \   00000032   0x....             LDR.N    R0,??DataTable16_5
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0x....             LDR.N    R1,??DataTable16_5
   \   00000038   0x6849             LDR      R1,[R1, #+4]
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x5442             STRB     R2,[R0, R1]
    113          	append(logging, (char *) intermediateLoggingBufferData);
   \   0000003E   0x....             LDR.N    R1,??DataTable16_8
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       append
    114          }
   \                     ??vappendPrintfI_1:
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    115          
    116          /**
    117           * this method acquires system lock to guard the shared intermediateLoggingBuffer memory stream
    118           */

   \                                 In section .text, align 2, keep-with-next
    119          void vappendPrintf(Logging *logging, const char *fmt, va_list arg) {
   \                     vappendPrintf:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    120          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#5b");
   \   00000008   0x....             LDR.N    R0,??DataTable16_6
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0x.... 0x....      BL       getRemainingStack
   \   00000010   0x2881             CMP      R0,#+129
   \   00000012   0xDA03             BGE.N    ??vappendPrintf_0
   \   00000014   0x....             LDR.N    R0,??DataTable16_9
   \   00000016   0x.... 0x....      BL       firmwareError
   \   0000001A   0xE013             B.N      ??vappendPrintf_1
    121          	if (!intermediateLoggingBufferInited) {
   \                     ??vappendPrintf_0:
   \   0000001C   0x....             LDR.N    R0,??DataTable16_10
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD103             BNE.N    ??vappendPrintf_2
    122          		firmwareError("intermediateLoggingBufferInited not inited!");
   \   00000024   0x....             LDR.N    R0,??DataTable16_11
   \   00000026   0x.... 0x....      BL       firmwareError
    123          		return;
   \   0000002A   0xE00B             B.N      ??vappendPrintf_1
    124          	}
    125          	int wasLocked = lockAnyContext();
   \                     ??vappendPrintf_2:
   \   0000002C   0x.... 0x....      BL       lockAnyContext
   \   00000030   0x0007             MOVS     R7,R0
    126          	vappendPrintfI(logging, fmt, arg);
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       _Z14vappendPrintfIP7LoggingPKc8_VA_LIST
    127          	if (!wasLocked) {
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD101             BNE.N    ??vappendPrintf_3
    128          		unlockAnyContext();
   \   00000040   0x.... 0x....      BL       unlockAnyContext
    129          	}
    130          }
   \                     ??vappendPrintf_3:
   \                     ??vappendPrintf_1:
   \   00000044   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void appendPrintf(Logging *logging, const char *fmt, ...) {
   \                     appendPrintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB570             PUSH     {R4-R6,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    133          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#4");
   \   00000008   0x....             LDR.N    R0,??DataTable16_6
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0x.... 0x....      BL       getRemainingStack
   \   00000010   0x2881             CMP      R0,#+129
   \   00000012   0xDA03             BGE.N    ??appendPrintf_0
   \   00000014   0x....             LDR.N    R0,??DataTable16_12
   \   00000016   0x.... 0x....      BL       firmwareError
   \   0000001A   0xE006             B.N      ??appendPrintf_1
    134          	va_list ap;
    135          	va_start(ap, fmt);
   \                     ??appendPrintf_0:
   \   0000001C   0xA804             ADD      R0,SP,#+16
   \   0000001E   0x0006             MOVS     R6,R0
    136          	vappendPrintf(logging, fmt, ap);
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       vappendPrintf
    137          	va_end(ap);
    138          }
   \                     ??appendPrintf_1:
   \   0000002A   0xBC70             POP      {R4-R6}
   \   0000002C   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    139          

   \                                 In section .text, align 2, keep-with-next
    140          void initLoggingExt(Logging *logging, const char *name, char *buffer, int bufferSize) {
   \                     initLoggingExt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    141          	logging->name = name;
   \   0000000A   0x6025             STR      R5,[R4, #+0]
    142          	logging->buffer = buffer;
   \   0000000C   0x62E6             STR      R6,[R4, #+44]
    143          	logging->bufferSize = bufferSize;
   \   0000000E   0x6367             STR      R7,[R4, #+52]
    144          	resetLogging(logging);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       resetLogging
    145          	logging->isInitialized = MAGIC_LOGGING_FLAG;
   \   00000016   0x....             LDR.N    R0,??DataTable16_13  ;; 0x2b23909
   \   00000018   0x63A0             STR      R0,[R4, #+56]
    146          }
   \   0000001A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    147          

   \                                 In section .text, align 2, keep-with-next
    148          int isInitialized(Logging *logging) {
    149          	return logging->isInitialized == MAGIC_LOGGING_FLAG;
   \                     isInitialized:
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x....             LDR.N    R1,??DataTable16_13  ;; 0x2b23909
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD101             BNE.N    ??isInitialized_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??isInitialized_1
   \                     ??isInitialized_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??isInitialized_1:
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
    150          }
    151          

   \                                 In section .text, align 2, keep-with-next
    152          void debugInt(Logging *logging, const char *caption, int value) {
   \                     debugInt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    153          	append(logging, caption);
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       append
    154          	append(logging, DELIMETER);
   \   00000010   0x....             ADR.N    R1,??DataTable16  ;; ","
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       append
    155          	appendPrintf(logging, "%d%s", value, DELIMETER);
   \   00000018   0x....             ADR.N    R3,??DataTable16  ;; ","
   \   0000001A   0x0032             MOVS     R2,R6
   \   0000001C   0x....             LDR.N    R1,??DataTable16_14
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       appendPrintf
    156          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void appendFloat(Logging *logging, float value, int precision) {
   \                     appendFloat:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0x000D             MOVS     R5,R1
    159          	/**
    160          	 * todo: #1 this implementation is less than perfect
    161          	 * todo: #2 The only way to avoid double promotion would probably be using *float instead of float
    162          	 * See also http://stackoverflow.com/questions/5522051/printing-a-float-in-c-while-avoiding-variadic-parameter-promotion-to-double
    163          	 */
    164          	switch (precision) {
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD009             BEQ.N    ??appendFloat_0
   \   00000012   0xD34A             BCC.N    ??appendFloat_1
   \   00000014   0x2D03             CMP      R5,#+3
   \   00000016   0xD01C             BEQ.N    ??appendFloat_2
   \   00000018   0xD310             BCC.N    ??appendFloat_3
   \   0000001A   0x2D05             CMP      R5,#+5
   \   0000001C   0xD02F             BEQ.N    ??appendFloat_4
   \   0000001E   0xD323             BCC.N    ??appendFloat_5
   \   00000020   0x2D06             CMP      R5,#+6
   \   00000022   0xD037             BEQ.N    ??appendFloat_6
   \   00000024   0xE041             B.N      ??appendFloat_1
    165          	case 1:
    166          		appendPrintf(logging, "%..10f", value);
   \                     ??appendFloat_0:
   \   00000026   0xEE18 0x0A10      VMOV     R0,S16
   \   0000002A   0x.... 0x....      BL       __aeabi_f2d
   \   0000002E   0x0002             MOVS     R2,R0
   \   00000030   0x000B             MOVS     R3,R1
   \   00000032   0x....             LDR.N    R1,??DataTable16_15
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       appendPrintf
    167          		break;
   \   0000003A   0xE040             B.N      ??appendFloat_7
    168          	case 2:
    169          		appendPrintf(logging, "%..100f", value);
   \                     ??appendFloat_3:
   \   0000003C   0xEE18 0x0A10      VMOV     R0,S16
   \   00000040   0x.... 0x....      BL       __aeabi_f2d
   \   00000044   0x0002             MOVS     R2,R0
   \   00000046   0x000B             MOVS     R3,R1
   \   00000048   0x....             LDR.N    R1,??DataTable16_16
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       appendPrintf
    170          		break;
   \   00000050   0xE035             B.N      ??appendFloat_7
    171          	case 3:
    172          		appendPrintf(logging, "%..1000f", value);
   \                     ??appendFloat_2:
   \   00000052   0xEE18 0x0A10      VMOV     R0,S16
   \   00000056   0x.... 0x....      BL       __aeabi_f2d
   \   0000005A   0x0002             MOVS     R2,R0
   \   0000005C   0x000B             MOVS     R3,R1
   \   0000005E   0x....             LDR.N    R1,??DataTable16_17
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       appendPrintf
    173          		break;
   \   00000066   0xE02A             B.N      ??appendFloat_7
    174          	case 4:
    175          		appendPrintf(logging, "%..10000f", value);
   \                     ??appendFloat_5:
   \   00000068   0xEE18 0x0A10      VMOV     R0,S16
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x0002             MOVS     R2,R0
   \   00000072   0x000B             MOVS     R3,R1
   \   00000074   0x....             LDR.N    R1,??DataTable16_18
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       appendPrintf
    176          		break;
   \   0000007C   0xE01F             B.N      ??appendFloat_7
    177          	case 5:
    178          		appendPrintf(logging, "%..100000f", value);
   \                     ??appendFloat_4:
   \   0000007E   0xEE18 0x0A10      VMOV     R0,S16
   \   00000082   0x.... 0x....      BL       __aeabi_f2d
   \   00000086   0x0002             MOVS     R2,R0
   \   00000088   0x000B             MOVS     R3,R1
   \   0000008A   0x....             LDR.N    R1,??DataTable16_19
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       appendPrintf
    179          		break;
   \   00000092   0xE014             B.N      ??appendFloat_7
    180          	case 6:
    181          		appendPrintf(logging, "%..1000000f", value);
   \                     ??appendFloat_6:
   \   00000094   0xEE18 0x0A10      VMOV     R0,S16
   \   00000098   0x.... 0x....      BL       __aeabi_f2d
   \   0000009C   0x0002             MOVS     R2,R0
   \   0000009E   0x000B             MOVS     R3,R1
   \   000000A0   0x....             LDR.N    R1,??DataTable16_20
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       appendPrintf
    182          		break;
   \   000000A8   0xE009             B.N      ??appendFloat_7
    183          
    184          	default:
    185          		appendPrintf(logging, "%f", value);
   \                     ??appendFloat_1:
   \   000000AA   0xEE18 0x0A10      VMOV     R0,S16
   \   000000AE   0x.... 0x....      BL       __aeabi_f2d
   \   000000B2   0x0002             MOVS     R2,R0
   \   000000B4   0x000B             MOVS     R3,R1
   \   000000B6   0x....             ADR.N    R1,??DataTable16_1  ;; 0x25, 0x66, 0x00, 0x00
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       appendPrintf
    186          	}
    187          }
   \                     ??appendFloat_7:
   \   000000BE   0xECBD 0x8B02      VPOP     {D8}
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    188          

   \                                 In section .text, align 2, keep-with-next
    189          void debugFloat(Logging *logging, const char *caption, float value, int precision) {
   \                     debugFloat:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000E   0x0016             MOVS     R6,R2
    190          	append(logging, caption);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       append
    191          	append(logging, DELIMETER);
   \   00000018   0x....             ADR.N    R1,??DataTable16  ;; ","
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       append
    192          
    193          	appendFloat(logging, value, precision);
   \   00000020   0x0031             MOVS     R1,R6
   \   00000022   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       appendFloat
    194          	append(logging, DELIMETER);
   \   0000002C   0x....             ADR.N    R1,??DataTable16  ;; ","
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       append
    195          }
   \   00000034   0xECBD 0x8B02      VPOP     {D8}
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    196          

   \                                 In section .bss, align 4
    197          static char header[16];
   \                     header:
   \   00000000                      DS8 16
    198          
    199          /**
    200           * this method should invoked on the main thread only
    201           */

   \                                 In section .text, align 2, keep-with-next
    202          void printWithLength(char *line) {
   \                     printWithLength:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    203          	/**
    204          	 * this is my way to detect serial port transmission errors
    205          	 * following code is functionally identical to
    206          	 *   print("line:%d:%s\r\n", len, line);
    207          	 * but it is faster because it outputs the whole buffer, not single characters
    208          	 * We need this optimization because when we output larger chunks of data like the wave_chart:
    209          	 * When we work with actual hardware, it is faster to invoke 'chSequentialStreamWrite' for the
    210          	 * whole buffer then to invoke 'chSequentialStreamPut' once per character.
    211          	 */
    212          	int len = efiStrlen(line);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       efiStrlen
   \   0000000A   0x0005             MOVS     R5,R0
    213          	strcpy(header, "line:");
   \   0000000C   0x....             LDR.N    R1,??DataTable16_21
   \   0000000E   0x....             LDR.N    R0,??DataTable16_22
   \   00000010   0x.... 0x....      BL       strcpy
    214          	char *p = header + efiStrlen(header);
   \   00000014   0x.... 0x....      BL       efiStrlen
   \   00000018   0x....             LDR.N    R1,??DataTable16_22
   \   0000001A   0x1846             ADDS     R6,R0,R1
    215          	p = itoa10(p, len);
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x.... 0x....      BL       itoa10
   \   00000024   0x0006             MOVS     R6,R0
    216          	*p++ = ':';
   \   00000026   0x203A             MOVS     R0,#+58
   \   00000028   0x7030             STRB     R0,[R6, #+0]
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
    217          	*p++ = '\0';
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
   \   00000030   0x1C76             ADDS     R6,R6,#+1
    218          
    219          	p = line;
   \   00000032   0x0026             MOVS     R6,R4
    220          	p += len;
   \   00000034   0x19AE             ADDS     R6,R5,R6
    221          	*p++ = '\r';
   \   00000036   0x200D             MOVS     R0,#+13
   \   00000038   0x7030             STRB     R0,[R6, #+0]
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
    222          	*p++ = '\n';
   \   0000003C   0x200A             MOVS     R0,#+10
   \   0000003E   0x7030             STRB     R0,[R6, #+0]
   \   00000040   0x1C76             ADDS     R6,R6,#+1
    223          
    224          	if (!isConsoleReady())
   \   00000042   0x.... 0x....      BL       _Z14isConsoleReadyv
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD00A             BEQ.N    ??printWithLength_0
    225          		return;
    226          	consoleOutputBuffer((const uint8_t *) header, strlen(header));
   \                     ??printWithLength_1:
   \   0000004A   0x....             LDR.N    R0,??DataTable16_22
   \   0000004C   0x.... 0x....      BL       strlen
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0x....             LDR.N    R0,??DataTable16_22
   \   00000054   0x.... 0x....      BL       _Z19consoleOutputBufferPKhi
    227          	consoleOutputBuffer((const uint8_t *) line, p - line);
   \   00000058   0x1B31             SUBS     R1,R6,R4
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       _Z19consoleOutputBufferPKhi
    228          }
   \                     ??printWithLength_0:
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    229          

   \                                 In section .text, align 2, keep-with-next
    230          void printLine(Logging *logging) {
   \                     printLine:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    231          	printWithLength(logging->buffer);
   \   00000004   0x6AE0             LDR      R0,[R4, #+44]
   \   00000006   0x.... 0x....      BL       printWithLength
    232          	resetLogging(logging);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       resetLogging
    233          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    234          

   \                                 In section .text, align 2, keep-with-next
    235          void appendMsgPrefix(Logging *logging) {
   \                     appendMsgPrefix:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    236          	append(logging, "msg" DELIMETER);
   \   00000004   0x....             LDR.N    R1,??DataTable16_23
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       append
    237          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    238          

   \                                 In section .text, align 2, keep-with-next
    239          void appendMsgPostfix(Logging *logging) {
   \                     appendMsgPostfix:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240          	append(logging, DELIMETER);
   \   00000004   0x....             ADR.N    R1,??DataTable16  ;; ","
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       append
    241          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    242          

   \                                 In section .text, align 2, keep-with-next
    243          void resetLogging(Logging *logging) {
   \                     resetLogging:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    244          	char *buffer = logging->buffer;
   \   00000004   0x6AE5             LDR      R5,[R4, #+44]
    245          	if (buffer == NULL) {
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD104             BNE.N    ??resetLogging_0
    246          		firmwareError("Null buffer: %s", logging->name);
   \   0000000A   0x6821             LDR      R1,[R4, #+0]
   \   0000000C   0x....             LDR.N    R0,??DataTable16_24
   \   0000000E   0x.... 0x....      BL       firmwareError
    247          		return;
   \   00000012   0xE003             B.N      ??resetLogging_1
    248          	}
    249          	logging->linePointer = buffer;
   \                     ??resetLogging_0:
   \   00000014   0x6325             STR      R5,[R4, #+48]
    250          	logging->linePointer[0] = 0;
   \   00000016   0x6B20             LDR      R0,[R4, #+48]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    251          }
   \                     ??resetLogging_1:
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    252          
    253          /**
    254           * This method would output a simple console message immediately.
    255           * This method should only be invoked on main thread because only the main thread can write to the console
    256           */

   \                                 In section .text, align 2, keep-with-next
    257          void printMsg(Logging *logger, const char *fmt, ...) {
   \                     printMsg:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB570             PUSH     {R4-R6,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    258          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#5o");
   \   00000008   0x....             LDR.N    R0,??DataTable16_6
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0x.... 0x....      BL       getRemainingStack
   \   00000010   0x2881             CMP      R0,#+129
   \   00000012   0xDA03             BGE.N    ??printMsg_0
   \   00000014   0x....             LDR.N    R0,??DataTable16_25
   \   00000016   0x.... 0x....      BL       firmwareError
   \   0000001A   0xE010             B.N      ??printMsg_1
    259          //	resetLogging(logging); // I guess 'reset' is not needed here?
    260          	appendMsgPrefix(logger);
   \                     ??printMsg_0:
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       appendMsgPrefix
    261          
    262          	va_list ap;
    263          	va_start(ap, fmt);
   \   00000022   0xA804             ADD      R0,SP,#+16
   \   00000024   0x0006             MOVS     R6,R0
    264          	vappendPrintf(logger, fmt, ap);
   \   00000026   0x0032             MOVS     R2,R6
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       vappendPrintf
    265          	va_end(ap);
    266          
    267          	append(logger, DELIMETER);
   \   00000030   0x....             ADR.N    R1,??DataTable16  ;; ","
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       append
    268          	printLine(logger);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       printLine
    269          }
   \                     ??printMsg_1:
   \   0000003E   0xBC70             POP      {R4-R6}
   \   00000040   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    270          
    271          /**
    272           * this whole method is executed under syslock so that we can have multiple threads use the same shared buffer
    273           * in order to reduce memory usage
    274           */

   \                                 In section .text, align 2, keep-with-next
    275          void scheduleMsg(Logging *logging, const char *fmt, ...) {
   \                     scheduleMsg:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB5F8             PUSH     {R3-R7,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    276          	efiAssertVoid(logging != NULL, "logging NULL");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD103             BNE.N    ??scheduleMsg_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_26
   \   0000000E   0x.... 0x....      BL       firmwareError
   \   00000012   0xE019             B.N      ??scheduleMsg_1
    277          	int wasLocked = lockAnyContext();
   \                     ??scheduleMsg_0:
   \   00000014   0x.... 0x....      BL       lockAnyContext
   \   00000018   0x0006             MOVS     R6,R0
    278          	resetLogging(logging); // todo: is 'reset' really needed here?
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       resetLogging
    279          	appendMsgPrefix(logging);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       appendMsgPrefix
    280          
    281          	va_list ap;
    282          	va_start(ap, fmt);
   \   00000026   0xA806             ADD      R0,SP,#+24
   \   00000028   0x0007             MOVS     R7,R0
    283          	vappendPrintf(logging, fmt, ap);
   \   0000002A   0x003A             MOVS     R2,R7
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       vappendPrintf
    284          	va_end(ap);
    285          
    286          	appendMsgPostfix(logging);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       appendMsgPostfix
    287          	scheduleLogging(logging);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       scheduleLogging
    288          	if (!wasLocked) {
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD101             BNE.N    ??scheduleMsg_2
    289          		unlockAnyContext();
   \   00000044   0x.... 0x....      BL       unlockAnyContext
    290          	}
    291          }
   \                     ??scheduleMsg_2:
   \                     ??scheduleMsg_1:
   \   00000048   0xBCF1             POP      {R0,R4-R7}
   \   0000004A   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
    292          

   \                                 In section .text, align 2, keep-with-next
    293          uint32_t remainingSize(Logging *logging) {
    294          	return logging->bufferSize - loggingSize(logging);
   \                     remainingSize:
   \   00000000   0x6B41             LDR      R1,[R0, #+52]
   \   00000002   0x6B02             LDR      R2,[R0, #+48]
   \   00000004   0x1A89             SUBS     R1,R1,R2
   \   00000006   0x6AC0             LDR      R0,[R0, #+44]
   \   00000008   0x1840             ADDS     R0,R0,R1
   \   0000000A   0x4770             BX       LR               ;; return
    295          }
    296          

   \                                 In section .text, align 2, keep-with-next
    297          void initIntermediateLoggingBuffer(void) {
   \                     initIntermediateLoggingBuffer:
   \   00000000   0xB580             PUSH     {R7,LR}
    298          	initLoggingCentral();
   \   00000002   0x.... 0x....      BL       _Z18initLoggingCentralv
    299          
    300          	msObjectInit(&intermediateLoggingBuffer, intermediateLoggingBufferData, INTERMEDIATE_LOGGING_BUFFER_SIZE, 0);
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xF44F 0x62FA      MOV      R2,#+2000
   \   0000000C   0x....             LDR.N    R1,??DataTable16_8
   \   0000000E   0x....             LDR.N    R0,??DataTable16_5
   \   00000010   0x.... 0x....      BL       msObjectInit
    301          	intermediateLoggingBufferInited = TRUE;
   \   00000014   0x....             LDR.N    R0,??DataTable16_10
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x7001             STRB     R1,[R0, #+0]
    302          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    303          
    304          #endif /* ! EFI_UNIT_TEST */
    305          

   \                                 In section .text, align 2, keep-with-next
    306          void Logging::baseConstructor() {
    307          	name = NULL;
   \                     _ZN7Logging15baseConstructorEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    308          	buffer = NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x62C1             STR      R1,[R0, #+44]
    309          	linePointer = NULL;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6301             STR      R1,[R0, #+48]
    310          	bufferSize = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6341             STR      R1,[R0, #+52]
    311          	isInitialized = false;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6381             STR      R1,[R0, #+56]
    312          }
   \   00000014   0x4770             BX       LR               ;; return
    313          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Logging::subobject Logging()
   \                     _ZN7LoggingC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN7LoggingC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    314          Logging::Logging() {
   \                     _ZN7LoggingC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    315          	baseConstructor();
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN7Logging15baseConstructorEv
    316          }
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    317          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Logging::subobject Logging(char const *, char *, int)
   \                     _ZN7LoggingC2EPKcPci:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN7LoggingC1EPKcPci
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    318          Logging::Logging(char const *name, char *buffer, int bufferSize) {
   \                     _ZN7LoggingC1EPKcPci:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    319          	baseConstructor();
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN7Logging15baseConstructorEv
    320          #if ! EFI_UNIT_TEST
    321          	initLoggingExt(this, name, buffer, bufferSize);
   \   00000010   0x003B             MOVS     R3,R7
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       initLoggingExt
    322          #endif /* ! EFI_UNIT_TEST */
    323          }
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    324          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp LoggingWithStorage::subobject LoggingWithStorage(char const *)
   \                     _ZN18LoggingWithStorageC2EPKc:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN18LoggingWithStorageC1EPKc
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    325          LoggingWithStorage::LoggingWithStorage(const char *name) : Logging(name, DEFAULT_BUFFER, sizeof(DEFAULT_BUFFER))   {
   \                     _ZN18LoggingWithStorageC1EPKc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x23C8             MOVS     R3,#+200
   \   00000008   0xF114 0x023C      ADDS     R2,R4,#+60
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZN7LoggingC2EPKcPci
    326          }
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x2C 0x00          DC8      ",",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     `?<Constant "Logging not initializ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     `?<Constant "output overflow %s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     `?<Constant "append NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     intermediateLoggingBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     `?<Constant "lowstck#1b">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     intermediateLoggingBufferData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     `?<Constant "lowstck#5b">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     intermediateLoggingBufferInited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     `?<Constant "intermediateLoggingBu...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     `?<Constant "lowstck#4">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x02B23909         DC32     0x2b23909

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x........         DC32     `?<Constant "%d%s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x........         DC32     `?<Constant "%..10f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x........         DC32     `?<Constant "%..100f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x........         DC32     `?<Constant "%..1000f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x........         DC32     `?<Constant "%..10000f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x........         DC32     `?<Constant "%..100000f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   0x........         DC32     `?<Constant "%..1000000f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   0x........         DC32     `?<Constant "line:">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   0x........         DC32     header

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \   00000000   0x........         DC32     `?<Constant "msg,">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \   00000000   0x........         DC32     `?<Constant "Null buffer: %s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \   00000000   0x........         DC32     `?<Constant "lowstck#5o">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \   00000000   0x........         DC32     `?<Constant "logging NULL">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "Logging not initializ...">`:
   \   00000000   0x4C 0x6F          DC8 "Logging not initialized: %s"
   \              0x67 0x67    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x65    
   \              0x64 0x3A    
   \              0x20 0x25    
   \              0x73 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "output overflow %s">`:
   \   00000000   0x6F 0x75          DC8 "output overflow %s"
   \              0x74 0x70    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x76 0x65    
   \              0x72 0x66    
   \              0x6C 0x6F    
   \              0x77 0x20    
   \              0x25 0x73    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "append NULL">`:
   \   00000000   0x61 0x70          DC8 "append NULL"
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#1b">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#1b"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x31 0x62    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#5b">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#5b"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x35 0x62    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "intermediateLoggingBu...">`:
   \   00000000   0x69 0x6E          DC8 "intermediateLoggingBufferInited not inited!"
   \              0x74 0x65    
   \              0x72 0x6D    
   \              0x65 0x64    
   \              0x69 0x61    
   \              0x74 0x65    
   \              0x4C 0x6F    
   \              0x67 0x67    
   \              0x69 0x6E    
   \              0x67 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x49    
   \              0x6E 0x69    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x65 0x64    
   \              0x21 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#4">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#4"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x34 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x2C 0x00          DC8 ","

   \                                 In section .rodata, align 4
   \                     `?<Constant "%d%s">`:
   \   00000000   0x25 0x64          DC8 "%d%s"
   \              0x25 0x73    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "%..10f">`:
   \   00000000   0x25 0x2E          DC8 "%..10f"
   \              0x2E 0x31    
   \              0x30 0x66    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%..100f">`:
   \   00000000   0x25 0x2E          DC8 "%..100f"
   \              0x2E 0x31    
   \              0x30 0x30    
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "%..1000f">`:
   \   00000000   0x25 0x2E          DC8 "%..1000f"
   \              0x2E 0x31    
   \              0x30 0x30    
   \              0x30 0x66    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "%..10000f">`:
   \   00000000   0x25 0x2E          DC8 "%..10000f"
   \              0x2E 0x31    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x66 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%..100000f">`:
   \   00000000   0x25 0x2E          DC8 "%..100000f"
   \              0x2E 0x31    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x30 0x66    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%..1000000f">`:
   \   00000000   0x25 0x2E          DC8 "%..1000000f"
   \              0x2E 0x31    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x66          DC8 "%f"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "line:">`:
   \   00000000   0x6C 0x69          DC8 "line:"
   \              0x6E 0x65    
   \              0x3A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "msg,">`:
   \   00000000   0x6D 0x73          DC8 "msg,"
   \              0x67 0x2C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Null buffer: %s">`:
   \   00000000   0x4E 0x75          DC8 "Null buffer: %s"
   \              0x6C 0x6C    
   \              0x20 0x62    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#5o">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#5o"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x35 0x6F    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "logging NULL">`:
   \   00000000   0x6C 0x6F          DC8 "logging NULL"
   \              0x67 0x67    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Logging::Logging()
         8   -> Logging::baseConstructor()
      24   Logging::Logging(char const *, char *, int)
        24   -> Logging::baseConstructor()
        24   -> initLoggingExt
       0   Logging::baseConstructor()
       8   Logging::subobject Logging()
         8   -> Logging::Logging()
       8   Logging::subobject Logging(char const *, char *, int)
         8   -> Logging::Logging(char const *, char *, int)
      16   LoggingWithStorage::LoggingWithStorage(char const *)
        16   -> Logging::subobject Logging(char const *, char *, int)
       8   LoggingWithStorage::subobject LoggingWithStorage(char const *)
         8   -> LoggingWithStorage::LoggingWithStorage(char const *)
      24   append
        24   -> efiStrlen
        24   -> firmwareError
        24   -> strcpy
        24   -> validateBuffer(Logging *, uint32_t)
       4   appendFast
      24   appendFloat
        24   -> __aeabi_f2d
        24   -> appendPrintf
       8   appendMsgPostfix
         8   -> append
       8   appendMsgPrefix
         8   -> append
      24   appendPrintf
        24   -> firmwareError
        24   -> getRemainingStack
        24   -> vappendPrintf
      24   debugFloat
        24   -> append
        24   -> appendFloat
      16   debugInt
        16   -> append
        16   -> appendPrintf
       8   initIntermediateLoggingBuffer
         8   -> initLoggingCentral()
         8   -> msObjectInit
      24   initLoggingExt
        24   -> resetLogging
       0   isInitialized
       8   printLine
         8   -> printWithLength
         8   -> resetLogging
      24   printMsg
        24   -> append
        24   -> appendMsgPrefix
        24   -> firmwareError
        24   -> getRemainingStack
        24   -> printLine
        24   -> vappendPrintf
      16   printWithLength
        16   -> consoleOutputBuffer(uint8_t const *, int)
        16   -> efiStrlen
        16   -> isConsoleReady()
        16   -> itoa10
        16   -> strcpy
        16   -> strlen
       0   remainingSize
      16   resetLogging
        16   -> firmwareError
      32   scheduleMsg
        32   -> appendMsgPostfix
        32   -> appendMsgPrefix
        32   -> firmwareError
        32   -> lockAnyContext
        32   -> resetLogging
        32   -> scheduleLogging
        32   -> unlockAnyContext
        32   -> vappendPrintf
      16   validateBuffer(Logging *, uint32_t)
        16   -> firmwareError
        16   -> remainingSize
        16   -> warning
      24   vappendPrintf
        24   -> firmwareError
        24   -> getRemainingStack
        24   -> lockAnyContext
        24   -> unlockAnyContext
        24   -> vappendPrintfI(Logging *, char const *, va_list)
      16   vappendPrintfI(Logging *, char const *, va_list)
        16   -> append
        16   -> chvprintf
        16   -> firmwareError
        16   -> getRemainingStack


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "%..1000000f">
      12  ?<Constant "%..100000f">
      12  ?<Constant "%..10000f">
      12  ?<Constant "%..1000f">
       8  ?<Constant "%..100f">
       8  ?<Constant "%..10f">
       8  ?<Constant "%d%s">
       4  ?<Constant "%f">
       2  ?<Constant ",">
      28  ?<Constant "Logging not initializ...">
      16  ?<Constant "Null buffer: %s">
      12  ?<Constant "append NULL">
      44  ?<Constant "intermediateLoggingBu...">
       8  ?<Constant "line:">
      16  ?<Constant "logging NULL">
      12  ?<Constant "lowstck#1b">
      12  ?<Constant "lowstck#4">
      12  ?<Constant "lowstck#5b">
      12  ?<Constant "lowstck#5o">
       8  ?<Constant "msg,">
      20  ?<Constant "output overflow %s">
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      14  Logging::Logging()
      32  Logging::Logging(char const *, char *, int)
      22  Logging::baseConstructor()
      12  Logging::subobject Logging()
      12  Logging::subobject Logging(char const *, char *, int)
      24  LoggingWithStorage::LoggingWithStorage(char const *)
      12  LoggingWithStorage::subobject LoggingWithStorage(char const *)
      60  append
      44  appendFast
     196  appendFloat
      14  appendMsgPostfix
      14  appendMsgPrefix
      48  appendPrintf
      58  debugFloat
      38  debugInt
      16  header
      28  initIntermediateLoggingBuffer
      28  initLoggingExt
      20  intermediateLoggingBuffer
    2000  intermediateLoggingBufferData
       1  intermediateLoggingBufferInited
      18  isInitialized
      18  printLine
      68  printMsg
      98  printWithLength
      12  remainingSize
      30  resetLogging
      78  scheduleMsg
      60  validateBuffer(Logging *, uint32_t)
      70  vappendPrintf
      72  vappendPrintfI(Logging *, char const *, va_list)

 
    37 bytes in section .bss
 2 000 bytes in section .ccm
   278 bytes in section .rodata
 1 288 bytes in section .text
 
 1 288 bytes of CODE  memory
   278 bytes of CONST memory
 2 037 bytes of DATA  memory

Errors: none
Warnings: none
