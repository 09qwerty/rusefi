###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:38 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32F4xx\adc_lld.c                          #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32F4xx\adc_lld.c -lCN                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\a #
#                       dc_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ad #
#                       c_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32F4xx\adc_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32F4xx/adc_lld.c
     19           * @brief   STM32F4xx/STM32F2xx ADC subsystem low level driver source.
     20           *
     21           * @addtogroup ADC
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_ADC || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          #define ADC1_DMA_CHANNEL                                                    \
     35            STM32_DMA_GETCHANNEL(STM32_ADC_ADC1_DMA_STREAM, STM32_ADC1_DMA_CHN)
     36          
     37          #define ADC2_DMA_CHANNEL                                                    \
     38            STM32_DMA_GETCHANNEL(STM32_ADC_ADC2_DMA_STREAM, STM32_ADC2_DMA_CHN)
     39          
     40          #define ADC3_DMA_CHANNEL                                                    \
     41            STM32_DMA_GETCHANNEL(STM32_ADC_ADC3_DMA_STREAM, STM32_ADC3_DMA_CHN)
     42          
     43          /*===========================================================================*/
     44          /* Driver exported variables.                                                */
     45          /*===========================================================================*/
     46          
     47          /** @brief ADC1 driver identifier.*/
     48          #if STM32_ADC_USE_ADC1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     49          ADCDriver ADCD1;
   \                     ADCD1:
   \   00000000                      DS8 52
     50          #endif
     51          
     52          /** @brief ADC2 driver identifier.*/
     53          #if STM32_ADC_USE_ADC2 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     54          ADCDriver ADCD2;
   \                     ADCD2:
   \   00000000                      DS8 52
     55          #endif
     56          
     57          /** @brief ADC3 driver identifier.*/
     58          #if STM32_ADC_USE_ADC3 || defined(__DOXYGEN__)
     59          ADCDriver ADCD3;
     60          #endif
     61          
     62          /*===========================================================================*/
     63          /* Driver local variables and types.                                         */
     64          /*===========================================================================*/
     65          
     66          /*===========================================================================*/
     67          /* Driver local functions.                                                   */
     68          /*===========================================================================*/
     69          
     70          #include "error_handling.h"
     71          
     72          /**
     73           * @brief   ADC DMA ISR service routine.
     74           *
     75           * @param[in] adcp      pointer to the @p ADCDriver object
     76           * @param[in] flags     pre-shifted content of the ISR register
     77           */

   \                                 In section .text, align 2, keep-with-next
     78          static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
   \                     adc_lld_serve_rx_interrupt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     79          
     80          	efiAssertVoid(getRemainingStack(chThdSelf()) > 64, "sys_adc");
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0x.... 0x....      BL       getRemainingStack
   \   00000010   0x2841             CMP      R0,#+65
   \   00000012   0xDA04             BGE.N    ??adc_lld_serve_rx_interrupt_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000018   0x.... 0x....      BL       firmwareError
   \   0000001C   0xE096             B.N      ??adc_lld_serve_rx_interrupt_1
     81          
     82            /* DMA errors handling.*/
     83            if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
   \                     ??adc_lld_serve_rx_interrupt_0:
   \   0000001E   0xF015 0x0F0C      TST      R5,#0xC
   \   00000022   0xD02C             BEQ.N    ??adc_lld_serve_rx_interrupt_2
     84              /* DMA, this could help only if the DMA tries to access an unmapped
     85                 address space or violates alignment rules.*/
     86              _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       adc_lld_stop_conversion
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x6880             LDR      R0,[R0, #+8]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00B             BEQ.N    ??adc_lld_serve_rx_interrupt_3
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x6922             LDR      R2,[R4, #+16]
   \   0000003C   0x6892             LDR      R2,[R2, #+8]
   \   0000003E   0x4790             BLX      R2
   \   00000040   0x7820             LDRB     R0,[R4, #+0]
   \   00000042   0x2805             CMP      R0,#+5
   \   00000044   0xD101             BNE.N    ??adc_lld_serve_rx_interrupt_3
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x7020             STRB     R0,[R4, #+0]
   \                     ??adc_lld_serve_rx_interrupt_3:
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6120             STR      R0,[R4, #+16]
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000054   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   00000058   0x6960             LDR      R0,[R4, #+20]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD009             BEQ.N    ??adc_lld_serve_rx_interrupt_4
   \   0000005E   0x6960             LDR      R0,[R4, #+20]
   \   00000060   0x0006             MOVS     R6,R0
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6160             STR      R0,[R4, #+20]
   \   00000066   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000006A   0x62B0             STR      R0,[R6, #+40]
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0x.... 0x....      BL       chSchReadyI
   \                     ??adc_lld_serve_rx_interrupt_4:
   \   00000072   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000007C   0xE066             B.N      ??adc_lld_serve_rx_interrupt_5
     87            }
     88            else {
     89              /* It is possible that the conversion group has already be reset by the
     90                 ADC error handler, in this case this interrupt is spurious.*/
     91              if (adcp->grpp != NULL) {
   \                     ??adc_lld_serve_rx_interrupt_2:
   \   0000007E   0x6920             LDR      R0,[R4, #+16]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD063             BEQ.N    ??adc_lld_serve_rx_interrupt_5
     92                if ((flags & STM32_DMA_ISR_TCIF) != 0) {
   \   00000084   0x06A8             LSLS     R0,R5,#+26
   \   00000086   0xD554             BPL.N    ??adc_lld_serve_rx_interrupt_6
     93                  /* Transfer complete processing.*/
     94                  _adc_isr_full_code(adcp);
   \   00000088   0x6920             LDR      R0,[R4, #+16]
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD01E             BEQ.N    ??adc_lld_serve_rx_interrupt_7
   \   00000090   0x6920             LDR      R0,[R4, #+16]
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD059             BEQ.N    ??adc_lld_serve_rx_interrupt_5
   \   00000098   0x68E0             LDR      R0,[R4, #+12]
   \   0000009A   0x2802             CMP      R0,#+2
   \   0000009C   0xD310             BCC.N    ??adc_lld_serve_rx_interrupt_8
   \   0000009E   0x68E0             LDR      R0,[R4, #+12]
   \   000000A0   0x0840             LSRS     R0,R0,#+1
   \   000000A2   0x0007             MOVS     R7,R0
   \   000000A4   0x6920             LDR      R0,[R4, #+16]
   \   000000A6   0x8840             LDRH     R0,[R0, #+2]
   \   000000A8   0xFB00 0xF007      MUL      R0,R0,R7
   \   000000AC   0x0006             MOVS     R6,R0
   \   000000AE   0x003A             MOVS     R2,R7
   \   000000B0   0x68A0             LDR      R0,[R4, #+8]
   \   000000B2   0xEB10 0x0146      ADDS     R1,R0,R6, LSL #+1
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x6923             LDR      R3,[R4, #+16]
   \   000000BA   0x685B             LDR      R3,[R3, #+4]
   \   000000BC   0x4798             BLX      R3
   \   000000BE   0xE045             B.N      ??adc_lld_serve_rx_interrupt_5
   \                     ??adc_lld_serve_rx_interrupt_8:
   \   000000C0   0x68E2             LDR      R2,[R4, #+12]
   \   000000C2   0x68A1             LDR      R1,[R4, #+8]
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x6923             LDR      R3,[R4, #+16]
   \   000000C8   0x685B             LDR      R3,[R3, #+4]
   \   000000CA   0x4798             BLX      R3
   \   000000CC   0xE03E             B.N      ??adc_lld_serve_rx_interrupt_5
   \                     ??adc_lld_serve_rx_interrupt_7:
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       adc_lld_stop_conversion
   \   000000D4   0x6920             LDR      R0,[R4, #+16]
   \   000000D6   0x6840             LDR      R0,[R0, #+4]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD00F             BEQ.N    ??adc_lld_serve_rx_interrupt_9
   \   000000DC   0x2004             MOVS     R0,#+4
   \   000000DE   0x7020             STRB     R0,[R4, #+0]
   \   000000E0   0x68E2             LDR      R2,[R4, #+12]
   \   000000E2   0x68A1             LDR      R1,[R4, #+8]
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x6923             LDR      R3,[R4, #+16]
   \   000000E8   0x685B             LDR      R3,[R3, #+4]
   \   000000EA   0x4798             BLX      R3
   \   000000EC   0x7820             LDRB     R0,[R4, #+0]
   \   000000EE   0x2804             CMP      R0,#+4
   \   000000F0   0xD108             BNE.N    ??adc_lld_serve_rx_interrupt_10
   \   000000F2   0x2002             MOVS     R0,#+2
   \   000000F4   0x7020             STRB     R0,[R4, #+0]
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x6120             STR      R0,[R4, #+16]
   \   000000FA   0xE003             B.N      ??adc_lld_serve_rx_interrupt_10
   \                     ??adc_lld_serve_rx_interrupt_9:
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0x7020             STRB     R0,[R4, #+0]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x6120             STR      R0,[R4, #+16]
   \                     ??adc_lld_serve_rx_interrupt_10:
   \   00000104   0x2020             MOVS     R0,#+32
   \   00000106   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000010A   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   0000010E   0x6960             LDR      R0,[R4, #+20]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD008             BEQ.N    ??adc_lld_serve_rx_interrupt_11
   \   00000114   0x6960             LDR      R0,[R4, #+20]
   \   00000116   0x0006             MOVS     R6,R0
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x6160             STR      R0,[R4, #+20]
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x62B0             STR      R0,[R6, #+40]
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0x.... 0x....      BL       chSchReadyI
   \                     ??adc_lld_serve_rx_interrupt_11:
   \   00000126   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000130   0xE00C             B.N      ??adc_lld_serve_rx_interrupt_5
     95                }
     96                else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
   \                     ??adc_lld_serve_rx_interrupt_6:
   \   00000132   0x06E8             LSLS     R0,R5,#+27
   \   00000134   0xD50A             BPL.N    ??adc_lld_serve_rx_interrupt_5
     97                  /* Half transfer processing.*/
     98                  _adc_isr_half_code(adcp);
   \   00000136   0x6920             LDR      R0,[R4, #+16]
   \   00000138   0x6840             LDR      R0,[R0, #+4]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD006             BEQ.N    ??adc_lld_serve_rx_interrupt_5
   \   0000013E   0x68E0             LDR      R0,[R4, #+12]
   \   00000140   0x0842             LSRS     R2,R0,#+1
   \   00000142   0x68A1             LDR      R1,[R4, #+8]
   \   00000144   0x0020             MOVS     R0,R4
   \   00000146   0x6923             LDR      R3,[R4, #+16]
   \   00000148   0x685B             LDR      R3,[R3, #+4]
   \   0000014A   0x4798             BLX      R3
     99                }
    100              }
    101            }
    102          }
   \                     ??adc_lld_serve_rx_interrupt_5:
   \                     ??adc_lld_serve_rx_interrupt_1:
   \   0000014C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    103          
    104          /*===========================================================================*/
    105          /* Driver interrupt handlers.                                                */
    106          /*===========================================================================*/
    107          
    108          #if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2 || STM32_ADC_USE_ADC3 ||       \
    109              defined(__DOXYGEN__)
    110          /**
    111           * @brief   ADC interrupt handler.
    112           *
    113           * @isr
    114           */

   \                                 In section .text, align 2, keep-with-next
    115          CH_IRQ_HANDLER(ADC1_2_3_IRQHandler) {
   \                     Vector88:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    116            uint32_t sr;
    117          
    118            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    119          
    120          #if STM32_ADC_USE_ADC1
    121            sr = ADC1->SR;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40012000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0004             MOVS     R4,R0
    122            ADC1->SR = 0;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40012000
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6001             STR      R1,[R0, #+0]
    123            /* Note, an overflow may occur after the conversion ended before the driver
    124               is able to stop the ADC, this is why the DMA channel is checked too.*/
    125            if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
   \   00000016   0x06A0             LSLS     R0,R4,#+26
   \   00000018   0xD542             BPL.N    ??Vector88_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000001E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD03B             BEQ.N    ??Vector88_0
    126              /* ADC overflow condition, this could happen only if the DMA is unable
    127                 to read data fast enough.*/
    128              if (ADCD1.grpp != NULL)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000002C   0x6900             LDR      R0,[R0, #+16]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD036             BEQ.N    ??Vector88_0
    129                _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000036   0x.... 0x....      BL       adc_lld_stop_conversion
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000003E   0x6900             LDR      R0,[R0, #+16]
   \   00000040   0x6880             LDR      R0,[R0, #+8]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD00F             BEQ.N    ??Vector88_1
   \   00000046   0x....             LDR.N    R0,??DataTable8_3
   \   00000048   0x2105             MOVS     R1,#+5
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x....             LDR.N    R0,??DataTable8_3
   \   00000050   0x....             LDR.N    R2,??DataTable8_3
   \   00000052   0x6912             LDR      R2,[R2, #+16]
   \   00000054   0x6892             LDR      R2,[R2, #+8]
   \   00000056   0x4790             BLX      R2
   \   00000058   0x....             LDR.N    R0,??DataTable8_3
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x2805             CMP      R0,#+5
   \   0000005E   0xD102             BNE.N    ??Vector88_1
   \   00000060   0x....             LDR.N    R0,??DataTable8_3
   \   00000062   0x2102             MOVS     R1,#+2
   \   00000064   0x7001             STRB     R1,[R0, #+0]
   \                     ??Vector88_1:
   \   00000066   0x....             LDR.N    R0,??DataTable8_3
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x6101             STR      R1,[R0, #+16]
   \   0000006C   0x2020             MOVS     R0,#+32
   \   0000006E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000072   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   00000076   0x....             LDR.N    R0,??DataTable8_3
   \   00000078   0x6940             LDR      R0,[R0, #+20]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD00B             BEQ.N    ??Vector88_2
   \   0000007E   0x....             LDR.N    R0,??DataTable8_3
   \   00000080   0x6940             LDR      R0,[R0, #+20]
   \   00000082   0x0005             MOVS     R5,R0
   \   00000084   0x....             LDR.N    R0,??DataTable8_3
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6141             STR      R1,[R0, #+20]
   \   0000008A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000008E   0x62A8             STR      R0,[R5, #+40]
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x.... 0x....      BL       chSchReadyI
   \                     ??Vector88_2:
   \   00000096   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF380 0x8811      MSR      BASEPRI,R0
    130            }
    131            /* TODO: Add here analog watchdog handling.*/
    132          #endif /* STM32_ADC_USE_ADC1 */
    133          
    134          #if STM32_ADC_USE_ADC2
    135            sr = ADC2->SR;
   \                     ??Vector88_0:
   \   000000A0   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40012100
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x0004             MOVS     R4,R0
    136            ADC2->SR = 0;
   \   000000A6   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40012100
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x6001             STR      R1,[R0, #+0]
    137            /* Note, an overflow may occur after the conversion ended before the driver
    138               is able to stop the ADC, this is why the DMA channel is checked too.*/
    139            if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD2.dmastp) > 0)) {
   \   000000AC   0x06A0             LSLS     R0,R4,#+26
   \   000000AE   0xD53E             BPL.N    ??Vector88_3
   \   000000B0   0x....             LDR.N    R0,??DataTable8_5
   \   000000B2   0x6AC0             LDR      R0,[R0, #+44]
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x6840             LDR      R0,[R0, #+4]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD038             BEQ.N    ??Vector88_3
    140              /* ADC overflow condition, this could happen only if the DMA is unable
    141                 to read data fast enough.*/
    142              if (ADCD2.grpp != NULL)
   \   000000BC   0x....             LDR.N    R0,??DataTable8_5
   \   000000BE   0x6900             LDR      R0,[R0, #+16]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD034             BEQ.N    ??Vector88_3
    143                _adc_isr_error_code(&ADCD2, ADC_ERR_OVERFLOW);
   \   000000C4   0x....             LDR.N    R0,??DataTable8_5
   \   000000C6   0x.... 0x....      BL       adc_lld_stop_conversion
   \   000000CA   0x....             LDR.N    R0,??DataTable8_5
   \   000000CC   0x6900             LDR      R0,[R0, #+16]
   \   000000CE   0x6880             LDR      R0,[R0, #+8]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD00F             BEQ.N    ??Vector88_4
   \   000000D4   0x....             LDR.N    R0,??DataTable8_5
   \   000000D6   0x2105             MOVS     R1,#+5
   \   000000D8   0x7001             STRB     R1,[R0, #+0]
   \   000000DA   0x2101             MOVS     R1,#+1
   \   000000DC   0x....             LDR.N    R0,??DataTable8_5
   \   000000DE   0x....             LDR.N    R2,??DataTable8_5
   \   000000E0   0x6912             LDR      R2,[R2, #+16]
   \   000000E2   0x6892             LDR      R2,[R2, #+8]
   \   000000E4   0x4790             BLX      R2
   \   000000E6   0x....             LDR.N    R0,??DataTable8_5
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x2805             CMP      R0,#+5
   \   000000EC   0xD102             BNE.N    ??Vector88_4
   \   000000EE   0x....             LDR.N    R0,??DataTable8_5
   \   000000F0   0x2102             MOVS     R1,#+2
   \   000000F2   0x7001             STRB     R1,[R0, #+0]
   \                     ??Vector88_4:
   \   000000F4   0x....             LDR.N    R0,??DataTable8_5
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x6101             STR      R1,[R0, #+16]
   \   000000FA   0x2020             MOVS     R0,#+32
   \   000000FC   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000100   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   00000104   0x....             LDR.N    R0,??DataTable8_5
   \   00000106   0x6940             LDR      R0,[R0, #+20]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD00B             BEQ.N    ??Vector88_5
   \   0000010C   0x....             LDR.N    R0,??DataTable8_5
   \   0000010E   0x6940             LDR      R0,[R0, #+20]
   \   00000110   0x0005             MOVS     R5,R0
   \   00000112   0x....             LDR.N    R0,??DataTable8_5
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0x6141             STR      R1,[R0, #+20]
   \   00000118   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000011C   0x62A8             STR      R0,[R5, #+40]
   \   0000011E   0x0028             MOVS     R0,R5
   \   00000120   0x.... 0x....      BL       chSchReadyI
   \                     ??Vector88_5:
   \   00000124   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF380 0x8811      MSR      BASEPRI,R0
    144            }
    145            /* TODO: Add here analog watchdog handling.*/
    146          #endif /* STM32_ADC_USE_ADC2 */
    147          
    148          #if STM32_ADC_USE_ADC3
    149            sr = ADC3->SR;
    150            ADC3->SR = 0;
    151            /* Note, an overflow may occur after the conversion ended before the driver
    152               is able to stop the ADC, this is why the DMA channel is checked too.*/
    153            if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD3.dmastp) > 0)) {
    154              /* ADC overflow condition, this could happen only if the DMA is unable
    155                 to read data fast enough.*/
    156              if (ADCD3.grpp != NULL)
    157                _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
    158            }
    159            /* TODO: Add here analog watchdog handling.*/
    160          #endif /* STM32_ADC_USE_ADC3 */
    161          
    162            CH_IRQ_EPILOGUE();
   \                     ??Vector88_3:
   \   0000012E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000132   0x.... 0x....      BL       _port_irq_epilogue
    163          }
   \   00000136   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    164          #endif
    165          
    166          /*===========================================================================*/
    167          /* Driver exported functions.                                                */
    168          /*===========================================================================*/
    169          
    170          /**
    171           * @brief   Low level ADC driver initialization.
    172           *
    173           * @notapi
    174           */

   \                                 In section .text, align 2, keep-with-next
    175          void adc_lld_init(void) {
   \                     adc_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    176          
    177          #if STM32_ADC_USE_ADC1
    178            /* Driver initialization.*/
    179            adcObjectInit(&ADCD1);
   \   00000002   0x....             LDR.N    R0,??DataTable8_3
   \   00000004   0x.... 0x....      BL       adcObjectInit
    180            ADCD1.adc = ADC1;
   \   00000008   0x....             LDR.N    R0,??DataTable8_3
   \   0000000A   0x....             LDR.N    R1,??DataTable8_2  ;; 0x40012000
   \   0000000C   0x6281             STR      R1,[R0, #+40]
    181            ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
   \   0000000E   0x....             LDR.N    R0,??DataTable8_3
   \   00000010   0x....             LDR.N    R1,??DataTable8_6
   \   00000012   0x62C1             STR      R1,[R0, #+44]
    182            ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
    183                            STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
    184                            STM32_DMA_CR_DIR_P2M |
    185                            STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
    186                            STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
    187                            STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
   \   00000014   0x....             LDR.N    R0,??DataTable8_3
   \   00000016   0x....             LDR.N    R1,??DataTable8_7  ;; 0x22c16
   \   00000018   0x6301             STR      R1,[R0, #+48]
    188          #endif
    189          
    190          #if STM32_ADC_USE_ADC2
    191            /* Driver initialization.*/
    192            adcObjectInit(&ADCD2);
   \   0000001A   0x....             LDR.N    R0,??DataTable8_5
   \   0000001C   0x.... 0x....      BL       adcObjectInit
    193            ADCD2.adc = ADC2;
   \   00000020   0x....             LDR.N    R0,??DataTable8_5
   \   00000022   0x....             LDR.N    R1,??DataTable8_4  ;; 0x40012100
   \   00000024   0x6281             STR      R1,[R0, #+40]
    194            ADCD2.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC2_DMA_STREAM);
   \   00000026   0x....             LDR.N    R0,??DataTable8_5
   \   00000028   0x....             LDR.N    R1,??DataTable8_8
   \   0000002A   0x62C1             STR      R1,[R0, #+44]
    195            ADCD2.dmamode = STM32_DMA_CR_CHSEL(ADC2_DMA_CHANNEL) |
    196                            STM32_DMA_CR_PL(STM32_ADC_ADC2_DMA_PRIORITY) |
    197                            STM32_DMA_CR_DIR_P2M |
    198                            STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
    199                            STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
    200                            STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
   \   0000002C   0x....             LDR.N    R0,??DataTable8_5
   \   0000002E   0x....             LDR.N    R1,??DataTable8_9  ;; 0x2022c16
   \   00000030   0x6301             STR      R1,[R0, #+48]
    201          #endif
    202          
    203          #if STM32_ADC_USE_ADC3
    204            /* Driver initialization.*/
    205            adcObjectInit(&ADCD3);
    206            ADCD3.adc = ADC3;
    207            ADCD3.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC3_DMA_STREAM);
    208            ADCD3.dmamode = STM32_DMA_CR_CHSEL(ADC3_DMA_CHANNEL) |
    209                            STM32_DMA_CR_PL(STM32_ADC_ADC3_DMA_PRIORITY) |
    210                            STM32_DMA_CR_DIR_P2M |
    211                            STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
    212                            STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
    213                            STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
    214          #endif
    215          
    216            /* The shared vector is initialized on driver initialization and never
    217               disabled.*/
    218            nvicEnableVector(ADC_IRQn, CORTEX_PRIORITY_MASK(STM32_ADC_IRQ_PRIORITY));
   \   00000032   0x2160             MOVS     R1,#+96
   \   00000034   0x2012             MOVS     R0,#+18
   \   00000036   0x.... 0x....      BL       nvicEnableVector
    219          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    220          
    221          /**
    222           * @brief   Configures and activates the ADC peripheral.
    223           *
    224           * @param[in] adcp      pointer to the @p ADCDriver object
    225           *
    226           * @notapi
    227           */

   \                                 In section .text, align 2, keep-with-next
    228          void adc_lld_start(ADCDriver *adcp) {
   \                     adc_lld_start:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    229          
    230            /* If in stopped state then enables the ADC and DMA clocks.*/
    231            if (adcp->state == ADC_STOP) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD144             BNE.N    ??adc_lld_start_0
    232          #if STM32_ADC_USE_ADC1
    233              if (&ADCD1 == adcp) {
   \   0000000A   0x....             LDR.N    R0,??DataTable8_3
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD116             BNE.N    ??adc_lld_start_1
    234                bool_t b;
    235                b = dmaStreamAllocate(adcp->dmastp,
    236                                      STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
    237                                      (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
    238                                      (void *)adcp);
   \   00000010   0x0023             MOVS     R3,R4
   \   00000012   0x....             LDR.N    R2,??DataTable8_10
   \   00000014   0x2106             MOVS     R1,#+6
   \   00000016   0x6AE0             LDR      R0,[R4, #+44]
   \   00000018   0x.... 0x....      BL       dmaStreamAllocate
   \   0000001C   0x0005             MOVS     R5,R0
    239                chDbgAssert(!b, "adc_lld_start(), #1", "stream already allocated");
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD002             BEQ.N    ??adc_lld_start_2
   \   00000024   0x....             LDR.N    R0,??DataTable8_11
   \   00000026   0x.... 0x....      BL       chDbgPanic
    240                dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
   \                     ??adc_lld_start_2:
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable8_12  ;; 0x4001204c
   \   00000030   0x6081             STR      R1,[R0, #+8]
    241                rccEnableADC1(FALSE);
   \   00000032   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40023844
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000003A   0x....             LDR.N    R1,??DataTable8_13  ;; 0x40023844
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    242              }
    243          #endif /* STM32_ADC_USE_ADC1 */
    244          
    245          #if STM32_ADC_USE_ADC2
    246              if (&ADCD2 == adcp) {
   \                     ??adc_lld_start_1:
   \   0000003E   0x....             LDR.N    R0,??DataTable8_5
   \   00000040   0x42A0             CMP      R0,R4
   \   00000042   0xD116             BNE.N    ??adc_lld_start_3
    247                bool_t b;
    248                b = dmaStreamAllocate(adcp->dmastp,
    249                                      STM32_ADC_ADC2_DMA_IRQ_PRIORITY,
    250                                      (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
    251                                      (void *)adcp);
   \   00000044   0x0023             MOVS     R3,R4
   \   00000046   0x....             LDR.N    R2,??DataTable8_10
   \   00000048   0x2106             MOVS     R1,#+6
   \   0000004A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004C   0x.... 0x....      BL       dmaStreamAllocate
   \   00000050   0x0005             MOVS     R5,R0
    252                chDbgAssert(!b, "adc_lld_start(), #2", "stream already allocated");
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ.N    ??adc_lld_start_4
   \   00000058   0x....             LDR.N    R0,??DataTable8_14
   \   0000005A   0x.... 0x....      BL       chDbgPanic
    253                dmaStreamSetPeripheral(adcp->dmastp, &ADC2->DR);
   \                     ??adc_lld_start_4:
   \   0000005E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x....             LDR.N    R1,??DataTable8_15  ;; 0x4001214c
   \   00000064   0x6081             STR      R1,[R0, #+8]
    254                rccEnableADC2(FALSE);
   \   00000066   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40023844
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000006E   0x....             LDR.N    R1,??DataTable8_13  ;; 0x40023844
   \   00000070   0x6008             STR      R0,[R1, #+0]
    255              }
    256          #endif /* STM32_ADC_USE_ADC2 */
    257          
    258          #if STM32_ADC_USE_ADC3
    259              if (&ADCD3 == adcp) {
    260                bool_t b;
    261                b = dmaStreamAllocate(adcp->dmastp,
    262                                      STM32_ADC_ADC3_DMA_IRQ_PRIORITY,
    263                                      (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
    264                                      (void *)adcp);
    265                chDbgAssert(!b, "adc_lld_start(), #3", "stream already allocated");
    266                dmaStreamSetPeripheral(adcp->dmastp, &ADC3->DR);
    267                rccEnableADC3(FALSE);
    268              }
    269          #endif /* STM32_ADC_USE_ADC3 */
    270          
    271              /* This is a common register but apparently it requires that at least one
    272                 of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    273              ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
    274                         (STM32_ADC_ADCPRE << 16);
   \                     ??adc_lld_start_3:
   \   00000072   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40012304
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF410 0x0040      ANDS     R0,R0,#0xC00000
   \   0000007A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   0000007E   0x....             LDR.N    R1,??DataTable8_16  ;; 0x40012304
   \   00000080   0x6008             STR      R0,[R1, #+0]
    275          
    276              /* ADC initial setup, starting the analog part here in order to reduce
    277                 the latency when starting a conversion.*/
    278              adcp->adc->CR1 = 0;
   \   00000082   0x6AA0             LDR      R0,[R4, #+40]
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x6041             STR      R1,[R0, #+4]
    279              adcp->adc->CR2 = 0;
   \   00000088   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x6081             STR      R1,[R0, #+8]
    280              adcp->adc->CR2 = ADC_CR2_ADON;
   \   0000008E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000090   0x2101             MOVS     R1,#+1
   \   00000092   0x6081             STR      R1,[R0, #+8]
    281            }
    282          }
   \                     ??adc_lld_start_0:
   \   00000094   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    283          
    284          /**
    285           * @brief   Deactivates the ADC peripheral.
    286           *
    287           * @param[in] adcp      pointer to the @p ADCDriver object
    288           *
    289           * @notapi
    290           */

   \                                 In section .text, align 2, keep-with-next
    291          void adc_lld_stop(ADCDriver *adcp) {
   \                     adc_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    292          
    293            /* If in ready state then disables the ADC clock.*/
    294            if (adcp->state == ADC_READY) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD11A             BNE.N    ??adc_lld_stop_0
    295              dmaStreamRelease(adcp->dmastp);
   \   0000000A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000000C   0x.... 0x....      BL       dmaStreamRelease
    296              adcp->adc->CR1 = 0;
   \   00000010   0x6AA0             LDR      R0,[R4, #+40]
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6041             STR      R1,[R0, #+4]
    297              adcp->adc->CR2 = 0;
   \   00000016   0x6AA0             LDR      R0,[R4, #+40]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6081             STR      R1,[R0, #+8]
    298          
    299          #if STM32_ADC_USE_ADC1
    300              if (&ADCD1 == adcp)
   \   0000001C   0x....             LDR.N    R0,??DataTable8_3
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD105             BNE.N    ??adc_lld_stop_1
    301                rccDisableADC1(FALSE);
   \   00000022   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40023844
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000002A   0x....             LDR.N    R1,??DataTable8_13  ;; 0x40023844
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    302          #endif
    303          
    304          #if STM32_ADC_USE_ADC2
    305              if (&ADCD2 == adcp)
   \                     ??adc_lld_stop_1:
   \   0000002E   0x....             LDR.N    R0,??DataTable8_5
   \   00000030   0x42A0             CMP      R0,R4
   \   00000032   0xD105             BNE.N    ??adc_lld_stop_0
    306                rccDisableADC2(FALSE);
   \   00000034   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40023844
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000003C   0x....             LDR.N    R1,??DataTable8_13  ;; 0x40023844
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    307          #endif
    308          
    309          #if STM32_ADC_USE_ADC3
    310              if (&ADCD3 == adcp)
    311                rccDisableADC3(FALSE);
    312          #endif
    313            }
    314          }
   \                     ??adc_lld_stop_0:
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    315          
    316          /**
    317           * @brief   Starts an ADC conversion.
    318           *
    319           * @param[in] adcp      pointer to the @p ADCDriver object
    320           *
    321           * @notapi
    322           */

   \                                 In section .text, align 2, keep-with-next
    323          void adc_lld_start_conversion(ADCDriver *adcp) {
   \                     adc_lld_start_conversion:
   \   00000000   0xB430             PUSH     {R4,R5}
    324            uint32_t mode;
    325            uint32_t cr2;
    326            const ADCConversionGroup *grpp = adcp->grpp;
   \   00000002   0x6902             LDR      R2,[R0, #+16]
    327          
    328            /* DMA setup.*/
    329            mode = adcp->dmamode;
   \   00000004   0x6B04             LDR      R4,[R0, #+48]
   \   00000006   0x0023             MOVS     R3,R4
    330            if (grpp->circular) {
   \   00000008   0x7814             LDRB     R4,[R2, #+0]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??adc_lld_start_conversion_0
    331              mode |= STM32_DMA_CR_CIRC;
   \   0000000E   0xF453 0x7380      ORRS     R3,R3,#0x100
    332              if (adcp->depth > 1) {
   \   00000012   0x68C4             LDR      R4,[R0, #+12]
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xD301             BCC.N    ??adc_lld_start_conversion_0
    333                /* If circular buffer depth > 1, then the half transfer interrupt
    334                   is enabled in order to allow streaming processing.*/
    335                mode |= STM32_DMA_CR_HTIE;
   \   00000018   0xF053 0x0308      ORRS     R3,R3,#0x8
    336              }
    337            }
    338            dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
   \                     ??adc_lld_start_conversion_0:
   \   0000001C   0x6AC4             LDR      R4,[R0, #+44]
   \   0000001E   0x6824             LDR      R4,[R4, #+0]
   \   00000020   0x6885             LDR      R5,[R0, #+8]
   \   00000022   0x60E5             STR      R5,[R4, #+12]
    339            dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
    340                                                      (uint32_t)adcp->depth);
   \   00000024   0x8854             LDRH     R4,[R2, #+2]
   \   00000026   0x68C5             LDR      R5,[R0, #+12]
   \   00000028   0x436C             MULS     R4,R5,R4
   \   0000002A   0x6AC5             LDR      R5,[R0, #+44]
   \   0000002C   0x682D             LDR      R5,[R5, #+0]
   \   0000002E   0x606C             STR      R4,[R5, #+4]
    341            dmaStreamSetMode(adcp->dmastp, mode);
   \   00000030   0x6AC4             LDR      R4,[R0, #+44]
   \   00000032   0x6824             LDR      R4,[R4, #+0]
   \   00000034   0x6023             STR      R3,[R4, #+0]
    342            dmaStreamEnable(adcp->dmastp);
   \   00000036   0x6AC4             LDR      R4,[R0, #+44]
   \   00000038   0x6824             LDR      R4,[R4, #+0]
   \   0000003A   0x6824             LDR      R4,[R4, #+0]
   \   0000003C   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   00000040   0x6AC5             LDR      R5,[R0, #+44]
   \   00000042   0x682D             LDR      R5,[R5, #+0]
   \   00000044   0x602C             STR      R4,[R5, #+0]
    343          
    344            /* ADC setup.*/
    345            adcp->adc->SR    = 0;
   \   00000046   0x6A84             LDR      R4,[R0, #+40]
   \   00000048   0x2500             MOVS     R5,#+0
   \   0000004A   0x6025             STR      R5,[R4, #+0]
    346            adcp->adc->SMPR1 = grpp->smpr1;
   \   0000004C   0x6A84             LDR      R4,[R0, #+40]
   \   0000004E   0x6955             LDR      R5,[R2, #+20]
   \   00000050   0x60E5             STR      R5,[R4, #+12]
    347            adcp->adc->SMPR2 = grpp->smpr2;
   \   00000052   0x6A84             LDR      R4,[R0, #+40]
   \   00000054   0x6995             LDR      R5,[R2, #+24]
   \   00000056   0x6125             STR      R5,[R4, #+16]
    348            adcp->adc->SQR1  = grpp->sqr1;
   \   00000058   0x6A84             LDR      R4,[R0, #+40]
   \   0000005A   0x69D5             LDR      R5,[R2, #+28]
   \   0000005C   0x62E5             STR      R5,[R4, #+44]
    349            adcp->adc->SQR2  = grpp->sqr2;
   \   0000005E   0x6A84             LDR      R4,[R0, #+40]
   \   00000060   0x6A15             LDR      R5,[R2, #+32]
   \   00000062   0x6325             STR      R5,[R4, #+48]
    350            adcp->adc->SQR3  = grpp->sqr3;
   \   00000064   0x6A84             LDR      R4,[R0, #+40]
   \   00000066   0x6A55             LDR      R5,[R2, #+36]
   \   00000068   0x6365             STR      R5,[R4, #+52]
    351          
    352            /* ADC configuration and start.*/
    353            adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
   \   0000006A   0x6A84             LDR      R4,[R0, #+40]
   \   0000006C   0x68D5             LDR      R5,[R2, #+12]
   \   0000006E   0xF045 0x6580      ORR      R5,R5,#0x4000000
   \   00000072   0xF455 0x7580      ORRS     R5,R5,#0x100
   \   00000076   0x6065             STR      R5,[R4, #+4]
    354          
    355            /* Enforcing the mandatory bits in CR2.*/
    356            cr2 = grpp->cr2 | ADC_CR2_DMA | ADC_CR2_DDS | ADC_CR2_ADON;
   \   00000078   0x6914             LDR      R4,[R2, #+16]
   \   0000007A   0xF240 0x3501      MOVW     R5,#+769
   \   0000007E   0x432C             ORRS     R4,R5,R4
   \   00000080   0x0021             MOVS     R1,R4
    357          
    358            /* The start method is different dependign if HW or SW triggered, the
    359               start is performed using the method specified in the CR2 configuration.*/
    360            if ((cr2 & ADC_CR2_SWSTART) != 0) {
   \   00000082   0x004C             LSLS     R4,R1,#+1
   \   00000084   0xD50A             BPL.N    ??adc_lld_start_conversion_1
    361              /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    362              adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
   \   00000086   0x6A84             LDR      R4,[R0, #+40]
   \   00000088   0xF031 0x4580      BICS     R5,R1,#0x40000000
   \   0000008C   0xF055 0x0502      ORRS     R5,R5,#0x2
   \   00000090   0x60A5             STR      R5,[R4, #+8]
    363          
    364              /* Finally enabling ADC_CR2_SWSTART.*/
    365              adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
   \   00000092   0x6A84             LDR      R4,[R0, #+40]
   \   00000094   0xF051 0x0502      ORRS     R5,R1,#0x2
   \   00000098   0x60A5             STR      R5,[R4, #+8]
   \   0000009A   0xE001             B.N      ??adc_lld_start_conversion_2
    366            }
    367            else
    368              adcp->adc->CR2 = cr2;
   \                     ??adc_lld_start_conversion_1:
   \   0000009C   0x6A84             LDR      R4,[R0, #+40]
   \   0000009E   0x60A1             STR      R1,[R4, #+8]
    369          }
   \                     ??adc_lld_start_conversion_2:
   \   000000A0   0xBC30             POP      {R4,R5}
   \   000000A2   0x4770             BX       LR               ;; return
    370          
    371          /**
    372           * @brief   Stops an ongoing conversion.
    373           *
    374           * @param[in] adcp      pointer to the @p ADCDriver object
    375           *
    376           * @notapi
    377           */

   \                                 In section .text, align 2, keep-with-next
    378          void adc_lld_stop_conversion(ADCDriver *adcp) {
    379          
    380            dmaStreamDisable(adcp->dmastp);
   \                     adc_lld_stop_conversion:
   \   00000000   0x6AC1             LDR      R1,[R0, #+44]
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0949             LSRS     R1,R1,#+5
   \   00000008   0x0149             LSLS     R1,R1,#+5
   \   0000000A   0x6AC2             LDR      R2,[R0, #+44]
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x6011             STR      R1,[R2, #+0]
   \                     ??adc_lld_stop_conversion_0:
   \   00000010   0x6AC1             LDR      R1,[R0, #+44]
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x07C9             LSLS     R1,R1,#+31
   \   00000018   0xD4FA             BMI.N    ??adc_lld_stop_conversion_0
   \   0000001A   0x213D             MOVS     R1,#+61
   \   0000001C   0x6AC2             LDR      R2,[R0, #+44]
   \   0000001E   0xF992 0x2008      LDRSB    R2,[R2, #+8]
   \   00000022   0x4091             LSLS     R1,R1,R2
   \   00000024   0x6AC2             LDR      R2,[R0, #+44]
   \   00000026   0x6852             LDR      R2,[R2, #+4]
   \   00000028   0x6011             STR      R1,[R2, #+0]
    381            adcp->adc->CR1 = 0;
   \   0000002A   0x6A81             LDR      R1,[R0, #+40]
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x604A             STR      R2,[R1, #+4]
    382            adcp->adc->CR2 = 0;
   \   00000030   0x6A81             LDR      R1,[R0, #+40]
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x608A             STR      R2,[R1, #+8]
    383            adcp->adc->CR2 = ADC_CR2_ADON;
   \   00000036   0x6A81             LDR      R1,[R0, #+40]
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x608A             STR      R2,[R1, #+8]
    384          }
   \   0000003C   0x4770             BX       LR               ;; return
    385          
    386          /**
    387           * @brief   Enables the TSVREFE bit.
    388           * @details The TSVREFE bit is required in order to sample the internal
    389           *          temperature sensor and internal reference voltage.
    390           * @note    This is an STM32-only functionality.
    391           */

   \                                 In section .text, align 2, keep-with-next
    392          void adcSTM32EnableTSVREFE(void) {
    393          
    394            ADC->CCR |= ADC_CCR_TSVREFE;
   \                     adcSTM32EnableTSVREFE:
   \   00000000   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40012304
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000008   0x....             LDR.N    R1,??DataTable8_16  ;; 0x40012304
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    395          }
   \   0000000C   0x4770             BX       LR               ;; return
    396          
    397          /**
    398           * @brief   Disables the TSVREFE bit.
    399           * @details The TSVREFE bit is required in order to sample the internal
    400           *          temperature sensor and internal reference voltage.
    401           * @note    This is an STM32-only functionality.
    402           */

   \                                 In section .text, align 2, keep-with-next
    403          void adcSTM32DisableTSVREFE(void) {
    404          
    405            ADC->CCR &= ~ADC_CCR_TSVREFE;
   \                     adcSTM32DisableTSVREFE:
   \   00000000   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40012304
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   00000008   0x....             LDR.N    R1,??DataTable8_16  ;; 0x40012304
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    406          }
   \   0000000C   0x4770             BX       LR               ;; return
    407          
    408          /**
    409           * @brief   Enables the VBATE bit.
    410           * @details The VBATE bit is required in order to sample the VBAT channel.
    411           * @note    This is an STM32-only functionality.
    412           * @note    This function is meant to be called after @p adcStart().
    413           */

   \                                 In section .text, align 2, keep-with-next
    414          void adcSTM32EnableVBATE(void) {
    415          
    416            ADC->CCR |= ADC_CCR_VBATE;
   \                     adcSTM32EnableVBATE:
   \   00000000   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40012304
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000008   0x....             LDR.N    R1,??DataTable8_16  ;; 0x40012304
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    417          }
   \   0000000C   0x4770             BX       LR               ;; return
    418          
    419          /**
    420           * @brief   Disables the VBATE bit.
    421           * @details The VBATE bit is required in order to sample the VBAT channel.
    422           * @note    This is an STM32-only functionality.
    423           * @note    This function is meant to be called after @p adcStart().
    424           */

   \                                 In section .text, align 2, keep-with-next
    425          void adcSTM32DisableVBATE(void) {
    426          
    427            ADC->CCR &= ~ADC_CCR_VBATE;
   \                     adcSTM32DisableVBATE:
   \   00000000   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40012304
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   00000008   0x....             LDR.N    R1,??DataTable8_16  ;; 0x40012304
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    428          }
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     `?<Constant "sys_adc">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     ADCD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40012100         DC32     0x40012100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     ADCD2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x90

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x00022C16         DC32     0x22c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x02022C16         DC32     0x2022c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     adc_lld_serve_rx_interrupt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     `?<Constant "adc_lld_start(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x4001204C         DC32     0x4001204c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     `?<Constant "adc_lld_start(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x4001214C         DC32     0x4001214c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .rodata, align 4
   \                     `?<Constant "sys_adc">`:
   \   00000000   0x73 0x79          DC8 "sys_adc"
   \              0x73 0x5F    
   \              0x61 0x64    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "adc_lld_start(), #1">`:
   \   00000000   0x61 0x64          DC8 "adc_lld_start(), #1"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "adc_lld_start(), #2">`:
   \   00000000   0x61 0x64          DC8 "adc_lld_start(), #2"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x32 0x00    
    429          
    430          #endif /* HAL_USE_ADC */
    431          
    432          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Vector88
        16   -- Indirect call
        16   -> _port_irq_epilogue
        16   -> adc_lld_stop_conversion
        16   -> chSchReadyI
        16   -> dbg_check_enter_isr
        16   -> dbg_check_leave_isr
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
       0   adcSTM32DisableTSVREFE
       0   adcSTM32DisableVBATE
       0   adcSTM32EnableTSVREFE
       0   adcSTM32EnableVBATE
       8   adc_lld_init
         8   -> adcObjectInit
         8   -> nvicEnableVector
      24   adc_lld_serve_rx_interrupt
        24   -- Indirect call
        24   -> adc_lld_stop_conversion
        24   -> chSchReadyI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> firmwareError
        24   -> getRemainingStack
      16   adc_lld_start
        16   -> chDbgPanic
        16   -> dmaStreamAllocate
       8   adc_lld_start_conversion
       8   adc_lld_stop
         8   -> dmaStreamRelease
       0   adc_lld_stop_conversion


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "adc_lld_start(), #1">
      20  ?<Constant "adc_lld_start(), #2">
       8  ?<Constant "sys_adc">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      52  ADCD1
      52  ADCD2
     312  Vector88
      14  adcSTM32DisableTSVREFE
      14  adcSTM32DisableVBATE
      14  adcSTM32EnableTSVREFE
      14  adcSTM32EnableVBATE
      60  adc_lld_init
     334  adc_lld_serve_rx_interrupt
     150  adc_lld_start
     164  adc_lld_start_conversion
      66  adc_lld_stop
      62  adc_lld_stop_conversion

 
   104 bytes in section .bss
    48 bytes in section .rodata
 1 272 bytes in section .text
 
 1 272 bytes of CODE  memory
    48 bytes of CONST memory
   104 bytes of DATA  memory

Errors: none
Warnings: none
