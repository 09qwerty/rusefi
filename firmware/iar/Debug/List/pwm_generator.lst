###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:58 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\pwm_gen #
#                       erator.cpp                                            #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\pwm_gen #
#                       erator.cpp -lCN F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmw #
#                       are\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\Obj\ --no_cse --no_unroll            #
#                       --no_inline --no_code_motion --no_tbaa                #
#                       --no_clustering --no_scheduling --debug               #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\p #
#                       wm_generator.lst                                      #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\pw #
#                       m_generator.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\hw_layer\pwm_generator.cpp
      1          /**
      2           * @file    pwm_generator.cpp
      3           * @brief   software PWM generator
      4           *
      5           * Software PWM implementation. Considering how low all frequencies are, we can totally afford a couple of float multiplications.
      6           * By generating PWM programmatically we are saving the timers for better purposes. This implementation also supports generating
      7           * synchronized waves as needed for example to emulate dual Hall-effect crankshaft position sensors.
      8           *
      9           *
     10           * @date May 28, 2013
     11           * @author Andrey Belomutskiy, (c) 2012-2015
     12           *
     13           */
     14          
     15          #include "pwm_generator.h"
     16          
     17          #include "pin_repository.h"
     18          #include "datalogging.h"
     19          
     20          /**
     21           * This method controls the actual hardware pins
     22           *
     23           * This method takes ~350 ticks.
     24           */

   \                                 In section .text, align 2, keep-with-next
     25          void applyPinState(PwmConfig *state, int stateIndex) {
   \                     _Z13applyPinStateP9PwmConfigi:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     26          	efiAssertVoid(stateIndex < PWM_PHASE_MAX_COUNT, "invalid stateIndex");
   \   00000008   0x2DFC             CMP      R5,#+252
   \   0000000A   0xDB03             BLT.N    ??applyPinState_0
   \   0000000C   0x....             LDR.N    R0,??DataTable1_2
   \   0000000E   0x.... 0x....      BL       firmwareError
   \   00000012   0xE017             B.N      ??applyPinState_1
     27          	efiAssertVoid(state->multiWave.waveCount <= PWM_PHASE_MAX_WAVE_PER_PWM, "invalid waveCount");
   \                     ??applyPinState_0:
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x2804             CMP      R0,#+4
   \   00000018   0xDB03             BLT.N    ??applyPinState_2
   \   0000001A   0x....             LDR.N    R0,??DataTable1_3
   \   0000001C   0x.... 0x....      BL       firmwareError
   \   00000020   0xE010             B.N      ??applyPinState_1
     28          	for (int waveIndex = 0; waveIndex < state->multiWave.waveCount; waveIndex++) {
   \                     ??applyPinState_2:
   \   00000022   0x2600             MOVS     R6,#+0
   \                     ??applyPinState_3:
   \   00000024   0x68E0             LDR      R0,[R4, #+12]
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xDA0C             BGE.N    ??applyPinState_4
     29          		OutputPin *output = state->outputPins[waveIndex];
   \   0000002A   0xF854 0x7026      LDR      R7,[R4, R6, LSL #+2]
     30          		int value = state->multiWave.waves[waveIndex].pinStates[stateIndex];
   \   0000002E   0x6920             LDR      R0,[R4, #+16]
   \   00000030   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000034   0xF915 0x8000      LDRSB    R8,[R5, R0]
     31          		output->setValue(value);
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       _ZN9OutputPin8setValueEi
     32          	}
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \   00000042   0xE7EF             B.N      ??applyPinState_3
     33          }
   \                     ??applyPinState_4:
   \                     ??applyPinState_1:
   \   00000044   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     34          

   \                                 In section .text, align 4, keep-with-next
     35          void startSimplePwm(PwmConfig *state, const char *msg, OutputPin *output, float frequency, float dutyCycle, pwm_gen_callback *stateChangeCallback) {
   \                     _Z14startSimplePwmP9PwmConfigPKcP9OutputPinffPFvS0_iE:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB088             SUB      SP,SP,#+32
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000F             MOVS     R7,R1
   \   0000000E   0x0015             MOVS     R5,R2
   \   00000010   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000014   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000018   0x001E             MOVS     R6,R3
     36          	efiAssertVoid(dutyCycle >= 0 && dutyCycle <= 1, "dutyCycle");
   \   0000001A   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   0000001E   0xEEF1 0xFA10      FMSTAT   
   \   00000022   0xDB06             BLT.N    ??startSimplePwm_0
   \   00000024   0xED9F 0x....      VLDR.W   S0,??DataTable1  ;; 0x3f800001
   \   00000028   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   0000002C   0xEEF1 0xFA10      FMSTAT   
   \   00000030   0xD403             BMI.N    ??startSimplePwm_1
   \                     ??startSimplePwm_0:
   \   00000032   0x....             LDR.N    R0,??DataTable1_4
   \   00000034   0x.... 0x....      BL       firmwareError
   \   00000038   0xE030             B.N      ??startSimplePwm_2
     37          
     38          	float switchTimes[] = { dutyCycle, 1 };
   \                     ??startSimplePwm_1:
   \   0000003A   0xA806             ADD      R0,SP,#+24
   \   0000003C   0x....             LDR.N    R1,??DataTable1_5
   \   0000003E   0xC90C             LDM      R1!,{R2,R3}
   \   00000040   0xC00C             STM      R0!,{R2,R3}
   \   00000042   0x3908             SUBS     R1,R1,#+8
   \   00000044   0x3808             SUBS     R0,R0,#+8
   \   00000046   0xEDCD 0x8A06      VSTR     S17,[SP, #+24]
     39          	pin_state_t pinStates0[] = { 0, 1 };
   \   0000004A   0x....             LDR.N    R0,??DataTable1_6
   \   0000004C   0x8800             LDRH     R0,[R0, #+0]
   \   0000004E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
     40          
     41          	pin_state_t *pinStates[1] = { pinStates0 };
   \   00000052   0xA804             ADD      R0,SP,#+16
   \   00000054   0x9005             STR      R0,[SP, #+20]
     42          
     43          	state->outputPins[0] = output;
   \   00000056   0x6025             STR      R5,[R4, #+0]
     44          
     45          	state->periodNt = US2NT(frequency2periodUs(frequency));
   \   00000058   0xED9F 0x....      VLDR.W   S0,??DataTable1_1  ;; 0x49742400
   \   0000005C   0xEE80 0x0A08      VDIV.F32 S0,S0,S16
   \   00000060   0xEE10 0x0A10      VMOV     R0,S0
   \   00000064   0x.... 0x....      BL       __aeabi_f2lz
   \   00000068   0x22A8             MOVS     R2,#+168
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x4680             MOV      R8,R0
   \   0000006E   0x4689             MOV      R9,R1
   \   00000070   0xFBA2 0x0108      UMULL    R0,R1,R2,R8
   \   00000074   0xFB02 0x1109      MLA      R1,R2,R9,R1
   \   00000078   0xFB03 0x1108      MLA      R1,R3,R8,R1
   \   0000007C   0x.... 0x....      BL       __aeabi_l2f
   \   00000080   0x61A0             STR      R0,[R4, #+24]
     46          	state->weComplexInit(msg, 2, switchTimes, 1, pinStates, NULL, stateChangeCallback);
   \   00000082   0x9603             STR      R6,[SP, #+12]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9002             STR      R0,[SP, #+8]
   \   00000088   0xA805             ADD      R0,SP,#+20
   \   0000008A   0x9001             STR      R0,[SP, #+4]
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0xAB06             ADD      R3,SP,#+24
   \   00000092   0x2202             MOVS     R2,#+2
   \   00000094   0x0039             MOVS     R1,R7
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       _ZN9PwmConfig13weComplexInitEPKciPfiPPaPFvPS_EPFvS5_iE
     47          }
   \                     ??startSimplePwm_2:
   \   0000009C   0xB008             ADD      SP,SP,#+32
   \   0000009E   0xECBD 0x8B02      VPOP     {D8}
   \   000000A2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
     48          

   \                                 In section .text, align 2, keep-with-next
     49          void startSimplePwmExt(PwmConfig *state, const char *msg, brain_pin_e brainPin, OutputPin *output, float frequency,
     50          		float dutyCycle, pwm_gen_callback *stateChangeCallback) {
   \                     _Z17startSimplePwmExtP9PwmConfigPKc11brain_pin_eP9OutputPinffPFvS0_iE:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
   \   0000000C   0x0016             MOVS     R6,R2
   \   0000000E   0x001F             MOVS     R7,R3
   \   00000010   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000014   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000018   0xF8DD 0x8028      LDR      R8,[SP, #+40]
     51          
     52          	GPIO_TypeDef * port = getHwPort(brainPin);
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       _Z9getHwPort11brain_pin_e
   \   00000022   0x4681             MOV      R9,R0
     53          	int pin = getHwPin(brainPin);
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       _Z8getHwPin11brain_pin_e
   \   0000002A   0x4682             MOV      R10,R0
     54          	outputPinRegister(msg, output, port, pin);
   \   0000002C   0x4653             MOV      R3,R10
   \   0000002E   0x464A             MOV      R2,R9
   \   00000030   0x0039             MOVS     R1,R7
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       _Z17outputPinRegisterPKcP9OutputPinP12GPIO_TypeDefj
     55          
     56          	startSimplePwm(state, msg, output, frequency, dutyCycle, stateChangeCallback);
   \   00000038   0x4643             MOV      R3,R8
   \   0000003A   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   0000003E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000042   0x003A             MOVS     R2,R7
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       _Z14startSimplePwmP9PwmConfigPKcP9OutputPinffPFvS0_iE
     57          }
   \   0000004C   0xECBD 0x8B02      VPOP     {D8}
   \   00000050   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void initPwmGenerator(void) {
     60          }
   \                     _Z16initPwmGeneratorv:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x3F800001         DC32     0x3f800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x49742400         DC32     0x49742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     `?<Constant "invalid stateIndex">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     `?<Constant "invalid waveCount">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     `?<Constant "dutyCycle">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x........         DC32     `?<Constant {(0.0F), (1.0F)}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x........         DC32     `?<Constant {(int8_t)'\\000', (int8_t)'\\001'}>`

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid stateIndex">`:
   \   00000000   0x69 0x6E          DC8 "invalid stateIndex"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x65 0x49    
   \              0x6E 0x64    
   \              0x65 0x78    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid waveCount">`:
   \   00000000   0x69 0x6E          DC8 "invalid waveCount"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x77 0x61    
   \              0x76 0x65    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "dutyCycle">`:
   \   00000000   0x64 0x75          DC8 "dutyCycle"
   \              0x74 0x79    
   \              0x43 0x79    
   \              0x63 0x6C    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant {(0.0F), (1.0F)}>`:
   \   00000000   0x00000000         DC32 0H, 3F800000H
   \              0x3F800000   

   \                                 In section .rodata, align 2
   \                     `?<Constant {(int8_t)'\\000', (int8_t)'\\001'}>`:
   \   00000000   0x00 0x01          DC8 0, 1
     61          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   applyPinState(PwmConfig *, int)
        24   -> OutputPin::setValue(int)
        24   -> firmwareError
       0   initPwmGenerator()
      72   startSimplePwm(PwmConfig *, char const *, OutputPin *, float, float, pwm_gen_callback *)
        72   -> PwmConfig::weComplexInit(char const *, int, float *, int, signed char **, pwm_cycle_callback *, pwm_gen_callback *)
        72   -> __aeabi_f2lz
        72   -> __aeabi_l2f
        72   -> firmwareError
      40   startSimplePwmExt(PwmConfig *, char const *, brain_pin_e, OutputPin *, float, float, pwm_gen_callback *)
        40   -> getHwPin(brain_pin_e)
        40   -> getHwPort(brain_pin_e)
        40   -> outputPinRegister(char const *, OutputPin *, GPIO_TypeDef *, uint32_t)
        40   -> startSimplePwm(PwmConfig *, char const *, OutputPin *, float, float, pwm_gen_callback *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "dutyCycle">
      20  ?<Constant "invalid stateIndex">
      20  ?<Constant "invalid waveCount">
       8  ?<Constant {(0.0F), (1.0F)}>
       2  ?<Constant {(int8_t)'\000', (int8_t)'\001'}>
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
      72  applyPinState(PwmConfig *, int)
       2  initPwmGenerator()
     166  startSimplePwm(PwmConfig *, char const *, OutputPin *, float, float, pwm_gen_callback *)
      84  startSimplePwmExt(PwmConfig *, char const *, brain_pin_e, OutputPin *, float, float, pwm_gen_callback *)

 
  62 bytes in section .rodata
 352 bytes in section .text
 
 352 bytes of CODE  memory
  62 bytes of CONST memory

Errors: none
Warnings: 1
