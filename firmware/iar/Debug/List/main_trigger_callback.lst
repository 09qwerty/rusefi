###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:32 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\trig #
#                       ger\main_trigger_callback.cpp                         #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\trig #
#                       ger\main_trigger_callback.cpp -lCN                    #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\m #
#                       ain_trigger_callback.lst                              #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ma #
#                       in_trigger_callback.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\trigger\main_trigger_callback.cpp
      1          /**
      2           * @file    main_trigger_callback.cpp
      3           * @brief   Main logic is here!
      4           *
      5           * See http://rusefi.com/docs/html/
      6           *
      7           * @date Feb 7, 2013
      8           * @author Andrey Belomutskiy, (c) 2012-2015
      9           *
     10           * This file is part of rusEfi - see http://rusefi.com
     11           *
     12           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     13           * the GNU General Public License as published by the Free Software Foundation; either
     14           * version 3 of the License, or (at your option) any later version.
     15           *
     16           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     17           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     18           * GNU General Public License for more details.
     19           *
     20           * You should have received a copy of the GNU General Public License along with this program.
     21           * If not, see <http://www.gnu.org/licenses/>.
     22           */
     23          
     24          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     25          #if EFI_PROD_CODE
     26          #include <nvic.h>
     27          #endif
     28          
     29          #if !EFI_PROD_CODE && !EFI_SIMULATOR
     30          
     31          #define chThdSelf() 0
     32          #define getRemainingStack(x) (999999)
     33          
     34          #endif
     35          
     36          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
     37          
     38          #include "main_trigger_callback.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp cyclic_buffer<int>::cyclic_buffer()
   \                     _ZN13cyclic_bufferIiEC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x2140             MOVS     R1,#+64
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       _ZN13cyclic_bufferIiE5baseCEi
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void cyclic_buffer<int>::baseC(int)
   \                     _ZN13cyclic_bufferIiE5baseCEi:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8C4 0x0100      STR      R0,[R4, #+256]
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZN13cyclic_bufferIiE7setSizeEi
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp cyclic_buffer<int>::~cyclic_buffer()
   \                     _ZN13cyclic_bufferIiED1Ev:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void cyclic_buffer<int>::add(int)
   \                     _ZN13cyclic_bufferIiE3addEi:
   \   00000000   0xF8D0 0x2100      LDR      R2,[R0, #+256]
   \   00000004   0x1C52             ADDS     R2,R2,#+1
   \   00000006   0xF8C0 0x2100      STR      R2,[R0, #+256]
   \   0000000A   0xF8D0 0x2100      LDR      R2,[R0, #+256]
   \   0000000E   0xF8D0 0x3108      LDR      R3,[R0, #+264]
   \   00000012   0x429A             CMP      R2,R3
   \   00000014   0xD102             BNE.N    ??add_0
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xF8C0 0x2100      STR      R2,[R0, #+256]
   \                     ??add_0:
   \   0000001C   0xF8D0 0x2100      LDR      R2,[R0, #+256]
   \   00000020   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
   \   00000024   0xF8D0 0x2104      LDR      R2,[R0, #+260]
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   \   0000002A   0xF8C0 0x2104      STR      R2,[R0, #+260]
   \   0000002E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void cyclic_buffer<int>::setSize(int)
   \                     _ZN13cyclic_bufferIiE7setSizeEi:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       _ZN13cyclic_bufferIiE5clearEv
   \   0000000C   0x2D40             CMP      R5,#+64
   \   0000000E   0xDA01             BGE.N    ??setSize_0
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0xE000             B.N      ??setSize_1
   \                     ??setSize_0:
   \   00000014   0x2040             MOVS     R0,#+64
   \                     ??setSize_1:
   \   00000016   0xF8C4 0x0108      STR      R0,[R4, #+264]
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int cyclic_buffer<int>::sum(int)
   \                     _ZN13cyclic_bufferIiE3sumEi:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
   \   00000004   0xF8D2 0x0104      LDR      R0,[R2, #+260]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xDA02             BGE.N    ??sum_0
   \   0000000C   0xF8D2 0x0104      LDR      R0,[R2, #+260]
   \   00000010   0x0001             MOVS     R1,R0
   \                     ??sum_0:
   \   00000012   0xF8D2 0x3100      LDR      R3,[R2, #+256]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x2400             MOVS     R4,#+0
   \                     ??sum_1:
   \   0000001A   0x428C             CMP      R4,R1
   \   0000001C   0xDA0B             BGE.N    ??sum_2
   \   0000001E   0x1B1D             SUBS     R5,R3,R4
   \                     ??sum_3:
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD503             BPL.N    ??sum_4
   \   00000024   0xF8D2 0x6108      LDR      R6,[R2, #+264]
   \   00000028   0x1975             ADDS     R5,R6,R5
   \   0000002A   0xE7F9             B.N      ??sum_3
   \                     ??sum_4:
   \   0000002C   0xF852 0x5025      LDR      R5,[R2, R5, LSL #+2]
   \   00000030   0x1828             ADDS     R0,R5,R0
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \   00000034   0xE7F1             B.N      ??sum_1
   \                     ??sum_2:
   \   00000036   0xBC70             POP      {R4-R6}
   \   00000038   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void cyclic_buffer<int>::clear()
   \                     _ZN13cyclic_bufferIiE5clearEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xF44F 0x7280      MOV      R2,#+256
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       memset
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8C4 0x0104      STR      R0,[R4, #+260]
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8C4 0x0104      STR      R0,[R4, #+260]
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     39          #include "efiGpio.h"
     40          #include "engine_math.h"
     41          #include "trigger_central.h"
     42          #include "rpm_calculator.h"
     43          #include "signal_executor.h"
     44          #include "engine_configuration.h"
     45          #include "interpolation.h"
     46          #include "advance_map.h"
     47          #include "allsensors.h"
     48          #include "cyclic_buffer.h"
     49          #include "histogram.h"
     50          #include "fuel_math.h"
     51          #include "histogram.h"
     52          #if EFI_PROD_CODE
     53          #include "rfiutil.h"
     54          #endif /* EFI_HISTOGRAMS */
     55          #include "LocalVersionHolder.h"
     56          #include "event_queue.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool assertNotInList<IgnitionEvent>(IgnitionEvent *, IgnitionEvent *)
   \                     _Z15assertNotInListI13IgnitionEventEbPT_S2_:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x0026             MOVS     R6,R4
   \                     ??assertNotInList_0:
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD013             BEQ.N    ??assertNotInList_1
   \   0000000E   0x1C7F             ADDS     R7,R7,#+1
   \   00000010   0xF5B7 0x7F7A      CMP      R7,#+1000
   \   00000014   0xDD04             BLE.N    ??assertNotInList_2
   \   00000016   0x4809             LDR.N    R0,??assertNotInList_3
   \   00000018   0x.... 0x....      BL       firmwareError
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00B             B.N      ??assertNotInList_4
   \                     ??assertNotInList_2:
   \   00000020   0x42AE             CMP      R6,R5
   \   00000022   0xD106             BNE.N    ??assertNotInList_5
   \   00000024   0x4906             LDR.N    R1,??assertNotInList_3+0x4
   \   00000026   0xF240 0x205E      MOVW     R0,#+606
   \   0000002A   0x.... 0x....      BL       warning
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE002             B.N      ??assertNotInList_4
   \                     ??assertNotInList_5:
   \   00000032   0x6D76             LDR      R6,[R6, #+84]
   \   00000034   0xE7E9             B.N      ??assertNotInList_0
   \                     ??assertNotInList_1:
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??assertNotInList_4:
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??assertNotInList_3:
   \   0000003C   0x........         DC32     _ZZ15assertNotInListI13IgnitionEventEbPT_S2_Es
   \   00000040   0x........         DC32     _ZZ15assertNotInListI13IgnitionEventEbPT_S2_Es_0
     57          #include "engine.h"
     58          #include "efilib2.h"
     59          
     60          EXTERN_ENGINE
     61          ;
     62          extern bool hasFirmwareErrorFlag;
     63          

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine:
   \   00000000   0xB580             PUSH     {R7,LR}
     64          static LocalVersionHolder triggerVersion;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000006   0x.... 0x....      BL       _ZN18LocalVersionHolderC1Ev
     65          
     66          extern engine_pins_s enginePins;
     67          static MainTriggerCallback mainTriggerCallbackInstance;
     68          
     69          /**
     70           * That's the list of pending spark firing events
     71           */
     72          static IgnitionEvent *iHead = NULL;
     73          
     74          /**
     75           * In order to archive higher event precision, we are using a hybrid approach
     76           * where we are scheduling events based on the closest trigger event with a time offset.
     77           *
     78           * This queue is using global trigger event index as 'time'
     79           */
     80          //static EventQueue triggerEventsQueue;
     81          static cyclic_buffer<int> ignitionErrorDetection;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000000E   0x.... 0x....      BL       _ZN13cyclic_bufferIiEC1Ev
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000001A   0x.... 0x....      BL       __aeabi_atexit
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     triggerVersion:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     mainTriggerCallbackInstance:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     iHead:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ignitionErrorDetection:
   \   00000000                      DS8 268
     82          

   \                                 In section .bss, align 4
     83          static Logging *logger;
   \                     logger:
   \   00000000                      DS8 4
     84          
     85          // todo: figure out if this even helps?
     86          //#if defined __GNUC__
     87          //#define RAM_METHOD_PREFIX __attribute__((section(".ram")))
     88          //#else
     89          //#define RAM_METHOD_PREFIX
     90          //#endif
     91          

   \                                 In section .text, align 2, keep-with-next
     92          static void startSimultaniousInjection(Engine *engine) {
   \                     _Z26startSimultaniousInjectionP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     93          	for (int i = 0; i < engine->engineConfiguration->specs.cylindersCount; i++) {
   \   00000004   0x2500             MOVS     R5,#+0
   \                     ??startSimultaniousInjection_0:
   \   00000006   0x6A60             LDR      R0,[R4, #+36]
   \   00000008   0xF8D0 0x0194      LDR      R0,[R0, #+404]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xDA09             BGE.N    ??startSimultaniousInjection_1
     94          		turnPinHigh(&enginePins.injectors[i]);
   \   00000010   0x2014             MOVS     R0,#+20
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000016   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000001A   0x3060             ADDS     R0,R0,#+96
   \   0000001C   0x.... 0x....      BL       _Z11turnPinHighP14NamedOutputPin
     95          	}
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0xE7F0             B.N      ??startSimultaniousInjection_0
     96          }
   \                     ??startSimultaniousInjection_1:
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     97          

   \                                 In section .text, align 2, keep-with-next
     98          static void endSimultaniousInjection(Engine *engine) {
   \                     _Z24endSimultaniousInjectionP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     99          	for (int i = 0; i < engine->engineConfiguration->specs.cylindersCount; i++) {
   \   00000004   0x2500             MOVS     R5,#+0
   \                     ??endSimultaniousInjection_0:
   \   00000006   0x6A60             LDR      R0,[R4, #+36]
   \   00000008   0xF8D0 0x0194      LDR      R0,[R0, #+404]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xDA09             BGE.N    ??endSimultaniousInjection_1
    100          		turnPinLow(&enginePins.injectors[i]);
   \   00000010   0x2014             MOVS     R0,#+20
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000016   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000001A   0x3060             ADDS     R0,R0,#+96
   \   0000001C   0x.... 0x....      BL       _Z10turnPinLowP14NamedOutputPin
    101          	}
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0xE7F0             B.N      ??endSimultaniousInjection_0
    102          }
   \                     ??endSimultaniousInjection_1:
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    103          

   \                                 In section .text, align 4, keep-with-next
    104          static ALWAYS_INLINE void handleFuelInjectionEvent(InjectionEvent *event, int rpm DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z24handleFuelInjectionEventP14InjectionEventi:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000D             MOVS     R5,R1
    105          	floatms_t injectionDuration = ENGINE(fuelMs);
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000012   0xED90 0x8A98      VLDR     S16,[R0, #+608]
    106          	if (cisnan(injectionDuration)) {
   \   00000016   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000001A   0x.... 0x....      BL       __iar_FDtest
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD106             BNE.N    ??handleFuelInjectionEvent_0
    107          		warning(OBD_PCM_Processor_Fault, "NaN injection pulse");
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable13_6
   \   00000026   0xF240 0x205E      MOVW     R0,#+606
   \   0000002A   0x.... 0x....      BL       warning
    108          		return;
   \   0000002E   0xE095             B.N      ??handleFuelInjectionEvent_1
    109          	}
    110          	if (injectionDuration < 0) {
   \                     ??handleFuelInjectionEvent_0:
   \   00000030   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000034   0xEEF1 0xFA10      FMSTAT   
   \   00000038   0xD50C             BPL.N    ??handleFuelInjectionEvent_2
    111          		warning(OBD_PCM_Processor_Fault, "Negative injection pulse %f", injectionDuration);
   \   0000003A   0xEE18 0x0A10      VMOV     R0,S16
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x0002             MOVS     R2,R0
   \   00000044   0x000B             MOVS     R3,R1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \   0000004A   0xF240 0x205E      MOVW     R0,#+606
   \   0000004E   0x.... 0x....      BL       warning
    112          		return;
   \   00000052   0xE083             B.N      ??handleFuelInjectionEvent_1
    113          	}
    114          
    115          	if (engine->isCylinderCleanupMode)
   \                     ??handleFuelInjectionEvent_2:
   \   00000054   0xF641 0x60F8      MOVW     R0,#+7928
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable13_8
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x5C40             LDRB     R0,[R0, R1]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD17B             BNE.N    ??handleFuelInjectionEvent_1
    116          		return;
    117          
    118          	floatus_t injectionStartDelayUs = ENGINE(rpmCalculator.oneDegreeUs) * event->injectionStart.angleOffset;
   \                     ??handleFuelInjectionEvent_3:
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000068   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   0000006C   0xEDD4 0x0A02      VLDR     S1,[R4, #+8]
   \   00000070   0xEE60 0x8A20      VMUL.F32 S17,S0,S1
    119          
    120          	if (event->isSimultanious) {
   \   00000074   0xF894 0x0078      LDRB     R0,[R4, #+120]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD061             BEQ.N    ??handleFuelInjectionEvent_4
    121          		if (injectionDuration < 0) {
   \   0000007C   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000080   0xEEF1 0xFA10      FMSTAT   
   \   00000084   0xD50A             BPL.N    ??handleFuelInjectionEvent_5
    122          			firmwareError("duration cannot be negative: %d", injectionDuration);
   \   00000086   0xEE18 0x0A10      VMOV     R0,S16
   \   0000008A   0x.... 0x....      BL       __aeabi_f2d
   \   0000008E   0x0002             MOVS     R2,R0
   \   00000090   0x000B             MOVS     R3,R1
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   00000096   0x.... 0x....      BL       firmwareError
    123          			return;
   \   0000009A   0xE05F             B.N      ??handleFuelInjectionEvent_1
    124          		}
    125          		if (cisnan(injectionDuration)) {
   \                     ??handleFuelInjectionEvent_5:
   \   0000009C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000A0   0x.... 0x....      BL       __iar_FDtest
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD10A             BNE.N    ??handleFuelInjectionEvent_6
    126          			firmwareError("NaN in scheduleOutput", injectionDuration);
   \   000000A8   0xEE18 0x0A10      VMOV     R0,S16
   \   000000AC   0x.... 0x....      BL       __aeabi_f2d
   \   000000B0   0x0002             MOVS     R2,R0
   \   000000B2   0x000B             MOVS     R3,R1
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   000000B8   0x.... 0x....      BL       firmwareError
    127          			return;
   \   000000BC   0xE04E             B.N      ??handleFuelInjectionEvent_1
    128          		}
    129          		/**
    130          		 * this is pretty much copy-paste of 'scheduleOutput'
    131          		 * 'scheduleOutput' is currently only used for injection, so maybe it should be
    132          		 * changed into 'scheduleInjection' and unified? todo: think about it.
    133          		 */
    134          		OutputSignal *signal = &event->actuator;
   \                     ??handleFuelInjectionEvent_6:
   \   000000BE   0xF114 0x0610      ADDS     R6,R4,#+16
    135          		efiAssertVoid(signal!=NULL, "signal is NULL");
   \   000000C2   0x2E00             CMP      R6,#+0
   \   000000C4   0xD104             BNE.N    ??handleFuelInjectionEvent_7
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable13_11
   \   000000CA   0x.... 0x....      BL       firmwareError
   \   000000CE   0xE045             B.N      ??handleFuelInjectionEvent_1
    136          		int index = getRevolutionCounter() % 2;
   \                     ??handleFuelInjectionEvent_7:
   \   000000D0   0x.... 0x....      BL       _Z20getRevolutionCounterv
   \   000000D4   0x2102             MOVS     R1,#+2
   \   000000D6   0xFB90 0xF7F1      SDIV     R7,R0,R1
   \   000000DA   0xFB07 0x0711      MLS      R7,R7,R1,R0
    137          		scheduling_s * sUp = &signal->signalTimerUp[index];
   \   000000DE   0x2018             MOVS     R0,#+24
   \   000000E0   0xFB00 0x6007      MLA      R0,R0,R7,R6
   \   000000E4   0xF110 0x0808      ADDS     R8,R0,#+8
    138          		scheduling_s * sDown = &signal->signalTimerDown[index];
   \   000000E8   0x2018             MOVS     R0,#+24
   \   000000EA   0xFB00 0x6007      MLA      R0,R0,R7,R6
   \   000000EE   0xF110 0x0938      ADDS     R9,R0,#+56
    139          
    140          		scheduleTask("out up", sUp, (int) injectionStartDelayUs, (schfunc_t) &startSimultaniousInjection, engine);
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x9000             STR      R0,[SP, #+0]
   \   000000FA   0x.... 0x....      LDR.W    R3,??DataTable13_12
   \   000000FE   0xEEBD 0x0AE8      VCVT.S32.F32 S0,S17
   \   00000102   0xEE10 0x2A10      VMOV     R2,S0
   \   00000106   0x4641             MOV      R1,R8
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable13_13
   \   0000010C   0x.... 0x....      BL       _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_
    141          		scheduleTask("out down", sDown, (int) injectionStartDelayUs + MS2US(injectionDuration), (schfunc_t) &endSimultaniousInjection, engine);
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x9000             STR      R0,[SP, #+0]
   \   00000118   0x.... 0x....      LDR.W    R3,??DataTable13_14
   \   0000011C   0xEEBD 0x0AE8      VCVT.S32.F32 S0,S17
   \   00000120   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000124   0xEDDF 0x....      VLDR.W   S1,??DataTable5  ;; 0x447a0000
   \   00000128   0xEE08 0x0A20      VMLA.F32 S0,S16,S1
   \   0000012C   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000130   0xEE10 0x2A10      VMOV     R2,S0
   \   00000134   0x4649             MOV      R1,R9
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable13_15
   \   0000013A   0x.... 0x....      BL       _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_
   \   0000013E   0xE00D             B.N      ??handleFuelInjectionEvent_8
    142          
    143          	} else {
    144          		scheduleOutput(&event->actuator, getTimeNowUs(), injectionStartDelayUs, MS2US(injectionDuration));
   \                     ??handleFuelInjectionEvent_4:
   \   00000140   0x.... 0x....      BL       getTimeNowUs
   \   00000144   0xED9F 0x....      VLDR.W   S0,??DataTable5  ;; 0x447a0000
   \   00000148   0xEE68 0x0A00      VMUL.F32 S1,S16,S0
   \   0000014C   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000150   0x0002             MOVS     R2,R0
   \   00000152   0x000B             MOVS     R3,R1
   \   00000154   0xF114 0x0010      ADDS     R0,R4,#+16
   \   00000158   0x.... 0x....      BL       _Z14scheduleOutputP19OutputSignal_structxff
    145          	}
    146          }
   \                     ??handleFuelInjectionEvent_8:
   \                     ??handleFuelInjectionEvent_1:
   \   0000015C   0xB002             ADD      SP,SP,#+8
   \   0000015E   0xECBD 0x8B02      VPOP     {D8}
   \   00000162   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    147          

   \                                 In section .text, align 2, keep-with-next
    148          static ALWAYS_INLINE void handleFuel(uint32_t eventIndex, int rpm DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z10handleFuelji:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    149          	if (!isInjectionEnabled(engine->engineConfiguration))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6A40             LDR      R0,[R0, #+36]
   \   00000010   0x.... 0x....      BL       _Z18isInjectionEnabledP22engine_configuration_s
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD063             BEQ.N    ??handleFuel_0
    150          		return;
    151          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#3");
   \                     ??handleFuel_1:
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13_16
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x.... 0x....      BL       getRemainingStack
   \   00000022   0x2881             CMP      R0,#+129
   \   00000024   0xDA04             BGE.N    ??handleFuel_2
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_17
   \   0000002A   0x.... 0x....      BL       firmwareError
   \   0000002E   0xE057             B.N      ??handleFuel_0
    152          	efiAssertVoid(eventIndex < engine->triggerShape.getLength(), "handleFuel/event index");
   \                     ??handleFuel_2:
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF510 0x7021      ADDS     R0,R0,#+644
   \   0000003A   0x.... 0x....      BL       _ZNK12TriggerShape9getLengthEv
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD304             BCC.N    ??handleFuel_3
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable13_18
   \   00000046   0x.... 0x....      BL       firmwareError
   \   0000004A   0xE049             B.N      ??handleFuel_0
    153          
    154          	/**
    155          	 * Ignition events are defined by addFuelEvents() according to selected
    156          	 * fueling strategy
    157          	 */
    158          	FuelSchedule *fs =
    159          	isCrankingR(rpm) ?
    160          			&ENGINE(engineConfiguration2)->crankingInjectionEvents : &engine->engineConfiguration2->injectionEvents;
   \                     ??handleFuel_3:
   \   0000004C   0x2D01             CMP      R5,#+1
   \   0000004E   0xDB09             BLT.N    ??handleFuel_4
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13_19
   \   00000054   0xF9B0 0x0068      LDRSH    R0,[R0, #+104]
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xDA03             BGE.N    ??handleFuel_4
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000060   0x6A86             LDR      R6,[R0, #+40]
   \   00000062   0xE006             B.N      ??handleFuel_5
   \                     ??handleFuel_4:
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x6A80             LDR      R0,[R0, #+40]
   \   0000006C   0xF500 0x56B8      ADD      R6,R0,#+5888
   \   00000070   0x3688             ADDS     R6,R6,#+136
    161          
    162          	InjectionEventList *source = &fs->events;
   \                     ??handleFuel_5:
   \   00000072   0x0037             MOVS     R7,R6
    163          
    164          	if (!fs->hasEvents[eventIndex])
   \   00000074   0xF241 0x6088      MOVW     R0,#+5768
   \   00000078   0x19A1             ADDS     R1,R4,R6
   \   0000007A   0x5C40             LDRB     R0,[R0, R1]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD02F             BEQ.N    ??handleFuel_0
    165          		return;
    166          
    167          	engine->tpsAccelEnrichment.onEngineCycleTps(PASS_ENGINE_PARAMETER_F);
   \                     ??handleFuel_6:
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF510 0x70A6      ADDS     R0,R0,#+332
   \   0000008A   0x.... 0x....      BL       _ZN16AccelEnrichmemnt16onEngineCycleTpsEv
    168          
    169          	engine->mapAccelEnrichment.onEngineCycle(PASS_ENGINE_PARAMETER_F);
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x3038             ADDS     R0,R0,#+56
   \   00000096   0x.... 0x....      BL       _ZN16AccelEnrichmemnt13onEngineCycleEv
    170          	ENGINE(fuelMs) = getFuelMs(rpm PASS_ENGINE_PARAMETER) * engineConfiguration->globalFuelCorrection;
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0x.... 0x....      BL       _Z9getFuelMsi
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xEDD0 0x0A8E      VLDR     S1,[R0, #+568]
   \   000000AA   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000000B2   0xED80 0x0A98      VSTR     S0,[R0, #+608]
    171          
    172          	for (int i = 0; i < source->size; i++) {
   \   000000B6   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??handleFuel_7:
   \   000000BA   0x6838             LDR      R0,[R7, #+0]
   \   000000BC   0x4580             CMP      R8,R0
   \   000000BE   0xDA0F             BGE.N    ??handleFuel_8
    173          		InjectionEvent *event = &source->elements[i];
   \   000000C0   0x2080             MOVS     R0,#+128
   \   000000C2   0xFB00 0x7008      MLA      R0,R0,R8,R7
   \   000000C6   0xF110 0x0908      ADDS     R9,R0,#+8
    174          		if (event->injectionStart.eventIndex != eventIndex)
   \   000000CA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000CE   0x42A0             CMP      R0,R4
   \   000000D0   0xD103             BNE.N    ??handleFuel_9
    175          			continue;
    176          		handleFuelInjectionEvent(event, rpm PASS_ENGINE_PARAMETER);
   \                     ??handleFuel_10:
   \   000000D2   0x0029             MOVS     R1,R5
   \   000000D4   0x4648             MOV      R0,R9
   \   000000D6   0x.... 0x....      BL       _Z24handleFuelInjectionEventP14InjectionEventi
    177          	}
   \                     ??handleFuel_9:
   \   000000DA   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000DE   0xE7EC             B.N      ??handleFuel_7
    178          }
   \                     ??handleFuel_8:
   \                     ??handleFuel_0:
   \   000000E0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    179          

   \                                 In section .text, align 4, keep-with-next
    180          static ALWAYS_INLINE void handleSparkEvent(uint32_t eventIndex, IgnitionEvent *iEvent,
    181          		int rpm DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z16handleSparkEventjP13IgnitionEventi:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000D             MOVS     R5,R1
   \   0000000E   0x0016             MOVS     R6,R2
    182          
    183          	float dwellMs = engine->engineState.sparkDwell;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF500 0x50F0      ADD      R0,R0,#+7680
   \   0000001A   0x30B4             ADDS     R0,R0,#+180
   \   0000001C   0xED90 0x8A00      VLDR     S16,[R0, #0]
    184          	if (cisnan(dwellMs) || dwellMs < 0) {
   \   00000020   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000024   0x.... 0x....      BL       __iar_FDtest
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD004             BEQ.N    ??handleSparkEvent_0
   \   0000002C   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000030   0xEEF1 0xFA10      FMSTAT   
   \   00000034   0xD50B             BPL.N    ??handleSparkEvent_1
    185          		firmwareError("invalid dwell: %f at %d", dwellMs, rpm);
   \                     ??handleSparkEvent_0:
   \   00000036   0x9600             STR      R6,[SP, #+0]
   \   00000038   0xEE18 0x0A10      VMOV     R0,S16
   \   0000003C   0x.... 0x....      BL       __aeabi_f2d
   \   00000040   0x0002             MOVS     R2,R0
   \   00000042   0x000B             MOVS     R3,R1
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable13_21
   \   00000048   0x.... 0x....      BL       firmwareError
    186          		return;
   \   0000004C   0xE08E             B.N      ??handleSparkEvent_2
    187          	}
    188          
    189          	floatus_t chargeDelayUs = engine->rpmCalculator.oneDegreeUs * iEvent->dwellPosition.angleOffset;
   \                     ??handleSparkEvent_1:
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000058   0xEDD5 0x0A11      VLDR     S1,[R5, #+68]
   \   0000005C   0xEE60 0x8A20      VMUL.F32 S17,S0,S1
    190          	int isIgnitionError = chargeDelayUs < 0;
   \   00000060   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   00000064   0xEEF1 0xFA10      FMSTAT   
   \   00000068   0xD501             BPL.N    ??handleSparkEvent_3
   \   0000006A   0x2701             MOVS     R7,#+1
   \   0000006C   0xE000             B.N      ??handleSparkEvent_4
   \                     ??handleSparkEvent_3:
   \   0000006E   0x2700             MOVS     R7,#+0
   \                     ??handleSparkEvent_4:
   \   00000070   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
    191          	ignitionErrorDetection.add(isIgnitionError);
   \   00000072   0x0039             MOVS     R1,R7
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000078   0x.... 0x....      BL       _ZN13cyclic_bufferIiE3addEi
    192          	if (isIgnitionError) {
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD011             BEQ.N    ??handleSparkEvent_5
    193          #if EFI_PROD_CODE
    194          		scheduleMsg(logger, "Negative spark delay=%f", chargeDelayUs);
   \   00000080   0xEE18 0x0A90      VMOV     R0,S17
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x0002             MOVS     R2,R0
   \   0000008A   0x000B             MOVS     R3,R1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable13_22
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable13_23
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x.... 0x....      BL       scheduleMsg
    195          #endif
    196          		chargeDelayUs = 0;
   \   0000009A   0xED9F 0x....      VLDR.W   S0,??DataTable8  ;; 0x0
   \   0000009E   0xEEF0 0x8A40      VMOV.F32 S17,S0
    197          		return;
   \   000000A2   0xE063             B.N      ??handleSparkEvent_2
    198          	}
    199          
    200          	if (cisnan(dwellMs)) {
   \                     ??handleSparkEvent_5:
   \   000000A4   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000A8   0x.... 0x....      BL       __iar_FDtest
   \   000000AC   0x2802             CMP      R0,#+2
   \   000000AE   0xD10A             BNE.N    ??handleSparkEvent_6
    201          		firmwareError("NaN in scheduleOutput", dwellMs);
   \   000000B0   0xEE18 0x0A10      VMOV     R0,S16
   \   000000B4   0x.... 0x....      BL       __aeabi_f2d
   \   000000B8   0x0002             MOVS     R2,R0
   \   000000BA   0x000B             MOVS     R3,R1
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   000000C0   0x.... 0x....      BL       firmwareError
    202          		return;
   \   000000C4   0xE052             B.N      ??handleSparkEvent_2
    203          	}
    204          
    205          	/**
    206          	 * We are alternating two event lists in order to avoid a potential issue around revolution boundary
    207          	 * when an event is scheduled within the next revolution.
    208          	 */
    209          	scheduling_s * sUp = &iEvent->signalTimerUp;
   \                     ??handleSparkEvent_6:
   \   000000C6   0xF115 0x0808      ADDS     R8,R5,#+8
    210          	scheduling_s * sDown = &iEvent->signalTimerDown;
   \   000000CA   0xF115 0x0920      ADDS     R9,R5,#+32
    211          
    212          	/**
    213          	 * The start of charge is always within the current trigger event range, so just plain time-based scheduling
    214          	 */
    215          	scheduleTask("spark up", sUp, chargeDelayUs, (schfunc_t) &turnPinHigh, iEvent->output);
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0x.... 0x....      LDR.W    R3,??DataTable13_24
   \   000000D6   0xEEBD 0x0AE8      VCVT.S32.F32 S0,S17
   \   000000DA   0xEE10 0x2A10      VMOV     R2,S0
   \   000000DE   0x4641             MOV      R1,R8
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable13_25
   \   000000E4   0x.... 0x....      BL       _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_
    216          	/**
    217          	 * Spark event is often happening during a later trigger event timeframe
    218          	 * TODO: improve precision
    219          	 */
    220          
    221          	findTriggerPosition(&iEvent->sparkPosition, iEvent->advance PASS_ENGINE_PARAMETER);
   \   000000E8   0xED95 0x0A0E      VLDR     S0,[R5, #+56]
   \   000000EC   0xF115 0x0048      ADDS     R0,R5,#+72
   \   000000F0   0x.... 0x....      BL       _Z19findTriggerPositionP24event_trigger_position_sf
    222          
    223          	if (iEvent->sparkPosition.eventIndex == eventIndex) {
   \   000000F4   0x6CA8             LDR      R0,[R5, #+72]
   \   000000F6   0x42A0             CMP      R0,R4
   \   000000F8   0xD116             BNE.N    ??handleSparkEvent_7
    224          		/**
    225          		 * Spark should be fired before the next trigger event - time-based delay is best precision possible
    226          		 */
    227          		float timeTillIgnitionUs = engine->rpmCalculator.oneDegreeUs * iEvent->sparkPosition.angleOffset;
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000104   0xEDD5 0x0A14      VLDR     S1,[R5, #+80]
   \   00000108   0xEE20 0x9A20      VMUL.F32 S18,S0,S1
    228          
    229          		scheduleTask("spark 1down", sDown, (int) timeTillIgnitionUs, (schfunc_t) &turnPinLow, iEvent->output);
   \   0000010C   0x6828             LDR      R0,[R5, #+0]
   \   0000010E   0x9000             STR      R0,[SP, #+0]
   \   00000110   0x.... 0x....      LDR.W    R3,??DataTable13_26
   \   00000114   0xEEBD 0x0AC9      VCVT.S32.F32 S0,S18
   \   00000118   0xEE10 0x2A10      VMOV     R2,S0
   \   0000011C   0x4649             MOV      R1,R9
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable13_27
   \   00000122   0x.... 0x....      BL       _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_
   \   00000126   0xE021             B.N      ??handleSparkEvent_8
    230          	} else {
    231          		/**
    232          		 * Spark should be scheduled in relation to some future trigger event, this way we get better firing precision
    233          		 */
    234          		bool isPending = assertNotInList<IgnitionEvent>(iHead, iEvent);
   \                     ??handleSparkEvent_7:
   \   00000128   0x0029             MOVS     R1,R5
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable13_28
   \   0000012E   0x6800             LDR      R0,[R0, #+0]
   \   00000130   0x.... 0x....      BL       _Z15assertNotInListI13IgnitionEventEbPT_S2_
    235          		if (isPending)
   \   00000134   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD118             BNE.N    ??handleSparkEvent_2
    236          			return;
    237          
    238          		LL_APPEND(iHead, iEvent);
   \                     ??handleSparkEvent_9:
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   0000013E   0x6809             LDR      R1,[R1, #+0]
   \   00000140   0x2900             CMP      R1,#+0
   \   00000142   0xD00E             BEQ.N    ??handleSparkEvent_10
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   00000148   0x6809             LDR      R1,[R1, #+0]
   \   0000014A   0x6569             STR      R1,[R5, #+84]
   \                     ??handleSparkEvent_11:
   \   0000014C   0x6D69             LDR      R1,[R5, #+84]
   \   0000014E   0x6D49             LDR      R1,[R1, #+84]
   \   00000150   0x2900             CMP      R1,#+0
   \   00000152   0xD003             BEQ.N    ??handleSparkEvent_12
   \   00000154   0x6D69             LDR      R1,[R5, #+84]
   \   00000156   0x6D49             LDR      R1,[R1, #+84]
   \   00000158   0x6569             STR      R1,[R5, #+84]
   \   0000015A   0xE7F7             B.N      ??handleSparkEvent_11
   \                     ??handleSparkEvent_12:
   \   0000015C   0x6D69             LDR      R1,[R5, #+84]
   \   0000015E   0x654D             STR      R5,[R1, #+84]
   \   00000160   0xE002             B.N      ??handleSparkEvent_13
   \                     ??handleSparkEvent_10:
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   00000166   0x600D             STR      R5,[R1, #+0]
   \                     ??handleSparkEvent_13:
   \   00000168   0x2100             MOVS     R1,#+0
   \   0000016A   0x6569             STR      R1,[R5, #+84]
    239          	}
    240          }
   \                     ??handleSparkEvent_8:
   \                     ??handleSparkEvent_2:
   \   0000016C   0xB002             ADD      SP,SP,#+8
   \   0000016E   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000172   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    241          

   \                                 In section .text, align 2, keep-with-next
    242          static ALWAYS_INLINE void handleSpark(uint32_t eventIndex, int rpm,
    243          		IgnitionEventList *list DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z11handleSparkjiP9ArrayListI13IgnitionEventLi80EE:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000D             MOVS     R5,R1
   \   0000000E   0x0016             MOVS     R6,R2
    244          	if (!isValidRpm(rpm) || !engineConfiguration->isIgnitionEnabled)
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xDB0E             BLT.N    ??handleSpark_0
   \   00000014   0xF247 0x5030      MOVW     R0,#+30000
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xDA0A             BGE.N    ??handleSpark_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF890 0x05E4      LDRB     R0,[R0, #+1508]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD100             BNE.N    ??handleSpark_1
    245          		return; // this might happen for instance in case of a single trigger event after a pause
   \                     ??handleSpark_0:
   \   00000032   0xE070             B.N      ??handleSpark_2
    246          
    247          	/**
    248          	 * Ignition schedule is defined once per revolution
    249          	 * See initializeIgnitionActions()
    250          	 */
    251          
    252          	IgnitionEvent *current, *tmp;
    253          
    254          	LL_FOREACH_SAFE(iHead, current, tmp)
   \                     ??handleSpark_1:
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable13_28
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0007             MOVS     R7,R0
   \                     ??handleSpark_3:
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD054             BEQ.N    ??handleSpark_4
   \   00000040   0xF8D7 0x8054      LDR      R8,[R7, #+84]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD14F             BNE.N    ??handleSpark_4
    255          	{
    256          		if (current->sparkPosition.eventIndex == eventIndex) {
   \   0000004A   0x6CB8             LDR      R0,[R7, #+72]
   \   0000004C   0x42A0             CMP      R0,R4
   \   0000004E   0xD14A             BNE.N    ??handleSpark_5
    257          			// time to fire a spark which was scheduled previously
    258          			LL_DELETE(iHead, current);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13_28
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x42B8             CMP      R0,R7
   \   00000058   0xD107             BNE.N    ??handleSpark_6
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable13_28
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6D40             LDR      R0,[R0, #+84]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE026             B.N      ??handleSpark_7
   \                     ??handleSpark_6:
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0x0008             MOVS     R0,R1
   \                     ??handleSpark_8:
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x6D49             LDR      R1,[R1, #+84]
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD00D             BEQ.N    ??handleSpark_9
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x6D49             LDR      R1,[R1, #+84]
   \   00000086   0x42B9             CMP      R1,R7
   \   00000088   0xD007             BEQ.N    ??handleSpark_9
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0x6D49             LDR      R1,[R1, #+84]
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable13_28
   \   00000096   0x6011             STR      R1,[R2, #+0]
   \   00000098   0xE7EB             B.N      ??handleSpark_8
   \                     ??handleSpark_9:
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0x6D49             LDR      R1,[R1, #+84]
   \   000000A2   0x2900             CMP      R1,#+0
   \   000000A4   0xD004             BEQ.N    ??handleSpark_10
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable13_28
   \   000000AA   0x6809             LDR      R1,[R1, #+0]
   \   000000AC   0x6D7A             LDR      R2,[R7, #+84]
   \   000000AE   0x654A             STR      R2,[R1, #+84]
   \                     ??handleSpark_10:
   \   000000B0   0x.... 0x....      LDR.W    R2,??DataTable13_28
   \   000000B4   0x0011             MOVS     R1,R2
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    259          
    260          			scheduling_s * sDown = &current->signalTimerDown;
   \                     ??handleSpark_7:
   \   000000B8   0xF117 0x0920      ADDS     R9,R7,#+32
    261          
    262          			float timeTillIgnitionUs = ENGINE(rpmCalculator.oneDegreeUs) * current->sparkPosition.angleOffset;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000000C0   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   000000C4   0xEDD7 0x0A14      VLDR     S1,[R7, #+80]
   \   000000C8   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
    263          			scheduleTask("spark 2down", sDown, (int) timeTillIgnitionUs, (schfunc_t) &turnPinLow, current->output);
   \   000000CC   0x6838             LDR      R0,[R7, #+0]
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0x.... 0x....      LDR.W    R3,??DataTable13_26
   \   000000D4   0xEEBD 0x0AC8      VCVT.S32.F32 S0,S16
   \   000000D8   0xEE10 0x2A10      VMOV     R2,S0
   \   000000DC   0x4649             MOV      R1,R9
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13_29
   \   000000E2   0x.... 0x....      BL       _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_
    264          		}
    265          	}
   \                     ??handleSpark_5:
   \   000000E6   0x4647             MOV      R7,R8
   \   000000E8   0xE7A8             B.N      ??handleSpark_3
    266          
    267          //	scheduleSimpleMsg(&logger, "eventId spark ", eventIndex);
    268          	for (int i = 0; i < list->size; i++) {
   \                     ??handleSpark_4:
   \   000000EA   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??handleSpark_11:
   \   000000EE   0x6830             LDR      R0,[R6, #+0]
   \   000000F0   0x4581             CMP      R9,R0
   \   000000F2   0xDA10             BGE.N    ??handleSpark_12
    269          		IgnitionEvent *event = &list->elements[i];
   \   000000F4   0x2060             MOVS     R0,#+96
   \   000000F6   0xFB00 0x6009      MLA      R0,R0,R9,R6
   \   000000FA   0xF110 0x0A08      ADDS     R10,R0,#+8
    270          		if (event->dwellPosition.eventIndex != eventIndex)
   \   000000FE   0xF8DA 0x003C      LDR      R0,[R10, #+60]
   \   00000102   0x42A0             CMP      R0,R4
   \   00000104   0xD104             BNE.N    ??handleSpark_13
    271          			continue;
    272          		handleSparkEvent(eventIndex, event, rpm PASS_ENGINE_PARAMETER);
   \                     ??handleSpark_14:
   \   00000106   0x002A             MOVS     R2,R5
   \   00000108   0x4651             MOV      R1,R10
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0x.... 0x....      BL       _Z16handleSparkEventjP13IgnitionEventi
    273          	}
   \                     ??handleSpark_13:
   \   00000110   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000114   0xE7EB             B.N      ??handleSpark_11
    274          }
   \                     ??handleSpark_12:
   \                     ??handleSpark_2:
   \   00000116   0xB002             ADD      SP,SP,#+8
   \   00000118   0xECBD 0x8B02      VPOP     {D8}
   \   0000011C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    275          

   \                                 In section .bss, align 8
    276          static histogram_s mainLoopHisto;
   \                     mainLoopHisto:
   \   00000000                      DS8 3616
    277          

   \                                 In section .text, align 2, keep-with-next
    278          void showMainHistogram(void) {
   \                     showMainHistogram:
   \   00000000   0xB580             PUSH     {R7,LR}
    279          #if EFI_PROD_CODE
    280          	printHistogram(logger, &mainLoopHisto);
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable13_30
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_23
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x.... 0x....      BL       _Z14printHistogramP7LoggingP11histogram_s
    281          #endif
    282          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    283          

   \                                 In section .text, align 2, keep-with-next
    284          static void ignitionCalc(int rpm DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z12ignitionCalci:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x0004             MOVS     R4,R0
    285          	/**
    286          	 * Within one engine cycle all cylinders are fired with same timing advance.
    287          	 * todo: one day we can control cylinders individually?
    288          	 */
    289          	float dwellMs = ENGINE(engineState.sparkDwell);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_31
   \   0000000E   0xED90 0x8A00      VLDR     S16,[R0, #0]
    290          
    291          	if (cisnan(dwellMs) || dwellMs < 0) {
   \   00000012   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000016   0x.... 0x....      BL       __iar_FDtest
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD004             BEQ.N    ??ignitionCalc_0
   \   0000001E   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   00000022   0xEEF1 0xFA10      FMSTAT   
   \   00000026   0xD50B             BPL.N    ??ignitionCalc_1
    292          		firmwareError("invalid dwell: %f at %d", dwellMs, rpm);
   \                     ??ignitionCalc_0:
   \   00000028   0x9400             STR      R4,[SP, #+0]
   \   0000002A   0xEE18 0x0A10      VMOV     R0,S16
   \   0000002E   0x.... 0x....      BL       __aeabi_f2d
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0x000B             MOVS     R3,R1
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable13_21
   \   0000003A   0x.... 0x....      BL       firmwareError
    293          		return;
   \   0000003E   0xE00C             B.N      ??ignitionCalc_2
    294          	}
    295          	// todo: eliminate this field
    296          	engine->engineState.advance = -ENGINE(engineState.timingAdvance);
   \                     ??ignitionCalc_1:
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF510 0x50F6      ADDS     R0,R0,#+7872
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable13_32
   \   0000004E   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000052   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \   00000056   0xED80 0x0A00      VSTR     S0,[R0, #0]
    297          }
   \                     ??ignitionCalc_2:
   \   0000005A   0xB002             ADD      SP,SP,#+8
   \   0000005C   0xECBD 0x8B02      VPOP     {D8}
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    298          
    299          #if EFI_PROD_CODE
    300          /**
    301           * this field is used as an Expression in IAR debugger
    302           */

   \                                 In section .data, align 4
    303          uint32_t *cyccnt = (uint32_t*)&DWT_CYCCNT;
   \                     cyccnt:
   \   00000000   0xE0001004         DC32 0E0001004H
    304          #endif
    305          
    306          /**
    307           * This is the main trigger event handler.
    308           * Both injection and ignition are controlled from this method.
    309           */

   \                                 In section .text, align 4, keep-with-next
    310          void mainTriggerCallback(trigger_event_e ckpSignalType, uint32_t eventIndex DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z19mainTriggerCallback15trigger_event_ej:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    311          	engine->m.beforeMainTrigger = GET_TIMESTAMP();
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF510 0x500F      ADDS     R0,R0,#+9152
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable13_33  ;; 0xe0001004
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    312          	if (hasFirmwareError()) {
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_34
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xF040 0x81B1      BNE.W    ??mainTriggerCallback_0
    313          		/**
    314          		 * In case on a major error we should not process any more events.
    315          		 * TODO: add 'pin shutdown' invocation somewhere
    316          		 */
    317          		return;
    318          	}
    319          
    320          	(void) ckpSignalType;
    321          	efiAssertVoid(eventIndex < 2 * engine->triggerShape.getSize(), "trigger/event index");
   \                     ??mainTriggerCallback_1:
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF510 0x7021      ADDS     R0,R0,#+644
   \   00000032   0x.... 0x....      BL       _ZNK12TriggerShape7getSizeEv
   \   00000036   0xEBB5 0x0F40      CMP      R5,R0, LSL #+1
   \   0000003A   0xD304             BCC.N    ??mainTriggerCallback_2
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_35
   \   00000040   0x.... 0x....      BL       firmwareError
   \   00000044   0xE1A1             B.N      ??mainTriggerCallback_0
    322          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#2");
   \                     ??mainTriggerCallback_2:
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13_16
   \   0000004A   0x6980             LDR      R0,[R0, #+24]
   \   0000004C   0x.... 0x....      BL       getRemainingStack
   \   00000050   0x2881             CMP      R0,#+129
   \   00000052   0xDA04             BGE.N    ??mainTriggerCallback_3
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable13_36
   \   00000058   0x.... 0x....      BL       firmwareError
   \   0000005C   0xE195             B.N      ??mainTriggerCallback_0
    323          
    324          	int rpm = getRpmE(engine);
   \                     ??mainTriggerCallback_3:
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
   \   00000068   0x0006             MOVS     R6,R0
    325          	if (rpm == 0) {
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xF000 0x818D      BEQ.W    ??mainTriggerCallback_0
    326          		// this happens while we just start cranking
    327          		// todo: check for 'trigger->is_synchnonized?'
    328          		return;
    329          	}
    330          	if (rpm == NOISY_RPM) {
   \                     ??mainTriggerCallback_4:
   \   00000070   0xF116 0x0F01      CMN      R6,#+1
   \   00000074   0xD106             BNE.N    ??mainTriggerCallback_5
    331          		warning(OBD_Camshaft_Position_Sensor_Circuit_Range_Performance, "noisy trigger");
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable13_37
   \   0000007A   0xF240 0x1055      MOVW     R0,#+341
   \   0000007E   0x.... 0x....      BL       warning
    332          		return;
   \   00000082   0xE182             B.N      ??mainTriggerCallback_0
    333          	}
    334          	if (rpm > engineConfiguration->rpmHardLimit) {
   \                     ??mainTriggerCallback_5:
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF8D0 0x01A4      LDR      R0,[R0, #+420]
   \   0000008E   0x42B0             CMP      R0,R6
   \   00000090   0xDA07             BGE.N    ??mainTriggerCallback_6
    335          		warning(OBD_PCM_Processor_Fault, "skipping stroke due to rpm=%d", rpm);
   \   00000092   0x0032             MOVS     R2,R6
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable13_38
   \   00000098   0xF240 0x205E      MOVW     R0,#+606
   \   0000009C   0x.... 0x....      BL       warning
    336          		return;
   \   000000A0   0xE173             B.N      ??mainTriggerCallback_0
    337          	}
    338          
    339          #if EFI_HISTOGRAMS && EFI_PROD_CODE
    340          	int beforeCallback = hal_lld_get_counter_value();
    341          #endif
    342          
    343          	int revolutionIndex = engine->rpmCalculator.getRevolutionCounter() % 2;
   \                     ??mainTriggerCallback_6:
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x.... 0x....      BL       _ZN13RpmCalculator20getRevolutionCounterEv
   \   000000AC   0xF010 0x0701      ANDS     R7,R0,#0x1
    344          
    345          	if (eventIndex == 0) {
   \   000000B0   0x2D00             CMP      R5,#+0
   \   000000B2   0xD107             BNE.N    ??mainTriggerCallback_7
    346          		if (triggerVersion.isOld())
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000B8   0x.... 0x....      BL       _ZN18LocalVersionHolder5isOldEv
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD001             BEQ.N    ??mainTriggerCallback_7
    347          			prepareOutputSignals(PASS_ENGINE_PARAMETER_F);
   \   000000C0   0x.... 0x....      BL       _Z20prepareOutputSignalsv
    348          	}
    349          
    350          	if (engineConfiguration->useOnlyFrontForTrigger && engineConfiguration->ignMathCalculateAtIndex % 2 != 0) {
   \                     ??mainTriggerCallback_7:
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF890 0x05E5      LDRB     R0,[R0, #+1509]
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x0980             LSRS     R0,R0,#+6
   \   000000D2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD014             BEQ.N    ??mainTriggerCallback_8
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF8D0 0x05F4      LDR      R0,[R0, #+1524]
   \   000000E4   0x2102             MOVS     R1,#+2
   \   000000E6   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   000000EA   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000EE   0x2A00             CMP      R2,#+0
   \   000000F0   0xD008             BEQ.N    ??mainTriggerCallback_8
    351          		firmwareError("invalid ignMathCalculateAtIndex %d", engineConfiguration->ignMathCalculateAtIndex);
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0xF8D0 0x15F4      LDR      R1,[R0, #+1524]
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable13_39
   \   00000100   0x.... 0x....      BL       firmwareError
    352          	}
    353          
    354          	if (eventIndex == engineConfiguration->ignMathCalculateAtIndex) {
   \                     ??mainTriggerCallback_8:
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xF8D0 0x05F4      LDR      R0,[R0, #+1524]
   \   0000010E   0x4285             CMP      R5,R0
   \   00000110   0xD13F             BNE.N    ??mainTriggerCallback_9
    355          		if (engineConfiguration->externalKnockSenseAdc != EFI_ADC_NONE) {
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF8D0 0x0654      LDR      R0,[R0, #+1620]
   \   0000011C   0x2810             CMP      R0,#+16
   \   0000011E   0xD01E             BEQ.N    ??mainTriggerCallback_10
    356          			float externalKnockValue = getVoltageDivided("knock", engineConfiguration->externalKnockSenseAdc);
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0xF8D0 0x1654      LDR      R1,[R0, #+1620]
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable13_40
   \   0000012E   0x.... 0x....      BL       _Z19getInternalAdcValuePKc13adc_channel_e
   \   00000132   0xEE00 0x0A10      VMOV     S0,R0
   \   00000136   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000013A   0xEDDF 0x....      VLDR.W   S1,??DataTable11  ;; 0x3a400c01
   \   0000013E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable13_20
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \   00000148   0xEDD0 0x0A74      VLDR     S1,[R0, #+464]
   \   0000014C   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
    357          			engine->knockLogic(externalKnockValue);
   \   00000150   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x.... 0x....      BL       _ZN6Engine10knockLogicEf
    358          		}
    359          
    360          		engine->m.beforeIgnitionMath = GET_TIMESTAMP();
   \                     ??mainTriggerCallback_10:
   \   0000015E   0xF242 0x30C8      MOVW     R0,#+9160
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable13_8
   \   00000166   0x6809             LDR      R1,[R1, #+0]
   \   00000168   0x.... 0x....      LDR.W    R2,??DataTable13_33  ;; 0xe0001004
   \   0000016C   0x6812             LDR      R2,[R2, #+0]
   \   0000016E   0x5042             STR      R2,[R0, R1]
    361          		ignitionCalc(rpm PASS_ENGINE_PARAMETER);
   \   00000170   0x0030             MOVS     R0,R6
   \   00000172   0x.... 0x....      BL       _Z12ignitionCalci
    362          		engine->m.ignitionMathTime = GET_TIMESTAMP() - engine->m.beforeIgnitionMath;
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable13_33  ;; 0xe0001004
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0xF242 0x31C8      MOVW     R1,#+9160
   \   00000180   0x....             LDR.N    R2,??DataTable13_8
   \   00000182   0x6812             LDR      R2,[R2, #+0]
   \   00000184   0x5889             LDR      R1,[R1, R2]
   \   00000186   0x1A40             SUBS     R0,R0,R1
   \   00000188   0xF242 0x31CC      MOVW     R1,#+9164
   \   0000018C   0x....             LDR.N    R2,??DataTable13_8
   \   0000018E   0x6812             LDR      R2,[R2, #+0]
   \   00000190   0x5088             STR      R0,[R1, R2]
    363          	}
    364          
    365          	if (eventIndex == 0) {
   \                     ??mainTriggerCallback_9:
   \   00000192   0x2D00             CMP      R5,#+0
   \   00000194   0xF040 0x80D8      BNE.W    ??mainTriggerCallback_11
    366          		engine->m.beforeFuelCalc = GET_TIMESTAMP();
   \   00000198   0xF242 0x30F0      MOVW     R0,#+9200
   \   0000019C   0x....             LDR.N    R1,??DataTable13_8
   \   0000019E   0x6809             LDR      R1,[R1, #+0]
   \   000001A0   0x.... 0x....      LDR.W    R2,??DataTable13_33  ;; 0xe0001004
   \   000001A4   0x6812             LDR      R2,[R2, #+0]
   \   000001A6   0x5042             STR      R2,[R0, R1]
    367          		ENGINE(fuelMs) = getFuelMs(rpm PASS_ENGINE_PARAMETER) * engineConfiguration->globalFuelCorrection;
   \   000001A8   0x0030             MOVS     R0,R6
   \   000001AA   0x.... 0x....      BL       _Z9getFuelMsi
   \   000001AE   0x....             LDR.N    R0,??DataTable13_20
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0xEDD0 0x0A8E      VLDR     S1,[R0, #+568]
   \   000001B6   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001BA   0x....             LDR.N    R0,??DataTable13_5
   \   000001BC   0xED80 0x0A98      VSTR     S0,[R0, #+608]
    368          		engine->m.fuelCalcTime = GET_TIMESTAMP() - engine->m.beforeFuelCalc;
   \   000001C0   0x.... 0x....      LDR.W    R0,??DataTable13_33  ;; 0xe0001004
   \   000001C4   0x6800             LDR      R0,[R0, #+0]
   \   000001C6   0xF242 0x31F0      MOVW     R1,#+9200
   \   000001CA   0x....             LDR.N    R2,??DataTable13_8
   \   000001CC   0x6812             LDR      R2,[R2, #+0]
   \   000001CE   0x5889             LDR      R1,[R1, R2]
   \   000001D0   0x1A40             SUBS     R0,R0,R1
   \   000001D2   0xF242 0x31F4      MOVW     R1,#+9204
   \   000001D6   0x....             LDR.N    R2,??DataTable13_8
   \   000001D8   0x6812             LDR      R2,[R2, #+0]
   \   000001DA   0x5088             STR      R0,[R1, R2]
    369          
    370          		engine->m.beforeIgnitionSch = GET_TIMESTAMP();
   \   000001DC   0xF242 0x30D0      MOVW     R0,#+9168
   \   000001E0   0x....             LDR.N    R1,??DataTable13_8
   \   000001E2   0x6809             LDR      R1,[R1, #+0]
   \   000001E4   0x....             LDR.N    R2,??DataTable13_33  ;; 0xe0001004
   \   000001E6   0x6812             LDR      R2,[R2, #+0]
   \   000001E8   0x5042             STR      R2,[R0, R1]
    371          		/**
    372          		 * TODO: warning. there is a bit of a hack here, todo: improve.
    373          		 * currently output signals/times signalTimerUp from the previous revolutions could be
    374          		 * still used because they have crossed the revolution boundary
    375          		 * but we are already repurposing the output signals, but everything works because we
    376          		 * are not affecting that space in memory. todo: use two instances of 'ignitionSignals'
    377          		 */
    378          		float maxAllowedDwellAngle = (int) (engineConfiguration->engineCycle / 2); // the cast is about making Coverity happy
   \   000001EA   0x....             LDR.N    R0,??DataTable13_20
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \   000001EE   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   000001F2   0x2102             MOVS     R1,#+2
   \   000001F4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001F8   0xEE00 0x0A10      VMOV     S0,R0
   \   000001FC   0xEEB8 0x8AC0      VCVT.F32.S32 S16,S0
    379          
    380          		if (engineConfiguration->ignitionMode == IM_ONE_COIL) {
   \   00000200   0x....             LDR.N    R0,??DataTable13_20
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0xF8D0 0x01BC      LDR      R0,[R0, #+444]
   \   00000208   0x2800             CMP      R0,#+0
   \   0000020A   0xD113             BNE.N    ??mainTriggerCallback_12
    381          			maxAllowedDwellAngle = engineConfiguration->engineCycle / engineConfiguration->specs.cylindersCount / 1.1;
   \   0000020C   0x....             LDR.N    R0,??DataTable13_20
   \   0000020E   0x6800             LDR      R0,[R0, #+0]
   \   00000210   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   00000214   0x....             LDR.N    R1,??DataTable13_20
   \   00000216   0x6809             LDR      R1,[R1, #+0]
   \   00000218   0xF8D1 0x1194      LDR      R1,[R1, #+404]
   \   0000021C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000220   0x.... 0x....      BL       __aeabi_i2d
   \   00000224   0x....             LDR.N    R2,??DataTable13_41  ;; 0x9999999a
   \   00000226   0x....             LDR.N    R3,??DataTable13_42  ;; 0x3ff19999
   \   00000228   0x.... 0x....      BL       __aeabi_ddiv
   \   0000022C   0x.... 0x....      BL       __aeabi_d2f
   \   00000230   0xEE08 0x0A10      VMOV     S16,R0
    382          		}
    383          
    384          		if (engine->engineState.dwellAngle == 0) {
   \                     ??mainTriggerCallback_12:
   \   00000234   0x....             LDR.N    R0,??DataTable13_8
   \   00000236   0x6800             LDR      R0,[R0, #+0]
   \   00000238   0xF500 0x50F0      ADD      R0,R0,#+7680
   \   0000023C   0x30BC             ADDS     R0,R0,#+188
   \   0000023E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000242   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000246   0xEEF1 0xFA10      FMSTAT   
   \   0000024A   0xD104             BNE.N    ??mainTriggerCallback_13
    385          			warning(OBD_PCM_Processor_Fault, "dwell is zero?");
   \   0000024C   0x....             LDR.N    R1,??DataTable13_43
   \   0000024E   0xF240 0x205E      MOVW     R0,#+606
   \   00000252   0x.... 0x....      BL       warning
    386          		}
    387          		if (engine->engineState.dwellAngle > maxAllowedDwellAngle) {
   \                     ??mainTriggerCallback_13:
   \   00000256   0x....             LDR.N    R0,??DataTable13_8
   \   00000258   0x6800             LDR      R0,[R0, #+0]
   \   0000025A   0xF500 0x50F0      ADD      R0,R0,#+7680
   \   0000025E   0x30BC             ADDS     R0,R0,#+188
   \   00000260   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000264   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000268   0xEEF1 0xFA10      FMSTAT   
   \   0000026C   0xD50D             BPL.N    ??mainTriggerCallback_14
    388          			warning(OBD_PCM_Processor_Fault, "dwell angle too long: %f", engine->engineState.dwellAngle);
   \   0000026E   0xF641 0x60BC      MOVW     R0,#+7868
   \   00000272   0x....             LDR.N    R1,??DataTable13_8
   \   00000274   0x6809             LDR      R1,[R1, #+0]
   \   00000276   0x5840             LDR      R0,[R0, R1]
   \   00000278   0x.... 0x....      BL       __aeabi_f2d
   \   0000027C   0x0002             MOVS     R2,R0
   \   0000027E   0x000B             MOVS     R3,R1
   \   00000280   0x....             LDR.N    R1,??DataTable13_44
   \   00000282   0xF240 0x205E      MOVW     R0,#+606
   \   00000286   0x.... 0x....      BL       warning
    389          		}
    390          
    391          		// todo: add some check for dwell overflow? like 4 times 6 ms while engine cycle is less then that
    392          
    393          		if (cisnan(engine->engineState.advance)) {
   \                     ??mainTriggerCallback_14:
   \   0000028A   0x....             LDR.N    R0,??DataTable13_8
   \   0000028C   0x6800             LDR      R0,[R0, #+0]
   \   0000028E   0xF510 0x50F6      ADDS     R0,R0,#+7872
   \   00000292   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000296   0x.... 0x....      BL       __iar_FDtest
   \   0000029A   0x2802             CMP      R0,#+2
   \   0000029C   0xD075             BEQ.N    ??mainTriggerCallback_0
    394          			// error should already be reported
    395          			return;
    396          		}
    397          		initializeIgnitionActions(engine->engineState.advance, engine->engineState.dwellAngle,
    398          				&engine->engineConfiguration2->ignitionEvents[revolutionIndex] PASS_ENGINE_PARAMETER);
   \                     ??mainTriggerCallback_15:
   \   0000029E   0xF641 0x6008      MOVW     R0,#+7688
   \   000002A2   0x....             LDR.N    R1,??DataTable13_8
   \   000002A4   0x6809             LDR      R1,[R1, #+0]
   \   000002A6   0x6A89             LDR      R1,[R1, #+40]
   \   000002A8   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000002AC   0xF500 0x503C      ADD      R0,R0,#+12032
   \   000002B0   0x3050             ADDS     R0,R0,#+80
   \   000002B2   0x....             LDR.N    R1,??DataTable13_8
   \   000002B4   0x6809             LDR      R1,[R1, #+0]
   \   000002B6   0xF501 0x51F0      ADD      R1,R1,#+7680
   \   000002BA   0x31BC             ADDS     R1,R1,#+188
   \   000002BC   0xEDD1 0x0A00      VLDR     S1,[R1, #0]
   \   000002C0   0x....             LDR.N    R1,??DataTable13_8
   \   000002C2   0x6809             LDR      R1,[R1, #+0]
   \   000002C4   0xF511 0x51F6      ADDS     R1,R1,#+7872
   \   000002C8   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   000002CC   0x.... 0x....      BL       _Z25initializeIgnitionActionsffP9ArrayListI13IgnitionEventLi80EE
    399          		engine->m.ignitionSchTime = GET_TIMESTAMP() - engine->m.beforeIgnitionSch;
   \   000002D0   0x....             LDR.N    R0,??DataTable13_33  ;; 0xe0001004
   \   000002D2   0x6800             LDR      R0,[R0, #+0]
   \   000002D4   0xF242 0x31D0      MOVW     R1,#+9168
   \   000002D8   0x....             LDR.N    R2,??DataTable13_8
   \   000002DA   0x6812             LDR      R2,[R2, #+0]
   \   000002DC   0x5889             LDR      R1,[R1, R2]
   \   000002DE   0x1A40             SUBS     R0,R0,R1
   \   000002E0   0xF242 0x31D4      MOVW     R1,#+9172
   \   000002E4   0x....             LDR.N    R2,??DataTable13_8
   \   000002E6   0x6812             LDR      R2,[R2, #+0]
   \   000002E8   0x5088             STR      R0,[R1, R2]
    400          
    401          		engine->m.beforeInjectonSch = GET_TIMESTAMP();
   \   000002EA   0xF242 0x30D8      MOVW     R0,#+9176
   \   000002EE   0x....             LDR.N    R1,??DataTable13_8
   \   000002F0   0x6809             LDR      R1,[R1, #+0]
   \   000002F2   0x....             LDR.N    R2,??DataTable13_33  ;; 0xe0001004
   \   000002F4   0x6812             LDR      R2,[R2, #+0]
   \   000002F6   0x5042             STR      R2,[R0, R1]
    402          
    403          		if (isCrankingR(rpm)) {
   \   000002F8   0x2E01             CMP      R6,#+1
   \   000002FA   0xDB0D             BLT.N    ??mainTriggerCallback_16
   \   000002FC   0x....             LDR.N    R0,??DataTable13_19
   \   000002FE   0xF9B0 0x0068      LDRSH    R0,[R0, #+104]
   \   00000302   0x4286             CMP      R6,R0
   \   00000304   0xDA08             BGE.N    ??mainTriggerCallback_16
    404          			ENGINE(engineConfiguration2)->crankingInjectionEvents.addFuelEvents(
    405          					engineConfiguration->crankingInjectionMode PASS_ENGINE_PARAMETER);
   \   00000306   0x....             LDR.N    R0,??DataTable13_20
   \   00000308   0x6800             LDR      R0,[R0, #+0]
   \   0000030A   0xF8D0 0x11AC      LDR      R1,[R0, #+428]
   \   0000030E   0x....             LDR.N    R0,??DataTable13_5
   \   00000310   0x6A80             LDR      R0,[R0, #+40]
   \   00000312   0x.... 0x....      BL       _ZN12FuelSchedule13addFuelEventsE16injection_mode_e
   \   00000316   0xE00A             B.N      ??mainTriggerCallback_17
    406          		} else {
    407          			ENGINE(engineConfiguration2)->injectionEvents.addFuelEvents(
    408          					engineConfiguration->injectionMode PASS_ENGINE_PARAMETER);
   \                     ??mainTriggerCallback_16:
   \   00000318   0x....             LDR.N    R0,??DataTable13_20
   \   0000031A   0x6800             LDR      R0,[R0, #+0]
   \   0000031C   0xF8D0 0x11B0      LDR      R1,[R0, #+432]
   \   00000320   0x....             LDR.N    R0,??DataTable13_5
   \   00000322   0x6A80             LDR      R0,[R0, #+40]
   \   00000324   0xF500 0x50B8      ADD      R0,R0,#+5888
   \   00000328   0x3088             ADDS     R0,R0,#+136
   \   0000032A   0x.... 0x....      BL       _ZN12FuelSchedule13addFuelEventsE16injection_mode_e
    409          		}
    410          		engine->m.injectonSchTime = GET_TIMESTAMP() - engine->m.beforeInjectonSch;
   \                     ??mainTriggerCallback_17:
   \   0000032E   0x....             LDR.N    R0,??DataTable13_33  ;; 0xe0001004
   \   00000330   0x6800             LDR      R0,[R0, #+0]
   \   00000332   0xF242 0x31D8      MOVW     R1,#+9176
   \   00000336   0x....             LDR.N    R2,??DataTable13_8
   \   00000338   0x6812             LDR      R2,[R2, #+0]
   \   0000033A   0x5889             LDR      R1,[R1, R2]
   \   0000033C   0x1A40             SUBS     R0,R0,R1
   \   0000033E   0xF242 0x31DC      MOVW     R1,#+9180
   \   00000342   0x....             LDR.N    R2,??DataTable13_8
   \   00000344   0x6812             LDR      R2,[R2, #+0]
   \   00000346   0x5088             STR      R0,[R1, R2]
    411          	}
    412          
    413          //	triggerEventsQueue.executeAll(getCrankEventCounter());
    414          
    415          	handleFuel(eventIndex, rpm PASS_ENGINE_PARAMETER);
   \                     ??mainTriggerCallback_11:
   \   00000348   0x0031             MOVS     R1,R6
   \   0000034A   0x0028             MOVS     R0,R5
   \   0000034C   0x.... 0x....      BL       _Z10handleFuelji
    416          	handleSpark(eventIndex, rpm, &engine->engineConfiguration2->ignitionEvents[revolutionIndex] PASS_ENGINE_PARAMETER);
   \   00000350   0xF641 0x6008      MOVW     R0,#+7688
   \   00000354   0x....             LDR.N    R1,??DataTable13_8
   \   00000356   0x6809             LDR      R1,[R1, #+0]
   \   00000358   0x6A89             LDR      R1,[R1, #+40]
   \   0000035A   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   0000035E   0xF500 0x523C      ADD      R2,R0,#+12032
   \   00000362   0x3250             ADDS     R2,R2,#+80
   \   00000364   0x0031             MOVS     R1,R6
   \   00000366   0x0028             MOVS     R0,R5
   \   00000368   0x.... 0x....      BL       _Z11handleSparkjiP9ArrayListI13IgnitionEventLi80EE
    417          #if EFI_HISTOGRAMS && EFI_PROD_CODE
    418          	int diff = hal_lld_get_counter_value() - beforeCallback;
    419          	if (diff > 0)
    420          	hsAdd(&mainLoopHisto, diff);
    421          #endif /* EFI_HISTOGRAMS */
    422          
    423          	if (eventIndex == 0) {
   \   0000036C   0x2D00             CMP      R5,#+0
   \   0000036E   0xD10C             BNE.N    ??mainTriggerCallback_18
    424          		engine->m.mainTriggerCallbackTime = GET_TIMESTAMP() - engine->m.beforeMainTrigger;
   \   00000370   0x....             LDR.N    R0,??DataTable13_33  ;; 0xe0001004
   \   00000372   0x6800             LDR      R0,[R0, #+0]
   \   00000374   0x....             LDR.N    R1,??DataTable13_8
   \   00000376   0x6809             LDR      R1,[R1, #+0]
   \   00000378   0xF511 0x510F      ADDS     R1,R1,#+9152
   \   0000037C   0x6809             LDR      R1,[R1, #+0]
   \   0000037E   0x1A40             SUBS     R0,R0,R1
   \   00000380   0xF242 0x31C4      MOVW     R1,#+9156
   \   00000384   0x....             LDR.N    R2,??DataTable13_8
   \   00000386   0x6812             LDR      R2,[R2, #+0]
   \   00000388   0x5088             STR      R0,[R1, R2]
    425          	}
    426          }
   \                     ??mainTriggerCallback_18:
   \                     ??mainTriggerCallback_0:
   \   0000038A   0xECBD 0x8B02      VPOP     {D8}
   \   0000038E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    427          
    428          #if EFI_WAVE_CHART || defined(__DOXYGEN__)
    429          #include "wave_chart.h"
    430          #endif
    431          

   \                                 In section .text, align 2, keep-with-next
    432          static void showTriggerHistogram(void) {
   \                     _Z20showTriggerHistogramv:
   \   00000000   0xB580             PUSH     {R7,LR}
    433          	printAllCallbacksHistogram();
   \   00000002   0x.... 0x....      BL       _Z26printAllCallbacksHistogramv
    434          	showMainHistogram();
   \   00000006   0x.... 0x....      BL       showMainHistogram
    435          #if EFI_WAVE_CHART || defined(__DOXYGEN__)
    436          	showWaveChartHistogram();
   \   0000000A   0x.... 0x....      BL       _Z22showWaveChartHistogramv
    437          #endif
    438          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void MainTriggerCallback::init(Engine *engine) {
   \                     _ZN19MainTriggerCallback4initEP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    441          	efiAssertVoid(engine!=NULL, "engine NULL");
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD103             BNE.N    ??init_0
   \   0000000A   0x....             LDR.N    R0,??DataTable13_45
   \   0000000C   0x.... 0x....      BL       firmwareError
   \   00000010   0xE000             B.N      ??init_1
    442          	this->engine = engine;
   \                     ??init_0:
   \   00000012   0x6025             STR      R5,[R4, #+0]
    443          }
   \                     ??init_1:
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    444          

   \                                 In section .text, align 2, keep-with-next
    445          static void showMainInfo(Engine *engine) {
   \                     _Z12showMainInfoP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x0004             MOVS     R4,R0
    446          #if EFI_PROD_CODE
    447          	int rpm = engine->rpmCalculator.rpm(PASS_ENGINE_PARAMETER_F);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
   \   00000010   0x0005             MOVS     R5,R0
    448          	float el = getEngineLoadT(PASS_ENGINE_PARAMETER_F);
   \   00000012   0x.... 0x....      BL       _Z14getEngineLoadTv
   \   00000016   0xEEB0 0x8A40      VMOV.F32 S16,S0
    449          	scheduleMsg(logger, "rpm %d engine_load %f", rpm, el);
   \   0000001A   0xEE18 0x0A10      VMOV     R0,S16
   \   0000001E   0x.... 0x....      BL       __aeabi_f2d
   \   00000022   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0x....             LDR.N    R1,??DataTable13_46
   \   0000002A   0x....             LDR.N    R0,??DataTable13_23
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       scheduleMsg
    450          	scheduleMsg(logger, "fuel %fms timing %f", getFuelMs(rpm PASS_ENGINE_PARAMETER),
    451          			engine->engineState.timingAdvance);
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       _Z9getFuelMsi
   \   00000038   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   0000003C   0xF641 0x60B8      MOVW     R0,#+7864
   \   00000040   0x5900             LDR      R0,[R0, R4]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000004A   0xEE18 0x0A90      VMOV     R0,S17
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x0002             MOVS     R2,R0
   \   00000054   0x000B             MOVS     R3,R1
   \   00000056   0x....             LDR.N    R1,??DataTable13_47
   \   00000058   0x....             LDR.N    R0,??DataTable13_23
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x.... 0x....      BL       scheduleMsg
    452          #endif
    453          }
   \   00000060   0xB002             ADD      SP,SP,#+8
   \   00000062   0xECBD 0x8B02      VPOP     {D8}
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    454          

   \                                 In section .text, align 2, keep-with-next
    455          void initMainEventListener(Logging *sharedLogger, Engine *engine) {
   \                     _Z21initMainEventListenerP7LoggingP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    456          	logger = sharedLogger;
   \   00000006   0x....             LDR.N    R0,??DataTable13_23
   \   00000008   0x6004             STR      R4,[R0, #+0]
    457          	efiAssertVoid(engine!=NULL, "null engine");
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD103             BNE.N    ??initMainEventListener_0
   \   0000000E   0x....             LDR.N    R0,??DataTable13_48
   \   00000010   0x.... 0x....      BL       firmwareError
   \   00000014   0xE025             B.N      ??initMainEventListener_1
    458          
    459          	mainTriggerCallbackInstance.init(engine);
   \                     ??initMainEventListener_0:
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0x....             LDR.N    R0,??DataTable13_49
   \   0000001A   0x.... 0x....      BL       _ZN19MainTriggerCallback4initEP6Engine
    460          
    461          #if EFI_PROD_CODE || defined(__DOXYGEN__)
    462          	addConsoleAction("performanceinfo", showTriggerHistogram);
   \   0000001E   0x....             LDR.N    R1,??DataTable13_50
   \   00000020   0x....             LDR.N    R0,??DataTable13_51
   \   00000022   0x.... 0x....      BL       addConsoleAction
    463          	addConsoleActionP("maininfo", (VoidPtr) showMainInfo, engine);
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0x....             LDR.N    R1,??DataTable13_52
   \   0000002A   0x....             LDR.N    R0,??DataTable13_53
   \   0000002C   0x.... 0x....      BL       addConsoleActionP
    464          
    465          	printMsg(logger, "initMainLoop: %d", currentTimeMillis());
   \   00000030   0x.... 0x....      BL       currentTimeMillis
   \   00000034   0x0002             MOVS     R2,R0
   \   00000036   0x....             LDR.N    R1,??DataTable13_54
   \   00000038   0x....             LDR.N    R0,??DataTable13_23
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x.... 0x....      BL       printMsg
    466          	if (!isInjectionEnabled(mainTriggerCallbackInstance.engine->engineConfiguration))
   \   00000040   0x....             LDR.N    R0,??DataTable13_49
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x6A40             LDR      R0,[R0, #+36]
   \   00000046   0x.... 0x....      BL       _Z18isInjectionEnabledP22engine_configuration_s
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD104             BNE.N    ??initMainEventListener_2
    467          		printMsg(logger, "!!!!!!!!!!!!!!!!!!! injection disabled");
   \   0000004E   0x....             LDR.N    R1,??DataTable13_55
   \   00000050   0x....             LDR.N    R0,??DataTable13_23
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x.... 0x....      BL       printMsg
    468          #endif
    469          
    470          #if EFI_HISTOGRAMS
    471          	initHistogram(&mainLoopHisto, "main callback");
    472          #endif /* EFI_HISTOGRAMS */
    473          
    474          	addTriggerEventListener(mainTriggerCallback, "main loop", engine);
   \                     ??initMainEventListener_2:
   \   00000058   0x002A             MOVS     R2,R5
   \   0000005A   0x....             LDR.N    R1,??DataTable13_56
   \   0000005C   0x....             LDR.N    R0,??DataTable13_57
   \   0000005E   0x.... 0x....      BL       _Z23addTriggerEventListenerPFv15trigger_event_ejEPKcP6Engine
    475          }
   \                     ??initMainEventListener_1:
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    476          

   \                                 In section .text, align 2, keep-with-next
    477          int isIgnitionTimingError(void) {
   \                     _Z21isIgnitionTimingErrorv:
   \   00000000   0xB580             PUSH     {R7,LR}
    478          	return ignitionErrorDetection.sum(6) > 4;
   \   00000002   0x2106             MOVS     R1,#+6
   \   00000004   0x....             LDR.N    R0,??DataTable13_1
   \   00000006   0x.... 0x....      BL       _ZN13cyclic_bufferIiE3sumEi
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xDB01             BLT.N    ??isIgnitionTimingError_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??isIgnitionTimingError_1
   \                     ??isIgnitionTimingError_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??isIgnitionTimingError_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    479          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x3A400C01         DC32     0x3a400c01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     triggerVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     ignitionErrorDetection

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     __dso_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     _ZN13cyclic_bufferIiED1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     enginePins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     _engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     `?<Constant "NaN injection pulse">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     `?<Constant "Negative injection pu...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     `?<Constant "duration cannot be ne...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     `?<Constant "NaN in scheduleOutput">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     `?<Constant "signal is NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     _Z26startSimultaniousInjectionP6Engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     `?<Constant "out up">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     _Z24endSimultaniousInjectionP6Engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x........         DC32     `?<Constant "out down">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x........         DC32     `?<Constant "lowstck#3">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x........         DC32     `?<Constant "handleFuel/event index">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x........         DC32     persistentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   0x........         DC32     `?<Constant "invalid dwell: %f at %d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \   00000000   0x........         DC32     `?<Constant "Negative spark delay=%f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_23:
   \   00000000   0x........         DC32     logger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_24:
   \   00000000   0x........         DC32     _Z11turnPinHighP14NamedOutputPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_25:
   \   00000000   0x........         DC32     `?<Constant "spark up">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_26:
   \   00000000   0x........         DC32     _Z10turnPinLowP14NamedOutputPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_27:
   \   00000000   0x........         DC32     `?<Constant "spark 1down">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_28:
   \   00000000   0x........         DC32     iHead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_29:
   \   00000000   0x........         DC32     `?<Constant "spark 2down">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_30:
   \   00000000   0x........         DC32     mainLoopHisto

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_31:
   \   00000000   0x........         DC32     _engine+0x1EB4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_32:
   \   00000000   0x........         DC32     _engine+0x1EB8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_33:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_34:
   \   00000000   0x........         DC32     hasFirmwareErrorFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_35:
   \   00000000   0x........         DC32     `?<Constant "trigger/event index">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_36:
   \   00000000   0x........         DC32     `?<Constant "lowstck#2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_37:
   \   00000000   0x........         DC32     `?<Constant "noisy trigger">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_38:
   \   00000000   0x........         DC32     `?<Constant "skipping stroke due t...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_39:
   \   00000000   0x........         DC32     `?<Constant "invalid ignMathCalcul...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_40:
   \   00000000   0x........         DC32     `?<Constant "knock">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_41:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_42:
   \   00000000   0x3FF19999         DC32     0x3ff19999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_43:
   \   00000000   0x........         DC32     `?<Constant "dwell is zero?">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_44:
   \   00000000   0x........         DC32     `?<Constant "dwell angle too long: %f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_45:
   \   00000000   0x........         DC32     `?<Constant "engine NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_46:
   \   00000000   0x........         DC32     `?<Constant "rpm %d engine_load %f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_47:
   \   00000000   0x........         DC32     `?<Constant "fuel %fms timing %f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_48:
   \   00000000   0x........         DC32     `?<Constant "null engine">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_49:
   \   00000000   0x........         DC32     mainTriggerCallbackInstance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_50:
   \   00000000   0x........         DC32     _Z20showTriggerHistogramv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_51:
   \   00000000   0x........         DC32     `?<Constant "performanceinfo">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_52:
   \   00000000   0x........         DC32     _Z12showMainInfoP6Engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_53:
   \   00000000   0x........         DC32     `?<Constant "maininfo">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_54:
   \   00000000   0x........         DC32     `?<Constant "initMainLoop: %d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_55:
   \   00000000   0x........         DC32     `?<Constant "!!!!!!!!!!!!!!!!!!! i...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_56:
   \   00000000   0x........         DC32     `?<Constant "main loop">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_57:
   \   00000000   0x........         DC32     _Z19mainTriggerCallback15trigger_event_ej

   \                                 In section .init_array, align 4, keep-with-next, root
   \   00000000   0x........         DC32    RELOC_ARM_TARGET1 __sti__routine

   \                                 In section .rodata, align 4
   \                     `?<Constant "NaN injection pulse">`:
   \   00000000   0x4E 0x61          DC8 "NaN injection pulse"
   \              0x4E 0x20    
   \              0x69 0x6E    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x75    
   \              0x6C 0x73    
   \              0x65 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Negative injection pu...">`:
   \   00000000   0x4E 0x65          DC8 "Negative injection pulse %f"
   \              0x67 0x61    
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x20 0x69    
   \              0x6E 0x6A    
   \              0x65 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x70    
   \              0x75 0x6C    
   \              0x73 0x65    
   \              0x20 0x25    
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "duration cannot be ne...">`:
   \   00000000   0x64 0x75          DC8 "duration cannot be negative: %d"
   \              0x72 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x63    
   \              0x61 0x6E    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x62 0x65    
   \              0x20 0x6E    
   \              0x65 0x67    
   \              0x61 0x74    
   \              0x69 0x76    
   \              0x65 0x3A    
   \              0x20 0x25    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "NaN in scheduleOutput">`:
   \   00000000   0x4E 0x61          DC8 "NaN in scheduleOutput"
   \              0x4E 0x20    
   \              0x69 0x6E    
   \              0x20 0x73    
   \              0x63 0x68    
   \              0x65 0x64    
   \              0x75 0x6C    
   \              0x65 0x4F    
   \              0x75 0x74    
   \              0x70 0x75    
   \              0x74 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "signal is NULL">`:
   \   00000000   0x73 0x69          DC8 "signal is NULL"
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "out up">`:
   \   00000000   0x6F 0x75          DC8 "out up"
   \              0x74 0x20    
   \              0x75 0x70    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "out down">`:
   \   00000000   0x6F 0x75          DC8 "out down"
   \              0x74 0x20    
   \              0x64 0x6F    
   \              0x77 0x6E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#3">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#3"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x33 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "handleFuel/event index">`:
   \   00000000   0x68 0x61          DC8 "handleFuel/event index"
   \              0x6E 0x64    
   \              0x6C 0x65    
   \              0x46 0x75    
   \              0x65 0x6C    
   \              0x2F 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x20 0x69    
   \              0x6E 0x64    
   \              0x65 0x78    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid dwell: %f at %d">`:
   \   00000000   0x69 0x6E          DC8 "invalid dwell: %f at %d"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x64 0x77    
   \              0x65 0x6C    
   \              0x6C 0x3A    
   \              0x20 0x25    
   \              0x66 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Negative spark delay=%f">`:
   \   00000000   0x4E 0x65          DC8 "Negative spark delay=%f"
   \              0x67 0x61    
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x72 0x6B    
   \              0x20 0x64    
   \              0x65 0x6C    
   \              0x61 0x79    
   \              0x3D 0x25    
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spark up">`:
   \   00000000   0x73 0x70          DC8 "spark up"
   \              0x61 0x72    
   \              0x6B 0x20    
   \              0x75 0x70    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "spark 1down">`:
   \   00000000   0x73 0x70          DC8 "spark 1down"
   \              0x61 0x72    
   \              0x6B 0x20    
   \              0x31 0x64    
   \              0x6F 0x77    
   \              0x6E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spark 2down">`:
   \   00000000   0x73 0x70          DC8 "spark 2down"
   \              0x61 0x72    
   \              0x6B 0x20    
   \              0x32 0x64    
   \              0x6F 0x77    
   \              0x6E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "trigger/event index">`:
   \   00000000   0x74 0x72          DC8 "trigger/event index"
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x2F    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x69 0x6E    
   \              0x64 0x65    
   \              0x78 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#2">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#2"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x32 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "noisy trigger">`:
   \   00000000   0x6E 0x6F          DC8 "noisy trigger"
   \              0x69 0x73    
   \              0x79 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "skipping stroke due t...">`:
   \   00000000   0x73 0x6B          DC8 "skipping stroke due to rpm=%d"
   \              0x69 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x20 0x73    
   \              0x74 0x72    
   \              0x6F 0x6B    
   \              0x65 0x20    
   \              0x64 0x75    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x72    
   \              0x70 0x6D    
   \              0x3D 0x25    
   \              0x64 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid ignMathCalcul...">`:
   \   00000000   0x69 0x6E          DC8 "invalid ignMathCalculateAtIndex %d"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x69 0x67    
   \              0x6E 0x4D    
   \              0x61 0x74    
   \              0x68 0x43    
   \              0x61 0x6C    
   \              0x63 0x75    
   \              0x6C 0x61    
   \              0x74 0x65    
   \              0x41 0x74    
   \              0x49 0x6E    
   \              0x64 0x65    
   \              0x78 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "knock">`:
   \   00000000   0x6B 0x6E          DC8 "knock"
   \              0x6F 0x63    
   \              0x6B 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "dwell is zero?">`:
   \   00000000   0x64 0x77          DC8 "dwell is zero?"
   \              0x65 0x6C    
   \              0x6C 0x20    
   \              0x69 0x73    
   \              0x20 0x7A    
   \              0x65 0x72    
   \              0x6F 0x3F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "dwell angle too long: %f">`:
   \   00000000   0x64 0x77          DC8 "dwell angle too long: %f"
   \              0x65 0x6C    
   \              0x6C 0x20    
   \              0x61 0x6E    
   \              0x67 0x6C    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x3A 0x20    
   \              0x25 0x66    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "rpm %d engine_load %f">`:
   \   00000000   0x72 0x70          DC8 "rpm %d engine_load %f"
   \              0x6D 0x20    
   \              0x25 0x64    
   \              0x20 0x65    
   \              0x6E 0x67    
   \              0x69 0x6E    
   \              0x65 0x5F    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x25    
   \              0x66 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "fuel %fms timing %f">`:
   \   00000000   0x66 0x75          DC8 "fuel %fms timing %f"
   \              0x65 0x6C    
   \              0x20 0x25    
   \              0x66 0x6D    
   \              0x73 0x20    
   \              0x74 0x69    
   \              0x6D 0x69    
   \              0x6E 0x67    
   \              0x20 0x25    
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "null engine">`:
   \   00000000   0x6E 0x75          DC8 "null engine"
   \              0x6C 0x6C    
   \              0x20 0x65    
   \              0x6E 0x67    
   \              0x69 0x6E    
   \              0x65 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "performanceinfo">`:
   \   00000000   0x70 0x65          DC8 "performanceinfo"
   \              0x72 0x66    
   \              0x6F 0x72    
   \              0x6D 0x61    
   \              0x6E 0x63    
   \              0x65 0x69    
   \              0x6E 0x66    
   \              0x6F 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "maininfo">`:
   \   00000000   0x6D 0x61          DC8 "maininfo"
   \              0x69 0x6E    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "initMainLoop: %d">`:
   \   00000000   0x69 0x6E          DC8 "initMainLoop: %d"
   \              0x69 0x74    
   \              0x4D 0x61    
   \              0x69 0x6E    
   \              0x4C 0x6F    
   \              0x6F 0x70    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "!!!!!!!!!!!!!!!!!!! i...">`:
   \   00000000   0x21 0x21          DC8 "!!!!!!!!!!!!!!!!!!! injection disabled"
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x21    
   \              0x21 0x20    
   \              0x69 0x6E    
   \              0x6A 0x65    
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "main loop">`:
   \   00000000   0x6D 0x61          DC8 "main loop"
   \              0x69 0x6E    
   \              0x20 0x6C    
   \              0x6F 0x6F    
   \              0x70 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "engine NULL">`:
   \   00000000   0x65 0x6E          DC8 "engine NULL"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    

   \                                 In section .text, align 2
   \   __code __interwork __softfp cyclic_buffer<int>::subobject cyclic_buffer()
   \                     _ZN13cyclic_bufferIiEC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13cyclic_bufferIiEC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp cyclic_buffer<int>::subobject ~cyclic_buffer()
   \                     _ZN13cyclic_bufferIiED2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13cyclic_bufferIiED1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    480          
    481          #endif /* EFI_ENGINE_CONTROL */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MainTriggerCallback::init(Engine *)
        16   -> firmwareError
       8   __sti__routine()
         8   -> LocalVersionHolder::LocalVersionHolder()
         8   -> __aeabi_atexit
         8   -> cyclic_buffer<int>::cyclic_buffer()
      24   assertNotInList<IgnitionEvent>(IgnitionEvent *, IgnitionEvent *)
        24   -> firmwareError
        24   -> warning
       0   cyclic_buffer<int>::add(int)
      16   cyclic_buffer<int>::baseC(int)
        16   -> cyclic_buffer<int>::setSize(int)
       8   cyclic_buffer<int>::clear()
         8   -> memset
       8   cyclic_buffer<int>::cyclic_buffer()
         8   -> cyclic_buffer<int>::baseC(int)
      16   cyclic_buffer<int>::setSize(int)
        16   -> cyclic_buffer<int>::clear()
       8   cyclic_buffer<int>::subobject cyclic_buffer()
         8   -> cyclic_buffer<int>::cyclic_buffer()
       8   cyclic_buffer<int>::subobject ~cyclic_buffer()
         8   -> cyclic_buffer<int>::~cyclic_buffer()
      12   cyclic_buffer<int>::sum(int)
       0   cyclic_buffer<int>::~cyclic_buffer()
      16   endSimultaniousInjection(Engine *)
        16   -> turnPinLow(NamedOutputPin *)
      32   handleFuel(uint32_t, int)
        32   -> AccelEnrichmemnt::onEngineCycle()
        32   -> AccelEnrichmemnt::onEngineCycleTps()
        32   -> TriggerShape::getLength() const
        32   -> firmwareError
        32   -> getFuelMs(int)
        32   -> getRemainingStack
        32   -> handleFuelInjectionEvent(InjectionEvent *, int)
        32   -> isInjectionEnabled(engine_configuration_s *)
      48   handleFuelInjectionEvent(InjectionEvent *, int)
        48   -> __aeabi_f2d
        48   -> __iar_FDtest
        48   -> firmwareError
        48   -> getRevolutionCounter()
        48   -> getTimeNowUs
        48   -> scheduleOutput(OutputSignal *, int64_t, float, float)
        48   -> scheduleTask(char const *, scheduling_s *, int, schfunc_t, void *)
        48   -> warning
      48   handleSpark(uint32_t, int, IgnitionEventList *)
        48   -> handleSparkEvent(uint32_t, IgnitionEvent *, int)
        48   -> scheduleTask(char const *, scheduling_s *, int, schfunc_t, void *)
      56   handleSparkEvent(uint32_t, IgnitionEvent *, int)
        56   -> __aeabi_f2d
        56   -> __iar_FDtest
        56   -> assertNotInList<IgnitionEvent>(IgnitionEvent *, IgnitionEvent *)
        56   -> cyclic_buffer<int>::add(int)
        56   -> findTriggerPosition(event_trigger_position_s *, float)
        56   -> firmwareError
        56   -> scheduleMsg
        56   -> scheduleTask(char const *, scheduling_s *, int, schfunc_t, void *)
      24   ignitionCalc(int)
        24   -> __aeabi_f2d
        24   -> __iar_FDtest
        24   -> firmwareError
      16   initMainEventListener(Logging *, Engine *)
        16   -> MainTriggerCallback::init(Engine *)
        16   -> addConsoleAction
        16   -> addConsoleActionP
        16   -> addTriggerEventListener(ShaftPositionListener, char const *, Engine *)
        16   -> currentTimeMillis
        16   -> firmwareError
        16   -> isInjectionEnabled(engine_configuration_s *)
        16   -> printMsg
       8   isIgnitionTimingError()
         8   -> cyclic_buffer<int>::sum(int)
      32   mainTriggerCallback(trigger_event_e, uint32_t)
        32   -> Engine::knockLogic(float)
        32   -> FuelSchedule::addFuelEvents(injection_mode_e)
        32   -> LocalVersionHolder::isOld()
        32   -> RpmCalculator::getRevolutionCounter()
        32   -> RpmCalculator::rpm()
        32   -> TriggerShape::getSize() const
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_f2d
        32   -> __aeabi_i2d
        32   -> __iar_FDtest
        32   -> firmwareError
        32   -> getFuelMs(int)
        32   -> getInternalAdcValue(char const *, adc_channel_e)
        32   -> getRemainingStack
        32   -> handleFuel(uint32_t, int)
        32   -> handleSpark(uint32_t, int, IgnitionEventList *)
        32   -> ignitionCalc(int)
        32   -> initializeIgnitionActions(float, float, IgnitionEventList *)
        32   -> prepareOutputSignals()
        32   -> warning
      16   memset
        16   -> __aeabi_memset
       8   showMainHistogram
         8   -> printHistogram(Logging *, histogram_s *)
      32   showMainInfo(Engine *)
        32   -> RpmCalculator::rpm()
        32   -> __aeabi_f2d
        32   -> getEngineLoadT()
        32   -> getFuelMs(int)
        32   -> scheduleMsg
       8   showTriggerHistogram()
         8   -> printAllCallbacksHistogram()
         8   -> showMainHistogram
         8   -> showWaveChartHistogram()
      16   startSimultaniousInjection(Engine *)
        16   -> turnPinHigh(NamedOutputPin *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  ?<Constant "!!!!!!!!!!!!!!!!!!! i...">
      24  ?<Constant "NaN in scheduleOutput">
      20  ?<Constant "NaN injection pulse">
      28  ?<Constant "Negative injection pu...">
      24  ?<Constant "Negative spark delay=%f">
      32  ?<Constant "duration cannot be ne...">
      28  ?<Constant "dwell angle too long: %f">
      16  ?<Constant "dwell is zero?">
      12  ?<Constant "engine NULL">
      20  ?<Constant "fuel %fms timing %f">
      24  ?<Constant "handleFuel/event index">
      20  ?<Constant "initMainLoop: %d">
      24  ?<Constant "invalid dwell: %f at %d">
      36  ?<Constant "invalid ignMathCalcul...">
       8  ?<Constant "knock">
      12  ?<Constant "lowstck#2">
      12  ?<Constant "lowstck#3">
      12  ?<Constant "main loop">
      12  ?<Constant "maininfo">
      16  ?<Constant "noisy trigger">
      12  ?<Constant "null engine">
      12  ?<Constant "out down">
       8  ?<Constant "out up">
      16  ?<Constant "performanceinfo">
      24  ?<Constant "rpm %d engine_load %f">
      16  ?<Constant "signal is NULL">
      32  ?<Constant "skipping stroke due t...">
      12  ?<Constant "spark 1down">
      12  ?<Constant "spark 2down">
      12  ?<Constant "spark up">
      20  ?<Constant "trigger/event index">
       4  ??DataTable11
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_23
       4  ??DataTable13_24
       4  ??DataTable13_25
       4  ??DataTable13_26
       4  ??DataTable13_27
       4  ??DataTable13_28
       4  ??DataTable13_29
       4  ??DataTable13_3
       4  ??DataTable13_30
       4  ??DataTable13_31
       4  ??DataTable13_32
       4  ??DataTable13_33
       4  ??DataTable13_34
       4  ??DataTable13_35
       4  ??DataTable13_36
       4  ??DataTable13_37
       4  ??DataTable13_38
       4  ??DataTable13_39
       4  ??DataTable13_4
       4  ??DataTable13_40
       4  ??DataTable13_41
       4  ??DataTable13_42
       4  ??DataTable13_43
       4  ??DataTable13_44
       4  ??DataTable13_45
       4  ??DataTable13_46
       4  ??DataTable13_47
       4  ??DataTable13_48
       4  ??DataTable13_49
       4  ??DataTable13_5
       4  ??DataTable13_50
       4  ??DataTable13_51
       4  ??DataTable13_52
       4  ??DataTable13_53
       4  ??DataTable13_54
       4  ??DataTable13_55
       4  ??DataTable13_56
       4  ??DataTable13_57
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable5
       4  ??DataTable8
      22  MainTriggerCallback::init(Engine *)
      32  __sti__routine()
      68  assertNotInList<IgnitionEvent>(IgnitionEvent *, IgnitionEvent *)
       4  cyccnt
      48  cyclic_buffer<int>::add(int)
      22  cyclic_buffer<int>::baseC(int)
      30  cyclic_buffer<int>::clear()
      16  cyclic_buffer<int>::cyclic_buffer()
      28  cyclic_buffer<int>::setSize(int)
      12  cyclic_buffer<int>::subobject cyclic_buffer()
      12  cyclic_buffer<int>::subobject ~cyclic_buffer()
      58  cyclic_buffer<int>::sum(int)
       2  cyclic_buffer<int>::~cyclic_buffer()
      38  endSimultaniousInjection(Engine *)
     228  handleFuel(uint32_t, int)
     358  handleFuelInjectionEvent(InjectionEvent *, int)
     288  handleSpark(uint32_t, int, IgnitionEventList *)
     374  handleSparkEvent(uint32_t, IgnitionEvent *, int)
       4  iHead
      98  ignitionCalc(int)
     268  ignitionErrorDetection
     100  initMainEventListener(Logging *, Engine *)
      24  isIgnitionTimingError()
       4  logger
    3616  mainLoopHisto
     912  mainTriggerCallback(trigger_event_e, uint32_t)
       4  mainTriggerCallbackInstance
      22  memset
      18  showMainHistogram
     104  showMainInfo(Engine *)
      16  showTriggerHistogram()
      38  startSimultaniousInjection(Engine *)
       4  triggerVersion
      56  -- Other

 
 3 900 bytes in section .bss
     4 bytes in section .data
     4 bytes in section .init_array
   648 bytes in section .rodata
 3 212 bytes in section .text
 
 2 898 bytes of CODE  memory (+ 318 bytes shared)
   596 bytes of CONST memory (+  52 bytes shared)
 3 904 bytes of DATA  memory

Errors: none
Warnings: 3
