###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:38 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\adc.c                                              #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\adc.c -lCN F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\Obj\ --no_cse --no_unroll --no_inline  #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\a #
#                       dc.lst                                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ad #
#                       c.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\adc.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    adc.c
     30           * @brief   ADC Driver code.
     31           *
     32           * @addtogroup ADC
     33           * @{
     34           */
     35          
     36          #include "ch.h"
     37          #include "hal.h"
     38          
     39          #if HAL_USE_ADC || defined(__DOXYGEN__)
     40          
     41          /*===========================================================================*/
     42          /* Driver local definitions.                                                 */
     43          /*===========================================================================*/
     44          
     45          /*===========================================================================*/
     46          /* Driver exported variables.                                                */
     47          /*===========================================================================*/
     48          
     49          /*===========================================================================*/
     50          /* Driver local variables and types.                                         */
     51          /*===========================================================================*/
     52          
     53          /*===========================================================================*/
     54          /* Driver local functions.                                                   */
     55          /*===========================================================================*/
     56          
     57          /*===========================================================================*/
     58          /* Driver exported functions.                                                */
     59          /*===========================================================================*/
     60          
     61          /**
     62           * @brief   ADC Driver initialization.
     63           * @note    This function is implicitly invoked by @p halInit(), there is
     64           *          no need to explicitly initialize the driver.
     65           *
     66           * @init
     67           */

   \                                 In section .text, align 2, keep-with-next
     68          void adcInit(void) {
   \                     adcInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     69          
     70            adc_lld_init();
   \   00000002   0x.... 0x....      BL       adc_lld_init
     71          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
     72          
     73          /**
     74           * @brief   Initializes the standard part of a @p ADCDriver structure.
     75           *
     76           * @param[out] adcp     pointer to the @p ADCDriver object
     77           *
     78           * @init
     79           */

   \                                 In section .text, align 2, keep-with-next
     80          void adcObjectInit(ADCDriver *adcp) {
   \                     adcObjectInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     81          
     82            adcp->state    = ADC_STOP;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x7020             STRB     R0,[R4, #+0]
     83            adcp->config   = NULL;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6060             STR      R0,[R4, #+4]
     84            adcp->samples  = NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x60A0             STR      R0,[R4, #+8]
     85            adcp->depth    = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x60E0             STR      R0,[R4, #+12]
     86            adcp->grpp     = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6120             STR      R0,[R4, #+16]
     87          #if ADC_USE_WAIT
     88            adcp->thread   = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6160             STR      R0,[R4, #+20]
     89          #endif /* ADC_USE_WAIT */
     90          #if ADC_USE_MUTUAL_EXCLUSION
     91          #if CH_USE_MUTEXES
     92            chMtxInit(&adcp->mutex);
   \   0000001C   0xF114 0x0018      ADDS     R0,R4,#+24
   \   00000020   0x.... 0x....      BL       chMtxInit
     93          #else
     94            chSemInit(&adcp->semaphore, 1);
     95          #endif
     96          #endif /* ADC_USE_MUTUAL_EXCLUSION */
     97          #if defined(ADC_DRIVER_EXT_INIT_HOOK)
     98            ADC_DRIVER_EXT_INIT_HOOK(adcp);
     99          #endif
    100          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    101          
    102          /**
    103           * @brief   Configures and activates the ADC peripheral.
    104           *
    105           * @param[in] adcp      pointer to the @p ADCDriver object
    106           * @param[in] config    pointer to the @p ADCConfig object. Depending on
    107           *                      the implementation the value can be @p NULL.
    108           *
    109           * @api
    110           */

   \                                 In section .text, align 2, keep-with-next
    111          void adcStart(ADCDriver *adcp, const ADCConfig *config) {
   \                     adcStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    112          
    113            chDbgCheck(adcp != NULL, "adcStart");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD104             BNE.N    ??adcStart_0
   \   0000000A   0x2271             MOVS     R2,#+113
   \   0000000C   0x....             LDR.N    R1,??DataTable7
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    114          
    115            chSysLock();
   \                     ??adcStart_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    116            chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
    117                        "adcStart(), #1", "invalid state");
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD005             BEQ.N    ??adcStart_1
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD002             BEQ.N    ??adcStart_1
   \   0000002A   0x....             LDR.N    R0,??DataTable7_2
   \   0000002C   0x.... 0x....      BL       chDbgPanic
    118            adcp->config = config;
   \                     ??adcStart_1:
   \   00000030   0x6065             STR      R5,[R4, #+4]
    119            adc_lld_start(adcp);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       adc_lld_start
    120            adcp->state = ADC_READY;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    121            chSysUnlock();
   \   0000003C   0x.... 0x....      BL       dbg_check_unlock
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF380 0x8811      MSR      BASEPRI,R0
    122          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    123          
    124          /**
    125           * @brief   Deactivates the ADC peripheral.
    126           *
    127           * @param[in] adcp      pointer to the @p ADCDriver object
    128           *
    129           * @api
    130           */

   \                                 In section .text, align 2, keep-with-next
    131          void adcStop(ADCDriver *adcp) {
   \                     adcStop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    132          
    133            chDbgCheck(adcp != NULL, "adcStop");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??adcStop_0
   \   00000008   0x2285             MOVS     R2,#+133
   \   0000000A   0x....             LDR.N    R1,??DataTable7
   \   0000000C   0x....             LDR.N    R0,??DataTable7_3
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    134          
    135            chSysLock();
   \                     ??adcStop_0:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock
    136            chDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
    137                        "adcStop(), #1", "invalid state");
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD005             BEQ.N    ??adcStop_1
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD002             BEQ.N    ??adcStop_1
   \   00000028   0x....             LDR.N    R0,??DataTable7_4
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    138            adc_lld_stop(adcp);
   \                     ??adcStop_1:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       adc_lld_stop
    139            adcp->state = ADC_STOP;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7020             STRB     R0,[R4, #+0]
    140            chSysUnlock();
   \   00000038   0x.... 0x....      BL       dbg_check_unlock
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF380 0x8811      MSR      BASEPRI,R0
    141          }
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    142          
    143          /**
    144           * @brief   Starts an ADC conversion.
    145           * @details Starts an asynchronous conversion operation.
    146           * @note    The buffer is organized as a matrix of M*N elements where M is the
    147           *          channels number configured into the conversion group and N is the
    148           *          buffer depth. The samples are sequentially written into the buffer
    149           *          with no gaps.
    150           *
    151           * @param[in] adcp      pointer to the @p ADCDriver object
    152           * @param[in] grpp      pointer to a @p ADCConversionGroup object
    153           * @param[out] samples  pointer to the samples buffer
    154           * @param[in] depth     buffer depth (matrix rows number). The buffer depth
    155           *                      must be one or an even number.
    156           *
    157           * @api
    158           */

   \                                 In section .text, align 2, keep-with-next
    159          void adcStartConversion(ADCDriver *adcp,
    160                                  const ADCConversionGroup *grpp,
    161                                  adcsample_t *samples,
    162                                  size_t depth) {
   \                     adcStartConversion:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    163          
    164            chSysLock();
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000010   0x.... 0x....      BL       dbg_check_lock
    165            adcStartConversionI(adcp, grpp, samples, depth);
   \   00000014   0x003B             MOVS     R3,R7
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       adcStartConversionI
    166            chSysUnlock();
   \   00000020   0x.... 0x....      BL       dbg_check_unlock
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
    167          }
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    168          
    169          /**
    170           * @brief   Starts an ADC conversion.
    171           * @details Starts an asynchronous conversion operation.
    172           * @post    The callbacks associated to the conversion group will be invoked
    173           *          on buffer fill and error events.
    174           * @note    The buffer is organized as a matrix of M*N elements where M is the
    175           *          channels number configured into the conversion group and N is the
    176           *          buffer depth. The samples are sequentially written into the buffer
    177           *          with no gaps.
    178           *
    179           * @param[in] adcp      pointer to the @p ADCDriver object
    180           * @param[in] grpp      pointer to a @p ADCConversionGroup object
    181           * @param[out] samples  pointer to the samples buffer
    182           * @param[in] depth     buffer depth (matrix rows number). The buffer depth
    183           *                      must be one or an even number.
    184           *
    185           * @iclass
    186           */

   \                                 In section .text, align 2, keep-with-next
    187          void adcStartConversionI(ADCDriver *adcp,
    188                                   const ADCConversionGroup *grpp,
    189                                   adcsample_t *samples,
    190                                   size_t depth) {
   \                     adcStartConversionI:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    191          
    192            chDbgCheckClassI();
   \   0000000A   0x.... 0x....      BL       chDbgCheckClassI
    193            chDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
    194                       ((depth == 1) || ((depth & 1) == 0)),
    195                       "adcStartConversionI");
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD007             BEQ.N    ??adcStartConversionI_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD005             BEQ.N    ??adcStartConversionI_0
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD003             BEQ.N    ??adcStartConversionI_0
   \   0000001A   0x2F01             CMP      R7,#+1
   \   0000001C   0xD006             BEQ.N    ??adcStartConversionI_1
   \   0000001E   0x07F8             LSLS     R0,R7,#+31
   \   00000020   0xD504             BPL.N    ??adcStartConversionI_1
   \                     ??adcStartConversionI_0:
   \   00000022   0x22C3             MOVS     R2,#+195
   \   00000024   0x....             LDR.N    R1,??DataTable7
   \   00000026   0x....             LDR.N    R0,??DataTable7_5
   \   00000028   0x.... 0x....      BL       chDbgPanic3
    196            chDbgAssert((adcp->state == ADC_READY) ||
    197                        (adcp->state == ADC_COMPLETE) ||
    198                        (adcp->state == ADC_ERROR),
    199                        "adcStartConversionI(), #1", "not ready");
   \                     ??adcStartConversionI_1:
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xD008             BEQ.N    ??adcStartConversionI_2
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xD005             BEQ.N    ??adcStartConversionI_2
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0x2805             CMP      R0,#+5
   \   0000003C   0xD002             BEQ.N    ??adcStartConversionI_2
   \   0000003E   0x....             LDR.N    R0,??DataTable7_6
   \   00000040   0x.... 0x....      BL       chDbgPanic
    200          
    201            adcp->samples  = samples;
   \                     ??adcStartConversionI_2:
   \   00000044   0x60A6             STR      R6,[R4, #+8]
    202            adcp->depth    = depth;
   \   00000046   0x60E7             STR      R7,[R4, #+12]
    203            adcp->grpp     = grpp;
   \   00000048   0x6125             STR      R5,[R4, #+16]
    204            adcp->state    = ADC_ACTIVE;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    205            adc_lld_start_conversion(adcp);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       adc_lld_start_conversion
    206          }
   \   00000054   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    207          
    208          /**
    209           * @brief   Stops an ongoing conversion.
    210           * @details This function stops the currently ongoing conversion and returns
    211           *          the driver in the @p ADC_READY state. If there was no conversion
    212           *          being processed then the function does nothing.
    213           *
    214           * @param[in] adcp      pointer to the @p ADCDriver object
    215           *
    216           * @api
    217           */

   \                                 In section .text, align 2, keep-with-next
    218          void adcStopConversion(ADCDriver *adcp) {
   \                     adcStopConversion:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    219          
    220            chDbgCheck(adcp != NULL, "adcStopConversion");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??adcStopConversion_0
   \   00000008   0x22DC             MOVS     R2,#+220
   \   0000000A   0x....             LDR.N    R1,??DataTable7
   \   0000000C   0x....             LDR.N    R0,??DataTable7_7
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    221          
    222            chSysLock();
   \                     ??adcStopConversion_0:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock
    223            chDbgAssert((adcp->state == ADC_READY) ||
    224                        (adcp->state == ADC_ACTIVE),
    225                        "adcStopConversion(), #1", "invalid state");
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD005             BEQ.N    ??adcStopConversion_1
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD002             BEQ.N    ??adcStopConversion_1
   \   00000028   0x....             LDR.N    R0,??DataTable7_8
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    226            if (adcp->state != ADC_READY) {
   \                     ??adcStopConversion_1:
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x2802             CMP      R0,#+2
   \   00000032   0xD012             BEQ.N    ??adcStopConversion_2
    227              adc_lld_stop_conversion(adcp);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       adc_lld_stop_conversion
    228              adcp->grpp  = NULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6120             STR      R0,[R4, #+16]
    229              adcp->state = ADC_READY;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x7020             STRB     R0,[R4, #+0]
    230              _adc_reset_s(adcp);
   \   00000042   0x6960             LDR      R0,[R4, #+20]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD008             BEQ.N    ??adcStopConversion_2
   \   00000048   0x6960             LDR      R0,[R4, #+20]
   \   0000004A   0x0005             MOVS     R5,R0
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6160             STR      R0,[R4, #+20]
   \   00000050   0xF07F 0x0101      MVNS     R1,#+1
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       chSchWakeupS
    231            }
    232            chSysUnlock();
   \                     ??adcStopConversion_2:
   \   0000005A   0x.... 0x....      BL       dbg_check_unlock
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF380 0x8811      MSR      BASEPRI,R0
    233          }
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    234          
    235          /**
    236           * @brief   Stops an ongoing conversion.
    237           * @details This function stops the currently ongoing conversion and returns
    238           *          the driver in the @p ADC_READY state. If there was no conversion
    239           *          being processed then the function does nothing.
    240           *
    241           * @param[in] adcp      pointer to the @p ADCDriver object
    242           *
    243           * @iclass
    244           */

   \                                 In section .text, align 2, keep-with-next
    245          void adcStopConversionI(ADCDriver *adcp) {
   \                     adcStopConversionI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246          
    247            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    248            chDbgCheck(adcp != NULL, "adcStopConversionI");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??adcStopConversionI_0
   \   0000000C   0x22F8             MOVS     R2,#+248
   \   0000000E   0x....             LDR.N    R1,??DataTable7
   \   00000010   0x....             LDR.N    R0,??DataTable7_9
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    249            chDbgAssert((adcp->state == ADC_READY) ||
    250                        (adcp->state == ADC_ACTIVE) ||
    251                        (adcp->state == ADC_COMPLETE),
    252                        "adcStopConversionI(), #1", "invalid state");
   \                     ??adcStopConversionI_0:
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD008             BEQ.N    ??adcStopConversionI_1
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD005             BEQ.N    ??adcStopConversionI_1
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xD002             BEQ.N    ??adcStopConversionI_1
   \   00000028   0x....             LDR.N    R0,??DataTable7_10
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    253          
    254            if (adcp->state != ADC_READY) {
   \                     ??adcStopConversionI_1:
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x2802             CMP      R0,#+2
   \   00000032   0xD013             BEQ.N    ??adcStopConversionI_2
    255              adc_lld_stop_conversion(adcp);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       adc_lld_stop_conversion
    256              adcp->grpp  = NULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6120             STR      R0,[R4, #+16]
    257              adcp->state = ADC_READY;
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x7020             STRB     R0,[R4, #+0]
    258              _adc_reset_i(adcp);
   \   00000042   0x6960             LDR      R0,[R4, #+20]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD009             BEQ.N    ??adcStopConversionI_2
   \   00000048   0x6960             LDR      R0,[R4, #+20]
   \   0000004A   0x0005             MOVS     R5,R0
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6160             STR      R0,[R4, #+20]
   \   00000050   0xF07F 0x0001      MVNS     R0,#+1
   \   00000054   0x62A8             STR      R0,[R5, #+40]
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x.... 0x....      BL       chSchReadyI
    259            }
    260          }
   \                     ??adcStopConversionI_2:
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    261          
    262          #if ADC_USE_WAIT || defined(__DOXYGEN__)
    263          /**
    264           * @brief   Performs an ADC conversion.
    265           * @details Performs a synchronous conversion operation.
    266           * @note    The buffer is organized as a matrix of M*N elements where M is the
    267           *          channels number configured into the conversion group and N is the
    268           *          buffer depth. The samples are sequentially written into the buffer
    269           *          with no gaps.
    270           *
    271           * @param[in] adcp      pointer to the @p ADCDriver object
    272           * @param[in] grpp      pointer to a @p ADCConversionGroup object
    273           * @param[out] samples  pointer to the samples buffer
    274           * @param[in] depth     buffer depth (matrix rows number). The buffer depth
    275           *                      must be one or an even number.
    276           * @return              The operation result.
    277           * @retval RDY_OK       Conversion finished.
    278           * @retval RDY_RESET    The conversion has been stopped using
    279           *                      @p acdStopConversion() or @p acdStopConversionI(),
    280           *                      the result buffer may contain incorrect data.
    281           * @retval RDY_TIMEOUT  The conversion has been stopped because an hardware
    282           *                      error.
    283           *
    284           * @api
    285           */

   \                                 In section .text, align 2, keep-with-next
    286          msg_t adcConvert(ADCDriver *adcp,
    287                           const ADCConversionGroup *grpp,
    288                           adcsample_t *samples,
    289                           size_t depth) {
   \                     adcConvert:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    290            msg_t msg;
    291          
    292            chSysLock();
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000012   0x.... 0x....      BL       dbg_check_lock
    293            chDbgAssert(adcp->thread == NULL, "adcConvert(), #1", "already waiting");
   \   00000016   0x6960             LDR      R0,[R4, #+20]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??adcConvert_0
   \   0000001C   0x....             LDR.N    R0,??DataTable7_11
   \   0000001E   0x.... 0x....      BL       chDbgPanic
    294            adcStartConversionI(adcp, grpp, samples, depth);
   \                     ??adcConvert_0:
   \   00000022   0x003B             MOVS     R3,R7
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       adcStartConversionI
    295            adcp->thread = chThdSelf();
   \   0000002E   0x....             LDR.N    R0,??DataTable7_12
   \   00000030   0x6980             LDR      R0,[R0, #+24]
   \   00000032   0x6160             STR      R0,[R4, #+20]
    296            chSchGoSleepS(THD_STATE_SUSPENDED);
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x.... 0x....      BL       chSchGoSleepS
    297            msg = chThdSelf()->p_u.rdymsg;
   \   0000003A   0x....             LDR.N    R0,??DataTable7_12
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x6A80             LDR      R0,[R0, #+40]
   \   00000040   0x4680             MOV      R8,R0
    298            chSysUnlock();
   \   00000042   0x.... 0x....      BL       dbg_check_unlock
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF380 0x8811      MSR      BASEPRI,R0
    299            return msg;
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    300          }
    301          #endif /* ADC_USE_WAIT */
    302          
    303          #if ADC_USE_MUTUAL_EXCLUSION || defined(__DOXYGEN__)
    304          /**
    305           * @brief   Gains exclusive access to the ADC peripheral.
    306           * @details This function tries to gain ownership to the ADC bus, if the bus
    307           *          is already being used then the invoking thread is queued.
    308           * @pre     In order to use this function the option
    309           *          @p ADC_USE_MUTUAL_EXCLUSION must be enabled.
    310           *
    311           * @param[in] adcp      pointer to the @p ADCDriver object
    312           *
    313           * @api
    314           */

   \                                 In section .text, align 2, keep-with-next
    315          void adcAcquireBus(ADCDriver *adcp) {
   \                     adcAcquireBus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    316          
    317            chDbgCheck(adcp != NULL, "adcAcquireBus");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??adcAcquireBus_0
   \   00000008   0xF240 0x123D      MOVW     R2,#+317
   \   0000000C   0x....             LDR.N    R1,??DataTable7
   \   0000000E   0x....             LDR.N    R0,??DataTable7_13
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    318          
    319          #if CH_USE_MUTEXES
    320            chMtxLock(&adcp->mutex);
   \                     ??adcAcquireBus_0:
   \   00000014   0xF114 0x0018      ADDS     R0,R4,#+24
   \   00000018   0x.... 0x....      BL       chMtxLock
    321          #elif CH_USE_SEMAPHORES
    322            chSemWait(&adcp->semaphore);
    323          #endif
    324          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    325          
    326          /**
    327           * @brief   Releases exclusive access to the ADC peripheral.
    328           * @pre     In order to use this function the option
    329           *          @p ADC_USE_MUTUAL_EXCLUSION must be enabled.
    330           *
    331           * @param[in] adcp      pointer to the @p ADCDriver object
    332           *
    333           * @api
    334           */

   \                                 In section .text, align 2, keep-with-next
    335          void adcReleaseBus(ADCDriver *adcp) {
   \                     adcReleaseBus:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    336          
    337            chDbgCheck(adcp != NULL, "adcReleaseBus");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??adcReleaseBus_0
   \   00000008   0xF240 0x1251      MOVW     R2,#+337
   \   0000000C   0x....             LDR.N    R1,??DataTable7
   \   0000000E   0x....             LDR.N    R0,??DataTable7_14
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    338          
    339          #if CH_USE_MUTEXES
    340            (void)adcp;
    341            chMtxUnlock();
   \                     ??adcReleaseBus_0:
   \   00000014   0x.... 0x....      BL       chMtxUnlock
    342          #elif CH_USE_SEMAPHORES
    343            chSemSignal(&adcp->semaphore);
    344          #endif
    345          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     `?<Constant "\\"adcStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     `?<Constant "adcStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     `?<Constant "\\"adcStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     `?<Constant "adcStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     `?<Constant "\\"adcStartConversionI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     `?<Constant "adcStartConversionI()...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     `?<Constant "\\"adcStopConversion\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     `?<Constant "adcStopConversion(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     `?<Constant "\\"adcStopConversionI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     `?<Constant "adcStopConversionI(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x........         DC32     `?<Constant "adcConvert(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     `?<Constant "\\"adcAcquireBus\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     `?<Constant "\\"adcReleaseBus\\"()">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcStart\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcStart\"()"
   \              0x64 0x63    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x61 0x64          DC8 61H, 64H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "adcStart(), #1">`:
   \   00000000   0x61 0x64          DC8 "adcStart(), #1"
   \              0x63 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcStop\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcStop\"()"
   \              0x64 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "adcStop(), #1">`:
   \   00000000   0x61 0x64          DC8 "adcStop(), #1"
   \              0x63 0x53    
   \              0x74 0x6F    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcStartConversionI\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcStartConversionI\"()"
   \              0x64 0x63    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x43    
   \              0x6F 0x6E    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x49    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "adcStartConversionI()...">`:
   \   00000000   0x61 0x64          DC8 "adcStartConversionI(), #1"
   \              0x63 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x43 0x6F    
   \              0x6E 0x76    
   \              0x65 0x72    
   \              0x73 0x69    
   \              0x6F 0x6E    
   \              0x49 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcStopConversion\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcStopConversion\"()"
   \              0x64 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x43 0x6F    
   \              0x6E 0x76    
   \              0x65 0x72    
   \              0x73 0x69    
   \              0x6F 0x6E    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "adcStopConversion(), #1">`:
   \   00000000   0x61 0x64          DC8 "adcStopConversion(), #1"
   \              0x63 0x53    
   \              0x74 0x6F    
   \              0x70 0x43    
   \              0x6F 0x6E    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcStopConversionI\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcStopConversionI\"()"
   \              0x64 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x43 0x6F    
   \              0x6E 0x76    
   \              0x65 0x72    
   \              0x73 0x69    
   \              0x6F 0x6E    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "adcStopConversionI(), #1">`:
   \   00000000   0x61 0x64          DC8 "adcStopConversionI(), #1"
   \              0x63 0x53    
   \              0x74 0x6F    
   \              0x70 0x43    
   \              0x6F 0x6E    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x49    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "adcConvert(), #1">`:
   \   00000000   0x61 0x64          DC8 "adcConvert(), #1"
   \              0x63 0x43    
   \              0x6F 0x6E    
   \              0x76 0x65    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcAcquireBus\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcAcquireBus\"()"
   \              0x64 0x63    
   \              0x41 0x63    
   \              0x71 0x75    
   \              0x69 0x72    
   \              0x65 0x42    
   \              0x75 0x73    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"adcReleaseBus\\"()">`:
   \   00000000   0x22 0x61          DC8 "\"adcReleaseBus\"()"
   \              0x64 0x63    
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \              0x65 0x42    
   \              0x75 0x73    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
    346          #endif /* ADC_USE_MUTUAL_EXCLUSION */
    347          
    348          #endif /* HAL_USE_ADC */
    349          
    350          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   adcAcquireBus
         8   -> chDbgPanic3
         8   -> chMtxLock
      24   adcConvert
        24   -> adcStartConversionI
        24   -> chDbgPanic
        24   -> chSchGoSleepS
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
       8   adcInit
         8   -> adc_lld_init
       8   adcObjectInit
         8   -> chMtxInit
       8   adcReleaseBus
         8   -> chDbgPanic3
         8   -> chMtxUnlock
      16   adcStart
        16   -> adc_lld_start
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      24   adcStartConversion
        24   -> adcStartConversionI
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
      24   adcStartConversionI
        24   -> adc_lld_start_conversion
        24   -> chDbgCheckClassI
        24   -> chDbgPanic
        24   -> chDbgPanic3
       8   adcStop
         8   -> adc_lld_stop
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
      16   adcStopConversion
        16   -> adc_lld_stop_conversion
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchWakeupS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   adcStopConversionI
        16   -> adc_lld_stop_conversion
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchReadyI


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      64  ?<Constant "F:\\stuff\\rusefi_sourc...">
      20  ?<Constant "\"adcAcquireBus\"()">
      20  ?<Constant "\"adcReleaseBus\"()">
      24  ?<Constant "\"adcStartConversionI\"()">
      16  ?<Constant "\"adcStart\"()">
      24  ?<Constant "\"adcStopConversionI\"()">
      24  ?<Constant "\"adcStopConversion\"()">
      12  ?<Constant "\"adcStop\"()">
      20  ?<Constant "adcConvert(), #1">
      16  ?<Constant "adcStart(), #1">
      28  ?<Constant "adcStartConversionI()...">
      16  ?<Constant "adcStop(), #1">
      24  ?<Constant "adcStopConversion(), #1">
      28  ?<Constant "adcStopConversionI(), #1">
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      30  adcAcquireBus
      82  adcConvert
       8  adcInit
      38  adcObjectInit
      26  adcReleaseBus
      72  adcStart
      44  adcStartConversion
      86  adcStartConversionI
      68  adcStop
     102  adcStopConversion
      94  adcStopConversionI

 
 336 bytes in section .rodata
 710 bytes in section .text
 
 710 bytes of CODE  memory
 336 bytes of CONST memory

Errors: none
Warnings: none
