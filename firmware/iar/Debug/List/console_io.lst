###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:44 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\console\console_ #
#                       io.cpp                                                #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\console\console_ #
#                       io.cpp -lCN F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\Debug\Obj\ --no_cse --no_unroll --no_inline    #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       onsole_io.lst                                         #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\co #
#                       nsole_io.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\console\console_io.cpp
      1          /**
      2           * @file	console_io.c
      3           *
      4           * @date Dec 29, 2012
      5           * @author Andrey Belomutskiy, (c) 2012-2015
      6           *
      7           * This file is part of rusEfi - see http://rusefi.com
      8           *
      9           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     10           * the GNU General Public License as published by the Free Software Foundation; either
     11           * version 3 of the License, or (at your option) any later version.
     12           *
     13           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     14           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15           * GNU General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU General Public License along with this program.
     18           * If not, see <http://www.gnu.org/licenses/>.
     19           */
     20          
     21          #include "main.h"
     22          #include "console_io.h"
     23          #include "rfiutil.h"
     24          #include "tunerstudio.h"
     25          
     26          #if HAL_USE_SERIAL_USB || defined(__DOXYGEN__)
     27          #include "usbcfg.h"
     28          #include "usbconsole.h"
     29          extern SerialUSBDriver SDU1;
     30          #endif
     31          

   \                                 In section .bss, align 4
     32          int lastWriteSize;
   \                     lastWriteSize:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     33          int lastWriteActual;
   \                     lastWriteActual:
   \   00000000                      DS8 4
     34          

   \                                 In section .bss, align 1
     35          static bool isSerialConsoleStarted = false;
   \                     isSerialConsoleStarted:
   \   00000000                      DS8 1
     36          

   \                                 In section .bss, align 4
     37          static EventListener consoleEventListener;
   \                     consoleEventListener:
   \   00000000                      DS8 16
     38          
     39          /**
     40           * @brief   Reads a whole line from the input channel.
     41           *
     42           * @param[in] chp       pointer to a @p BaseChannel object
     43           * @param[in] line      pointer to the line buffer
     44           * @param[in] size      buffer maximum length
     45           * @return              The operation status.
     46           * @retval TRUE         the channel was reset or CTRL-D pressed.
     47           * @retval FALSE        operation successful.
     48           */

   \                                 In section .text, align 2, keep-with-next
     49          static bool getConsoleLine(BaseSequentialStream *chp, char *line, unsigned size) {
   \                     _Z14getConsoleLineP20BaseSequentialStreamPcj:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     50          	char *p = line;
   \   0000000A   0x002F             MOVS     R7,R5
     51          
     52          	while (true) {
     53          		if (!isConsoleReady()) {
   \                     ??getConsoleLine_0:
   \   0000000C   0x.... 0x....      BL       _Z14isConsoleReadyv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE.N    ??getConsoleLine_1
     54          			// we better do not read from USB serial before it is ready
     55          			chThdSleepMilliseconds(10);
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x.... 0x....      BL       chThdSleep
     56          			continue;
   \   0000001A   0xE7F7             B.N      ??getConsoleLine_0
     57          		}
     58          
     59          		short c = (short) chSequentialStreamGet(chp);
   \                     ??getConsoleLine_1:
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x68C9             LDR      R1,[R1, #+12]
   \   00000022   0x4788             BLX      R1
   \   00000024   0x4680             MOV      R8,R0
     60          
     61          		if (isSerialOverUart()) {
   \   00000026   0x.... 0x....      BL       _Z16isSerialOverUartv
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00D             BEQ.N    ??getConsoleLine_2
     62          			uint32_t flags;
     63          			chSysLock()
   \   0000002E   0x2020             MOVS     R0,#+32
   \   00000030   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000034   0x.... 0x....      BL       dbg_check_lock
     64          			;
     65          
     66          			flags = chEvtGetAndClearFlagsI(&consoleEventListener);
   \   00000038   0x....             LDR.N    R0,??DataTable9_1
   \   0000003A   0x.... 0x....      BL       chEvtGetAndClearFlagsI
   \   0000003E   0x4681             MOV      R9,R0
     67          			chSysUnlock()
   \   00000040   0x.... 0x....      BL       dbg_check_unlock
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF380 0x8811      MSR      BASEPRI,R0
     68          			;
     69          
     70          			if (flags & SD_OVERRUN_ERROR) {
     71          //				firmwareError("serial overrun");
     72          			}
     73          
     74          		}
     75          
     76          #if EFI_UART_ECHO_TEST_MODE
     77          		/**
     78          		 * That's test code - let's test connectivity
     79          		 */
     80          		consolePutChar((uint8_t) c);
     81          		continue;
     82          #endif
     83          
     84          		if (c < 0 || c == 4) {
   \                     ??getConsoleLine_2:
   \   0000004A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000004E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000052   0xD404             BMI.N    ??getConsoleLine_3
   \   00000054   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000058   0xF1B8 0x0F04      CMP      R8,#+4
   \   0000005C   0xD101             BNE.N    ??getConsoleLine_4
     85          			return true;
   \                     ??getConsoleLine_3:
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE03F             B.N      ??getConsoleLine_5
     86          		}
     87          		if (c == 8) {
   \                     ??getConsoleLine_4:
   \   00000062   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000066   0xF1B8 0x0F08      CMP      R8,#+8
   \   0000006A   0xD10E             BNE.N    ??getConsoleLine_6
     88          			if (p != line) {
   \   0000006C   0x42AF             CMP      R7,R5
   \   0000006E   0xD00B             BEQ.N    ??getConsoleLine_7
     89          				// backspace
     90          				consolePutChar((uint8_t) c);
   \   00000070   0x4640             MOV      R0,R8
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x.... 0x....      BL       _Z14consolePutChari
     91          				consolePutChar(0x20);
   \   00000078   0x2020             MOVS     R0,#+32
   \   0000007A   0x.... 0x....      BL       _Z14consolePutChari
     92          				consolePutChar((uint8_t) c);
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x.... 0x....      BL       _Z14consolePutChari
     93          				p--;
   \   00000086   0x1E7F             SUBS     R7,R7,#+1
     94          			}
     95          			continue;
   \                     ??getConsoleLine_7:
   \   00000088   0xE7C0             B.N      ??getConsoleLine_0
     96          		}
     97          		if (c == '\r') {
   \                     ??getConsoleLine_6:
   \   0000008A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000008E   0xF1B8 0x0F0D      CMP      R8,#+13
   \   00000092   0xD109             BNE.N    ??getConsoleLine_8
     98          			consolePutChar('\r');
   \   00000094   0x200D             MOVS     R0,#+13
   \   00000096   0x.... 0x....      BL       _Z14consolePutChari
     99          			consolePutChar('\n');
   \   0000009A   0x200A             MOVS     R0,#+10
   \   0000009C   0x.... 0x....      BL       _Z14consolePutChari
    100          			*p = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x7038             STRB     R0,[R7, #+0]
    101          			return false;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE01C             B.N      ??getConsoleLine_5
    102          		}
    103          		if (c == '\n') {
   \                     ??getConsoleLine_8:
   \   000000A8   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   000000AC   0xF1B8 0x0F0A      CMP      R8,#+10
   \   000000B0   0xD106             BNE.N    ??getConsoleLine_9
    104          			consolePutChar('\n');
   \   000000B2   0x200A             MOVS     R0,#+10
   \   000000B4   0x.... 0x....      BL       _Z14consolePutChari
    105          			*p = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x7038             STRB     R0,[R7, #+0]
    106          			return false;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE010             B.N      ??getConsoleLine_5
    107          		}
    108          		if (c < 0x20) {
   \                     ??getConsoleLine_9:
   \   000000C0   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   000000C4   0xF1B8 0x0F20      CMP      R8,#+32
   \   000000C8   0xDBA0             BLT.N    ??getConsoleLine_0
    109          			continue;
    110          		}
    111          		if (p < line + size - 1) {
   \                     ??getConsoleLine_10:
   \   000000CA   0x1970             ADDS     R0,R6,R5
   \   000000CC   0x1E40             SUBS     R0,R0,#+1
   \   000000CE   0x4287             CMP      R7,R0
   \   000000D0   0xD29C             BCS.N    ??getConsoleLine_0
    112          			consolePutChar((uint8_t) c);
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x.... 0x....      BL       _Z14consolePutChari
    113          			*p++ = (char) c;
   \   000000DA   0xF887 0x8000      STRB     R8,[R7, #+0]
   \   000000DE   0x1C7F             ADDS     R7,R7,#+1
   \   000000E0   0xE794             B.N      ??getConsoleLine_0
    114          		}
    115          	}
   \                     ??getConsoleLine_5:
   \   000000E2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    116          }
    117          
    118          // todo: this is ugly as hell!

   \                                 In section .data, align 4
    119          static char consoleInput[] = "                                                                              ";
   \                     consoleInput:
   \   00000000   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000008   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000010   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000018   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000020   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000028   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000030   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000038   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000040   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000048   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 20H, 0
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   0000004F   0x00               DC8 0
    120          

   \                                 In section .bss, align 4
    121          CommandHandler console_line_callback;
   \                     console_line_callback:
   \   00000000                      DS8 4
    122          

   \                                 In section .bss, align 1
    123          static bool is_serial_over_uart;
   \                     is_serial_over_uart:
   \   00000000                      DS8 1
    124          

   \                                 In section .text, align 2, keep-with-next
    125          bool isSerialOverUart(void) {
    126          	return is_serial_over_uart;
   \                     _Z16isSerialOverUartv:
   \   00000000   0x....             LDR.N    R0,??DataTable9_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    127          }
    128          
    129          #if (defined(EFI_CONSOLE_UART_DEVICE) && ! EFI_SIMULATOR ) || defined(__DOXYGEN__)

   \                                 In section .data, align 4
    130          static SerialConfig serialConfig = { SERIAL_SPEED, 0, USART_CR2_STOP1_BITS | USART_CR2_LINEN, 0 };
   \                     serialConfig:
   \   00000000   0x0001C200         DC32 115200
   \   00000004   0x0000 0x4000      DC16 0, 16384, 0
   \              0x0000       
   \   0000000A   0x00 0x00          DC8 0, 0
    131          #endif
    132          
    133          #if EFI_PROD_CODE || EFI_EGT || defined(__DOXYGEN__)
    134          

   \                                 In section .text, align 2, keep-with-next
    135          SerialDriver * getConsoleChannel(void) {
   \                     _Z17getConsoleChannelv:
   \   00000000   0xB580             PUSH     {R7,LR}
    136          #if defined(EFI_CONSOLE_UART_DEVICE) || defined(__DOXYGEN__)
    137          	if (isSerialOverUart()) {
   \   00000002   0x.... 0x....      BL       _Z16isSerialOverUartv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??getConsoleChannel_0
    138          		return (SerialDriver *) EFI_CONSOLE_UART_DEVICE;
   \   0000000A   0x....             LDR.N    R0,??DataTable9_3
   \   0000000C   0xE000             B.N      ??getConsoleChannel_1
    139          	}
    140          #endif /* EFI_CONSOLE_UART_DEVICE */
    141          
    142          #if HAL_USE_SERIAL_USB || defined(__DOXYGEN__)
    143          	return (SerialDriver *) &SDU1;
   \                     ??getConsoleChannel_0:
   \   0000000E   0x....             LDR.N    R0,??DataTable9_4
   \                     ??getConsoleChannel_1:
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    144          #else
    145          	return NULL;
    146          #endif
    147          }
    148          

   \                                 In section .text, align 2, keep-with-next
    149          bool isConsoleReady(void) {
   \                     _Z14isConsoleReadyv:
   \   00000000   0xB580             PUSH     {R7,LR}
    150          	if (isSerialOverUart()) {
   \   00000002   0x.... 0x....      BL       _Z16isSerialOverUartv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??isConsoleReady_0
    151          		return isSerialConsoleStarted;
   \   0000000A   0x....             LDR.N    R0,??DataTable9_5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xE001             B.N      ??isConsoleReady_1
    152          	} else {
    153          		return is_usb_serial_ready();
   \                     ??isConsoleReady_0:
   \   00000010   0x.... 0x....      BL       is_usb_serial_ready
   \                     ??isConsoleReady_1:
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    154          	}
    155          }
    156          #endif /* EFI_PROD_CODE || EFI_EGT */
    157          

   \                                 In section .bss, align 1
    158          bool_t consoleInBinaryMode = false;
   \                     consoleInBinaryMode:
   \   00000000                      DS8 1
    159          

   \                                 In section .bss, align 4
    160          ts_channel_s binaryConsole;
   \                     binaryConsole:
   \   00000000                      DS8 308
    161          

   \                                 In section .bss, align 4
    162          uint8_t buffer[DL_OUTPUT_BUFFER];
   \                     buffer:
   \   00000000                      DS8 8000
    163          

   \                                 In section .bss, align 8
    164          static THD_WORKING_AREA(consoleThreadStack, 2 * UTILITY_THREAD_STACK_SIZE);
   \                     consoleThreadStack:
   \   00000000                      DS8 1112

   \                                 In section .text, align 2, keep-with-next
    165          static msg_t consoleThreadThreadEntryPoint(void *arg) {
   \                     _Z29consoleThreadThreadEntryPointPv:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    166          	(void) arg;
    167          	chRegSetThreadName("console thread");
   \   00000004   0x....             LDR.N    R0,??DataTable9_6
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x....             LDR.N    R1,??DataTable9_7
   \   0000000A   0x6181             STR      R1,[R0, #+24]
    168          
    169          #if EFI_PROD_CODE
    170          	if (!isSerialOverUart()) {
   \   0000000C   0x.... 0x....      BL       _Z16isSerialOverUartv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??consoleThreadThreadEntryPoint_0
    171          		/**
    172          		 * This method contains a long delay, that's the reason why this is not done on the main thread
    173          		 */
    174          		usb_serial_start();
   \   00000014   0x.... 0x....      BL       usb_serial_start
    175          	}
    176          #endif /* EFI_PROD_CODE */
    177          
    178          	binaryConsole.channel = (BaseChannel *) getConsoleChannel();
   \                     ??consoleThreadThreadEntryPoint_0:
   \   00000018   0x.... 0x....      BL       _Z17getConsoleChannelv
   \   0000001C   0x....             LDR.N    R1,??DataTable9_8
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    179          	// todo: clean this spot!
    180          	binaryConsole.writeBuffer = buffer;
   \   00000020   0x....             LDR.N    R0,??DataTable9_8
   \   00000022   0x....             LDR.N    R1,??DataTable9_9
   \   00000024   0x6041             STR      R1,[R0, #+4]
    181          
    182          	while (true) {
    183          		efiAssert(getRemainingStack(chThdSelf()) > 256, "lowstck#9e", 0);
   \                     ??consoleThreadThreadEntryPoint_1:
   \   00000026   0x....             LDR.N    R0,??DataTable9_6
   \   00000028   0x6980             LDR      R0,[R0, #+24]
   \   0000002A   0x.... 0x....      BL       getRemainingStack
   \   0000002E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000032   0xDC04             BGT.N    ??consoleThreadThreadEntryPoint_2
   \   00000034   0x....             LDR.N    R0,??DataTable9_10
   \   00000036   0x.... 0x....      BL       firmwareError
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE01A             B.N      ??consoleThreadThreadEntryPoint_3
    184          		bool end = getConsoleLine((BaseSequentialStream*) getConsoleChannel(), consoleInput, sizeof(consoleInput));
   \                     ??consoleThreadThreadEntryPoint_2:
   \   0000003E   0x.... 0x....      BL       _Z17getConsoleChannelv
   \   00000042   0x224F             MOVS     R2,#+79
   \   00000044   0x....             LDR.N    R1,??DataTable9_11
   \   00000046   0x.... 0x....      BL       _Z14getConsoleLineP20BaseSequentialStreamPcj
   \   0000004A   0x0005             MOVS     R5,R0
    185          		if (end) {
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD1E9             BNE.N    ??consoleThreadThreadEntryPoint_1
    186          			// firmware simulator is the only case when this happens
    187          			continue;
    188          		}
    189          
    190          		char *trimmed = efiTrim(consoleInput);
   \                     ??consoleThreadThreadEntryPoint_4:
   \   00000052   0x....             LDR.N    R0,??DataTable9_11
   \   00000054   0x.... 0x....      BL       efiTrim
   \   00000058   0x0006             MOVS     R6,R0
    191          
    192          		(console_line_callback)(trimmed);
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x....             LDR.N    R1,??DataTable9_12
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x4788             BLX      R1
    193          
    194          		if (consoleInBinaryMode) {
   \   00000062   0x....             LDR.N    R0,??DataTable9_13
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD0DD             BEQ.N    ??consoleThreadThreadEntryPoint_1
    195          			// switch to binary protocol
    196          			runBinaryProtocolLoop(&binaryConsole, true);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x....             LDR.N    R0,??DataTable9_8
   \   0000006E   0x.... 0x....      BL       _Z21runBinaryProtocolLoopP12ts_channel_sb
   \   00000072   0xE7D8             B.N      ??consoleThreadThreadEntryPoint_1
    197          		}
    198          	}
   \                     ??consoleThreadThreadEntryPoint_3:
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
    199          #if defined __GNUC__
    200          	return false;
    201          #endif        
    202          }
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void consolePutChar(int x) {
   \                     _Z14consolePutChari:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    205          	chSequentialStreamPut(getConsoleChannel(), (uint8_t )(x));
   \   00000004   0x.... 0x....      BL       _Z17getConsoleChannelv
   \   00000008   0x0005             MOVS     R5,R0
   \   0000000A   0x.... 0x....      BL       _Z17getConsoleChannelv
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x6892             LDR      R2,[R2, #+8]
   \   0000001A   0x4790             BLX      R2
    206          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    207          
    208          // 10 seconds
    209          #define CONSOLE_WRITE_TIMEOUT 10000
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void consoleOutputBuffer(const uint8_t *buf, int size) {
   \                     _Z19consoleOutputBufferPKhi:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    212          	lastWriteSize = size;
   \   00000006   0x....             LDR.N    R0,??DataTable9_14
   \   00000008   0x6005             STR      R5,[R0, #+0]
    213          #if !EFI_UART_ECHO_TEST_MODE
    214          	lastWriteActual = chnWriteTimeout(getConsoleChannel(), buf, size, CONSOLE_WRITE_TIMEOUT);
   \   0000000A   0x.... 0x....      BL       _Z17getConsoleChannelv
   \   0000000E   0x0006             MOVS     R6,R0
   \   00000010   0x.... 0x....      BL       _Z17getConsoleChannelv
   \   00000014   0x0007             MOVS     R7,R0
   \   00000016   0xF242 0x7310      MOVW     R3,#+10000
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x683E             LDR      R6,[R7, #+0]
   \   00000022   0x69B6             LDR      R6,[R6, #+24]
   \   00000024   0x47B0             BLX      R6
   \   00000026   0x....             LDR.N    R1,??DataTable9_15
   \   00000028   0x6008             STR      R0,[R1, #+0]
    215          //	if (r != size)
    216          //		firmwareError("Partial console write");
    217          #endif /* EFI_UART_ECHO_TEST_MODE */
    218          }
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    219          

   \                                 In section .bss, align 4
    220          static Logging *logger;
   \                     logger:
   \   00000000                      DS8 4
    221          

   \                                 In section .text, align 2, keep-with-next
    222          static void switchToBinaryProtocol(void) {
   \                     _Z22switchToBinaryProtocolv:
   \   00000000   0xB580             PUSH     {R7,LR}
    223          	scheduleMsg(logger, "switching to binary protocol");
   \   00000002   0x....             LDR.N    R1,??DataTable9_16
   \   00000004   0x....             LDR.N    R0,??DataTable9_17
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       scheduleMsg
    224          	consoleInBinaryMode = true;
   \   0000000C   0x....             LDR.N    R0,??DataTable9_13
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    225          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    226          

   \                                 In section .text, align 2, keep-with-next
    227          void startConsole(Logging *sharedLogger, CommandHandler console_line_callback_p) {
   \                     _Z12startConsoleP7LoggingPFvPcE:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    228          	logger = sharedLogger;
   \   00000006   0x....             LDR.N    R0,??DataTable9_17
   \   00000008   0x6004             STR      R4,[R0, #+0]
    229          	console_line_callback = console_line_callback_p;
   \   0000000A   0x....             LDR.N    R0,??DataTable9_12
   \   0000000C   0x6005             STR      R5,[R0, #+0]
    230          
    231          #if (defined(EFI_CONSOLE_UART_DEVICE) && ! EFI_SIMULATOR) || defined(__DOXYGEN__)
    232          
    233          	palSetPadMode(CONSOLE_MODE_SWITCH_PORT, CONSOLE_MODE_SWITCH_PIN, PAL_MODE_INPUT_PULLUP);
   \   0000000E   0x2220             MOVS     R2,#+32
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x....             LDR.N    R0,??DataTable9_18  ;; 0x40020400
   \   00000014   0x.... 0x....      BL       _pal_lld_setgroupmode
    234          
    235          	is_serial_over_uart = GET_CONSOLE_MODE_VALUE() == EFI_USE_UART_FOR_CONSOLE;
   \   00000018   0x....             LDR.N    R0,??DataTable9_19  ;; 0x40020410
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000020   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000024   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000028   0x....             LDR.N    R1,??DataTable9_2
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    236          
    237          	if (isSerialOverUart()) {
   \   0000002C   0x.... 0x....      BL       _Z16isSerialOverUartv
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD019             BEQ.N    ??startConsole_0
    238          		/*
    239          		 * Activates the serial using the driver default configuration (that's 38400)
    240          		 * it is important to set 'NONE' as flow control! in terminal application on the PC
    241          		 */
    242          		sdStart(EFI_CONSOLE_UART_DEVICE, &serialConfig);
   \   00000034   0x....             LDR.N    R1,??DataTable9_20
   \   00000036   0x....             LDR.N    R0,??DataTable9_3
   \   00000038   0x.... 0x....      BL       sdStart
    243          
    244          // cannot use pin repository here because pin repository prints to console
    245          		palSetPadMode(EFI_CONSOLE_RX_PORT, EFI_CONSOLE_RX_PIN, PAL_MODE_ALTERNATE(EFI_CONSOLE_AF));
   \   0000003C   0xF240 0x3282      MOVW     R2,#+898
   \   00000040   0xF44F 0x6100      MOV      R1,#+2048
   \   00000044   0x....             LDR.N    R0,??DataTable9_21  ;; 0x40020800
   \   00000046   0x.... 0x....      BL       _pal_lld_setgroupmode
    246          		palSetPadMode(EFI_CONSOLE_TX_PORT, EFI_CONSOLE_TX_PIN, PAL_MODE_ALTERNATE(EFI_CONSOLE_AF));
   \   0000004A   0xF240 0x3282      MOVW     R2,#+898
   \   0000004E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000052   0x....             LDR.N    R0,??DataTable9_21  ;; 0x40020800
   \   00000054   0x.... 0x....      BL       _pal_lld_setgroupmode
    247          
    248          		isSerialConsoleStarted = true;
   \   00000058   0x....             LDR.N    R0,??DataTable9_5
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    249          
    250          		chEvtRegisterMask((EventSource *) chnGetEventSource(EFI_CONSOLE_UART_DEVICE), &consoleEventListener, 1);
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x....             LDR.N    R1,??DataTable9_1
   \   00000062   0x....             LDR.N    R0,??DataTable9_22
   \   00000064   0x.... 0x....      BL       chEvtRegisterMask
    251          	}
    252          #else
    253          	is_serial_over_uart = false;
    254          #endif /* EFI_PROD_CODE */
    255          
    256          	chThdCreateStatic(consoleThreadStack, sizeof(consoleThreadStack), NORMALPRIO, consoleThreadThreadEntryPoint, NULL);
   \                     ??startConsole_0:
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x....             LDR.N    R3,??DataTable9_23
   \   0000006E   0x2240             MOVS     R2,#+64
   \   00000070   0xF44F 0x618B      MOV      R1,#+1112
   \   00000074   0x....             LDR.N    R0,??DataTable9_24
   \   00000076   0x.... 0x....      BL       chThdCreateStatic
    257          	addConsoleAction(SWITCH_TO_BINARY_COMMAND, switchToBinaryProtocol);
   \   0000007A   0x....             LDR.N    R1,??DataTable9_25
   \   0000007C   0x....             ADR.N    R0,??DataTable9  ;; "~"
   \   0000007E   0x.... 0x....      BL       addConsoleAction
    258          }
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    259          
    260          /**
    261           * @return TRUE if already in locked context
    262           */

   \                                 In section .text, align 2, keep-with-next
    263          bool lockAnyContext(void) {
   \                     lockAnyContext:
   \   00000000   0xB510             PUSH     {R4,LR}
    264          	int alreadyLocked = isLocked();
   \   00000002   0x....             LDR.N    R0,??DataTable9_26
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB01             BLT.N    ??lockAnyContext_0
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0xE000             B.N      ??lockAnyContext_1
   \                     ??lockAnyContext_0:
   \   0000000E   0x2400             MOVS     R4,#+0
   \                     ??lockAnyContext_1:
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
    265          	if (alreadyLocked)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD001             BEQ.N    ??lockAnyContext_2
    266          		return true;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00F             B.N      ??lockAnyContext_3
    267          	if (isIsrContext()) {
   \                     ??lockAnyContext_2:
   \   0000001A   0x....             LDR.N    R0,??DataTable9_27
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xDB05             BLT.N    ??lockAnyContext_4
    268          		chSysLockFromIsr()
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000028   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   0000002C   0xE004             B.N      ??lockAnyContext_5
    269          		;
    270          	} else {
    271          		chSysLock()
   \                     ??lockAnyContext_4:
   \   0000002E   0x2020             MOVS     R0,#+32
   \   00000030   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000034   0x.... 0x....      BL       dbg_check_lock
    272          		;
    273          	}
    274          	return false;
   \                     ??lockAnyContext_5:
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??lockAnyContext_3:
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          bool lockOutputBuffer(void) {
   \                     lockOutputBuffer:
   \   00000000   0xB580             PUSH     {R7,LR}
    278          	return lockAnyContext();
   \   00000002   0x.... 0x....      BL       lockAnyContext
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    279          }
    280          

   \                                 In section .text, align 2, keep-with-next
    281          void unlockAnyContext(void) {
   \                     unlockAnyContext:
   \   00000000   0xB580             PUSH     {R7,LR}
    282          	if (isIsrContext()) {
   \   00000002   0x....             LDR.N    R0,??DataTable9_27
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDB05             BLT.N    ??unlockAnyContext_0
    283          		chSysUnlockFromIsr()
   \   0000000A   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000014   0xE004             B.N      ??unlockAnyContext_1
    284          		;
    285          	} else {
    286          		chSysUnlock()
   \                     ??unlockAnyContext_0:
   \   00000016   0x.... 0x....      BL       dbg_check_unlock
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF380 0x8811      MSR      BASEPRI,R0
    287          		;
    288          	}
    289          }
   \                     ??unlockAnyContext_1:
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void unlockOutputBuffer(void) {
   \                     unlockOutputBuffer:
   \   00000000   0xB580             PUSH     {R7,LR}
    292          	unlockAnyContext();
   \   00000002   0x.... 0x....      BL       unlockAnyContext
    293          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x7E 0x00          DC8      "~",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     consoleEventListener

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     is_serial_over_uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     SD3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     SDU1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     isSerialConsoleStarted

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     `?<Constant "console thread">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     binaryConsole

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     `?<Constant "lowstck#9e">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     consoleInput

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     console_line_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     consoleInBinaryMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     lastWriteSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     lastWriteActual

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x........         DC32     `?<Constant "switching to binary p...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     logger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x40020410         DC32     0x40020410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x........         DC32     serialConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     SD3+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x........         DC32     _Z29consoleThreadThreadEntryPointPv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x........         DC32     consoleThreadStack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x........         DC32     _Z22switchToBinaryProtocolv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_26:
   \   00000000   0x........         DC32     dbg_lock_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_27:
   \   00000000   0x........         DC32     dbg_isr_cnt

   \                                 In section .rodata, align 4
   \                     `?<Constant "console thread">`:
   \   00000000   0x63 0x6F          DC8 "console thread"
   \              0x6E 0x73    
   \              0x6F 0x6C    
   \              0x65 0x20    
   \              0x74 0x68    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#9e">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#9e"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x39 0x65    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "switching to binary p...">`:
   \   00000000   0x73 0x77          DC8 "switching to binary protocol"
   \              0x69 0x74    
   \              0x63 0x68    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x74 0x6F    
   \              0x20 0x62    
   \              0x69 0x6E    
   \              0x61 0x72    
   \              0x79 0x20    
   \              0x70 0x72    
   \              0x6F 0x74    
   \              0x6F 0x63    
   \              0x6F 0x6C    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x7E 0x00          DC8 "~"

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   consoleOutputBuffer(uint8_t const *, int)
        24   -- Indirect call
        24   -> getConsoleChannel()
      16   consolePutChar(int)
        16   -- Indirect call
        16   -> getConsoleChannel()
      16   consoleThreadThreadEntryPoint(void *)
        16   -- Indirect call
        16   -> efiTrim
        16   -> firmwareError
        16   -> getConsoleChannel()
        16   -> getConsoleLine(BaseSequentialStream *, char *, unsigned int)
        16   -> getRemainingStack
        16   -> isSerialOverUart()
        16   -> runBinaryProtocolLoop(ts_channel_s *, bool)
        16   -> usb_serial_start
       8   getConsoleChannel()
         8   -> isSerialOverUart()
      32   getConsoleLine(BaseSequentialStream *, char *, unsigned int)
        32   -- Indirect call
        32   -> chEvtGetAndClearFlagsI
        32   -> chThdSleep
        32   -> consolePutChar(int)
        32   -> dbg_check_lock
        32   -> dbg_check_unlock
        32   -> isConsoleReady()
        32   -> isSerialOverUart()
       8   isConsoleReady()
         8   -> isSerialOverUart()
         8   -> is_usb_serial_ready
       0   isSerialOverUart()
       8   lockAnyContext
         8   -> dbg_check_lock
         8   -> dbg_check_lock_from_isr
       8   lockOutputBuffer
         8   -> lockAnyContext
      16   startConsole(Logging *, CommandHandler)
        16   -> _pal_lld_setgroupmode
        16   -> addConsoleAction
        16   -> chEvtRegisterMask
        16   -> chThdCreateStatic
        16   -> isSerialOverUart()
        16   -> sdStart
       8   switchToBinaryProtocol()
         8   -> scheduleMsg
       8   unlockAnyContext
         8   -> dbg_check_unlock
         8   -> dbg_check_unlock_from_isr
       8   unlockOutputBuffer
         8   -> unlockAnyContext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "console thread">
      12  ?<Constant "lowstck#9e">
      32  ?<Constant "switching to binary p...">
       2  ?<Constant "~">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     308  binaryConsole
    8000  buffer
      16  consoleEventListener
       1  consoleInBinaryMode
      80  consoleInput
      44  consoleOutputBuffer(uint8_t const *, int)
      30  consolePutChar(int)
    1112  consoleThreadStack
     118  consoleThreadThreadEntryPoint(void *)
       4  console_line_callback
      18  getConsoleChannel()
     230  getConsoleLine(BaseSequentialStream *, char *, unsigned int)
      22  isConsoleReady()
       1  isSerialConsoleStarted
       6  isSerialOverUart()
       1  is_serial_over_uart
       4  lastWriteActual
       4  lastWriteSize
      60  lockAnyContext
       8  lockOutputBuffer
       4  logger
      12  serialConfig
     132  startConsole(Logging *, CommandHandler)
      20  switchToBinaryProtocol()
      34  unlockAnyContext
       8  unlockOutputBuffer

 
 9 455 bytes in section .bss
    92 bytes in section .data
    62 bytes in section .rodata
   842 bytes in section .text
 
   842 bytes of CODE  memory
    62 bytes of CONST memory
 9 547 bytes of DATA  memory

Errors: none
Warnings: 1
