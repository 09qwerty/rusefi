###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:29 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chqueues.c                                      #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chqueues.c -lCN F:\stuff\rusefi_sourceforge\fir #
#                       mware\iar\Debug\List\ -lA                             #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hqueues.lst                                           #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       queues.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chqueues.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chqueues.c
     30           * @brief   I/O Queues code.
     31           *
     32           * @addtogroup io_queues
     33           * @details ChibiOS/RT queues are mostly used in serial-like device drivers.
     34           *          The device drivers are usually designed to have a lower side
     35           *          (lower driver, it is usually an interrupt service routine) and an
     36           *          upper side (upper driver, accessed by the application threads).<br>
     37           *          There are several kind of queues:<br>
     38           *          - <b>Input queue</b>, unidirectional queue where the writer is the
     39           *            lower side and the reader is the upper side.
     40           *          - <b>Output queue</b>, unidirectional queue where the writer is the
     41           *            upper side and the reader is the lower side.
     42           *          - <b>Full duplex queue</b>, bidirectional queue. Full duplex queues
     43           *            are implemented by pairing an input queue and an output queue
     44           *            together.
     45           *          .
     46           * @pre     In order to use the I/O queues the @p CH_USE_QUEUES option must
     47           *          be enabled in @p chconf.h.
     48           * @{
     49           */
     50          
     51          #include "ch.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void queue_insert(struct Thread *, ThreadsQueue *)
   \                     queue_insert:
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x6042             STR      R2,[R0, #+4]
   \   00000006   0x6048             STR      R0,[R1, #+4]
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *fifo_remove(ThreadsQueue *)
   \                     fifo_remove:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   \   00000008   0x6051             STR      R1,[R2, #+4]
   \   0000000A   0x4770             BX       LR               ;; return
     52          
     53          #if CH_USE_QUEUES || defined(__DOXYGEN__)
     54          
     55          /**
     56           * @brief   Puts the invoking thread into the queue's threads queue.
     57           *
     58           * @param[out] qp       pointer to an @p GenericQueue structure
     59           * @param[in] time      the number of ticks before the operation timeouts,
     60           *                      the following special values are allowed:
     61           *                      - @a TIME_IMMEDIATE immediate timeout.
     62           *                      - @a TIME_INFINITE no timeout.
     63           *                      .
     64           * @return              A message specifying how the invoking thread has been
     65           *                      released from threads queue.
     66           * @retval Q_OK         is the normal exit, thread signaled.
     67           * @retval Q_RESET      if the queue has been reset.
     68           * @retval Q_TIMEOUT    if the queue operation timed out.
     69           */

   \                                 In section .text, align 2, keep-with-next
     70          static msg_t qwait(GenericQueue *qp, systime_t time) {
   \                     qwait:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     71          
     72            if (TIME_IMMEDIATE == time)
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD102             BNE.N    ??qwait_0
     73              return Q_TIMEOUT;
   \   0000000A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000E   0xE00B             B.N      ??qwait_1
     74            currp->p_u.wtobjp = qp;
   \                     ??qwait_0:
   \   00000010   0x....             LDR.N    R0,??DataTable2
   \   00000012   0x6980             LDR      R0,[R0, #+24]
   \   00000014   0x6284             STR      R4,[R0, #+40]
     75            queue_insert(currp, &qp->q_waiting);
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x....             LDR.N    R0,??DataTable2
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \   0000001C   0x.... 0x....      BL       queue_insert
     76            return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x200D             MOVS     R0,#+13
   \   00000024   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \                     ??qwait_1:
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     77          }
     78          
     79          /**
     80           * @brief   Initializes an input queue.
     81           * @details A Semaphore is internally initialized and works as a counter of
     82           *          the bytes contained in the queue.
     83           * @note    The callback is invoked from within the S-Locked system state,
     84           *          see @ref system_states.
     85           *
     86           * @param[out] iqp      pointer to an @p InputQueue structure
     87           * @param[in] bp        pointer to a memory area allocated as queue buffer
     88           * @param[in] size      size of the queue buffer
     89           * @param[in] infy      pointer to a callback function that is invoked when
     90           *                      data is read from the queue. The value can be @p NULL.
     91           * @param[in] link      application defined pointer
     92           *
     93           * @init
     94           */

   \                                 In section .text, align 2, keep-with-next
     95          void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
     96                        void *link) {
   \                     chIQInit:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x9C02             LDR      R4,[SP, #+8]
     97          
     98            queue_init(&iqp->q_waiting);
   \   00000004   0x6040             STR      R0,[R0, #+4]
   \   00000006   0x6000             STR      R0,[R0, #+0]
     99            iqp->q_counter = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x6085             STR      R5,[R0, #+8]
    100            iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
   \   0000000E   0x6181             STR      R1,[R0, #+24]
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    101            iqp->q_top = bp + size;
   \   00000012   0x1855             ADDS     R5,R2,R1
   \   00000014   0x6105             STR      R5,[R0, #+16]
    102            iqp->q_notify = infy;
   \   00000016   0x61C3             STR      R3,[R0, #+28]
    103            iqp->q_link = link;
   \   00000018   0x6204             STR      R4,[R0, #+32]
    104          }
   \   0000001A   0xBC30             POP      {R4,R5}
   \   0000001C   0x4770             BX       LR               ;; return
    105          
    106          /**
    107           * @brief   Resets an input queue.
    108           * @details All the data in the input queue is erased and lost, any waiting
    109           *          thread is resumed with status @p Q_RESET.
    110           * @note    A reset operation can be used by a low level driver in order to
    111           *          obtain immediate attention from the high level layers.
    112           *
    113           * @param[in] iqp       pointer to an @p InputQueue structure
    114           *
    115           * @iclass
    116           */

   \                                 In section .text, align 2, keep-with-next
    117          void chIQResetI(InputQueue *iqp) {
   \                     chIQResetI:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    118          
    119            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    120          
    121            iqp->q_rdptr = iqp->q_wrptr = iqp->q_buffer;
   \   00000008   0x68E0             LDR      R0,[R4, #+12]
   \   0000000A   0x6160             STR      R0,[R4, #+20]
   \   0000000C   0x61A0             STR      R0,[R4, #+24]
    122            iqp->q_counter = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x60A0             STR      R0,[R4, #+8]
    123            while (notempty(&iqp->q_waiting))
   \                     ??chIQResetI_0:
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x42A0             CMP      R0,R4
   \   00000016   0xD008             BEQ.N    ??chIQResetI_1
    124              chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_RESET;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       fifo_remove
   \   0000001E   0x.... 0x....      BL       chSchReadyI
   \   00000022   0xF07F 0x0101      MVNS     R1,#+1
   \   00000026   0x6281             STR      R1,[R0, #+40]
   \   00000028   0xE7F3             B.N      ??chIQResetI_0
    125          }
   \                     ??chIQResetI_1:
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    126          
    127          /**
    128           * @brief   Input queue write.
    129           * @details A byte value is written into the low end of an input queue.
    130           *
    131           * @param[in] iqp       pointer to an @p InputQueue structure
    132           * @param[in] b         the byte value to be written in the queue
    133           * @return              The operation status.
    134           * @retval Q_OK         if the operation has been completed with success.
    135           * @retval Q_FULL       if the queue is full and the operation cannot be
    136           *                      completed.
    137           *
    138           * @iclass
    139           */

   \                                 In section .text, align 2, keep-with-next
    140          msg_t chIQPutI(InputQueue *iqp, uint8_t b) {
   \                     chIQPutI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    141          
    142            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    143          
    144            if (chIQIsFullI(iqp))
   \   0000000A   0x6960             LDR      R0,[R4, #+20]
   \   0000000C   0x69A1             LDR      R1,[R4, #+24]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD104             BNE.N    ??chIQPutI_0
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??chIQPutI_0
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??chIQPutI_1
   \                     ??chIQPutI_0:
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??chIQPutI_1:
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD002             BEQ.N    ??chIQPutI_2
    145              return Q_FULL;
   \   00000024   0xF07F 0x0003      MVNS     R0,#+3
   \   00000028   0xE017             B.N      ??chIQPutI_3
    146          
    147            iqp->q_counter++;
   \                     ??chIQPutI_2:
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x60A0             STR      R0,[R4, #+8]
    148            *iqp->q_wrptr++ = b;
   \   00000030   0x6960             LDR      R0,[R4, #+20]
   \   00000032   0x1C41             ADDS     R1,R0,#+1
   \   00000034   0x6161             STR      R1,[R4, #+20]
   \   00000036   0x7005             STRB     R5,[R0, #+0]
    149            if (iqp->q_wrptr >= iqp->q_top)
   \   00000038   0x6960             LDR      R0,[R4, #+20]
   \   0000003A   0x6921             LDR      R1,[R4, #+16]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD301             BCC.N    ??chIQPutI_4
    150              iqp->q_wrptr = iqp->q_buffer;
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0x6160             STR      R0,[R4, #+20]
    151          
    152            if (notempty(&iqp->q_waiting))
   \                     ??chIQPutI_4:
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x42A0             CMP      R0,R4
   \   00000048   0xD006             BEQ.N    ??chIQPutI_5
    153              chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       fifo_remove
   \   00000050   0x.... 0x....      BL       chSchReadyI
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6281             STR      R1,[R0, #+40]
    154          
    155            return Q_OK;
   \                     ??chIQPutI_5:
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??chIQPutI_3:
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    156          }
    157          
    158          /**
    159           * @brief   Input queue read with timeout.
    160           * @details This function reads a byte value from an input queue. If the queue
    161           *          is empty then the calling thread is suspended until a byte arrives
    162           *          in the queue or a timeout occurs.
    163           * @note    The callback is invoked before reading the character from the
    164           *          buffer or before entering the state @p THD_STATE_WTQUEUE.
    165           *
    166           * @param[in] iqp       pointer to an @p InputQueue structure
    167           * @param[in] time      the number of ticks before the operation timeouts,
    168           *                      the following special values are allowed:
    169           *                      - @a TIME_IMMEDIATE immediate timeout.
    170           *                      - @a TIME_INFINITE no timeout.
    171           *                      .
    172           * @return              A byte value from the queue.
    173           * @retval Q_TIMEOUT    if the specified time expired.
    174           * @retval Q_RESET      if the queue has been reset.
    175           *
    176           * @api
    177           */

   \                                 In section .text, align 2, keep-with-next
    178          msg_t chIQGetTimeout(InputQueue *iqp, systime_t time) {
   \                     chIQGetTimeout:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    179            uint8_t b;
    180          
    181            chSysLock();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock
    182            if (iqp->q_notify)
   \   00000010   0x69E0             LDR      R0,[R4, #+28]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??chIQGetTimeout_0
    183              iqp->q_notify(iqp);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x69E1             LDR      R1,[R4, #+28]
   \   0000001A   0x4788             BLX      R1
    184          
    185            while (chIQIsEmptyI(iqp)) {
   \                     ??chIQGetTimeout_0:
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10D             BNE.N    ??chIQGetTimeout_1
    186              msg_t msg;
    187              if ((msg = qwait((GenericQueue *)iqp, time)) < Q_OK) {
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       qwait
   \   0000002A   0x0007             MOVS     R7,R0
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD5F5             BPL.N    ??chIQGetTimeout_0
    188                chSysUnlock();
   \   00000030   0x.... 0x....      BL       dbg_check_unlock
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF380 0x8811      MSR      BASEPRI,R0
    189                return msg;
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0xE014             B.N      ??chIQGetTimeout_2
    190              }
    191            }
    192          
    193            iqp->q_counter--;
   \                     ??chIQGetTimeout_1:
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x60A0             STR      R0,[R4, #+8]
    194            b = *iqp->q_rdptr++;
   \   00000044   0x69A0             LDR      R0,[R4, #+24]
   \   00000046   0x1C41             ADDS     R1,R0,#+1
   \   00000048   0x61A1             STR      R1,[R4, #+24]
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x0006             MOVS     R6,R0
    195            if (iqp->q_rdptr >= iqp->q_top)
   \   0000004E   0x69A0             LDR      R0,[R4, #+24]
   \   00000050   0x6921             LDR      R1,[R4, #+16]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD301             BCC.N    ??chIQGetTimeout_3
    196              iqp->q_rdptr = iqp->q_buffer;
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x61A0             STR      R0,[R4, #+24]
    197          
    198            chSysUnlock();
   \                     ??chIQGetTimeout_3:
   \   0000005A   0x.... 0x....      BL       dbg_check_unlock
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF380 0x8811      MSR      BASEPRI,R0
    199            return b;
   \   00000064   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000066   0x0030             MOVS     R0,R6
   \                     ??chIQGetTimeout_2:
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    200          }
    201          
    202          /**
    203           * @brief   Input queue read with timeout.
    204           * @details The function reads data from an input queue into a buffer. The
    205           *          operation completes when the specified amount of data has been
    206           *          transferred or after the specified timeout or if the queue has
    207           *          been reset.
    208           * @note    The function is not atomic, if you need atomicity it is suggested
    209           *          to use a semaphore or a mutex for mutual exclusion.
    210           * @note    The callback is invoked before reading each character from the
    211           *          buffer or before entering the state @p THD_STATE_WTQUEUE.
    212           *
    213           * @param[in] iqp       pointer to an @p InputQueue structure
    214           * @param[out] bp       pointer to the data buffer
    215           * @param[in] n         the maximum amount of data to be transferred, the
    216           *                      value 0 is reserved
    217           * @param[in] time      the number of ticks before the operation timeouts,
    218           *                      the following special values are allowed:
    219           *                      - @a TIME_IMMEDIATE immediate timeout.
    220           *                      - @a TIME_INFINITE no timeout.
    221           *                      .
    222           * @return              The number of bytes effectively transferred.
    223           *
    224           * @api
    225           */

   \                                 In section .text, align 2, keep-with-next
    226          size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
    227                                 size_t n, systime_t time) {
   \                     chIQReadTimeout:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    228            qnotify_t nfy = iqp->q_notify;
   \   0000000C   0xF8D4 0x901C      LDR      R9,[R4, #+28]
    229            size_t r = 0;
   \   00000010   0xF05F 0x0800      MOVS     R8,#+0
    230          
    231            chDbgCheck(n > 0, "chIQReadTimeout");
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD104             BNE.N    ??chIQReadTimeout_0
   \   00000018   0x22E7             MOVS     R2,#+231
   \   0000001A   0x....             LDR.N    R1,??DataTable2_1
   \   0000001C   0x....             LDR.N    R0,??DataTable2_2
   \   0000001E   0x.... 0x....      BL       chDbgPanic3
    232          
    233            chSysLock();
   \                     ??chIQReadTimeout_0:
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000028   0x.... 0x....      BL       dbg_check_lock
    234            while (TRUE) {
    235              if (nfy)
   \                     ??chIQReadTimeout_1:
   \   0000002C   0x4648             MOV      R0,R9
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??chIQReadTimeout_2
    236                nfy(iqp);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x47C8             BLX      R9
    237          
    238              while (chIQIsEmptyI(iqp)) {
   \                     ??chIQReadTimeout_2:
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD10C             BNE.N    ??chIQReadTimeout_3
    239                if (qwait((GenericQueue *)iqp, time) != Q_OK) {
   \   0000003C   0x0039             MOVS     R1,R7
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       qwait
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD0F6             BEQ.N    ??chIQReadTimeout_2
    240                  chSysUnlock();
   \   00000048   0x.... 0x....      BL       dbg_check_unlock
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF380 0x8811      MSR      BASEPRI,R0
    241                  return r;
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0xE020             B.N      ??chIQReadTimeout_4
    242                }
    243              }
    244          
    245              iqp->q_counter--;
   \                     ??chIQReadTimeout_3:
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x60A0             STR      R0,[R4, #+8]
    246              *bp++ = *iqp->q_rdptr++;
   \   0000005C   0x69A0             LDR      R0,[R4, #+24]
   \   0000005E   0x1C41             ADDS     R1,R0,#+1
   \   00000060   0x61A1             STR      R1,[R4, #+24]
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x7028             STRB     R0,[R5, #+0]
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
    247              if (iqp->q_rdptr >= iqp->q_top)
   \   00000068   0x69A0             LDR      R0,[R4, #+24]
   \   0000006A   0x6921             LDR      R1,[R4, #+16]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD301             BCC.N    ??chIQReadTimeout_5
    248                iqp->q_rdptr = iqp->q_buffer;
   \   00000070   0x68E0             LDR      R0,[R4, #+12]
   \   00000072   0x61A0             STR      R0,[R4, #+24]
    249          
    250              chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
   \                     ??chIQReadTimeout_5:
   \   00000074   0x.... 0x....      BL       dbg_check_unlock
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF380 0x8811      MSR      BASEPRI,R0
    251              r++;
   \   0000007E   0xF118 0x0801      ADDS     R8,R8,#+1
    252              if (--n == 0)
   \   00000082   0x1E76             SUBS     R6,R6,#+1
   \   00000084   0x2E00             CMP      R6,#+0
   \   00000086   0xD101             BNE.N    ??chIQReadTimeout_6
    253                return r;
   \   00000088   0x4640             MOV      R0,R8
   \   0000008A   0xE005             B.N      ??chIQReadTimeout_4
    254          
    255              chSysLock();
   \                     ??chIQReadTimeout_6:
   \   0000008C   0x2020             MOVS     R0,#+32
   \   0000008E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000092   0x.... 0x....      BL       dbg_check_lock
   \   00000096   0xE7C9             B.N      ??chIQReadTimeout_1
    256            }
   \                     ??chIQReadTimeout_4:
   \   00000098   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    257          }
    258          
    259          /**
    260           * @brief   Initializes an output queue.
    261           * @details A Semaphore is internally initialized and works as a counter of
    262           *          the free bytes in the queue.
    263           * @note    The callback is invoked from within the S-Locked system state,
    264           *          see @ref system_states.
    265           *
    266           * @param[out] oqp      pointer to an @p OutputQueue structure
    267           * @param[in] bp        pointer to a memory area allocated as queue buffer
    268           * @param[in] size      size of the queue buffer
    269           * @param[in] onfy      pointer to a callback function that is invoked when
    270           *                      data is written to the queue. The value can be @p NULL.
    271           * @param[in] link      application defined pointer
    272           *
    273           * @init
    274           */

   \                                 In section .text, align 2, keep-with-next
    275          void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
    276                        void *link) {
   \                     chOQInit:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x9C02             LDR      R4,[SP, #+8]
    277          
    278            queue_init(&oqp->q_waiting);
   \   00000004   0x6040             STR      R0,[R0, #+4]
   \   00000006   0x6000             STR      R0,[R0, #+0]
    279            oqp->q_counter = size;
   \   00000008   0x6082             STR      R2,[R0, #+8]
    280            oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
   \   0000000A   0x6141             STR      R1,[R0, #+20]
   \   0000000C   0x6181             STR      R1,[R0, #+24]
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    281            oqp->q_top = bp + size;
   \   00000010   0x1855             ADDS     R5,R2,R1
   \   00000012   0x6105             STR      R5,[R0, #+16]
    282            oqp->q_notify = onfy;
   \   00000014   0x61C3             STR      R3,[R0, #+28]
    283            oqp->q_link = link;
   \   00000016   0x6204             STR      R4,[R0, #+32]
    284          }
   \   00000018   0xBC30             POP      {R4,R5}
   \   0000001A   0x4770             BX       LR               ;; return
    285          
    286          /**
    287           * @brief   Resets an output queue.
    288           * @details All the data in the output queue is erased and lost, any waiting
    289           *          thread is resumed with status @p Q_RESET.
    290           * @note    A reset operation can be used by a low level driver in order to
    291           *          obtain immediate attention from the high level layers.
    292           *
    293           * @param[in] oqp       pointer to an @p OutputQueue structure
    294           *
    295           * @iclass
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          void chOQResetI(OutputQueue *oqp) {
   \                     chOQResetI:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    298          
    299            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    300          
    301            oqp->q_rdptr = oqp->q_wrptr = oqp->q_buffer;
   \   00000008   0x68E0             LDR      R0,[R4, #+12]
   \   0000000A   0x6160             STR      R0,[R4, #+20]
   \   0000000C   0x61A0             STR      R0,[R4, #+24]
    302            oqp->q_counter = chQSizeI(oqp);
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x68E1             LDR      R1,[R4, #+12]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    303            while (notempty(&oqp->q_waiting))
   \                     ??chOQResetI_0:
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD008             BEQ.N    ??chOQResetI_1
    304              chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_RESET;
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       fifo_remove
   \   00000022   0x.... 0x....      BL       chSchReadyI
   \   00000026   0xF07F 0x0101      MVNS     R1,#+1
   \   0000002A   0x6281             STR      R1,[R0, #+40]
   \   0000002C   0xE7F3             B.N      ??chOQResetI_0
    305          }
   \                     ??chOQResetI_1:
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    306          
    307          /**
    308           * @brief   Output queue write with timeout.
    309           * @details This function writes a byte value to an output queue. If the queue
    310           *          is full then the calling thread is suspended until there is space
    311           *          in the queue or a timeout occurs.
    312           * @note    The callback is invoked after writing the character into the
    313           *          buffer.
    314           *
    315           * @param[in] oqp       pointer to an @p OutputQueue structure
    316           * @param[in] b         the byte value to be written in the queue
    317           * @param[in] time      the number of ticks before the operation timeouts,
    318           *                      the following special values are allowed:
    319           *                      - @a TIME_IMMEDIATE immediate timeout.
    320           *                      - @a TIME_INFINITE no timeout.
    321           *                      .
    322           * @return              The operation status.
    323           * @retval Q_OK         if the operation succeeded.
    324           * @retval Q_TIMEOUT    if the specified time expired.
    325           * @retval Q_RESET      if the queue has been reset.
    326           *
    327           * @api
    328           */

   \                                 In section .text, align 2, keep-with-next
    329          msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {
   \                     chOQPutTimeout:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    330          
    331            chSysLock();
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000E   0x.... 0x....      BL       dbg_check_lock
    332            while (chOQIsFullI(oqp)) {
   \                     ??chOQPutTimeout_0:
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD10D             BNE.N    ??chOQPutTimeout_1
    333              msg_t msg;
    334          
    335              if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       qwait
   \   00000020   0x0007             MOVS     R7,R0
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD5F5             BPL.N    ??chOQPutTimeout_0
    336                chSysUnlock();
   \   00000026   0x.... 0x....      BL       dbg_check_unlock
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF380 0x8811      MSR      BASEPRI,R0
    337                return msg;
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0xE018             B.N      ??chOQPutTimeout_2
    338              }
    339            }
    340          
    341            oqp->q_counter--;
   \                     ??chOQPutTimeout_1:
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x1E40             SUBS     R0,R0,#+1
   \   00000038   0x60A0             STR      R0,[R4, #+8]
    342            *oqp->q_wrptr++ = b;
   \   0000003A   0x6960             LDR      R0,[R4, #+20]
   \   0000003C   0x1C41             ADDS     R1,R0,#+1
   \   0000003E   0x6161             STR      R1,[R4, #+20]
   \   00000040   0x7005             STRB     R5,[R0, #+0]
    343            if (oqp->q_wrptr >= oqp->q_top)
   \   00000042   0x6960             LDR      R0,[R4, #+20]
   \   00000044   0x6921             LDR      R1,[R4, #+16]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD301             BCC.N    ??chOQPutTimeout_3
    344              oqp->q_wrptr = oqp->q_buffer;
   \   0000004A   0x68E0             LDR      R0,[R4, #+12]
   \   0000004C   0x6160             STR      R0,[R4, #+20]
    345          
    346            if (oqp->q_notify)
   \                     ??chOQPutTimeout_3:
   \   0000004E   0x69E0             LDR      R0,[R4, #+28]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ.N    ??chOQPutTimeout_4
    347              oqp->q_notify(oqp);
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x69E1             LDR      R1,[R4, #+28]
   \   00000058   0x4788             BLX      R1
    348          
    349            chSysUnlock();
   \                     ??chOQPutTimeout_4:
   \   0000005A   0x.... 0x....      BL       dbg_check_unlock
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF380 0x8811      MSR      BASEPRI,R0
    350            return Q_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??chOQPutTimeout_2:
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    351          }
    352          
    353          /**
    354           * @brief   Output queue read.
    355           * @details A byte value is read from the low end of an output queue.
    356           *
    357           * @param[in] oqp       pointer to an @p OutputQueue structure
    358           * @return              The byte value from the queue.
    359           * @retval Q_EMPTY      if the queue is empty.
    360           *
    361           * @iclass
    362           */

   \                                 In section .text, align 2, keep-with-next
    363          msg_t chOQGetI(OutputQueue *oqp) {
   \                     chOQGetI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    364            uint8_t b;
    365          
    366            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    367          
    368            if (chOQIsEmptyI(oqp))
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x69A1             LDR      R1,[R4, #+24]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD104             BNE.N    ??chOQGetI_0
   \   00000010   0x68A0             LDR      R0,[R4, #+8]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??chOQGetI_0
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??chOQGetI_1
   \                     ??chOQGetI_0:
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??chOQGetI_1:
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??chOQGetI_2
    369              return Q_EMPTY;
   \   00000022   0xF07F 0x0002      MVNS     R0,#+2
   \   00000026   0xE019             B.N      ??chOQGetI_3
    370          
    371            oqp->q_counter++;
   \                     ??chOQGetI_2:
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x60A0             STR      R0,[R4, #+8]
    372            b = *oqp->q_rdptr++;
   \   0000002E   0x69A0             LDR      R0,[R4, #+24]
   \   00000030   0x1C41             ADDS     R1,R0,#+1
   \   00000032   0x61A1             STR      R1,[R4, #+24]
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x0005             MOVS     R5,R0
    373            if (oqp->q_rdptr >= oqp->q_top)
   \   00000038   0x69A0             LDR      R0,[R4, #+24]
   \   0000003A   0x6921             LDR      R1,[R4, #+16]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD301             BCC.N    ??chOQGetI_4
    374              oqp->q_rdptr = oqp->q_buffer;
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0x61A0             STR      R0,[R4, #+24]
    375          
    376            if (notempty(&oqp->q_waiting))
   \                     ??chOQGetI_4:
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x42A0             CMP      R0,R4
   \   00000048   0xD006             BEQ.N    ??chOQGetI_5
    377              chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       fifo_remove
   \   00000050   0x.... 0x....      BL       chSchReadyI
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6281             STR      R1,[R0, #+40]
    378          
    379            return b;
   \                     ??chOQGetI_5:
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x0028             MOVS     R0,R5
   \                     ??chOQGetI_3:
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    380          }
    381          
    382          /**
    383           * @brief   Output queue write with timeout.
    384           * @details The function writes data from a buffer to an output queue. The
    385           *          operation completes when the specified amount of data has been
    386           *          transferred or after the specified timeout or if the queue has
    387           *          been reset.
    388           * @note    The function is not atomic, if you need atomicity it is suggested
    389           *          to use a semaphore or a mutex for mutual exclusion.
    390           * @note    The callback is invoked after writing each character into the
    391           *          buffer.
    392           *
    393           * @param[in] oqp       pointer to an @p OutputQueue structure
    394           * @param[in] bp        pointer to the data buffer
    395           * @param[in] n         the maximum amount of data to be transferred, the
    396           *                      value 0 is reserved
    397           * @param[in] time      the number of ticks before the operation timeouts,
    398           *                      the following special values are allowed:
    399           *                      - @a TIME_IMMEDIATE immediate timeout.
    400           *                      - @a TIME_INFINITE no timeout.
    401           *                      .
    402           * @return              The number of bytes effectively transferred.
    403           *
    404           * @api
    405           */

   \                                 In section .text, align 2, keep-with-next
    406          size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
    407                                  size_t n, systime_t time) {
   \                     chOQWriteTimeout:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    408            qnotify_t nfy = oqp->q_notify;
   \   0000000C   0xF8D4 0x801C      LDR      R8,[R4, #+28]
    409            size_t w = 0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    410          
    411            chDbgCheck(n > 0, "chOQWriteTimeout");
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD105             BNE.N    ??chOQWriteTimeout_0
   \   00000018   0xF240 0x129B      MOVW     R2,#+411
   \   0000001C   0x....             LDR.N    R1,??DataTable2_1
   \   0000001E   0x....             LDR.N    R0,??DataTable2_3
   \   00000020   0x.... 0x....      BL       chDbgPanic3
    412          
    413            chSysLock();
   \                     ??chOQWriteTimeout_0:
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000002A   0x.... 0x....      BL       dbg_check_lock
    414            while (TRUE) {
    415              while (chOQIsFullI(oqp)) {
   \                     ??chOQWriteTimeout_1:
   \                     ??chOQWriteTimeout_2:
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10C             BNE.N    ??chOQWriteTimeout_3
    416                if (qwait((GenericQueue *)oqp, time) != Q_OK) {
   \   00000034   0x0039             MOVS     R1,R7
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       qwait
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD0F6             BEQ.N    ??chOQWriteTimeout_2
    417                  chSysUnlock();
   \   00000040   0x.... 0x....      BL       dbg_check_unlock
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF380 0x8811      MSR      BASEPRI,R0
    418                  return w;
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0xE025             B.N      ??chOQWriteTimeout_4
    419                }
    420              }
    421              oqp->q_counter--;
   \                     ??chOQWriteTimeout_3:
   \   0000004E   0x68A0             LDR      R0,[R4, #+8]
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x60A0             STR      R0,[R4, #+8]
    422              *oqp->q_wrptr++ = *bp++;
   \   00000054   0x6960             LDR      R0,[R4, #+20]
   \   00000056   0x1C41             ADDS     R1,R0,#+1
   \   00000058   0x6161             STR      R1,[R4, #+20]
   \   0000005A   0x7829             LDRB     R1,[R5, #+0]
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
   \   0000005E   0x1C6D             ADDS     R5,R5,#+1
    423              if (oqp->q_wrptr >= oqp->q_top)
   \   00000060   0x6960             LDR      R0,[R4, #+20]
   \   00000062   0x6921             LDR      R1,[R4, #+16]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD301             BCC.N    ??chOQWriteTimeout_5
    424                oqp->q_wrptr = oqp->q_buffer;
   \   00000068   0x68E0             LDR      R0,[R4, #+12]
   \   0000006A   0x6160             STR      R0,[R4, #+20]
    425          
    426              if (nfy)
   \                     ??chOQWriteTimeout_5:
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD001             BEQ.N    ??chOQWriteTimeout_6
    427                nfy(oqp);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x47C0             BLX      R8
    428          
    429              chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
   \                     ??chOQWriteTimeout_6:
   \   00000076   0x.... 0x....      BL       dbg_check_unlock
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xF380 0x8811      MSR      BASEPRI,R0
    430              w++;
   \   00000080   0xF119 0x0901      ADDS     R9,R9,#+1
    431              if (--n == 0)
   \   00000084   0x1E76             SUBS     R6,R6,#+1
   \   00000086   0x2E00             CMP      R6,#+0
   \   00000088   0xD101             BNE.N    ??chOQWriteTimeout_7
    432                return w;
   \   0000008A   0x4648             MOV      R0,R9
   \   0000008C   0xE005             B.N      ??chOQWriteTimeout_4
    433              chSysLock();
   \                     ??chOQWriteTimeout_7:
   \   0000008E   0x2020             MOVS     R0,#+32
   \   00000090   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000094   0x.... 0x....      BL       dbg_check_lock
   \   00000098   0xE7C9             B.N      ??chOQWriteTimeout_1
    434            }
   \                     ??chOQWriteTimeout_4:
   \   0000009A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    435          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     `?<Constant "\\"chIQReadTimeout\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     `?<Constant "\\"chOQWriteTimeout\\"()">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chIQReadTimeout\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chIQReadTimeout\"()"
   \              0x68 0x49    
   \              0x51 0x52    
   \              0x65 0x61    
   \              0x64 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x6B 0x65          DC8 6BH, 65H, 72H, 6EH, 65H, 6CH, 5CH, 73H
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x5C 0x73    
   \   00000038   0x72 0x63          DC8 72H, 63H, 5CH, 63H, 68H, 71H, 75H, 65H
   \              0x5C 0x63    
   \              0x68 0x71    
   \              0x75 0x65    
   \   00000040   0x75 0x65          DC8 75H, 65H, 73H, 2EH, 63H, 0
   \              0x73 0x2E    
   \              0x63 0x00    
   \   00000046   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chOQWriteTimeout\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chOQWriteTimeout\"()"
   \              0x68 0x4F    
   \              0x51 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x6F 0x75    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    436          #endif  /* CH_USE_QUEUES */
    437          
    438          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   chIQGetTimeout
        24   -- Indirect call
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
        24   -> qwait
       8   chIQInit
      16   chIQPutI
        16   -> chDbgCheckClassI
        16   -> chSchReadyI
        16   -> fifo_remove
      32   chIQReadTimeout
        32   -- Indirect call
        32   -> chDbgPanic3
        32   -> dbg_check_lock
        32   -> dbg_check_unlock
        32   -> qwait
       8   chIQResetI
         8   -> chDbgCheckClassI
         8   -> chSchReadyI
         8   -> fifo_remove
      16   chOQGetI
        16   -> chDbgCheckClassI
        16   -> chSchReadyI
        16   -> fifo_remove
       8   chOQInit
      24   chOQPutTimeout
        24   -- Indirect call
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
        24   -> qwait
       8   chOQResetI
         8   -> chDbgCheckClassI
         8   -> chSchReadyI
         8   -> fifo_remove
      32   chOQWriteTimeout
        32   -- Indirect call
        32   -> chDbgPanic3
        32   -> dbg_check_lock
        32   -> dbg_check_unlock
        32   -> qwait
       0   fifo_remove
       0   queue_insert
      16   qwait
        16   -> chSchGoSleepTimeoutS
        16   -> queue_insert


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  ?<Constant "F:\\stuff\\rusefi_sourc...">
      20  ?<Constant "\"chIQReadTimeout\"()">
      24  ?<Constant "\"chOQWriteTimeout\"()">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
     106  chIQGetTimeout
      30  chIQInit
      92  chIQPutI
     156  chIQReadTimeout
      44  chIQResetI
      94  chOQGetI
      28  chOQInit
     104  chOQPutTimeout
      48  chOQResetI
     158  chOQWriteTimeout
      12  fifo_remove
      14  queue_insert
      42  qwait

 
 116 bytes in section .rodata
 944 bytes in section .text
 
 944 bytes of CODE  memory
 116 bytes of CONST memory

Errors: none
Warnings: none
