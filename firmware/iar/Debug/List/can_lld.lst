###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:41 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\can_lld.c                              #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\can_lld.c -lCN                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       an_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ca #
#                       n_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\can_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/can_lld.c
     19           * @brief   STM32 CAN subsystem low level driver source.
     20           *
     21           * @addtogroup CAN
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_CAN || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          /*===========================================================================*/
     35          /* Driver exported variables.                                                */
     36          /*===========================================================================*/
     37          
     38          /** @brief CAN1 driver identifier.*/
     39          #if STM32_CAN_USE_CAN1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     40          CANDriver CAND1;
   \                     CAND1:
   \   00000000                      DS8 56
     41          #endif
     42          
     43          /** @brief CAN2 driver identifier.*/
     44          #if STM32_CAN_USE_CAN2 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     45          CANDriver CAND2;
   \                     CAND2:
   \   00000000                      DS8 56
     46          #endif
     47          
     48          /*===========================================================================*/
     49          /* Driver local variables and types.                                         */
     50          /*===========================================================================*/
     51          
     52          /*===========================================================================*/
     53          /* Driver local functions.                                                   */
     54          /*===========================================================================*/
     55          
     56          /**
     57           * @brief   Programs the filters.
     58           *
     59           * @param[in] can2sb    number of the first filter assigned to CAN2
     60           * @param[in] num       number of entries in the filters array, if zero then
     61           *                      a default filter is programmed
     62           * @param[in] cfp       pointer to the filters array, can be @p NULL if
     63           *                      (num == 0)
     64           *
     65           * @notapi
     66           */

   \                                 In section .text, align 2, keep-with-next
     67          static void can_lld_set_filters(uint32_t can2sb,
     68                                          uint32_t num,
     69                                          const CANFilter *cfp) {
   \                     can_lld_set_filters:
   \   00000000   0xB4F0             PUSH     {R4-R7}
     70          
     71            /* Temporarily enabling CAN1 clock.*/
     72            rccEnableCAN1(FALSE);
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable13  ;; 0x40023840
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0xF053 0x7300      ORRS     R3,R3,#0x2000000
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable13  ;; 0x40023840
   \   00000010   0x6023             STR      R3,[R4, #+0]
     73          
     74            /* Filters initialization.*/
     75            CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable13_1  ;; 0x40006600
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0x0C1B             LSRS     R3,R3,#+16
   \   0000001A   0x041B             LSLS     R3,R3,#+16
   \   0000001C   0xEA53 0x2300      ORRS     R3,R3,R0, LSL #+8
   \   00000020   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000024   0x.... 0x....      LDR.W    R4,??DataTable13_1  ;; 0x40006600
   \   00000028   0x6023             STR      R3,[R4, #+0]
     76            if (num > 0) {
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD061             BEQ.N    ??can_lld_set_filters_0
     77              uint32_t i, fmask;
     78          
     79              /* All filters cleared.*/
     80              CAN1->FA1R = 0;
   \   0000002E   0x.... 0x....      LDR.W    R5,??DataTable13_2  ;; 0x4000661c
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0x602E             STR      R6,[R5, #+0]
     81              CAN1->FM1R = 0;
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable13_3  ;; 0x40006604
   \   0000003A   0x2600             MOVS     R6,#+0
   \   0000003C   0x602E             STR      R6,[R5, #+0]
     82              CAN1->FS1R = 0;
   \   0000003E   0x.... 0x....      LDR.W    R5,??DataTable13_4  ;; 0x4000660c
   \   00000042   0x2600             MOVS     R6,#+0
   \   00000044   0x602E             STR      R6,[R5, #+0]
     83              CAN1->FFA1R = 0;
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable13_5  ;; 0x40006614
   \   0000004A   0x2600             MOVS     R6,#+0
   \   0000004C   0x602E             STR      R6,[R5, #+0]
     84              for (i = 0; i < STM32_CAN_MAX_FILTERS; i++) {
   \   0000004E   0x2500             MOVS     R5,#+0
   \   00000050   0x002B             MOVS     R3,R5
   \                     ??can_lld_set_filters_1:
   \   00000052   0x2B1C             CMP      R3,#+28
   \   00000054   0xD20C             BCS.N    ??can_lld_set_filters_2
     85                CAN1->sFilterRegister[i].FR1 = 0;
   \   00000056   0x.... 0x....      LDR.W    R5,??DataTable13_6  ;; 0x40006640
   \   0000005A   0x2600             MOVS     R6,#+0
   \   0000005C   0xF845 0x6033      STR      R6,[R5, R3, LSL #+3]
     86                CAN1->sFilterRegister[i].FR2 = 0;
   \   00000060   0x.... 0x....      LDR.W    R5,??DataTable13_6  ;; 0x40006640
   \   00000064   0xEB15 0x05C3      ADDS     R5,R5,R3, LSL #+3
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0x606E             STR      R6,[R5, #+4]
     87              }
   \   0000006C   0x1C5B             ADDS     R3,R3,#+1
   \   0000006E   0xE7F0             B.N      ??can_lld_set_filters_1
     88          
     89              /* Scanning the filters array.*/
     90              for (i = 0; i < num; i++) {
   \                     ??can_lld_set_filters_2:
   \   00000070   0x2500             MOVS     R5,#+0
   \   00000072   0x002B             MOVS     R3,R5
   \                     ??can_lld_set_filters_3:
   \   00000074   0x428B             CMP      R3,R1
   \   00000076   0xD265             BCS.N    ??can_lld_set_filters_4
     91                fmask = 1 << cfp->filter;
   \   00000078   0x2501             MOVS     R5,#+1
   \   0000007A   0x6816             LDR      R6,[R2, #+0]
   \   0000007C   0x40B5             LSLS     R5,R5,R6
   \   0000007E   0x002C             MOVS     R4,R5
     92                if (cfp->mode)
   \   00000080   0x7915             LDRB     R5,[R2, #+4]
   \   00000082   0x07ED             LSLS     R5,R5,#+31
   \   00000084   0xD506             BPL.N    ??can_lld_set_filters_5
     93                  CAN1->FM1R |= fmask;
   \   00000086   0x.... 0x....      LDR.W    R5,??DataTable13_3  ;; 0x40006604
   \   0000008A   0x682D             LDR      R5,[R5, #+0]
   \   0000008C   0x4325             ORRS     R5,R4,R5
   \   0000008E   0x.... 0x....      LDR.W    R6,??DataTable13_3  ;; 0x40006604
   \   00000092   0x6035             STR      R5,[R6, #+0]
     94                if (cfp->scale)
   \                     ??can_lld_set_filters_5:
   \   00000094   0x6855             LDR      R5,[R2, #+4]
   \   00000096   0xF3C5 0x0540      UBFX     R5,R5,#+1,#+1
   \   0000009A   0x2D00             CMP      R5,#+0
   \   0000009C   0xD006             BEQ.N    ??can_lld_set_filters_6
     95                  CAN1->FS1R |= fmask;
   \   0000009E   0x.... 0x....      LDR.W    R5,??DataTable13_4  ;; 0x4000660c
   \   000000A2   0x682D             LDR      R5,[R5, #+0]
   \   000000A4   0x4325             ORRS     R5,R4,R5
   \   000000A6   0x.... 0x....      LDR.W    R6,??DataTable13_4  ;; 0x4000660c
   \   000000AA   0x6035             STR      R5,[R6, #+0]
     96                if (cfp->assignment)
   \                     ??can_lld_set_filters_6:
   \   000000AC   0x6855             LDR      R5,[R2, #+4]
   \   000000AE   0xF3C5 0x0580      UBFX     R5,R5,#+2,#+1
   \   000000B2   0x2D00             CMP      R5,#+0
   \   000000B4   0xD006             BEQ.N    ??can_lld_set_filters_7
     97                  CAN1->FFA1R |= fmask;
   \   000000B6   0x.... 0x....      LDR.W    R5,??DataTable13_5  ;; 0x40006614
   \   000000BA   0x682D             LDR      R5,[R5, #+0]
   \   000000BC   0x4325             ORRS     R5,R4,R5
   \   000000BE   0x.... 0x....      LDR.W    R6,??DataTable13_5  ;; 0x40006614
   \   000000C2   0x6035             STR      R5,[R6, #+0]
     98                CAN1->sFilterRegister[cfp->filter].FR1 = cfp->register1;
   \                     ??can_lld_set_filters_7:
   \   000000C4   0x6815             LDR      R5,[R2, #+0]
   \   000000C6   0x.... 0x....      LDR.W    R6,??DataTable13_6  ;; 0x40006640
   \   000000CA   0x6897             LDR      R7,[R2, #+8]
   \   000000CC   0xF846 0x7035      STR      R7,[R6, R5, LSL #+3]
     99                CAN1->sFilterRegister[cfp->filter].FR2 = cfp->register2;
   \   000000D0   0x6815             LDR      R5,[R2, #+0]
   \   000000D2   0x.... 0x....      LDR.W    R6,??DataTable13_6  ;; 0x40006640
   \   000000D6   0xEB16 0x05C5      ADDS     R5,R6,R5, LSL #+3
   \   000000DA   0x68D6             LDR      R6,[R2, #+12]
   \   000000DC   0x606E             STR      R6,[R5, #+4]
    100                CAN1->FA1R |= fmask;
   \   000000DE   0x.... 0x....      LDR.W    R5,??DataTable13_2  ;; 0x4000661c
   \   000000E2   0x682D             LDR      R5,[R5, #+0]
   \   000000E4   0x4325             ORRS     R5,R4,R5
   \   000000E6   0x.... 0x....      LDR.W    R6,??DataTable13_2  ;; 0x4000661c
   \   000000EA   0x6035             STR      R5,[R6, #+0]
    101                cfp++;
   \   000000EC   0x3210             ADDS     R2,R2,#+16
    102              }
   \   000000EE   0x1C5B             ADDS     R3,R3,#+1
   \   000000F0   0xE7C0             B.N      ??can_lld_set_filters_3
    103            }
    104            else {
    105              /* Setting up a single default filter that enables everything for both
    106                 CANs.*/
    107              CAN1->sFilterRegister[0].FR1 = 0;
   \                     ??can_lld_set_filters_0:
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable13_6  ;; 0x40006640
   \   000000F6   0x2400             MOVS     R4,#+0
   \   000000F8   0x601C             STR      R4,[R3, #+0]
    108              CAN1->sFilterRegister[0].FR2 = 0;
   \   000000FA   0x.... 0x....      LDR.W    R3,??DataTable13_7  ;; 0x40006644
   \   000000FE   0x2400             MOVS     R4,#+0
   \   00000100   0x601C             STR      R4,[R3, #+0]
    109          #if STM32_HAS_CAN2
    110              CAN1->sFilterRegister[can2sb].FR1 = 0;
   \   00000102   0x.... 0x....      LDR.W    R3,??DataTable13_6  ;; 0x40006640
   \   00000106   0x2400             MOVS     R4,#+0
   \   00000108   0xF843 0x4030      STR      R4,[R3, R0, LSL #+3]
    111              CAN1->sFilterRegister[can2sb].FR2 = 0;
   \   0000010C   0x.... 0x....      LDR.W    R3,??DataTable13_6  ;; 0x40006640
   \   00000110   0xEB13 0x03C0      ADDS     R3,R3,R0, LSL #+3
   \   00000114   0x2400             MOVS     R4,#+0
   \   00000116   0x605C             STR      R4,[R3, #+4]
    112          #endif
    113              CAN1->FM1R = 0;
   \   00000118   0x.... 0x....      LDR.W    R3,??DataTable13_3  ;; 0x40006604
   \   0000011C   0x2400             MOVS     R4,#+0
   \   0000011E   0x601C             STR      R4,[R3, #+0]
    114              CAN1->FFA1R = 0;
   \   00000120   0x.... 0x....      LDR.W    R3,??DataTable13_5  ;; 0x40006614
   \   00000124   0x2400             MOVS     R4,#+0
   \   00000126   0x601C             STR      R4,[R3, #+0]
    115          #if STM32_HAS_CAN2
    116              CAN1->FS1R = 1 | (1 << can2sb);
   \   00000128   0x2301             MOVS     R3,#+1
   \   0000012A   0x4083             LSLS     R3,R3,R0
   \   0000012C   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   00000130   0x.... 0x....      LDR.W    R4,??DataTable13_4  ;; 0x4000660c
   \   00000134   0x6023             STR      R3,[R4, #+0]
    117              CAN1->FA1R = 1 | (1 << can2sb);
   \   00000136   0x2301             MOVS     R3,#+1
   \   00000138   0x4083             LSLS     R3,R3,R0
   \   0000013A   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   0000013E   0x.... 0x....      LDR.W    R4,??DataTable13_2  ;; 0x4000661c
   \   00000142   0x6023             STR      R3,[R4, #+0]
    118          #else
    119              CAN1->FS1R = 1;
    120              CAN1->FA1R = 1;
    121          #endif
    122            }
    123            CAN1->FMR &= ~CAN_FMR_FINIT;
   \                     ??can_lld_set_filters_4:
   \   00000144   0x.... 0x....      LDR.W    R3,??DataTable13_1  ;; 0x40006600
   \   00000148   0x681B             LDR      R3,[R3, #+0]
   \   0000014A   0x085B             LSRS     R3,R3,#+1
   \   0000014C   0x005B             LSLS     R3,R3,#+1
   \   0000014E   0x.... 0x....      LDR.W    R4,??DataTable13_1  ;; 0x40006600
   \   00000152   0x6023             STR      R3,[R4, #+0]
    124          
    125            /* Clock disabled, it will be enabled again in can_lld_start().*/
    126            rccDisableCAN1(FALSE);
   \   00000154   0x.... 0x....      LDR.W    R3,??DataTable13  ;; 0x40023840
   \   00000158   0x681B             LDR      R3,[R3, #+0]
   \   0000015A   0xF033 0x7300      BICS     R3,R3,#0x2000000
   \   0000015E   0x.... 0x....      LDR.W    R4,??DataTable13  ;; 0x40023840
   \   00000162   0x6023             STR      R3,[R4, #+0]
    127          }
   \   00000164   0xBCF0             POP      {R4-R7}
   \   00000166   0x4770             BX       LR               ;; return
    128          
    129          /**
    130           * @brief   Common TX ISR handler.
    131           *
    132           * @param[in] canp      pointer to the @p CANDriver object
    133           *
    134           * @notapi
    135           */

   \                                 In section .text, align 2, keep-with-next
    136          static void can_lld_tx_handler(CANDriver *canp) {
   \                     can_lld_tx_handler:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    137          
    138            /* No more events until a message is transmitted.*/
    139            canp->can->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable13_8  ;; 0x10101
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    140            chSysLockFromIsr();
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000012   0x.... 0x....      BL       dbg_check_lock_from_isr
    141            while (chSemGetCounterI(&canp->txsem) < 0)
   \                     ??can_lld_tx_handler_0:
   \   00000016   0x6920             LDR      R0,[R4, #+16]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD504             BPL.N    ??can_lld_tx_handler_1
    142              chSemSignalI(&canp->txsem);
   \   0000001C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000020   0x.... 0x....      BL       chSemSignalI
   \   00000024   0xE7F7             B.N      ??can_lld_tx_handler_0
    143            chEvtBroadcastFlagsI(&canp->txempty_event, CAN_MAILBOX_TO_MASK(1));
   \                     ??can_lld_tx_handler_1:
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF114 0x0024      ADDS     R0,R4,#+36
   \   0000002C   0x.... 0x....      BL       chEvtBroadcastFlagsI
    144            chSysUnlockFromIsr();
   \   00000030   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF380 0x8811      MSR      BASEPRI,R0
    145          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    146          
    147          /**
    148           * @brief   Common RX0 ISR handler.
    149           *
    150           * @param[in] canp      pointer to the @p CANDriver object
    151           *
    152           * @notapi
    153           */

   \                                 In section .text, align 2, keep-with-next
    154          static void can_lld_rx0_handler(CANDriver *canp) {
   \                     can_lld_rx0_handler:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    155            uint32_t rf0r;
    156          
    157            rf0r = canp->can->RF0R;
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0x0005             MOVS     R5,R0
    158            if ((rf0r & CAN_RF0R_FMP0) > 0) {
   \   0000000A   0xF015 0x0F03      TST      R5,#0x3
   \   0000000E   0xD01C             BEQ.N    ??can_lld_rx0_handler_0
    159              /* No more receive events until the queue 0 has been emptied.*/
    160              canp->can->IER &= ~CAN_IER_FMPIE0;
   \   00000010   0x6B60             LDR      R0,[R4, #+52]
   \   00000012   0x6940             LDR      R0,[R0, #+20]
   \   00000014   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000018   0x6B61             LDR      R1,[R4, #+52]
   \   0000001A   0x6148             STR      R0,[R1, #+20]
    161              chSysLockFromIsr();
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000022   0x.... 0x....      BL       dbg_check_lock_from_isr
    162              while (chSemGetCounterI(&canp->rxsem) < 0)
   \                     ??can_lld_rx0_handler_1:
   \   00000026   0x69E0             LDR      R0,[R4, #+28]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD504             BPL.N    ??can_lld_rx0_handler_2
    163                chSemSignalI(&canp->rxsem);
   \   0000002C   0xF114 0x0014      ADDS     R0,R4,#+20
   \   00000030   0x.... 0x....      BL       chSemSignalI
   \   00000034   0xE7F7             B.N      ??can_lld_rx0_handler_1
    164              chEvtBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1));
   \                     ??can_lld_rx0_handler_2:
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000003C   0x.... 0x....      BL       chEvtBroadcastFlagsI
    165              chSysUnlockFromIsr();
   \   00000040   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF380 0x8811      MSR      BASEPRI,R0
    166            }
    167            if ((rf0r & CAN_RF0R_FOVR0) > 0) {
   \                     ??can_lld_rx0_handler_0:
   \   0000004A   0x06E8             LSLS     R0,R5,#+27
   \   0000004C   0xD511             BPL.N    ??can_lld_rx0_handler_3
    168              /* Overflow events handling.*/
    169              canp->can->RF0R = CAN_RF0R_FOVR0;
   \   0000004E   0x6B60             LDR      R0,[R4, #+52]
   \   00000050   0x2110             MOVS     R1,#+16
   \   00000052   0x60C1             STR      R1,[R0, #+12]
    170              chSysLockFromIsr();
   \   00000054   0x2020             MOVS     R0,#+32
   \   00000056   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000005A   0x.... 0x....      BL       dbg_check_lock_from_isr
    171              chEvtBroadcastFlagsI(&canp->error_event, CAN_OVERFLOW_ERROR);
   \   0000005E   0x2110             MOVS     R1,#+16
   \   00000060   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000064   0x.... 0x....      BL       chEvtBroadcastFlagsI
    172              chSysUnlockFromIsr();
   \   00000068   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF380 0x8811      MSR      BASEPRI,R0
    173            }
    174          }
   \                     ??can_lld_rx0_handler_3:
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    175          
    176          /**
    177           * @brief   Common RX1 ISR handler.
    178           *
    179           * @param[in] canp      pointer to the @p CANDriver object
    180           *
    181           * @notapi
    182           */

   \                                 In section .text, align 2, keep-with-next
    183          static void can_lld_rx1_handler(CANDriver *canp) {
   \                     can_lld_rx1_handler:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    184            uint32_t rf1r;
    185          
    186            rf1r = canp->can->RF1R;
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0005             MOVS     R5,R0
    187            if ((rf1r & CAN_RF1R_FMP1) > 0) {
   \   0000000A   0xF015 0x0F03      TST      R5,#0x3
   \   0000000E   0xD01C             BEQ.N    ??can_lld_rx1_handler_0
    188              /* No more receive events until the queue 0 has been emptied.*/
    189              canp->can->IER &= ~CAN_IER_FMPIE1;
   \   00000010   0x6B60             LDR      R0,[R4, #+52]
   \   00000012   0x6940             LDR      R0,[R0, #+20]
   \   00000014   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000018   0x6B61             LDR      R1,[R4, #+52]
   \   0000001A   0x6148             STR      R0,[R1, #+20]
    190              chSysLockFromIsr();
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000022   0x.... 0x....      BL       dbg_check_lock_from_isr
    191              while (chSemGetCounterI(&canp->rxsem) < 0)
   \                     ??can_lld_rx1_handler_1:
   \   00000026   0x69E0             LDR      R0,[R4, #+28]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD504             BPL.N    ??can_lld_rx1_handler_2
    192                chSemSignalI(&canp->rxsem);
   \   0000002C   0xF114 0x0014      ADDS     R0,R4,#+20
   \   00000030   0x.... 0x....      BL       chSemSignalI
   \   00000034   0xE7F7             B.N      ??can_lld_rx1_handler_1
    193              chEvtBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2));
   \                     ??can_lld_rx1_handler_2:
   \   00000036   0x2102             MOVS     R1,#+2
   \   00000038   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000003C   0x.... 0x....      BL       chEvtBroadcastFlagsI
    194              chSysUnlockFromIsr();
   \   00000040   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF380 0x8811      MSR      BASEPRI,R0
    195            }
    196            if ((rf1r & CAN_RF1R_FOVR1) > 0) {
   \                     ??can_lld_rx1_handler_0:
   \   0000004A   0x06E8             LSLS     R0,R5,#+27
   \   0000004C   0xD511             BPL.N    ??can_lld_rx1_handler_3
    197              /* Overflow events handling.*/
    198              canp->can->RF1R = CAN_RF1R_FOVR1;
   \   0000004E   0x6B60             LDR      R0,[R4, #+52]
   \   00000050   0x2110             MOVS     R1,#+16
   \   00000052   0x6101             STR      R1,[R0, #+16]
    199              chSysLockFromIsr();
   \   00000054   0x2020             MOVS     R0,#+32
   \   00000056   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000005A   0x.... 0x....      BL       dbg_check_lock_from_isr
    200              chEvtBroadcastFlagsI(&canp->error_event, CAN_OVERFLOW_ERROR);
   \   0000005E   0x2110             MOVS     R1,#+16
   \   00000060   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000064   0x.... 0x....      BL       chEvtBroadcastFlagsI
    201              chSysUnlockFromIsr();
   \   00000068   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF380 0x8811      MSR      BASEPRI,R0
    202            }
    203          }
   \                     ??can_lld_rx1_handler_3:
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    204          
    205          /**
    206           * @brief   Common SCE ISR handler.
    207           *
    208           * @param[in] canp      pointer to the @p CANDriver object
    209           *
    210           * @notapi
    211           */

   \                                 In section .text, align 2, keep-with-next
    212          static void can_lld_sce_handler(CANDriver *canp) {
   \                     can_lld_sce_handler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    213            uint32_t msr;
    214          
    215            msr = canp->can->MSR;
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x6840             LDR      R0,[R0, #+4]
   \   00000008   0x0005             MOVS     R5,R0
    216            canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
   \   0000000A   0x6B60             LDR      R0,[R4, #+52]
   \   0000000C   0x211C             MOVS     R1,#+28
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    217            /* Wakeup event.*/
    218          #if CAN_USE_SLEEP_MODE
    219            if (msr & CAN_MSR_WKUI) {
   \   00000010   0x0728             LSLS     R0,R5,#+28
   \   00000012   0xD516             BPL.N    ??can_lld_sce_handler_0
    220              canp->state = CAN_READY;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    221              canp->can->MCR &= ~CAN_MCR_SLEEP;
   \   00000018   0x6B60             LDR      R0,[R4, #+52]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000020   0x6B61             LDR      R1,[R4, #+52]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    222              chSysLockFromIsr();
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000002A   0x.... 0x....      BL       dbg_check_lock_from_isr
    223              chEvtBroadcastI(&canp->wakeup_event);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000034   0x.... 0x....      BL       chEvtBroadcastFlagsI
    224              chSysUnlockFromIsr();
   \   00000038   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF380 0x8811      MSR      BASEPRI,R0
    225            }
    226          #endif /* CAN_USE_SLEEP_MODE */
    227            /* Error event.*/
    228            if (msr & CAN_MSR_ERRI) {
   \                     ??can_lld_sce_handler_0:
   \   00000042   0x0768             LSLS     R0,R5,#+29
   \   00000044   0xD51F             BPL.N    ??can_lld_sce_handler_1
    229              flagsmask_t flags;
    230              uint32_t esr = canp->can->ESR;
   \   00000046   0x6B60             LDR      R0,[R4, #+52]
   \   00000048   0x6987             LDR      R7,[R0, #+24]
    231          
    232              canp->can->ESR &= ~CAN_ESR_LEC;
   \   0000004A   0x6B60             LDR      R0,[R4, #+52]
   \   0000004C   0x6980             LDR      R0,[R0, #+24]
   \   0000004E   0xF030 0x0070      BICS     R0,R0,#0x70
   \   00000052   0x6B61             LDR      R1,[R4, #+52]
   \   00000054   0x6188             STR      R0,[R1, #+24]
    233              flags = (flagsmask_t)(esr & 7);
   \   00000056   0xF017 0x0007      ANDS     R0,R7,#0x7
   \   0000005A   0x0006             MOVS     R6,R0
    234              if ((esr & CAN_ESR_LEC) > 0)
   \   0000005C   0xF017 0x0F70      TST      R7,#0x70
   \   00000060   0xD001             BEQ.N    ??can_lld_sce_handler_2
    235                flags |= CAN_FRAMING_ERROR;
   \   00000062   0xF056 0x0608      ORRS     R6,R6,#0x8
    236          
    237              chSysLockFromIsr();
   \                     ??can_lld_sce_handler_2:
   \   00000066   0x2020             MOVS     R0,#+32
   \   00000068   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000006C   0x.... 0x....      BL       dbg_check_lock_from_isr
    238              /* The content of the ESR register is copied unchanged in the upper
    239                 half word of the listener flags mask.*/
    240              chEvtBroadcastFlagsI(&canp->error_event, flags | (flagsmask_t)(esr << 16));
   \   00000070   0xEA56 0x4107      ORRS     R1,R6,R7, LSL #+16
   \   00000074   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000078   0x.... 0x....      BL       chEvtBroadcastFlagsI
    241              chSysUnlockFromIsr();
   \   0000007C   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF380 0x8811      MSR      BASEPRI,R0
    242            }
    243          }
   \                     ??can_lld_sce_handler_1:
   \   00000086   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    244          
    245          /*===========================================================================*/
    246          /* Driver interrupt handlers.                                                */
    247          /*===========================================================================*/
    248          
    249          #if STM32_CAN_USE_CAN1 || defined(__DOXYGEN__)
    250          /**
    251           * @brief   CAN1 TX interrupt handler.
    252           *
    253           * @isr
    254           */

   \                                 In section .text, align 2, keep-with-next
    255          CH_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
   \                     Vector8C:
   \   00000000   0xB580             PUSH     {R7,LR}
    256          
    257            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    258          
    259            can_lld_tx_handler(&CAND1);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000000A   0x.... 0x....      BL       can_lld_tx_handler
    260          
    261            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    262          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    263          
    264          /*
    265           * @brief   CAN1 RX0 interrupt handler.
    266           *
    267           * @isr
    268           */

   \                                 In section .text, align 2, keep-with-next
    269          CH_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
   \                     Vector90:
   \   00000000   0xB580             PUSH     {R7,LR}
    270          
    271            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    272          
    273            can_lld_rx0_handler(&CAND1);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000000A   0x.... 0x....      BL       can_lld_rx0_handler
    274          
    275            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    276          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    277          
    278          /**
    279           * @brief   CAN1 RX1 interrupt handler.
    280           *
    281           * @isr
    282           */

   \                                 In section .text, align 2, keep-with-next
    283          CH_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
   \                     Vector94:
   \   00000000   0xB580             PUSH     {R7,LR}
    284          
    285            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    286          
    287            can_lld_rx1_handler(&CAND1);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000000A   0x.... 0x....      BL       can_lld_rx1_handler
    288          
    289            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    290          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    291          
    292          /**
    293           * @brief   CAN1 SCE interrupt handler.
    294           *
    295           * @isr
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          CH_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
   \                     Vector98:
   \   00000000   0xB580             PUSH     {R7,LR}
    298          
    299            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    300          
    301            can_lld_sce_handler(&CAND1);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000000A   0x.... 0x....      BL       can_lld_sce_handler
    302          
    303            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    304          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    305          #endif /* STM32_CAN_USE_CAN1 */
    306          
    307          #if STM32_CAN_USE_CAN2 || defined(__DOXYGEN__)
    308          /**
    309           * @brief   CAN2 TX interrupt handler.
    310           *
    311           * @isr
    312           */

   \                                 In section .text, align 2, keep-with-next
    313          CH_IRQ_HANDLER(STM32_CAN2_TX_HANDLER) {
   \                     Vector13C:
   \   00000000   0xB580             PUSH     {R7,LR}
    314          
    315            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    316          
    317            can_lld_tx_handler(&CAND2);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   0000000A   0x.... 0x....      BL       can_lld_tx_handler
    318          
    319            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    320          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    321          
    322          /*
    323           * @brief   CAN2 RX0 interrupt handler.
    324           *
    325           * @isr
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          CH_IRQ_HANDLER(STM32_CAN2_RX0_HANDLER) {
   \                     Vector140:
   \   00000000   0xB580             PUSH     {R7,LR}
    328          
    329            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    330          
    331            can_lld_rx0_handler(&CAND2);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   0000000A   0x.... 0x....      BL       can_lld_rx0_handler
    332          
    333            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    334          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    335          
    336          /**
    337           * @brief   CAN2 RX1 interrupt handler.
    338           *
    339           * @isr
    340           */

   \                                 In section .text, align 2, keep-with-next
    341          CH_IRQ_HANDLER(STM32_CAN2_RX1_HANDLER) {
   \                     Vector144:
   \   00000000   0xB580             PUSH     {R7,LR}
    342          
    343            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    344          
    345            can_lld_rx1_handler(&CAND2);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   0000000A   0x.... 0x....      BL       can_lld_rx1_handler
    346          
    347            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    348          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    349          
    350          /**
    351           * @brief   CAN2 SCE interrupt handler.
    352           *
    353           * @isr
    354           */

   \                                 In section .text, align 2, keep-with-next
    355          CH_IRQ_HANDLER(STM32_CAN2_SCE_HANDLER) {
   \                     Vector148:
   \   00000000   0xB580             PUSH     {R7,LR}
    356          
    357            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    358          
    359            can_lld_sce_handler(&CAND2);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   0000000A   0x.... 0x....      BL       can_lld_sce_handler
    360          
    361            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    362          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    363          #endif /* STM32_CAN_USE_CAN2 */
    364          
    365          /*===========================================================================*/
    366          /* Driver exported functions.                                                */
    367          /*===========================================================================*/
    368          
    369          /**
    370           * @brief   Low level CAN driver initialization.
    371           *
    372           * @notapi
    373           */

   \                                 In section .text, align 2, keep-with-next
    374          void can_lld_init(void) {
   \                     can_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    375          
    376          #if STM32_CAN_USE_CAN1
    377            /* Driver initialization.*/
    378            canObjectInit(&CAND1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   00000006   0x.... 0x....      BL       canObjectInit
    379            CAND1.can = CAN1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13_11  ;; 0x40006400
   \   00000012   0x6341             STR      R1,[R0, #+52]
    380          #endif
    381          #if STM32_CAN_USE_CAN2
    382            /* Driver initialization.*/
    383            canObjectInit(&CAND2);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   00000018   0x.... 0x....      BL       canObjectInit
    384            CAND2.can = CAN2;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable13_12  ;; 0x40006800
   \   00000024   0x6341             STR      R1,[R0, #+52]
    385          #endif
    386          
    387            /* Filters initialization.*/
    388          #if STM32_HAS_CAN2
    389            can_lld_set_filters(STM32_CAN_MAX_FILTERS / 2, 0, NULL);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x200E             MOVS     R0,#+14
   \   0000002C   0x.... 0x....      BL       can_lld_set_filters
    390          #else
    391            can_lld_set_filters(STM32_CAN_MAX_FILTERS, 0, NULL);
    392          #endif
    393          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    394          
    395          /**
    396           * @brief   Configures and activates the CAN peripheral.
    397           *
    398           * @param[in] canp      pointer to the @p CANDriver object
    399           *
    400           * @notapi
    401           */

   \                                 In section .text, align 2, keep-with-next
    402          void can_lld_start(CANDriver *canp) {
   \                     can_lld_start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    403          
    404            /* Clock activation.*/
    405          #if STM32_CAN_USE_CAN1
    406            if (&CAND1 == canp) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   00000008   0x42A0             CMP      R0,R4
   \   0000000A   0xD117             BNE.N    ??can_lld_start_0
    407              nvicEnableVector(STM32_CAN1_TX_NUMBER,
    408                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN1_IRQ_PRIORITY));
   \   0000000C   0x21B0             MOVS     R1,#+176
   \   0000000E   0x2013             MOVS     R0,#+19
   \   00000010   0x.... 0x....      BL       nvicEnableVector
    409              nvicEnableVector(STM32_CAN1_RX0_NUMBER,
    410                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN1_IRQ_PRIORITY));
   \   00000014   0x21B0             MOVS     R1,#+176
   \   00000016   0x2014             MOVS     R0,#+20
   \   00000018   0x.... 0x....      BL       nvicEnableVector
    411              nvicEnableVector(STM32_CAN1_RX1_NUMBER,
    412                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN1_IRQ_PRIORITY));
   \   0000001C   0x21B0             MOVS     R1,#+176
   \   0000001E   0x2015             MOVS     R0,#+21
   \   00000020   0x.... 0x....      BL       nvicEnableVector
    413              nvicEnableVector(STM32_CAN1_SCE_NUMBER,
    414                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN1_IRQ_PRIORITY));
   \   00000024   0x21B0             MOVS     R1,#+176
   \   00000026   0x2016             MOVS     R0,#+22
   \   00000028   0x.... 0x....      BL       nvicEnableVector
    415              rccEnableCAN1(FALSE);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40023840
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40023840
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    416            }
    417          #endif
    418          #if STM32_CAN_USE_CAN2
    419            if (&CAND2 == canp) {
   \                     ??can_lld_start_0:
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   00000040   0x42A0             CMP      R0,R4
   \   00000042   0xD120             BNE.N    ??can_lld_start_1
    420          
    421              chDbgAssert(CAND1.state != CAN_STOP,
    422                          "can_lld_start(), #1", "CAN1 must be started");
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD103             BNE.N    ??can_lld_start_2
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable13_13
   \   00000052   0x.... 0x....      BL       chDbgPanic
    423          
    424              nvicEnableVector(STM32_CAN2_TX_NUMBER,
    425                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN2_IRQ_PRIORITY));
   \                     ??can_lld_start_2:
   \   00000056   0x21B0             MOVS     R1,#+176
   \   00000058   0x203F             MOVS     R0,#+63
   \   0000005A   0x.... 0x....      BL       nvicEnableVector
    426              nvicEnableVector(STM32_CAN2_RX0_NUMBER,
    427                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN2_IRQ_PRIORITY));
   \   0000005E   0x21B0             MOVS     R1,#+176
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x.... 0x....      BL       nvicEnableVector
    428              nvicEnableVector(STM32_CAN2_RX1_NUMBER,
    429                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN2_IRQ_PRIORITY));
   \   00000066   0x21B0             MOVS     R1,#+176
   \   00000068   0x2041             MOVS     R0,#+65
   \   0000006A   0x.... 0x....      BL       nvicEnableVector
    430              nvicEnableVector(STM32_CAN2_SCE_NUMBER,
    431                               CORTEX_PRIORITY_MASK(STM32_CAN_CAN2_IRQ_PRIORITY));
   \   0000006E   0x21B0             MOVS     R1,#+176
   \   00000070   0x2042             MOVS     R0,#+66
   \   00000072   0x.... 0x....      BL       nvicEnableVector
    432              rccEnableCAN2(FALSE);
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40023840
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40023840
   \   00000084   0x6008             STR      R0,[R1, #+0]
    433            }
    434          #endif
    435          
    436            /* Entering initialization mode. */
    437            canp->state = CAN_STARTING;
   \                     ??can_lld_start_1:
   \   00000086   0x2002             MOVS     R0,#+2
   \   00000088   0x7020             STRB     R0,[R4, #+0]
    438            canp->can->MCR = CAN_MCR_INRQ;
   \   0000008A   0x6B60             LDR      R0,[R4, #+52]
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x6001             STR      R1,[R0, #+0]
    439            while ((canp->can->MSR & CAN_MSR_INAK) == 0)
   \                     ??can_lld_start_3:
   \   00000090   0x6B60             LDR      R0,[R4, #+52]
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x07C0             LSLS     R0,R0,#+31
   \   00000096   0xD404             BMI.N    ??can_lld_start_4
    440              chThdSleepS(1);
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x2006             MOVS     R0,#+6
   \   0000009C   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \   000000A0   0xE7F6             B.N      ??can_lld_start_3
    441            /* BTR initialization.*/
    442            canp->can->BTR = canp->config->btr;
   \                     ??can_lld_start_4:
   \   000000A2   0x6B60             LDR      R0,[R4, #+52]
   \   000000A4   0x6861             LDR      R1,[R4, #+4]
   \   000000A6   0x6849             LDR      R1,[R1, #+4]
   \   000000A8   0x61C1             STR      R1,[R0, #+28]
    443            /* MCR initialization.*/
    444            canp->can->MCR = canp->config->mcr;
   \   000000AA   0x6B60             LDR      R0,[R4, #+52]
   \   000000AC   0x6861             LDR      R1,[R4, #+4]
   \   000000AE   0x6809             LDR      R1,[R1, #+0]
   \   000000B0   0x6001             STR      R1,[R0, #+0]
    445          
    446            /* Interrupt sources initialization.*/
    447            canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
    448                             CAN_IER_WKUIE  | CAN_IER_ERRIE  | CAN_IER_LECIE  |
    449                             CAN_IER_BOFIE  | CAN_IER_EPVIE  | CAN_IER_EWGIE  |
    450                             CAN_IER_FOVIE0 | CAN_IER_FOVIE1;
   \   000000B2   0x6B60             LDR      R0,[R4, #+52]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable13_14  ;; 0x18f5b
   \   000000B8   0x6141             STR      R1,[R0, #+20]
    451          }
   \   000000BA   0xBD10             POP      {R4,PC}          ;; return
    452          
    453          /**
    454           * @brief   Deactivates the CAN peripheral.
    455           *
    456           * @param[in] canp      pointer to the @p CANDriver object
    457           *
    458           * @notapi
    459           */

   \                                 In section .text, align 2, keep-with-next
    460          void can_lld_stop(CANDriver *canp) {
   \                     can_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    461          
    462            /* If in ready state then disables the CAN peripheral.*/
    463            if (canp->state == CAN_READY) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD140             BNE.N    ??can_lld_stop_0
    464          #if STM32_CAN_USE_CAN1
    465              if (&CAND1 == canp) {
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13_9
   \   0000000E   0x42A0             CMP      R0,R4
   \   00000010   0xD121             BNE.N    ??can_lld_stop_1
    466          
    467          #if STM32_CAN_USE_CAN2
    468                chDbgAssert(CAND2.state == CAN_STOP,
    469                            "can_lld_stop(), #1", "CAN2 must be stopped");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13_10
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD003             BEQ.N    ??can_lld_stop_2
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_15
   \   00000020   0x.... 0x....      BL       chDbgPanic
    470          #endif
    471          
    472                CAN1->MCR = 0x00010002;                   /* Register reset value.    */
   \                     ??can_lld_stop_2:
   \   00000024   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40006400
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_16  ;; 0x10002
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    473                CAN1->IER = 0x00000000;                   /* All sources disabled.    */
   \   0000002C   0x....             LDR.N    R0,??DataTable13_17  ;; 0x40006414
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6001             STR      R1,[R0, #+0]
    474                nvicDisableVector(STM32_CAN1_TX_NUMBER);
   \   00000032   0x2013             MOVS     R0,#+19
   \   00000034   0x.... 0x....      BL       nvicDisableVector
    475                nvicDisableVector(STM32_CAN1_RX0_NUMBER);
   \   00000038   0x2014             MOVS     R0,#+20
   \   0000003A   0x.... 0x....      BL       nvicDisableVector
    476                nvicDisableVector(STM32_CAN1_RX1_NUMBER);
   \   0000003E   0x2015             MOVS     R0,#+21
   \   00000040   0x.... 0x....      BL       nvicDisableVector
    477                nvicDisableVector(STM32_CAN1_SCE_NUMBER);
   \   00000044   0x2016             MOVS     R0,#+22
   \   00000046   0x.... 0x....      BL       nvicDisableVector
    478                rccDisableCAN1(FALSE);
   \   0000004A   0x....             LDR.N    R0,??DataTable13  ;; 0x40023840
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF030 0x7000      BICS     R0,R0,#0x2000000
   \   00000052   0x....             LDR.N    R1,??DataTable13  ;; 0x40023840
   \   00000054   0x6008             STR      R0,[R1, #+0]
    479              }
    480          #endif
    481          #if STM32_CAN_USE_CAN2
    482              if (&CAND2 == canp) {
   \                     ??can_lld_stop_1:
   \   00000056   0x....             LDR.N    R0,??DataTable13_10
   \   00000058   0x42A0             CMP      R0,R4
   \   0000005A   0xD117             BNE.N    ??can_lld_stop_0
    483                CAN2->MCR = 0x00010002;                   /* Register reset value.    */
   \   0000005C   0x....             LDR.N    R0,??DataTable13_12  ;; 0x40006800
   \   0000005E   0x....             LDR.N    R1,??DataTable13_16  ;; 0x10002
   \   00000060   0x6001             STR      R1,[R0, #+0]
    484                CAN2->IER = 0x00000000;                   /* All sources disabled.    */
   \   00000062   0x....             LDR.N    R0,??DataTable13_18  ;; 0x40006814
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x6001             STR      R1,[R0, #+0]
    485                nvicDisableVector(STM32_CAN2_TX_NUMBER);
   \   00000068   0x203F             MOVS     R0,#+63
   \   0000006A   0x.... 0x....      BL       nvicDisableVector
    486                nvicDisableVector(STM32_CAN2_RX0_NUMBER);
   \   0000006E   0x2040             MOVS     R0,#+64
   \   00000070   0x.... 0x....      BL       nvicDisableVector
    487                nvicDisableVector(STM32_CAN2_RX1_NUMBER);
   \   00000074   0x2041             MOVS     R0,#+65
   \   00000076   0x.... 0x....      BL       nvicDisableVector
    488                nvicDisableVector(STM32_CAN2_SCE_NUMBER);
   \   0000007A   0x2042             MOVS     R0,#+66
   \   0000007C   0x.... 0x....      BL       nvicDisableVector
    489                rccDisableCAN2(FALSE);
   \   00000080   0x....             LDR.N    R0,??DataTable13  ;; 0x40023840
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   00000088   0x....             LDR.N    R1,??DataTable13  ;; 0x40023840
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    490              }
    491          #endif
    492            }
    493          }
   \                     ??can_lld_stop_0:
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    494          
    495          /**
    496           * @brief   Determines whether a frame can be transmitted.
    497           *
    498           * @param[in] canp      pointer to the @p CANDriver object
    499           * @param[in] mailbox   mailbox number, @p CAN_ANY_MAILBOX for any mailbox
    500           *
    501           * @return              The queue space availability.
    502           * @retval FALSE        no space in the transmit queue.
    503           * @retval TRUE         transmit slot available.
    504           *
    505           * @notapi
    506           */

   \                                 In section .text, align 2, keep-with-next
    507          bool_t can_lld_is_tx_empty(CANDriver *canp, canmbx_t mailbox) {
   \                     can_lld_is_tx_empty:
   \   00000000   0x0002             MOVS     R2,R0
    508          
    509            switch (mailbox) {
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??can_lld_is_tx_empty_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD014             BEQ.N    ??can_lld_is_tx_empty_1
   \   0000000A   0xD30C             BCC.N    ??can_lld_is_tx_empty_2
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0xD018             BEQ.N    ??can_lld_is_tx_empty_3
   \   00000010   0xE01E             B.N      ??can_lld_is_tx_empty_4
    510            case CAN_ANY_MAILBOX:
    511              return (canp->can->TSR & CAN_TSR_TME) != 0;
   \                     ??can_lld_is_tx_empty_0:
   \   00000012   0x6B50             LDR      R0,[R2, #+52]
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0xF010 0x5FE0      TST      R0,#0x1C000000
   \   0000001A   0xD001             BEQ.N    ??can_lld_is_tx_empty_5
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE000             B.N      ??can_lld_is_tx_empty_6
   \                     ??can_lld_is_tx_empty_5:
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??can_lld_is_tx_empty_6:
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xE015             B.N      ??can_lld_is_tx_empty_7
    512            case 1:
    513              return (canp->can->TSR & CAN_TSR_TME0) != 0;
   \                     ??can_lld_is_tx_empty_2:
   \   00000026   0x6B50             LDR      R0,[R2, #+52]
   \   00000028   0x6880             LDR      R0,[R0, #+8]
   \   0000002A   0xF010 0x6080      ANDS     R0,R0,#0x4000000
   \   0000002E   0x0E80             LSRS     R0,R0,#+26
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xE00E             B.N      ??can_lld_is_tx_empty_7
    514            case 2:
    515              return (canp->can->TSR & CAN_TSR_TME1) != 0;
   \                     ??can_lld_is_tx_empty_1:
   \   00000034   0x6B50             LDR      R0,[R2, #+52]
   \   00000036   0x6880             LDR      R0,[R0, #+8]
   \   00000038   0xF010 0x6000      ANDS     R0,R0,#0x8000000
   \   0000003C   0x0EC0             LSRS     R0,R0,#+27
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE007             B.N      ??can_lld_is_tx_empty_7
    516            case 3:
    517              return (canp->can->TSR & CAN_TSR_TME2) != 0;
   \                     ??can_lld_is_tx_empty_3:
   \   00000042   0x6B50             LDR      R0,[R2, #+52]
   \   00000044   0x6880             LDR      R0,[R0, #+8]
   \   00000046   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   0000004A   0x0F00             LSRS     R0,R0,#+28
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xE000             B.N      ??can_lld_is_tx_empty_7
    518            default:
    519              return FALSE;
   \                     ??can_lld_is_tx_empty_4:
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??can_lld_is_tx_empty_7:
   \   00000052   0x4770             BX       LR               ;; return
    520            }
    521          }
    522          
    523          /**
    524           * @brief   Inserts a frame into the transmit queue.
    525           *
    526           * @param[in] canp      pointer to the @p CANDriver object
    527           * @param[in] ctfp      pointer to the CAN frame to be transmitted
    528           * @param[in] mailbox   mailbox number,  @p CAN_ANY_MAILBOX for any mailbox
    529           *
    530           * @notapi
    531           */

   \                                 In section .text, align 2, keep-with-next
    532          void can_lld_transmit(CANDriver *canp,
    533                                canmbx_t mailbox,
    534                                const CANTxFrame *ctfp) {
   \                     can_lld_transmit:
   \   00000000   0xB470             PUSH     {R4-R6}
    535            uint32_t tir;
    536            CAN_TxMailBox_TypeDef *tmbp;
    537          
    538            /* Pointer to a free transmission mailbox.*/
    539            switch (mailbox) {
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??can_lld_transmit_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD013             BEQ.N    ??can_lld_transmit_1
   \   0000000A   0xD30D             BCC.N    ??can_lld_transmit_2
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0xD015             BEQ.N    ??can_lld_transmit_3
   \   00000010   0xE019             B.N      ??can_lld_transmit_4
    540            case CAN_ANY_MAILBOX:
    541              tmbp = &canp->can->sTxMailBox[(canp->can->TSR & CAN_TSR_CODE) >> 24];
   \                     ??can_lld_transmit_0:
   \   00000012   0x6B45             LDR      R5,[R0, #+52]
   \   00000014   0x68AD             LDR      R5,[R5, #+8]
   \   00000016   0xF3C5 0x6501      UBFX     R5,R5,#+24,#+2
   \   0000001A   0x6B46             LDR      R6,[R0, #+52]
   \   0000001C   0xEB16 0x1505      ADDS     R5,R6,R5, LSL #+4
   \   00000020   0xF515 0x75C0      ADDS     R5,R5,#+384
   \   00000024   0x002C             MOVS     R4,R5
    542              break;
   \   00000026   0xE00F             B.N      ??can_lld_transmit_5
    543            case 1:
    544              tmbp = &canp->can->sTxMailBox[0];
   \                     ??can_lld_transmit_2:
   \   00000028   0x6B45             LDR      R5,[R0, #+52]
   \   0000002A   0xF515 0x75C0      ADDS     R5,R5,#+384
   \   0000002E   0x002C             MOVS     R4,R5
    545              break;
   \   00000030   0xE00A             B.N      ??can_lld_transmit_5
    546            case 2:
    547              tmbp = &canp->can->sTxMailBox[1];
   \                     ??can_lld_transmit_1:
   \   00000032   0x6B45             LDR      R5,[R0, #+52]
   \   00000034   0xF515 0x75C8      ADDS     R5,R5,#+400
   \   00000038   0x002C             MOVS     R4,R5
    548              break;
   \   0000003A   0xE005             B.N      ??can_lld_transmit_5
    549            case 3:
    550              tmbp = &canp->can->sTxMailBox[2];
   \                     ??can_lld_transmit_3:
   \   0000003C   0x6B45             LDR      R5,[R0, #+52]
   \   0000003E   0xF515 0x75D0      ADDS     R5,R5,#+416
   \   00000042   0x002C             MOVS     R4,R5
    551              break;
   \   00000044   0xE000             B.N      ??can_lld_transmit_5
    552            default:
    553              return;
   \                     ??can_lld_transmit_4:
   \   00000046   0xE025             B.N      ??can_lld_transmit_6
    554            }
    555          
    556            /* Preparing the message.*/
    557            if (ctfp->IDE)
   \                     ??can_lld_transmit_5:
   \   00000048   0x7815             LDRB     R5,[R2, #+0]
   \   0000004A   0xF3C5 0x1540      UBFX     R5,R5,#+5,#+1
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD00B             BEQ.N    ??can_lld_transmit_7
    558              tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
    559                    CAN_TI0R_IDE;
   \   00000054   0x6855             LDR      R5,[R2, #+4]
   \   00000056   0x7816             LDRB     R6,[R2, #+0]
   \   00000058   0xF3C6 0x1600      UBFX     R6,R6,#+4,#+1
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x0076             LSLS     R6,R6,#+1
   \   00000060   0xEA56 0x05C5      ORRS     R5,R6,R5, LSL #+3
   \   00000064   0xF055 0x0504      ORRS     R5,R5,#0x4
   \   00000068   0x002B             MOVS     R3,R5
   \   0000006A   0xE008             B.N      ??can_lld_transmit_8
    560            else
    561              tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
   \                     ??can_lld_transmit_7:
   \   0000006C   0x6855             LDR      R5,[R2, #+4]
   \   0000006E   0x7816             LDRB     R6,[R2, #+0]
   \   00000070   0xF3C6 0x1600      UBFX     R6,R6,#+4,#+1
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0x0076             LSLS     R6,R6,#+1
   \   00000078   0xEA56 0x5545      ORRS     R5,R6,R5, LSL #+21
   \   0000007C   0x002B             MOVS     R3,R5
    562            tmbp->TDTR = ctfp->DLC;
   \                     ??can_lld_transmit_8:
   \   0000007E   0x7815             LDRB     R5,[R2, #+0]
   \   00000080   0xF015 0x050F      ANDS     R5,R5,#0xF
   \   00000084   0x6065             STR      R5,[R4, #+4]
    563            tmbp->TDLR = ctfp->data32[0];
   \   00000086   0x6895             LDR      R5,[R2, #+8]
   \   00000088   0x60A5             STR      R5,[R4, #+8]
    564            tmbp->TDHR = ctfp->data32[1];
   \   0000008A   0x68D5             LDR      R5,[R2, #+12]
   \   0000008C   0x60E5             STR      R5,[R4, #+12]
    565            tmbp->TIR  = tir | CAN_TI0R_TXRQ;
   \   0000008E   0xF053 0x0501      ORRS     R5,R3,#0x1
   \   00000092   0x6025             STR      R5,[R4, #+0]
    566          }
   \                     ??can_lld_transmit_6:
   \   00000094   0xBC70             POP      {R4-R6}
   \   00000096   0x4770             BX       LR               ;; return
    567          
    568          /**
    569           * @brief   Determines whether a frame has been received.
    570           *
    571           * @param[in] canp      pointer to the @p CANDriver object
    572           * @param[in] mailbox   mailbox number, @p CAN_ANY_MAILBOX for any mailbox
    573           *
    574           * @return              The queue space availability.
    575           * @retval FALSE        no space in the transmit queue.
    576           * @retval TRUE         transmit slot available.
    577           *
    578           * @notapi
    579           */

   \                                 In section .text, align 2, keep-with-next
    580          bool_t can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {
   \                     can_lld_is_rx_nonempty:
   \   00000000   0x0002             MOVS     R2,R0
    581          
    582            switch (mailbox) {
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??can_lld_is_rx_nonempty_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD01A             BEQ.N    ??can_lld_is_rx_nonempty_1
   \   0000000A   0xD30F             BCC.N    ??can_lld_is_rx_nonempty_2
   \   0000000C   0xE022             B.N      ??can_lld_is_rx_nonempty_3
    583            case CAN_ANY_MAILBOX:
    584              return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
    585                      (canp->can->RF1R & CAN_RF1R_FMP1) != 0);
   \                     ??can_lld_is_rx_nonempty_0:
   \   0000000E   0x6B50             LDR      R0,[R2, #+52]
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0xF010 0x0F03      TST      R0,#0x3
   \   00000016   0xD104             BNE.N    ??can_lld_is_rx_nonempty_4
   \   00000018   0x6B50             LDR      R0,[R2, #+52]
   \   0000001A   0x6900             LDR      R0,[R0, #+16]
   \   0000001C   0xF010 0x0F03      TST      R0,#0x3
   \   00000020   0xD001             BEQ.N    ??can_lld_is_rx_nonempty_5
   \                     ??can_lld_is_rx_nonempty_4:
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B.N      ??can_lld_is_rx_nonempty_6
   \                     ??can_lld_is_rx_nonempty_5:
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??can_lld_is_rx_nonempty_6:
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xE014             B.N      ??can_lld_is_rx_nonempty_7
    586            case 1:
    587              return (canp->can->RF0R & CAN_RF0R_FMP0) != 0;
   \                     ??can_lld_is_rx_nonempty_2:
   \   0000002C   0x6B50             LDR      R0,[R2, #+52]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF010 0x0F03      TST      R0,#0x3
   \   00000034   0xD001             BEQ.N    ??can_lld_is_rx_nonempty_8
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE000             B.N      ??can_lld_is_rx_nonempty_9
   \                     ??can_lld_is_rx_nonempty_8:
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??can_lld_is_rx_nonempty_9:
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xE00A             B.N      ??can_lld_is_rx_nonempty_7
    588            case 2:
    589              return (canp->can->RF1R & CAN_RF1R_FMP1) != 0;
   \                     ??can_lld_is_rx_nonempty_1:
   \   00000040   0x6B50             LDR      R0,[R2, #+52]
   \   00000042   0x6900             LDR      R0,[R0, #+16]
   \   00000044   0xF010 0x0F03      TST      R0,#0x3
   \   00000048   0xD001             BEQ.N    ??can_lld_is_rx_nonempty_10
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE000             B.N      ??can_lld_is_rx_nonempty_11
   \                     ??can_lld_is_rx_nonempty_10:
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??can_lld_is_rx_nonempty_11:
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xE000             B.N      ??can_lld_is_rx_nonempty_7
    590            default:
    591              return FALSE;
   \                     ??can_lld_is_rx_nonempty_3:
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??can_lld_is_rx_nonempty_7:
   \   00000056   0x4770             BX       LR               ;; return
    592            }
    593          }
    594          
    595          /**
    596           * @brief   Receives a frame from the input queue.
    597           *
    598           * @param[in] canp      pointer to the @p CANDriver object
    599           * @param[in] mailbox   mailbox number, @p CAN_ANY_MAILBOX for any mailbox
    600           * @param[out] crfp     pointer to the buffer where the CAN frame is copied
    601           *
    602           * @notapi
    603           */

   \                                 In section .text, align 2, keep-with-next
    604          void can_lld_receive(CANDriver *canp,
    605                               canmbx_t mailbox,
    606                               CANRxFrame *crfp) {
   \                     can_lld_receive:
   \   00000000   0xB470             PUSH     {R4-R6}
    607            uint32_t rir, rdtr;
    608          
    609            if (mailbox == CAN_ANY_MAILBOX) {
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD110             BNE.N    ??can_lld_receive_0
    610              if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
   \   00000006   0x6B45             LDR      R5,[R0, #+52]
   \   00000008   0x68ED             LDR      R5,[R5, #+12]
   \   0000000A   0xF015 0x0F03      TST      R5,#0x3
   \   0000000E   0xD002             BEQ.N    ??can_lld_receive_1
    611                mailbox = 1;
   \   00000010   0x2501             MOVS     R5,#+1
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xE008             B.N      ??can_lld_receive_0
    612              else if ((canp->can->RF1R & CAN_RF1R_FMP1) != 0)
   \                     ??can_lld_receive_1:
   \   00000016   0x6B45             LDR      R5,[R0, #+52]
   \   00000018   0x692D             LDR      R5,[R5, #+16]
   \   0000001A   0xF015 0x0F03      TST      R5,#0x3
   \   0000001E   0xD002             BEQ.N    ??can_lld_receive_2
    613                mailbox = 2;
   \   00000020   0x2502             MOVS     R5,#+2
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0xE000             B.N      ??can_lld_receive_0
    614              else {
    615                /* Should not happen, do nothing.*/
    616                return;
   \                     ??can_lld_receive_2:
   \   00000026   0xE068             B.N      ??can_lld_receive_3
    617              }
    618            }
    619            switch (mailbox) {
   \                     ??can_lld_receive_0:
   \   00000028   0x000D             MOVS     R5,R1
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD002             BEQ.N    ??can_lld_receive_4
   \   0000002E   0x2D02             CMP      R5,#+2
   \   00000030   0xD01F             BEQ.N    ??can_lld_receive_5
   \   00000032   0xE03D             B.N      ??can_lld_receive_6
    620            case 1:
    621              /* Fetches the message.*/
    622              rir  = canp->can->sFIFOMailBox[0].RIR;
   \                     ??can_lld_receive_4:
   \   00000034   0x6B45             LDR      R5,[R0, #+52]
   \   00000036   0xF8D5 0x51B0      LDR      R5,[R5, #+432]
   \   0000003A   0x002B             MOVS     R3,R5
    623              rdtr = canp->can->sFIFOMailBox[0].RDTR;
   \   0000003C   0x6B45             LDR      R5,[R0, #+52]
   \   0000003E   0xF8D5 0x51B4      LDR      R5,[R5, #+436]
   \   00000042   0x002C             MOVS     R4,R5
    624              crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
   \   00000044   0x6B45             LDR      R5,[R0, #+52]
   \   00000046   0xF8D5 0x51B8      LDR      R5,[R5, #+440]
   \   0000004A   0x60D5             STR      R5,[R2, #+12]
    625              crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
   \   0000004C   0x6B45             LDR      R5,[R0, #+52]
   \   0000004E   0xF8D5 0x51BC      LDR      R5,[R5, #+444]
   \   00000052   0x6115             STR      R5,[R2, #+16]
    626          
    627              /* Releases the mailbox.*/
    628              canp->can->RF0R = CAN_RF0R_RFOM0;
   \   00000054   0x6B45             LDR      R5,[R0, #+52]
   \   00000056   0x2620             MOVS     R6,#+32
   \   00000058   0x60EE             STR      R6,[R5, #+12]
    629          
    630              /* If the queue is empty re-enables the interrupt in order to generate
    631                 events again.*/
    632              if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
   \   0000005A   0x6B45             LDR      R5,[R0, #+52]
   \   0000005C   0x68ED             LDR      R5,[R5, #+12]
   \   0000005E   0xF015 0x0F03      TST      R5,#0x3
   \   00000062   0xD105             BNE.N    ??can_lld_receive_7
    633                canp->can->IER |= CAN_IER_FMPIE0;
   \   00000064   0x6B45             LDR      R5,[R0, #+52]
   \   00000066   0x696D             LDR      R5,[R5, #+20]
   \   00000068   0xF055 0x0502      ORRS     R5,R5,#0x2
   \   0000006C   0x6B46             LDR      R6,[R0, #+52]
   \   0000006E   0x6175             STR      R5,[R6, #+20]
    634              break;
   \                     ??can_lld_receive_7:
   \   00000070   0xE01F             B.N      ??can_lld_receive_8
    635            case 2:
    636              /* Fetches the message.*/
    637              rir  = canp->can->sFIFOMailBox[1].RIR;
   \                     ??can_lld_receive_5:
   \   00000072   0x6B45             LDR      R5,[R0, #+52]
   \   00000074   0xF8D5 0x51C0      LDR      R5,[R5, #+448]
   \   00000078   0x002B             MOVS     R3,R5
    638              rdtr = canp->can->sFIFOMailBox[1].RDTR;
   \   0000007A   0x6B45             LDR      R5,[R0, #+52]
   \   0000007C   0xF8D5 0x51C4      LDR      R5,[R5, #+452]
   \   00000080   0x002C             MOVS     R4,R5
    639              crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
   \   00000082   0x6B45             LDR      R5,[R0, #+52]
   \   00000084   0xF8D5 0x51C8      LDR      R5,[R5, #+456]
   \   00000088   0x60D5             STR      R5,[R2, #+12]
    640              crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
   \   0000008A   0x6B45             LDR      R5,[R0, #+52]
   \   0000008C   0xF8D5 0x51CC      LDR      R5,[R5, #+460]
   \   00000090   0x6115             STR      R5,[R2, #+16]
    641          
    642              /* Releases the mailbox.*/
    643              canp->can->RF1R = CAN_RF1R_RFOM1;
   \   00000092   0x6B45             LDR      R5,[R0, #+52]
   \   00000094   0x2620             MOVS     R6,#+32
   \   00000096   0x612E             STR      R6,[R5, #+16]
    644          
    645              /* If the queue is empty re-enables the interrupt in order to generate
    646                 events again.*/
    647              if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
   \   00000098   0x6B45             LDR      R5,[R0, #+52]
   \   0000009A   0x692D             LDR      R5,[R5, #+16]
   \   0000009C   0xF015 0x0F03      TST      R5,#0x3
   \   000000A0   0xD105             BNE.N    ??can_lld_receive_9
    648                canp->can->IER |= CAN_IER_FMPIE1;
   \   000000A2   0x6B45             LDR      R5,[R0, #+52]
   \   000000A4   0x696D             LDR      R5,[R5, #+20]
   \   000000A6   0xF055 0x0510      ORRS     R5,R5,#0x10
   \   000000AA   0x6B46             LDR      R6,[R0, #+52]
   \   000000AC   0x6175             STR      R5,[R6, #+20]
    649              break;
   \                     ??can_lld_receive_9:
   \   000000AE   0xE000             B.N      ??can_lld_receive_8
    650            default:
    651              /* Should not happen, do nothing.*/
    652              return;
   \                     ??can_lld_receive_6:
   \   000000B0   0xE023             B.N      ??can_lld_receive_3
    653            }
    654          
    655            /* Decodes the various fields in the RX frame.*/
    656            crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
   \                     ??can_lld_receive_8:
   \   000000B2   0x085D             LSRS     R5,R3,#+1
   \   000000B4   0x7916             LDRB     R6,[R2, #+4]
   \   000000B6   0xF365 0x1604      BFI      R6,R5,#+4,#+1
   \   000000BA   0x7116             STRB     R6,[R2, #+4]
    657            crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
   \   000000BC   0x089D             LSRS     R5,R3,#+2
   \   000000BE   0x7916             LDRB     R6,[R2, #+4]
   \   000000C0   0xF365 0x1645      BFI      R6,R5,#+5,#+1
   \   000000C4   0x7116             STRB     R6,[R2, #+4]
    658            if (crfp->IDE)
   \   000000C6   0x7915             LDRB     R5,[R2, #+4]
   \   000000C8   0xF3C5 0x1540      UBFX     R5,R5,#+5,#+1
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0x2D00             CMP      R5,#+0
   \   000000D0   0xD005             BEQ.N    ??can_lld_receive_10
    659              crfp->EID = rir >> 3;
   \   000000D2   0x08DD             LSRS     R5,R3,#+3
   \   000000D4   0x6896             LDR      R6,[R2, #+8]
   \   000000D6   0xF365 0x061C      BFI      R6,R5,#+0,#+29
   \   000000DA   0x6096             STR      R6,[R2, #+8]
   \   000000DC   0xE004             B.N      ??can_lld_receive_11
    660            else
    661              crfp->SID = rir >> 21;
   \                     ??can_lld_receive_10:
   \   000000DE   0x0D5D             LSRS     R5,R3,#+21
   \   000000E0   0x6896             LDR      R6,[R2, #+8]
   \   000000E2   0xF365 0x060A      BFI      R6,R5,#+0,#+11
   \   000000E6   0x6096             STR      R6,[R2, #+8]
    662            crfp->DLC = rdtr & CAN_RDT0R_DLC;
   \                     ??can_lld_receive_11:
   \   000000E8   0x0025             MOVS     R5,R4
   \   000000EA   0x7916             LDRB     R6,[R2, #+4]
   \   000000EC   0xF365 0x0603      BFI      R6,R5,#+0,#+4
   \   000000F0   0x7116             STRB     R6,[R2, #+4]
    663            crfp->FMI = (uint8_t)(rdtr >> 8);
   \   000000F2   0x0A25             LSRS     R5,R4,#+8
   \   000000F4   0x7015             STRB     R5,[R2, #+0]
    664            crfp->TIME = (uint16_t)(rdtr >> 16);
   \   000000F6   0x0C25             LSRS     R5,R4,#+16
   \   000000F8   0x8055             STRH     R5,[R2, #+2]
    665          }
   \                     ??can_lld_receive_3:
   \   000000FA   0xBC70             POP      {R4-R6}
   \   000000FC   0x4770             BX       LR               ;; return
    666          
    667          #if CAN_USE_SLEEP_MODE || defined(__DOXYGEN__)
    668          /**
    669           * @brief   Enters the sleep mode.
    670           *
    671           * @param[in] canp      pointer to the @p CANDriver object
    672           *
    673           * @notapi
    674           */

   \                                 In section .text, align 2, keep-with-next
    675          void can_lld_sleep(CANDriver *canp) {
    676          
    677            canp->can->MCR |= CAN_MCR_SLEEP;
   \                     can_lld_sleep:
   \   00000000   0x6B41             LDR      R1,[R0, #+52]
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000008   0x6B42             LDR      R2,[R0, #+52]
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    678          }
   \   0000000C   0x4770             BX       LR               ;; return
    679          
    680          /**
    681           * @brief   Enforces leaving the sleep mode.
    682           *
    683           * @param[in] canp      pointer to the @p CANDriver object
    684           *
    685           * @notapi
    686           */

   \                                 In section .text, align 2, keep-with-next
    687          void can_lld_wakeup(CANDriver *canp) {
    688          
    689            canp->can->MCR &= ~CAN_MCR_SLEEP;
   \                     can_lld_wakeup:
   \   00000000   0x6B41             LDR      R1,[R0, #+52]
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xF031 0x0102      BICS     R1,R1,#0x2
   \   00000008   0x6B42             LDR      R2,[R0, #+52]
   \   0000000A   0x6011             STR      R1,[R2, #+0]
    690          }
   \   0000000C   0x4770             BX       LR               ;; return
    691          #endif /* CAN_USE_SLEEP_MODE */
    692          
    693          /**
    694           * @brief   Programs the filters.
    695           * @note    This is an STM32-specific API.
    696           *
    697           * @param[in] can2sb    number of the first filter assigned to CAN2
    698           * @param[in] num       number of entries in the filters array, if zero then
    699           *                      a default filter is programmed
    700           * @param[in] cfp       pointer to the filters array, can be @p NULL if
    701           *                      (num == 0)
    702           *
    703           * @api
    704           */

   \                                 In section .text, align 2, keep-with-next
    705          void canSTM32SetFilters(uint32_t can2sb, uint32_t num, const CANFilter *cfp) {
   \                     canSTM32SetFilters:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    706          
    707            chDbgCheck((can2sb >= 1) && (can2sb < STM32_CAN_MAX_FILTERS) &&
    708                       (num <= STM32_CAN_MAX_FILTERS),
    709                       "canSTM32SetFilters");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD003             BEQ.N    ??canSTM32SetFilters_0
   \   0000000C   0x2C1C             CMP      R4,#+28
   \   0000000E   0xD201             BCS.N    ??canSTM32SetFilters_0
   \   00000010   0x2D1D             CMP      R5,#+29
   \   00000012   0xD305             BCC.N    ??canSTM32SetFilters_1
   \                     ??canSTM32SetFilters_0:
   \   00000014   0xF240 0x22C5      MOVW     R2,#+709
   \   00000018   0x....             LDR.N    R1,??DataTable13_19
   \   0000001A   0x....             LDR.N    R0,??DataTable13_20
   \   0000001C   0x.... 0x....      BL       chDbgPanic3
    710          
    711          #if STM32_CAN_USE_CAN1
    712            chDbgAssert(CAND1.state == CAN_STOP,
    713                        "canSTM32SetFilters(), #1", "invalid state");
   \                     ??canSTM32SetFilters_1:
   \   00000020   0x....             LDR.N    R0,??DataTable13_9
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD002             BEQ.N    ??canSTM32SetFilters_2
   \   00000028   0x....             LDR.N    R0,??DataTable13_21
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    714          #endif
    715          #if STM32_CAN_USE_CAN2
    716            chDbgAssert(CAND2.state == CAN_STOP,
    717                        "canSTM32SetFilters(), #2", "invalid state");
   \                     ??canSTM32SetFilters_2:
   \   0000002E   0x....             LDR.N    R0,??DataTable13_10
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD002             BEQ.N    ??canSTM32SetFilters_3
   \   00000036   0x....             LDR.N    R0,??DataTable13_22
   \   00000038   0x.... 0x....      BL       chDbgPanic
    718          #endif
    719          
    720            can_lld_set_filters(can2sb, num, cfp);
   \                     ??canSTM32SetFilters_3:
   \   0000003C   0x0032             MOVS     R2,R6
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       can_lld_set_filters
    721          }
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x4000661C         DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40006604         DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x4000660C         DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40006614         DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40006644         DC32     0x40006644

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x00010101         DC32     0x10101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     CAND1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     CAND2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x40006800         DC32     0x40006800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     `?<Constant "can_lld_start(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x00018F5B         DC32     0x18f5b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x........         DC32     `?<Constant "can_lld_stop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x00010002         DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x40006414         DC32     0x40006414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x40006814         DC32     0x40006814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x........         DC32     `?<Constant "\\"canSTM32SetFilters\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \   00000000   0x........         DC32     `?<Constant "canSTM32SetFilters(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_22:
   \   00000000   0x........         DC32     `?<Constant "canSTM32SetFilters(), #2">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "can_lld_start(), #1">`:
   \   00000000   0x63 0x61          DC8 "can_lld_start(), #1"
   \              0x6E 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "can_lld_stop(), #1">`:
   \   00000000   0x63 0x61          DC8 "can_lld_stop(), #1"
   \              0x6E 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x6F 0x70    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canSTM32SetFilters\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canSTM32SetFilters\"()"
   \              0x61 0x6E    
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x53    
   \              0x65 0x74    
   \              0x46 0x69    
   \              0x6C 0x74    
   \              0x65 0x72    
   \              0x73 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 70H, 6CH, 61H, 74H
   \              0x6C 0x5C    
   \              0x70 0x6C    
   \              0x61 0x74    
   \   00000038   0x66 0x6F          DC8 66H, 6FH, 72H, 6DH, 73H, 5CH, 53H, 54H
   \              0x72 0x6D    
   \              0x73 0x5C    
   \              0x53 0x54    
   \   00000040   0x4D 0x33          DC8 4DH, 33H, 32H, 5CH, 63H, 61H, 6EH, 5FH
   \              0x32 0x5C    
   \              0x63 0x61    
   \              0x6E 0x5F    
   \   00000048   0x6C 0x6C          DC8 6CH, 6CH, 64H, 2EH, 63H, 0
   \              0x64 0x2E    
   \              0x63 0x00    
   \   0000004E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "canSTM32SetFilters(), #1">`:
   \   00000000   0x63 0x61          DC8 "canSTM32SetFilters(), #1"
   \              0x6E 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x53 0x65    
   \              0x74 0x46    
   \              0x69 0x6C    
   \              0x74 0x65    
   \              0x72 0x73    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "canSTM32SetFilters(), #2">`:
   \   00000000   0x63 0x61          DC8 "canSTM32SetFilters(), #2"
   \              0x6E 0x53    
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x53 0x65    
   \              0x74 0x46    
   \              0x69 0x6C    
   \              0x74 0x65    
   \              0x72 0x73    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x32    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    722          
    723          #endif /* HAL_USE_CAN */
    724          
    725          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Vector13C
         8   -> _port_irq_epilogue
         8   -> can_lld_tx_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector140
         8   -> _port_irq_epilogue
         8   -> can_lld_rx0_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector144
         8   -> _port_irq_epilogue
         8   -> can_lld_rx1_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector148
         8   -> _port_irq_epilogue
         8   -> can_lld_sce_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector8C
         8   -> _port_irq_epilogue
         8   -> can_lld_tx_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector90
         8   -> _port_irq_epilogue
         8   -> can_lld_rx0_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector94
         8   -> _port_irq_epilogue
         8   -> can_lld_rx1_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector98
         8   -> _port_irq_epilogue
         8   -> can_lld_sce_handler
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
      16   canSTM32SetFilters
        16   -> can_lld_set_filters
        16   -> chDbgPanic
        16   -> chDbgPanic3
       8   can_lld_init
         8   -> canObjectInit
         8   -> can_lld_set_filters
       0   can_lld_is_rx_nonempty
       0   can_lld_is_tx_empty
      12   can_lld_receive
      16   can_lld_rx0_handler
        16   -> chEvtBroadcastFlagsI
        16   -> chSemSignalI
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
      16   can_lld_rx1_handler
        16   -> chEvtBroadcastFlagsI
        16   -> chSemSignalI
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
      24   can_lld_sce_handler
        24   -> chEvtBroadcastFlagsI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
      16   can_lld_set_filters
       0   can_lld_sleep
       8   can_lld_start
         8   -> chDbgPanic
         8   -> chSchGoSleepTimeoutS
         8   -> nvicEnableVector
       8   can_lld_stop
         8   -> chDbgPanic
         8   -> nvicDisableVector
      12   can_lld_transmit
       8   can_lld_tx_handler
         8   -> chEvtBroadcastFlagsI
         8   -> chSemSignalI
         8   -> dbg_check_lock_from_isr
         8   -> dbg_check_unlock_from_isr
       0   can_lld_wakeup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      80  ?<Constant "F:\\stuff\\rusefi_sourc...">
      24  ?<Constant "\"canSTM32SetFilters\"()">
      28  ?<Constant "canSTM32SetFilters(), #1">
      28  ?<Constant "canSTM32SetFilters(), #2">
      20  ?<Constant "can_lld_start(), #1">
      20  ?<Constant "can_lld_stop(), #1">
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_22
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      56  CAND1
      56  CAND2
      24  Vector13C
      24  Vector140
      24  Vector144
      24  Vector148
      24  Vector8C
      24  Vector90
      24  Vector94
      24  Vector98
      72  canSTM32SetFilters
      50  can_lld_init
      88  can_lld_is_rx_nonempty
      84  can_lld_is_tx_empty
     254  can_lld_receive
     116  can_lld_rx0_handler
     116  can_lld_rx1_handler
     136  can_lld_sce_handler
     360  can_lld_set_filters
      14  can_lld_sleep
     188  can_lld_start
     142  can_lld_stop
     152  can_lld_transmit
      60  can_lld_tx_handler
      14  can_lld_wakeup

 
   112 bytes in section .bss
   200 bytes in section .rodata
 2 130 bytes in section .text
 
 2 130 bytes of CODE  memory
   200 bytes of CONST memory
   112 bytes of DATA  memory

Errors: none
Warnings: none
