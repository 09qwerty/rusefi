###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:04 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\TIMv1\gpt_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\TIMv1\gpt_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\g #
#                       pt_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\gp #
#                       t_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\TIMv1\gpt_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/gpt_lld.c
     19           * @brief   STM32 GPT subsystem low level driver source.
     20           *
     21           * @addtogroup GPT
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_GPT || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          /*===========================================================================*/
     35          /* Driver exported variables.                                                */
     36          /*===========================================================================*/
     37          
     38          /**
     39           * @brief   GPTD1 driver identifier.
     40           * @note    The driver GPTD1 allocates the complex timer TIM1 when enabled.
     41           */
     42          #if STM32_GPT_USE_TIM1 || defined(__DOXYGEN__)
     43          GPTDriver GPTD1;
     44          #endif
     45          
     46          /**
     47           * @brief   GPTD2 driver identifier.
     48           * @note    The driver GPTD2 allocates the timer TIM2 when enabled.
     49           */
     50          #if STM32_GPT_USE_TIM2 || defined(__DOXYGEN__)
     51          GPTDriver GPTD2;
     52          #endif
     53          
     54          /**
     55           * @brief   GPTD3 driver identifier.
     56           * @note    The driver GPTD3 allocates the timer TIM3 when enabled.
     57           */
     58          #if STM32_GPT_USE_TIM3 || defined(__DOXYGEN__)
     59          GPTDriver GPTD3;
     60          #endif
     61          
     62          /**
     63           * @brief   GPTD4 driver identifier.
     64           * @note    The driver GPTD4 allocates the timer TIM4 when enabled.
     65           */
     66          #if STM32_GPT_USE_TIM4 || defined(__DOXYGEN__)
     67          GPTDriver GPTD4;
     68          #endif
     69          
     70          /**
     71           * @brief   GPTD5 driver identifier.
     72           * @note    The driver GPTD5 allocates the timer TIM5 when enabled.
     73           */
     74          #if STM32_GPT_USE_TIM5 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     75          GPTDriver GPTD5;
   \                     GPTD5:
   \   00000000                      DS8 16
     76          #endif
     77          
     78          /**
     79           * @brief   GPTD6 driver identifier.
     80           * @note    The driver GPTD6 allocates the timer TIM6 when enabled.
     81           */
     82          #if STM32_GPT_USE_TIM6 || defined(__DOXYGEN__)
     83          GPTDriver GPTD6;
     84          #endif
     85          
     86          /**
     87           * @brief   GPTD7 driver identifier.
     88           * @note    The driver GPTD7 allocates the timer TIM7 when enabled.
     89           */
     90          #if STM32_GPT_USE_TIM7 || defined(__DOXYGEN__)
     91          GPTDriver GPTD7;
     92          #endif
     93          
     94          /**
     95           * @brief   GPTD8 driver identifier.
     96           * @note    The driver GPTD8 allocates the timer TIM8 when enabled.
     97           */
     98          #if STM32_GPT_USE_TIM8 || defined(__DOXYGEN__)
     99          GPTDriver GPTD8;
    100          #endif
    101          
    102          /**
    103           * @brief   GPTD9 driver identifier.
    104           * @note    The driver GPTD9 allocates the timer TIM9 when enabled.
    105           */
    106          #if STM32_GPT_USE_TIM9 || defined(__DOXYGEN__)
    107          GPTDriver GPTD9;
    108          #endif
    109          
    110          /**
    111           * @brief   GPTD11 driver identifier.
    112           * @note    The driver GPTD11 allocates the timer TIM11 when enabled.
    113           */
    114          #if STM32_GPT_USE_TIM11 || defined(__DOXYGEN__)
    115          GPTDriver GPTD11;
    116          #endif
    117          
    118          /**
    119           * @brief   GPTD12 driver identifier.
    120           * @note    The driver GPTD12 allocates the timer TIM12 when enabled.
    121           */
    122          #if STM32_GPT_USE_TIM12 || defined(__DOXYGEN__)
    123          GPTDriver GPTD12;
    124          #endif
    125          
    126          /**
    127           * @brief   GPTD14 driver identifier.
    128           * @note    The driver GPTD14 allocates the timer TIM14 when enabled.
    129           */
    130          #if STM32_GPT_USE_TIM14 || defined(__DOXYGEN__)
    131          GPTDriver GPTD14;
    132          #endif
    133          
    134          /*===========================================================================*/
    135          /* Driver local variables and types.                                         */
    136          /*===========================================================================*/
    137          
    138          /*===========================================================================*/
    139          /* Driver local functions.                                                   */
    140          /*===========================================================================*/
    141          
    142          /**
    143           * @brief   Shared IRQ handler.
    144           *
    145           * @param[in] gptp      pointer to a @p GPTDriver object
    146           */

   \                                 In section .text, align 2, keep-with-next
    147          static void gpt_lld_serve_interrupt(GPTDriver *gptp) {
   \                     gpt_lld_serve_interrupt:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    148          
    149            gptp->tim->SR = 0;
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6101             STR      R1,[R0, #+16]
    150            if (gptp->state == GPT_ONESHOT) {
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD104             BNE.N    ??gpt_lld_serve_interrupt_0
    151              gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    152              gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       gpt_lld_stop_timer
    153            }
    154            gptp->config->callback(gptp);
   \                     ??gpt_lld_serve_interrupt_0:
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x6861             LDR      R1,[R4, #+4]
   \   0000001E   0x6849             LDR      R1,[R1, #+4]
   \   00000020   0x4788             BLX      R1
    155          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    156          
    157          /*===========================================================================*/
    158          /* Driver interrupt handlers.                                                */
    159          /*===========================================================================*/
    160          
    161          #if STM32_GPT_USE_TIM1
    162          #if !defined(STM32_TIM1_UP_HANDLER)
    163          #error "STM32_TIM1_UP_HANDLER not defined"
    164          #endif
    165          /**
    166           * @brief   TIM2 interrupt handler.
    167           *
    168           * @isr
    169           */
    170          CH_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
    171          
    172            CH_IRQ_PROLOGUE();
    173          
    174            gpt_lld_serve_interrupt(&GPTD1);
    175          
    176            CH_IRQ_EPILOGUE();
    177          }
    178          #endif /* STM32_GPT_USE_TIM1 */
    179          
    180          #if STM32_GPT_USE_TIM2
    181          #if !defined(STM32_TIM2_HANDLER)
    182          #error "STM32_TIM2_HANDLER not defined"
    183          #endif
    184          /**
    185           * @brief   TIM2 interrupt handler.
    186           *
    187           * @isr
    188           */
    189          CH_IRQ_HANDLER(STM32_TIM2_HANDLER) {
    190          
    191            CH_IRQ_PROLOGUE();
    192          
    193            gpt_lld_serve_interrupt(&GPTD2);
    194          
    195            CH_IRQ_EPILOGUE();
    196          }
    197          #endif /* STM32_GPT_USE_TIM2 */
    198          
    199          #if STM32_GPT_USE_TIM3
    200          #if !defined(STM32_TIM3_HANDLER)
    201          #error "STM32_TIM3_HANDLER not defined"
    202          #endif
    203          /**
    204           * @brief   TIM3 interrupt handler.
    205           *
    206           * @isr
    207           */
    208          CH_IRQ_HANDLER(STM32_TIM3_HANDLER) {
    209          
    210            CH_IRQ_PROLOGUE();
    211          
    212            gpt_lld_serve_interrupt(&GPTD3);
    213          
    214            CH_IRQ_EPILOGUE();
    215          }
    216          #endif /* STM32_GPT_USE_TIM3 */
    217          
    218          #if STM32_GPT_USE_TIM4
    219          #if !defined(STM32_TIM4_HANDLER)
    220          #error "STM32_TIM4_HANDLER not defined"
    221          #endif
    222          /**
    223           * @brief   TIM4 interrupt handler.
    224           *
    225           * @isr
    226           */
    227          CH_IRQ_HANDLER(STM32_TIM4_HANDLER) {
    228          
    229            CH_IRQ_PROLOGUE();
    230          
    231            gpt_lld_serve_interrupt(&GPTD4);
    232          
    233            CH_IRQ_EPILOGUE();
    234          }
    235          #endif /* STM32_GPT_USE_TIM4 */
    236          
    237          #if STM32_GPT_USE_TIM5
    238          #if !defined(STM32_TIM5_HANDLER)
    239          #error "STM32_TIM5_HANDLER not defined"
    240          #endif
    241          /**
    242           * @brief   TIM5 interrupt handler.
    243           *
    244           * @isr
    245           */

   \                                 In section .text, align 2, keep-with-next
    246          CH_IRQ_HANDLER(STM32_TIM5_HANDLER) {
   \                     Vector108:
   \   00000000   0xB580             PUSH     {R7,LR}
    247          
    248            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    249          
    250            gpt_lld_serve_interrupt(&GPTD5);
   \   00000006   0x....             LDR.N    R0,??DataTable3
   \   00000008   0x.... 0x....      BL       gpt_lld_serve_interrupt
    251          
    252            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    253          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    254          #endif /* STM32_GPT_USE_TIM5 */
    255          
    256          #if STM32_GPT_USE_TIM6
    257          #if !defined(STM32_TIM6_HANDLER)
    258          #error "STM32_TIM6_HANDLER not defined"
    259          #endif
    260          /**
    261           * @brief   TIM6 interrupt handler.
    262           *
    263           * @isr
    264           */
    265          CH_IRQ_HANDLER(STM32_TIM6_HANDLER) {
    266          
    267            CH_IRQ_PROLOGUE();
    268          
    269            gpt_lld_serve_interrupt(&GPTD6);
    270          
    271            CH_IRQ_EPILOGUE();
    272          }
    273          #endif /* STM32_GPT_USE_TIM6 */
    274          
    275          #if STM32_GPT_USE_TIM7
    276          #if !defined(STM32_TIM7_HANDLER)
    277          #error "STM32_TIM7_HANDLER not defined"
    278          #endif
    279          /**
    280           * @brief   TIM7 interrupt handler.
    281           *
    282           * @isr
    283           */
    284          CH_IRQ_HANDLER(STM32_TIM7_HANDLER) {
    285          
    286            CH_IRQ_PROLOGUE();
    287          
    288            gpt_lld_serve_interrupt(&GPTD7);
    289          
    290            CH_IRQ_EPILOGUE();
    291          }
    292          #endif /* STM32_GPT_USE_TIM7 */
    293          
    294          #if STM32_GPT_USE_TIM8
    295          #if !defined(STM32_TIM8_UP_HANDLER)
    296          #error "STM32_TIM8_UP_HANDLER not defined"
    297          #endif
    298          /**
    299           * @brief   TIM8 interrupt handler.
    300           *
    301           * @isr
    302           */
    303          CH_IRQ_HANDLER(STM32_TIM8_UP_HANDLER) {
    304          
    305            CH_IRQ_PROLOGUE();
    306          
    307            gpt_lld_serve_interrupt(&GPTD8);
    308          
    309            CH_IRQ_EPILOGUE();
    310          }
    311          #endif /* STM32_GPT_USE_TIM8 */
    312          
    313          #if STM32_GPT_USE_TIM9
    314          #if !defined(STM32_TIM9_HANDLER)
    315          #error "STM32_TIM9_HANDLER not defined"
    316          #endif
    317          /**
    318           * @brief   TIM9 interrupt handler.
    319           *
    320           * @isr
    321           */
    322          CH_IRQ_HANDLER(STM32_TIM9_HANDLER) {
    323          
    324            CH_IRQ_PROLOGUE();
    325          
    326            gpt_lld_serve_interrupt(&GPTD9);
    327          
    328            CH_IRQ_EPILOGUE();
    329          }
    330          #endif /* STM32_GPT_USE_TIM9 */
    331          
    332          #if STM32_GPT_USE_TIM11
    333          #if !defined(STM32_TIM11_HANDLER)
    334          #error "STM32_TIM11_HANDLER not defined"
    335          #endif
    336          /**
    337           * @brief   TIM11 interrupt handler.
    338           *
    339           * @isr
    340           */
    341          CH_IRQ_HANDLER(STM32_TIM11_HANDLER) {
    342          
    343            CH_IRQ_PROLOGUE();
    344          
    345            gpt_lld_serve_interrupt(&GPTD11);
    346          
    347            CH_IRQ_EPILOGUE();
    348          }
    349          #endif /* STM32_GPT_USE_TIM11 */
    350          
    351          #if STM32_GPT_USE_TIM12
    352          #if !defined(STM32_TIM12_HANDLER)
    353          #error "STM32_TIM12_HANDLER not defined"
    354          #endif
    355          /**
    356           * @brief   TIM12 interrupt handler.
    357           *
    358           * @isr
    359           */
    360          CH_IRQ_HANDLER(STM32_TIM12_HANDLER) {
    361          
    362            CH_IRQ_PROLOGUE();
    363          
    364            gpt_lld_serve_interrupt(&GPTD12);
    365          
    366            CH_IRQ_EPILOGUE();
    367          }
    368          #endif /* STM32_GPT_USE_TIM12 */
    369          
    370          #if STM32_GPT_USE_TIM14
    371          #if !defined(STM32_TIM14_HANDLER)
    372          #error "STM32_TIM14_HANDLER not defined"
    373          #endif
    374          /**
    375           * @brief   TIM14 interrupt handler.
    376           *
    377           * @isr
    378           */
    379          CH_IRQ_HANDLER(STM32_TIM14_HANDLER) {
    380          
    381            CH_IRQ_PROLOGUE();
    382          
    383            gpt_lld_serve_interrupt(&GPTD14);
    384          
    385            CH_IRQ_EPILOGUE();
    386          }
    387          #endif /* STM32_GPT_USE_TIM14 */
    388          
    389          /*===========================================================================*/
    390          /* Driver exported functions.                                                */
    391          /*===========================================================================*/
    392          
    393          /**
    394           * @brief   Low level GPT driver initialization.
    395           *
    396           * @notapi
    397           */

   \                                 In section .text, align 2, keep-with-next
    398          void gpt_lld_init(void) {
   \                     gpt_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    399          
    400          #if STM32_GPT_USE_TIM1
    401            /* Driver initialization.*/
    402            GPTD1.tim = STM32_TIM1;
    403            gptObjectInit(&GPTD1);
    404          #endif
    405          
    406          #if STM32_GPT_USE_TIM2
    407            /* Driver initialization.*/
    408            GPTD2.tim = STM32_TIM2;
    409            gptObjectInit(&GPTD2);
    410          #endif
    411          
    412          #if STM32_GPT_USE_TIM3
    413            /* Driver initialization.*/
    414            GPTD3.tim = STM32_TIM3;
    415            gptObjectInit(&GPTD3);
    416          #endif
    417          
    418          #if STM32_GPT_USE_TIM4
    419            /* Driver initialization.*/
    420            GPTD4.tim = STM32_TIM4;
    421            gptObjectInit(&GPTD4);
    422          #endif
    423          
    424          #if STM32_GPT_USE_TIM5
    425            /* Driver initialization.*/
    426            GPTD5.tim = STM32_TIM5;
   \   00000002   0x....             LDR.N    R0,??DataTable3
   \   00000004   0x....             LDR.N    R1,??DataTable3_1  ;; 0x40000c00
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    427            gptObjectInit(&GPTD5);
   \   00000008   0x....             LDR.N    R0,??DataTable3
   \   0000000A   0x.... 0x....      BL       gptObjectInit
    428          #endif
    429          
    430          #if STM32_GPT_USE_TIM6
    431            /* Driver initialization.*/
    432            GPTD6.tim = STM32_TIM6;
    433            gptObjectInit(&GPTD6);
    434          #endif
    435          
    436          #if STM32_GPT_USE_TIM7
    437            /* Driver initialization.*/
    438            GPTD7.tim = STM32_TIM7;
    439            gptObjectInit(&GPTD7);
    440          #endif
    441          
    442          #if STM32_GPT_USE_TIM8
    443            /* Driver initialization.*/
    444            GPTD8.tim = STM32_TIM8;
    445            gptObjectInit(&GPTD8);
    446          #endif
    447          
    448          #if STM32_GPT_USE_TIM9
    449            /* Driver initialization.*/
    450            GPTD9.tim = STM32_TIM9;
    451            gptObjectInit(&GPTD9);
    452          #endif
    453          
    454          #if STM32_GPT_USE_TIM11
    455            /* Driver initialization.*/
    456            GPTD11.tim = STM32_TIM11;
    457            gptObjectInit(&GPTD11);
    458          #endif
    459          
    460          #if STM32_GPT_USE_TIM12
    461            /* Driver initialization.*/
    462            GPTD12.tim = STM32_TIM12;
    463            gptObjectInit(&GPTD12);
    464          #endif
    465          
    466          #if STM32_GPT_USE_TIM14
    467            /* Driver initialization.*/
    468            GPTD14.tim = STM32_TIM14;
    469            gptObjectInit(&GPTD14);
    470          #endif
    471          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    472          
    473          /**
    474           * @brief   Configures and activates the GPT peripheral.
    475           *
    476           * @param[in] gptp      pointer to the @p GPTDriver object
    477           *
    478           * @notapi
    479           */

   \                                 In section .text, align 2, keep-with-next
    480          void gpt_lld_start(GPTDriver *gptp) {
   \                     gpt_lld_start:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    481            uint16_t psc;
    482          
    483            if (gptp->state == GPT_STOP) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD117             BNE.N    ??gpt_lld_start_0
    484              /* Clock activation.*/
    485          #if STM32_GPT_USE_TIM1
    486              if (&GPTD1 == gptp) {
    487                rccEnableTIM1(FALSE);
    488                rccResetTIM1();
    489                nvicEnableVector(STM32_TIM1_UP_NUMBER,
    490                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM1_IRQ_PRIORITY));
    491          #if defined(STM32_TIM1CLK)
    492                gptp->clock = STM32_TIM1CLK;
    493          #else
    494                gptp->clock = STM32_TIMCLK2;
    495          #endif
    496              }
    497          #endif
    498          #if STM32_GPT_USE_TIM2
    499              if (&GPTD2 == gptp) {
    500                rccEnableTIM2(FALSE);
    501                rccResetTIM2();
    502                nvicEnableVector(STM32_TIM2_NUMBER,
    503                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM2_IRQ_PRIORITY));
    504                gptp->clock = STM32_TIMCLK1;
    505              }
    506          #endif
    507          #if STM32_GPT_USE_TIM3
    508              if (&GPTD3 == gptp) {
    509                rccEnableTIM3(FALSE);
    510                rccResetTIM3();
    511                nvicEnableVector(STM32_TIM3_NUMBER,
    512                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM3_IRQ_PRIORITY));
    513                gptp->clock = STM32_TIMCLK1;
    514              }
    515          #endif
    516          #if STM32_GPT_USE_TIM4
    517              if (&GPTD4 == gptp) {
    518                rccEnableTIM4(FALSE);
    519                rccResetTIM4();
    520                nvicEnableVector(STM32_TIM4_NUMBER,
    521                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM4_IRQ_PRIORITY));
    522                gptp->clock = STM32_TIMCLK1;
    523              }
    524          #endif
    525          
    526          #if STM32_GPT_USE_TIM5
    527              if (&GPTD5 == gptp) {
   \   0000000A   0x....             LDR.N    R0,??DataTable3
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD114             BNE.N    ??gpt_lld_start_0
    528                rccEnableTIM5(FALSE);
   \   00000010   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40023840
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000018   0x....             LDR.N    R1,??DataTable3_2  ;; 0x40023840
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    529                rccResetTIM5();
   \   0000001C   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40023820
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000024   0x....             LDR.N    R1,??DataTable3_3  ;; 0x40023820
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40023820
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    530                nvicEnableVector(STM32_TIM5_NUMBER,
    531                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM5_IRQ_PRIORITY));
   \   0000002E   0x2140             MOVS     R1,#+64
   \   00000030   0x2032             MOVS     R0,#+50
   \   00000032   0x.... 0x....      BL       nvicEnableVector
    532                gptp->clock = STM32_TIMCLK1;
   \   00000036   0x....             LDR.N    R0,??DataTable3_4  ;; 0x501bd00
   \   00000038   0x60A0             STR      R0,[R4, #+8]
    533              }
    534          #endif
    535          
    536          #if STM32_GPT_USE_TIM6
    537              if (&GPTD6 == gptp) {
    538                rccEnableTIM6(FALSE);
    539                rccResetTIM6();
    540                nvicEnableVector(STM32_TIM6_NUMBER,
    541                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM6_IRQ_PRIORITY));
    542                gptp->clock = STM32_TIMCLK1;
    543              }
    544          #endif
    545          
    546          #if STM32_GPT_USE_TIM7
    547              if (&GPTD7 == gptp) {
    548                rccEnableTIM7(FALSE);
    549                rccResetTIM7();
    550                nvicEnableVector(STM32_TIM7_NUMBER,
    551                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM7_IRQ_PRIORITY));
    552                gptp->clock = STM32_TIMCLK1;
    553              }
    554          #endif
    555          
    556          #if STM32_GPT_USE_TIM8
    557              if (&GPTD8 == gptp) {
    558                rccEnableTIM8(FALSE);
    559                rccResetTIM8();
    560                nvicEnableVector(STM32_TIM8_UP_NUMBER,
    561                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM8_IRQ_PRIORITY));
    562          #if defined(STM32_TIM8CLK)
    563                gptp->clock = STM32_TIM8CLK;
    564          #else
    565                gptp->clock = STM32_TIMCLK2;
    566          #endif
    567              }
    568          #endif
    569          
    570          #if STM32_GPT_USE_TIM9
    571              if (&GPTD9 == gptp) {
    572                rccEnableTIM9(FALSE);
    573                rccResetTIM9();
    574                nvicEnableVector(STM32_TIM9_NUMBER,
    575                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM9_IRQ_PRIORITY));
    576                gptp->clock = STM32_TIMCLK2;
    577              }
    578          #endif
    579          
    580          #if STM32_GPT_USE_TIM11
    581              if (&GPTD11 == gptp) {
    582                rccEnableTIM11(FALSE);
    583                rccResetTIM11();
    584                nvicEnableVector(STM32_TIM11_NUMBER,
    585                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM11_IRQ_PRIORITY));
    586                gptp->clock = STM32_TIMCLK2;
    587              }
    588          #endif
    589          
    590          #if STM32_GPT_USE_TIM12
    591              if (&GPTD12 == gptp) {
    592                rccEnableTIM12(FALSE);
    593                rccResetTIM12();
    594                nvicEnableVector(STM32_TIM12_NUMBER,
    595                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM12_IRQ_PRIORITY));
    596                gptp->clock = STM32_TIMCLK1;
    597              }
    598          #endif
    599          
    600          #if STM32_GPT_USE_TIM14
    601              if (&GPTD14 == gptp) {
    602                rccEnableTIM14(FALSE);
    603                rccResetTIM14();
    604                nvicEnableVector(STM32_TIM14_NUMBER,
    605                                 CORTEX_PRIORITY_MASK(STM32_GPT_TIM14_IRQ_PRIORITY));
    606                gptp->clock = STM32_TIMCLK1;
    607              }
    608          #endif
    609            }
    610          
    611            /* Prescaler value calculation.*/
    612            psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
   \                     ??gpt_lld_start_0:
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x6861             LDR      R1,[R4, #+4]
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000044   0x1E40             SUBS     R0,R0,#+1
   \   00000046   0x0005             MOVS     R5,R0
    613            chDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
    614                        "gpt_lld_start(), #1", "invalid frequency");
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x1C68             ADDS     R0,R5,#+1
   \   0000004C   0x6861             LDR      R1,[R4, #+4]
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x4348             MULS     R0,R1,R0
   \   00000052   0x68A1             LDR      R1,[R4, #+8]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD002             BEQ.N    ??gpt_lld_start_1
   \   00000058   0x....             LDR.N    R0,??DataTable3_5
   \   0000005A   0x.... 0x....      BL       chDbgPanic
    615          
    616            /* Timer configuration.*/
    617            gptp->tim->CR1  = 0;                          /* Initially stopped.       */
   \                     ??gpt_lld_start_1:
   \   0000005E   0x68E0             LDR      R0,[R4, #+12]
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x6001             STR      R1,[R0, #+0]
    618            gptp->tim->CR2  = STM32_TIM_CR2_CCDS;         /* DMA on UE (if any).      */
   \   00000064   0x68E0             LDR      R0,[R4, #+12]
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0x6041             STR      R1,[R0, #+4]
    619            gptp->tim->PSC  = psc;                        /* Prescaler value.         */
   \   0000006A   0x68E0             LDR      R0,[R4, #+12]
   \   0000006C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006E   0x6285             STR      R5,[R0, #+40]
    620            gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
    621                              STM32_TIM_DIER_IRQ_MASK;
   \   00000070   0x6860             LDR      R0,[R4, #+4]
   \   00000072   0x7A00             LDRB     R0,[R0, #+8]
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x68E1             LDR      R1,[R4, #+12]
   \   00000078   0x60C8             STR      R0,[R1, #+12]
    622            gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
   \   0000007A   0x68E0             LDR      R0,[R4, #+12]
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x6101             STR      R1,[R0, #+16]
    623          }
   \   00000080   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    624          
    625          /**
    626           * @brief   Deactivates the GPT peripheral.
    627           *
    628           * @param[in] gptp      pointer to the @p GPTDriver object
    629           *
    630           * @notapi
    631           */

   \                                 In section .text, align 2, keep-with-next
    632          void gpt_lld_stop(GPTDriver *gptp) {
   \                     gpt_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    633          
    634            if (gptp->state == GPT_READY) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD114             BNE.N    ??gpt_lld_stop_0
    635              gptp->tim->CR1  = 0;                        /* Timer disabled.          */
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    636              gptp->tim->DIER = 0;                        /* All IRQs disabled.       */
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x60C1             STR      R1,[R0, #+12]
    637              gptp->tim->SR   = 0;                        /* Clear pending IRQs.      */
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6101             STR      R1,[R0, #+16]
    638          
    639          #if STM32_GPT_USE_TIM1
    640              if (&GPTD1 == gptp) {
    641                nvicDisableVector(STM32_TIM1_UP_NUMBER);
    642                rccDisableTIM1(FALSE);
    643              }
    644          #endif
    645          #if STM32_GPT_USE_TIM2
    646              if (&GPTD2 == gptp) {
    647                nvicDisableVector(STM32_TIM2_NUMBER);
    648                rccDisableTIM2(FALSE);
    649              }
    650          #endif
    651          #if STM32_GPT_USE_TIM3
    652              if (&GPTD3 == gptp) {
    653                nvicDisableVector(STM32_TIM3_NUMBER);
    654                rccDisableTIM3(FALSE);
    655              }
    656          #endif
    657          #if STM32_GPT_USE_TIM4
    658              if (&GPTD4 == gptp) {
    659                nvicDisableVector(STM32_TIM4_NUMBER);
    660                rccDisableTIM4(FALSE);
    661              }
    662          #endif
    663          #if STM32_GPT_USE_TIM5
    664              if (&GPTD5 == gptp) {
   \   0000001C   0x....             LDR.N    R0,??DataTable3
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD108             BNE.N    ??gpt_lld_stop_0
    665                nvicDisableVector(STM32_TIM5_NUMBER);
   \   00000022   0x2032             MOVS     R0,#+50
   \   00000024   0x.... 0x....      BL       nvicDisableVector
    666                rccDisableTIM5(FALSE);
   \   00000028   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40023840
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000030   0x....             LDR.N    R1,??DataTable3_2  ;; 0x40023840
   \   00000032   0x6008             STR      R0,[R1, #+0]
    667              }
    668          #endif
    669          #if STM32_GPT_USE_TIM6
    670              if (&GPTD6 == gptp) {
    671                nvicDisableVector(STM32_TIM6_NUMBER);
    672                rccDisableTIM6(FALSE);
    673              }
    674          #endif
    675          #if STM32_GPT_USE_TIM7
    676              if (&GPTD7 == gptp) {
    677                nvicDisableVector(STM32_TIM7_NUMBER);
    678                rccDisableTIM7(FALSE);
    679              }
    680          #endif
    681          #if STM32_GPT_USE_TIM8
    682              if (&GPTD8 == gptp) {
    683                nvicDisableVector(STM32_TIM8_UP_NUMBER);
    684                rccDisableTIM8(FALSE);
    685              }
    686          #endif
    687          #if STM32_GPT_USE_TIM9
    688              if (&GPTD9 == gptp) {
    689                nvicDisableVector(STM32_TIM9_NUMBER);
    690                rccDisableTIM9(FALSE);
    691              }
    692          #endif
    693          #if STM32_GPT_USE_TIM11
    694              if (&GPTD11 == gptp) {
    695                nvicDisableVector(STM32_TIM11_NUMBER);
    696                rccDisableTIM11(FALSE);
    697              }
    698          #endif
    699          #if STM32_GPT_USE_TIM12
    700              if (&GPTD12 == gptp) {
    701                nvicDisableVector(STM32_TIM12_NUMBER);
    702                rccDisableTIM12(FALSE);
    703              }
    704          #endif
    705          #if STM32_GPT_USE_TIM14
    706              if (&GPTD14 == gptp) {
    707                nvicDisableVector(STM32_TIM14_NUMBER);
    708                rccDisableTIM14(FALSE);
    709              }
    710          #endif
    711            }
    712          }
   \                     ??gpt_lld_stop_0:
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    713          
    714          /**
    715           * @brief   Starts the timer in continuous mode.
    716           *
    717           * @param[in] gptp      pointer to the @p GPTDriver object
    718           * @param[in] interval  period in ticks
    719           *
    720           * @notapi
    721           */

   \                                 In section .text, align 2, keep-with-next
    722          void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
    723          
    724            gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
   \                     gpt_lld_start_timer:
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
   \   00000002   0x1E4B             SUBS     R3,R1,#+1
   \   00000004   0x62D3             STR      R3,[R2, #+44]
    725            gptp->tim->EGR   = STM32_TIM_EGR_UG;          /* Update event.            */
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x6153             STR      R3,[R2, #+20]
    726            gptp->tim->CNT   = 0;                         /* Reset counter.           */
   \   0000000C   0x68C2             LDR      R2,[R0, #+12]
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x6253             STR      R3,[R2, #+36]
    727          
    728            /* NOTE: After generating the UG event it takes several clock cycles before
    729               SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
    730               before the clearing of SR, to give it some time.*/
    731            gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
   \   00000012   0x68C2             LDR      R2,[R0, #+12]
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x6113             STR      R3,[R2, #+16]
    732            gptp->tim->DIER |= STM32_TIM_DIER_UIE;        /* Update Event IRQ enabled.*/
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0x68D2             LDR      R2,[R2, #+12]
   \   0000001C   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000020   0x68C3             LDR      R3,[R0, #+12]
   \   00000022   0x60DA             STR      R2,[R3, #+12]
    733            gptp->tim->CR1   = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0x2305             MOVS     R3,#+5
   \   00000028   0x6013             STR      R3,[R2, #+0]
    734          }
   \   0000002A   0x4770             BX       LR               ;; return
    735          
    736          /**
    737           * @brief   Stops the timer.
    738           *
    739           * @param[in] gptp      pointer to the @p GPTDriver object
    740           *
    741           * @notapi
    742           */

   \                                 In section .text, align 2, keep-with-next
    743          void gpt_lld_stop_timer(GPTDriver *gptp) {
    744          
    745            gptp->tim->CR1   = 0;                         /* Initially stopped.       */
   \                     gpt_lld_stop_timer:
   \   00000000   0x68C1             LDR      R1,[R0, #+12]
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x600A             STR      R2,[R1, #+0]
    746            gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x610A             STR      R2,[R1, #+16]
    747          
    748            /* All interrupts disabled.*/
    749            gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x68C9             LDR      R1,[R1, #+12]
   \   00000010   0x0A09             LSRS     R1,R1,#+8
   \   00000012   0x0209             LSLS     R1,R1,#+8
   \   00000014   0x68C2             LDR      R2,[R0, #+12]
   \   00000016   0x60D1             STR      R1,[R2, #+12]
    750          }
   \   00000018   0x4770             BX       LR               ;; return
    751          
    752          /**
    753           * @brief   Starts the timer in one shot mode and waits for completion.
    754           * @details This function specifically polls the timer waiting for completion
    755           *          in order to not have extra delays caused by interrupt servicing,
    756           *          this function is only recommended for short delays.
    757           *
    758           * @param[in] gptp      pointer to the @p GPTDriver object
    759           * @param[in] interval  time interval in ticks
    760           *
    761           * @notapi
    762           */

   \                                 In section .text, align 2, keep-with-next
    763          void gpt_lld_polled_delay(GPTDriver *gptp, gptcnt_t interval) {
    764          
    765            gptp->tim->ARR  = (uint32_t)(interval - 1);   /* Time constant.           */
   \                     gpt_lld_polled_delay:
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
   \   00000002   0x1E4B             SUBS     R3,R1,#+1
   \   00000004   0x62D3             STR      R3,[R2, #+44]
    766            gptp->tim->EGR  = STM32_TIM_EGR_UG;           /* Update event.            */
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x6153             STR      R3,[R2, #+20]
    767            gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
   \   0000000C   0x68C2             LDR      R2,[R0, #+12]
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x6113             STR      R3,[R2, #+16]
    768            gptp->tim->CR1  = STM32_TIM_CR1_OPM | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
   \   00000012   0x68C2             LDR      R2,[R0, #+12]
   \   00000014   0x230D             MOVS     R3,#+13
   \   00000016   0x6013             STR      R3,[R2, #+0]
    769            while (!(gptp->tim->SR & STM32_TIM_SR_UIF))
   \                     ??gpt_lld_polled_delay_0:
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0x6912             LDR      R2,[R2, #+16]
   \   0000001C   0x07D2             LSLS     R2,R2,#+31
   \   0000001E   0xD5FB             BPL.N    ??gpt_lld_polled_delay_0
    770              ;
    771          }
   \   00000020   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     GPTD5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x0501BD00         DC32     0x501bd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     `?<Constant "gpt_lld_start(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "gpt_lld_start(), #1">`:
   \   00000000   0x67 0x70          DC8 "gpt_lld_start(), #1"
   \              0x74 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
    772          
    773          #endif /* HAL_USE_GPT */
    774          
    775          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Vector108
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> gpt_lld_serve_interrupt
       8   gpt_lld_init
         8   -> gptObjectInit
       0   gpt_lld_polled_delay
       8   gpt_lld_serve_interrupt
         8   -- Indirect call
         8   -> gpt_lld_stop_timer
      16   gpt_lld_start
        16   -> chDbgPanic
        16   -> nvicEnableVector
       0   gpt_lld_start_timer
       8   gpt_lld_stop
         8   -> nvicDisableVector
       0   gpt_lld_stop_timer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "gpt_lld_start(), #1">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
      16  GPTD5
      22  Vector108
      16  gpt_lld_init
      34  gpt_lld_polled_delay
      36  gpt_lld_serve_interrupt
     130  gpt_lld_start
      44  gpt_lld_start_timer
      54  gpt_lld_stop
      26  gpt_lld_stop_timer

 
  16 bytes in section .bss
  20 bytes in section .rodata
 386 bytes in section .text
 
 386 bytes of CODE  memory
  20 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
