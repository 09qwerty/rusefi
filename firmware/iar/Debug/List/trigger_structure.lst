###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:58 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\trig #
#                       ger\trigger_structure.cpp                             #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\trig #
#                       ger\trigger_structure.cpp -lCN                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\t #
#                       rigger_structure.lst                                  #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\tr #
#                       igger_structure.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\trigger\trigger_structure.cpp
      1          /**
      2           * @file	trigger_structure.cpp
      3           *
      4           * @date Jan 20, 2014
      5           * @author Andrey Belomutskiy, (c) 2012-2015
      6           *
      7           * This file is part of rusEfi - see http://rusefi.com
      8           *
      9           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     10           * the GNU General Public License as published by the Free Software Foundation; either
     11           * version 3 of the License, or (at your option) any later version.
     12           *
     13           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     14           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15           * GNU General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU General Public License along with this program.
     18           * If not, see <http://www.gnu.org/licenses/>.
     19           */
     20          
     21          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     22          #include "trigger_structure.h"
     23          #include "error_handling.h"
     24          #include "trigger_decoder.h"
     25          #include "engine_math.h"
     26          
     27          EXTERN_ENGINE;
     28          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp trigger_shape_helper::subobject trigger_shape_helper()
   \                     _ZN20trigger_shape_helperC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN20trigger_shape_helperC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     29          trigger_shape_helper::trigger_shape_helper() {
   \                     _ZN20trigger_shape_helperC1Ev:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x2303             MOVS     R3,#+3
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_vec_ctor_nocookie_nodtor
     30          	memset(&pinStates, 0, sizeof(pinStates));
   \   00000012   0xF44F 0x723D      MOV      R2,#+756
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000001C   0x.... 0x....      BL       memset
     31          	for (int i = 0; i < TRIGGER_CHANNEL_COUNT; i++) {
   \   00000020   0x2500             MOVS     R5,#+0
   \                     ??trigger_shape_helper_0:
   \   00000022   0x2D03             CMP      R5,#+3
   \   00000024   0xDA0A             BGE.N    ??trigger_shape_helper_1
     32          		waves[i].init(pinStates[i]);
   \   00000026   0x20FC             MOVS     R0,#+252
   \   00000028   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000002C   0xF110 0x010C      ADDS     R1,R0,#+12
   \   00000030   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000034   0x.... 0x....      BL       _ZN13single_wave_s4initEPa
     33          	}
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \   0000003A   0xE7F2             B.N      ??trigger_shape_helper_0
     34          }
   \                     ??trigger_shape_helper_1:
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     35          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp TriggerShape::subobject TriggerShape()
   \                     _ZN12TriggerShapeC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN12TriggerShapeC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
     36          TriggerShape::TriggerShape() :
   \                     _ZN12TriggerShapeC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     37          		wave(switchTimesBuffer, NULL) {
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF504 0x51B8      ADD      R1,R4,#+5888
   \   0000000A   0x3174             ADDS     R1,R1,#+116
   \   0000000C   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   00000010   0x.... 0x....      BL       _ZN12multi_wave_sC1EPfP13single_wave_s
   \   00000014   0xF504 0x50A0      ADD      R0,R4,#+5120
   \   00000018   0x3070             ADDS     R0,R0,#+112
   \   0000001A   0x.... 0x....      BL       _ZN20trigger_shape_helperC1Ev
     38          	reset(OM_NONE, false);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       _ZN12TriggerShape5resetE16operation_mode_eb
     39          	wave.waves = h.waves;
   \   00000028   0xF504 0x50A0      ADD      R0,R4,#+5120
   \   0000002C   0x3070             ADDS     R0,R0,#+112
   \   0000002E   0xF8C4 0x0B78      STR      R0,[R4, #+2936]
     40          	// todo: false here, true in clear() what a mess!
     41          	useRiseEdge = false;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0B64      STRB     R0,[R4, #+2916]
     42          	gapBothDirections = false;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF884 0x0B65      STRB     R0,[R4, #+2917]
     43          	isSynchronizationNeeded = false;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7020             STRB     R0,[R4, #+0]
     44          	// todo: reuse 'clear' method?
     45          	invertOnAdd = false;
   \   00000042   0xF241 0x4068      MOVW     R0,#+5224
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x5501             STRB     R1,[R0, R4]
     46          	tdcPosition = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF8C4 0x0B60      STR      R0,[R4, #+2912]
     47          	skippedToothCount = totalToothCount = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6060             STR      R0,[R4, #+4]
   \   00000054   0x60A0             STR      R0,[R4, #+8]
     48          	syncRatioFrom = syncRatioTo = 0;
   \   00000056   0xED9F 0x....      VLDR.W   S0,??DataTable2  ;; 0x0
   \   0000005A   0xF604 0x305C      ADDW     R0,R4,#+2908
   \   0000005E   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   00000062   0xF604 0x3058      ADDW     R0,R4,#+2904
   \   00000066   0xED80 0x0A00      VSTR     S0,[R0, #0]
     49          	memset(eventAngles, 0, sizeof(eventAngles));
   \   0000006A   0xF44F 0x727C      MOV      R2,#+1008
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0xF604 0x308C      ADDW     R0,R4,#+2956
   \   00000074   0x.... 0x....      BL       memset
     50          	memset(frontOnlyIndexes, 0, sizeof(frontOnlyIndexes));
   \   00000078   0xF44F 0x727C      MOV      R2,#+1008
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0xF504 0x5080      ADD      R0,R4,#+4096
   \   00000082   0x3078             ADDS     R0,R0,#+120
   \   00000084   0x.... 0x....      BL       memset
     51          	memset(isFrontEvent, 0, sizeof(isFrontEvent));
   \   00000088   0x22FC             MOVS     R2,#+252
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0xF604 0x707C      ADDW     R0,R4,#+3964
   \   00000090   0x.... 0x....      BL       memset
     52          	memset(triggerIndexByAngle, 0, sizeof(triggerIndexByAngle));
   \   00000094   0xF44F 0x6234      MOV      R2,#+2880
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0xF114 0x0018      ADDS     R0,R4,#+24
   \   0000009E   0x.... 0x....      BL       memset
     53          #if EFI_UNIT_TEST
     54          	memset(&events, 0, sizeof(events));
     55          #endif
     56          
     57          }
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0xBD10             POP      {R4,PC}          ;; return
     58          

   \                                 In section .text, align 2, keep-with-next
     59          int TriggerShape::getSize() const {
     60          	return size;
   \                     _ZNK12TriggerShape7getSizeEv:
   \   00000000   0xF241 0x416C      MOVW     R1,#+5228
   \   00000004   0x5808             LDR      R0,[R1, R0]
   \   00000006   0x4770             BX       LR               ;; return
     61          }
     62          

   \                                 In section .text, align 2, keep-with-next
     63          int TriggerShape::getTriggerShapeSynchPointIndex() {
     64          	return triggerShapeSynchPointIndex;
   \                     _ZN12TriggerShape30getTriggerShapeSynchPointIndexEv:
   \   00000000   0xF241 0x7170      MOVW     R1,#+6000
   \   00000004   0x5808             LDR      R0,[R1, R0]
   \   00000006   0x4770             BX       LR               ;; return
     65          }
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void TriggerShape::calculateTriggerSynchPoint(DECLARE_ENGINE_PARAMETER_F) {
   \                     _ZN12TriggerShape26calculateTriggerSynchPointEv:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x0004             MOVS     R4,R0
     68          	trigger_config_s const*triggerConfig = &engineConfiguration->trigger;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF510 0x7506      ADDS     R5,R0,#+536
     69          
     70          	triggerShapeSynchPointIndex = findTriggerZeroEventIndex(this, triggerConfig PASS_ENGINE_PARAMETER);
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _Z25findTriggerZeroEventIndexP12TriggerShapePK16trigger_config_s
   \   0000001C   0xF241 0x7170      MOVW     R1,#+6000
   \   00000020   0x5108             STR      R0,[R1, R4]
     71          
     72          	engine->engineCycleEventCount = getLength();
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       _ZNK12TriggerShape9getLengthEv
   \   00000028   0xF641 0x61FC      MOVW     R1,#+7932
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable7_8
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0x5088             STR      R0,[R1, R2]
     73          
     74          	float firstAngle = getAngle(triggerShapeSynchPointIndex);
   \   00000034   0xF241 0x7070      MOVW     R0,#+6000
   \   00000038   0x5901             LDR      R1,[R0, R4]
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       _ZNK12TriggerShape8getAngleEi
   \   00000040   0xEEB0 0x8A40      VMOV.F32 S16,S0
     75          
     76          	int frontOnlyIndex = 0;
   \   00000044   0x2600             MOVS     R6,#+0
     77          
     78          	for (int eventIndex = 0; eventIndex < engine->engineCycleEventCount; eventIndex++) {
   \   00000046   0x2700             MOVS     R7,#+0
   \                     ??calculateTriggerSynchPoint_0:
   \   00000048   0xF641 0x60FC      MOVW     R0,#+7932
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable7_8
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x5840             LDR      R0,[R0, R1]
   \   00000054   0x4287             CMP      R7,R0
   \   00000056   0xF280 0x8085      BGE.W    ??calculateTriggerSynchPoint_1
     79          		if (eventIndex == 0) {
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD10A             BNE.N    ??calculateTriggerSynchPoint_2
     80          			// explicit check for zero to avoid issues where logical zero is not exactly zero due to float nature
     81          			eventAngles[0] = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8C4 0x0B8C      STR      R0,[R4, #+2956]
     82          			// this value would be used in case of front-only
     83          			eventAngles[1] = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF8C4 0x0B90      STR      R0,[R4, #+2960]
     84          			frontOnlyIndexes[0] = 0;
   \   0000006A   0xF241 0x0078      MOVW     R0,#+4216
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x5101             STR      R1,[R0, R4]
   \   00000072   0xE075             B.N      ??calculateTriggerSynchPoint_3
     85          		} else {
     86          			int triggerDefinitionCoordinate = (triggerShapeSynchPointIndex + eventIndex) % engine->engineCycleEventCount;
   \                     ??calculateTriggerSynchPoint_2:
   \   00000074   0xF241 0x7070      MOVW     R0,#+6000
   \   00000078   0x5900             LDR      R0,[R0, R4]
   \   0000007A   0x1838             ADDS     R0,R7,R0
   \   0000007C   0xF641 0x61FC      MOVW     R1,#+7932
   \   00000080   0x.... 0x....      LDR.W    R2,??DataTable7_8
   \   00000084   0x6812             LDR      R2,[R2, #+0]
   \   00000086   0x5889             LDR      R1,[R1, R2]
   \   00000088   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000008C   0xFB01 0x0812      MLS      R8,R1,R2,R0
     87          			int triggerDefinitionIndex = triggerDefinitionCoordinate >= size ? triggerDefinitionCoordinate - size : triggerDefinitionCoordinate;
   \   00000090   0xF241 0x406C      MOVW     R0,#+5228
   \   00000094   0x5900             LDR      R0,[R0, R4]
   \   00000096   0x4580             CMP      R8,R0
   \   00000098   0xDB05             BLT.N    ??calculateTriggerSynchPoint_4
   \   0000009A   0xF241 0x406C      MOVW     R0,#+5228
   \   0000009E   0x5900             LDR      R0,[R0, R4]
   \   000000A0   0xEBB8 0x0900      SUBS     R9,R8,R0
   \   000000A4   0xE000             B.N      ??calculateTriggerSynchPoint_5
   \                     ??calculateTriggerSynchPoint_4:
   \   000000A6   0x46C1             MOV      R9,R8
     88          			float angle = getAngle(triggerDefinitionCoordinate) - firstAngle;
   \                     ??calculateTriggerSynchPoint_5:
   \   000000A8   0x4641             MOV      R1,R8
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       _ZNK12TriggerShape8getAngleEi
   \   000000B0   0xEE70 0x8A48      VSUB.F32 S17,S0,S16
     89          			fixAngle(angle);
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable7_9
   \   000000B8   0xF8D0 0x01A8      LDR      R0,[R0, #+424]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD103             BNE.N    ??calculateTriggerSynchPoint_6
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable7_11
   \   000000C4   0x.... 0x....      BL       firmwareError
   \                     ??calculateTriggerSynchPoint_6:
   \   000000C8   0xEEF5 0x8A40      VCMP.F32 S17,#0.0
   \   000000CC   0xEEF1 0xFA10      FMSTAT   
   \   000000D0   0xD508             BPL.N    ??calculateTriggerSynchPoint_7
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable7_9
   \   000000D6   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   000000DA   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000DE   0xEE70 0x8A28      VADD.F32 S17,S0,S17
   \   000000E2   0xE7F1             B.N      ??calculateTriggerSynchPoint_6
   \                     ??calculateTriggerSynchPoint_7:
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable7_9
   \   000000E8   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   000000EC   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000F0   0xEEF4 0x8A40      VCMP.F32 S17,S0
   \   000000F4   0xEEF1 0xFA10      FMSTAT   
   \   000000F8   0xDB08             BLT.N    ??calculateTriggerSynchPoint_8
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable7_9
   \   000000FE   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   00000102   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000106   0xEE78 0x8AC0      VSUB.F32 S17,S17,S0
   \   0000010A   0xE7EB             B.N      ??calculateTriggerSynchPoint_7
     90          			if (engineConfiguration->useOnlyFrontForTrigger) {
   \                     ??calculateTriggerSynchPoint_8:
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF890 0x05E5      LDRB     R0,[R0, #+1509]
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0x0980             LSRS     R0,R0,#+6
   \   0000011A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD013             BEQ.N    ??calculateTriggerSynchPoint_9
     91          				if (isFrontEvent[triggerDefinitionIndex]) {
   \   00000122   0xEB19 0x0004      ADDS     R0,R9,R4
   \   00000126   0xF990 0x0F7C      LDRSB    R0,[R0, #+3964]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD013             BEQ.N    ??calculateTriggerSynchPoint_10
     92          					frontOnlyIndex += 2;
   \   0000012E   0x1CB6             ADDS     R6,R6,#+2
     93          					eventAngles[frontOnlyIndex] = angle;
   \   00000130   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   00000134   0xF600 0x308C      ADDW     R0,R0,#+2956
   \   00000138   0xEDC0 0x8A00      VSTR     S17,[R0, #0]
     94          					eventAngles[frontOnlyIndex + 1] = angle;
   \   0000013C   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   00000140   0xF600 0x3090      ADDW     R0,R0,#+2960
   \   00000144   0xEDC0 0x8A00      VSTR     S17,[R0, #0]
   \   00000148   0xE005             B.N      ??calculateTriggerSynchPoint_10
     95          				}
     96          			} else {
     97          				eventAngles[eventIndex] = angle;
   \                     ??calculateTriggerSynchPoint_9:
   \   0000014A   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   0000014E   0xF600 0x308C      ADDW     R0,R0,#+2956
   \   00000152   0xEDC0 0x8A00      VSTR     S17,[R0, #0]
     98          			}
     99          
    100          			frontOnlyIndexes[eventIndex] = frontOnlyIndex;
   \                     ??calculateTriggerSynchPoint_10:
   \   00000156   0xF241 0x0078      MOVW     R0,#+4216
   \   0000015A   0xEB14 0x0187      ADDS     R1,R4,R7, LSL #+2
   \   0000015E   0x5046             STR      R6,[R0, R1]
    101          		}
    102          	}
   \                     ??calculateTriggerSynchPoint_3:
   \   00000160   0x1C7F             ADDS     R7,R7,#+1
   \   00000162   0xE771             B.N      ??calculateTriggerSynchPoint_0
    103          }
   \                     ??calculateTriggerSynchPoint_1:
   \   00000164   0xECBD 0x8B02      VPOP     {D8}
   \   00000168   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void TriggerShape::clear() {
   \                     _ZN12TriggerShape5clearEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    106          	tdcPosition = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8C4 0x0B60      STR      R0,[R4, #+2912]
    107          	setTriggerSynchronizationGap(2);
   \   0000000A   0xEEB0 0x0A00      VMOV.F32 S0,#2.0
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZN12TriggerShape28setTriggerSynchronizationGapEf
    108          	// todo: true here, false in constructor() what a mess!
    109          	useRiseEdge = true;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0B64      STRB     R0,[R4, #+2916]
    110          
    111          	invertOnAdd = false;
   \   0000001A   0xF241 0x4068      MOVW     R0,#+5224
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x5501             STRB     R1,[R0, R4]
    112          	gapBothDirections = false;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x0B65      STRB     R0,[R4, #+2917]
    113          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    114          

   \                                 In section .text, align 2, keep-with-next
    115          void TriggerShape::reset(operation_mode_e operationMode, bool needSecondTriggerInput) {
   \                     _ZN12TriggerShape5resetE16operation_mode_eb:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    116          	this->operationMode = operationMode;
   \   00000008   0xF641 0x3068      MOVW     R0,#+7016
   \   0000000C   0x5105             STR      R5,[R0, R4]
    117          	size = 0;
   \   0000000E   0xF241 0x406C      MOVW     R0,#+5228
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x5101             STR      R1,[R0, R4]
    118          	this->needSecondTriggerInput = needSecondTriggerInput;
   \   00000016   0x7066             STRB     R6,[R4, #+1]
    119          	triggerShapeSynchPointIndex = 0;
   \   00000018   0xF241 0x7070      MOVW     R0,#+6000
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x5101             STR      R1,[R0, R4]
    120          	memset(initialState, 0, sizeof(initialState));
   \   00000020   0x220C             MOVS     R2,#+12
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF514 0x6038      ADDS     R0,R4,#+2944
   \   00000028   0x.... 0x....      BL       memset
    121          	memset(switchTimesBuffer, 0, sizeof(switchTimesBuffer));
   \   0000002C   0xF44F 0x727C      MOV      R2,#+1008
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF504 0x50B8      ADD      R0,R4,#+5888
   \   00000036   0x3074             ADDS     R0,R0,#+116
   \   00000038   0x.... 0x....      BL       memset
    122          	memset(expectedEventCount, 0, sizeof(expectedEventCount));
   \   0000003C   0x220C             MOVS     R2,#+12
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF604 0x3068      ADDW     R0,R4,#+2920
   \   00000044   0x.... 0x....      BL       memset
    123          	wave.reset();
   \   00000048   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   0000004C   0x.... 0x....      BL       _ZN12multi_wave_s5resetEv
    124          	previousAngle = 0;
   \   00000050   0xF641 0x3064      MOVW     R0,#+7012
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x5101             STR      R1,[R0, R4]
    125          }
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    126          

   \                                 In section .text, align 2, keep-with-next
    127          int multi_wave_s::getChannelState(int channelIndex, int phaseIndex) const {
    128          	return waves[channelIndex].pinStates[phaseIndex];
   \                     _ZNK12multi_wave_s15getChannelStateEii:
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000006   0x5610             LDRSB    R0,[R2, R0]
   \   00000008   0x4770             BX       LR               ;; return
    129          }
    130          

   \                                 In section .text, align 2, keep-with-next
    131          int multi_wave_s::waveIndertionAngle(float angle, int size) const {
   \                     _ZNK12multi_wave_s18waveIndertionAngleEfi:
   \   00000000   0x0002             MOVS     R2,R0
    132          	for (int i = size - 1; i >= 0; i--) {
   \   00000002   0x1E48             SUBS     R0,R1,#+1
   \                     ??waveIndertionAngle_0:
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD40D             BMI.N    ??waveIndertionAngle_1
    133          		if (angle > switchTimes[i])
   \   00000008   0x6893             LDR      R3,[R2, #+8]
   \   0000000A   0xEB13 0x0380      ADDS     R3,R3,R0, LSL #+2
   \   0000000E   0xEDD3 0x0A00      VLDR     S1,[R3, #0]
   \   00000012   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000016   0xEEF1 0xFA10      FMSTAT   
   \   0000001A   0xD501             BPL.N    ??waveIndertionAngle_2
    134          			return i + 1;
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xE002             B.N      ??waveIndertionAngle_3
    135          	}
   \                     ??waveIndertionAngle_2:
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0xE7EF             B.N      ??waveIndertionAngle_0
    136          	return 0;
   \                     ??waveIndertionAngle_1:
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??waveIndertionAngle_3:
   \   00000026   0x4770             BX       LR               ;; return
    137          }
    138          

   \                                 In section .text, align 2, keep-with-next
    139          int multi_wave_s::findAngleMatch(float angle, int size) const {
   \                     _ZNK12multi_wave_s14findAngleMatchEfi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0x000D             MOVS     R5,R1
    140          	for (int i = 0; i < size; i++) {
   \   0000000E   0x2600             MOVS     R6,#+0
   \                     ??findAngleMatch_0:
   \   00000010   0x42AE             CMP      R6,R5
   \   00000012   0xDA0E             BGE.N    ??findAngleMatch_1
    141          		if (isSameF(switchTimes[i], angle))
   \   00000014   0xEEF0 0x0A48      VMOV.F32 S1,S16
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   0000001E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000022   0x.... 0x....      BL       isSameF
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??findAngleMatch_2
    142          			return i;
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xE003             B.N      ??findAngleMatch_3
    143          	}
   \                     ??findAngleMatch_2:
   \   0000002E   0x1C76             ADDS     R6,R6,#+1
   \   00000030   0xE7EE             B.N      ??findAngleMatch_0
    144          	return EFI_ERROR_CODE;
   \                     ??findAngleMatch_1:
   \   00000032   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??findAngleMatch_3:
   \   00000036   0xECBD 0x8B02      VPOP     {D8}
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    145          }
    146          

   \                                 In section .text, align 2, keep-with-next
    147          void multi_wave_s::setSwitchTime(int index, float value) {
    148          	switchTimes[index] = value;
   \                     _ZN12multi_wave_s13setSwitchTimeEif:
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   00000006   0xED82 0x0A00      VSTR     S0,[R2, #0]
    149          }
   \   0000000A   0x4770             BX       LR               ;; return
    150          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp TriggerState::subobject TriggerState()
   \                     _ZN12TriggerStateC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN12TriggerStateC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    151          TriggerState::TriggerState() {
   \                     _ZN12TriggerStateC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    152          	cycleCallback = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    153          	shaft_is_synchronized = false;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7120             STRB     R0,[R4, #+4]
    154          	toothed_previous_time = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xE9C4 0x0104      STRD     R0,R1,[R4, #+16]
    155          	toothed_previous_duration = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x60A0             STR      R0,[R4, #+8]
    156          
    157          	totalRevolutionCounter = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF8C4 0x00A0      STR      R0,[R4, #+160]
    158          	totalTriggerErrorCounter = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x63E0             STR      R0,[R4, #+60]
    159          	orderingErrorCounter = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6460             STR      R0,[R4, #+68]
    160          	currentDuration = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x60E0             STR      R0,[R4, #+12]
    161          	curSignal = SHAFT_PRIMARY_DOWN;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF884 0x0060      STRB     R0,[R4, #+96]
    162          	prevSignal = SHAFT_PRIMARY_DOWN;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF884 0x0061      STRB     R0,[R4, #+97]
    163          	prevCycleDuration = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xE9C4 0x012A      STRD     R0,R1,[R4, #+168]
    164          	startOfCycleNt = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xE9C4 0x012C      STRD     R0,R1,[R4, #+176]
    165          
    166          	resetRunningCounters();
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       _ZN12TriggerState20resetRunningCountersEv
    167          	clear();
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       _ZN12TriggerState5clearEv
    168          	memset(expectedTotalTime, 0, sizeof(expectedTotalTime));
   \   00000052   0x220C             MOVS     R2,#+12
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xF114 0x0030      ADDS     R0,R4,#+48
   \   0000005A   0x.... 0x....      BL       memset
    169          	totalEventCountBase = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xE9C4 0x0126      STRD     R0,R1,[R4, #+152]
    170          	isFirstEvent = true;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x00A4      STRB     R0,[R4, #+164]
    171          }
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    172          

   \                                 In section .text, align 2, keep-with-next
    173          int TriggerState::getCurrentIndex() {
    174          	return current_index;
   \                     _ZN12TriggerState15getCurrentIndexEv:
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0x4770             BX       LR               ;; return
    175          }
    176          

   \                                 In section .text, align 2, keep-with-next
    177          efitime_t TriggerState::getStartOfRevolutionIndex() {
    178          	return totalEventCountBase;
   \                     _ZN12TriggerState25getStartOfRevolutionIndexEv:
   \   00000000   0xE9D0 0x2326      LDRD     R2,R3,[R0, #+152]
   \   00000004   0x0010             MOVS     R0,R2
   \   00000006   0x0019             MOVS     R1,R3
   \   00000008   0x4770             BX       LR               ;; return
    179          }
    180          

   \                                 In section .text, align 2, keep-with-next
    181          void TriggerState::resetRunningCounters() {
    182          	runningRevolutionCounter = 0;
   \                     _ZN12TriggerState20resetRunningCountersEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6501             STR      R1,[R0, #+80]
    183          	runningTriggerErrorCounter = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6401             STR      R1,[R0, #+64]
    184          	runningOrderingErrorCounter = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6481             STR      R1,[R0, #+72]
    185          }
   \   0000000C   0x4770             BX       LR               ;; return
    186          

   \                                 In section .text, align 2, keep-with-next
    187          efitime_t TriggerState::getTotalEventCounter() {
    188          	return totalEventCountBase + current_index;
   \                     _ZN12TriggerState20getTotalEventCounterEv:
   \   00000000   0xE9D0 0x2326      LDRD     R2,R3,[R0, #+152]
   \   00000004   0x6CC0             LDR      R0,[R0, #+76]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0x4159             ADCS     R1,R3,R1
   \   0000000C   0x4770             BX       LR               ;; return
    189          }
    190          

   \                                 In section .text, align 2, keep-with-next
    191          int TriggerState::getTotalRevolutionCounter() {
    192          	return totalRevolutionCounter;
   \                     _ZN12TriggerState25getTotalRevolutionCounterEv:
   \   00000000   0xF8D0 0x00A0      LDR      R0,[R0, #+160]
   \   00000004   0x4770             BX       LR               ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void TriggerState::clear() {
   \                     _ZN12TriggerState5clearEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    196          	memset(eventCount, 0, sizeof(eventCount));
   \   00000004   0x220C             MOVS     R2,#+12
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF114 0x0054      ADDS     R0,R4,#+84
   \   0000000C   0x.... 0x....      BL       memset
    197          	memset(eventCountExt, 0, sizeof(eventCountExt));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF114 0x0064      ADDS     R0,R4,#+100
   \   00000018   0x.... 0x....      BL       memset
    198          	memset(timeOfPreviousEventNt, 0, sizeof(timeOfPreviousEventNt));
   \   0000001C   0x2218             MOVS     R2,#+24
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF114 0x0080      ADDS     R0,R4,#+128
   \   00000024   0x.... 0x....      BL       memset
    199          	memset(totalTimeNt, 0, sizeof(totalTimeNt));
   \   00000028   0x220C             MOVS     R2,#+12
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF114 0x0018      ADDS     R0,R4,#+24
   \   00000030   0x.... 0x....      BL       memset
    200          	current_index = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x64E0             STR      R0,[R4, #+76]
    201          }
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    202          
    203          /**
    204           * Trigger event count equals engine cycle event count if we have a cam sensor.
    205           * Two trigger cycles make one engine cycle in case of a four stroke engine If we only have a cranksensor.
    206           */

   \                                 In section .text, align 2, keep-with-next
    207          uint32_t TriggerShape::getLength() const {
   \                     _ZNK12TriggerShape9getLengthEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    208          	return operationMode == FOUR_STROKE_CAM_SENSOR ? getSize() : 2 * getSize();
   \   00000004   0xF641 0x3068      MOVW     R0,#+7016
   \   00000008   0x5900             LDR      R0,[R0, R4]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD103             BNE.N    ??getLength_0
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZNK12TriggerShape7getSizeEv
   \   00000014   0xE003             B.N      ??getLength_1
   \                     ??getLength_0:
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _ZNK12TriggerShape7getSizeEv
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \                     ??getLength_1:
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    209          }
    210          

   \                                 In section .text, align 4, keep-with-next
    211          float TriggerShape::getAngle(int index) const {
   \                     _ZNK12TriggerShape8getAngleEi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    212          	// todo: why is this check here? looks like the code below could be used universally
    213          	if (operationMode == FOUR_STROKE_CAM_SENSOR) {
   \   00000006   0xF641 0x3068      MOVW     R0,#+7016
   \   0000000A   0x5900             LDR      R0,[R0, R4]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD104             BNE.N    ??getAngle_0
    214          		return getSwitchAngle(index);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       _ZNK12TriggerShape14getSwitchAngleEi
   \   00000018   0xE011             B.N      ??getAngle_1
    215          	}
    216          	/**
    217          	 * FOUR_STROKE_CRANK_SENSOR magic:
    218          	 * We have two crank shaft revolutions for each engine cycle
    219          	 * See also trigger_central.cpp
    220          	 * See also getEngineCycleEventCount()
    221          	 */
    222          	int triggerEventCounter = size;
   \                     ??getAngle_0:
   \   0000001A   0xF241 0x406C      MOVW     R0,#+5228
   \   0000001E   0x5906             LDR      R6,[R0, R4]
    223          
    224          	if (index < triggerEventCounter) {
   \   00000020   0x42B5             CMP      R5,R6
   \   00000022   0xDA04             BGE.N    ??getAngle_2
    225          		return getSwitchAngle(index);
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       _ZNK12TriggerShape14getSwitchAngleEi
   \   0000002C   0xE007             B.N      ??getAngle_1
    226          	} else {
    227          		return 360 + getSwitchAngle(index - triggerEventCounter);
   \                     ??getAngle_2:
   \   0000002E   0x1BA9             SUBS     R1,R5,R6
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       _ZNK12TriggerShape14getSwitchAngleEi
   \   00000036   0xEDDF 0x....      VLDR.W   S1,??DataTable4  ;; 0x43b40000
   \   0000003A   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \                     ??getAngle_1:
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    228          	}
    229          }
    230          

   \                                 In section .text, align 2, keep-with-next
    231          void TriggerShape::addEvent(float angle, trigger_wheel_e const waveIndex, trigger_value_e const stateParam, float filterLeft, float filterRight) {
   \                     _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_eff:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x9A40      VMOV.F32 S18,S0
   \   0000000C   0x000D             MOVS     R5,R1
   \   0000000E   0x0016             MOVS     R6,R2
   \   00000010   0xEEB0 0x8A60      VMOV.F32 S16,S1
   \   00000014   0xEEF0 0x8A41      VMOV.F32 S17,S2
    232          	if (angle > filterLeft && angle < filterRight)
   \   00000018   0xEEB4 0x8A49      VCMP.F32 S16,S18
   \   0000001C   0xEEF1 0xFA10      FMSTAT   
   \   00000020   0xD50D             BPL.N    ??addEvent_0
   \   00000022   0xEEB4 0x9A68      VCMP.F32 S18,S17
   \   00000026   0xEEF1 0xFA10      FMSTAT   
   \   0000002A   0xD508             BPL.N    ??addEvent_0
    233          		addEvent(angle, waveIndex, stateParam);
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    234          }
   \                     ??addEvent_0:
   \   0000003E   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    235          

   \                                 In section .text, align 2, keep-with-next
    236          operation_mode_e TriggerShape::getOperationMode() {
    237          	return operationMode;
   \                     _ZN12TriggerShape16getOperationModeEv:
   \   00000000   0xF641 0x3168      MOVW     R1,#+7016
   \   00000004   0x5808             LDR      R0,[R1, R0]
   \   00000006   0x4770             BX       LR               ;; return
    238          }
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void TriggerShape::addEvent(float angle, trigger_wheel_e const waveIndex, trigger_value_e const stateParam) {
   \                     _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e:
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000010   0x0015             MOVS     R5,R2
    241          	efiAssertVoid(operationMode != OM_NONE, "operationMode not set");
   \   00000012   0xF641 0x3068      MOVW     R0,#+7016
   \   00000016   0x5900             LDR      R0,[R0, R4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE.N    ??addEvent_1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable7_13
   \   00000020   0x.... 0x....      BL       firmwareError
   \   00000024   0xE12A             B.N      ??addEvent_2
    242          
    243          	efiAssertVoid(waveIndex!= T_SECONDARY || needSecondTriggerInput, "secondary needed or not?");
   \                     ??addEvent_1:
   \   00000026   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD107             BNE.N    ??addEvent_3
   \   0000002E   0x7860             LDRB     R0,[R4, #+1]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD104             BNE.N    ??addEvent_3
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable7_14
   \   00000038   0x.... 0x....      BL       firmwareError
   \   0000003C   0xE11E             B.N      ??addEvent_2
    244          
    245          	trigger_value_e state;
    246          	if (invertOnAdd) {
   \                     ??addEvent_3:
   \   0000003E   0xF241 0x4068      MOVW     R0,#+5224
   \   00000042   0x5D00             LDRB     R0,[R0, R4]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD006             BEQ.N    ??addEvent_4
    247          		state = (stateParam == TV_LOW) ? TV_HIGH : TV_LOW;
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD101             BNE.N    ??addEvent_5
   \   0000004E   0x2601             MOVS     R6,#+1
   \   00000050   0xE002             B.N      ??addEvent_6
   \                     ??addEvent_5:
   \   00000052   0x2600             MOVS     R6,#+0
   \   00000054   0xE000             B.N      ??addEvent_6
    248          	} else {
    249          		state = stateParam;
   \                     ??addEvent_4:
   \   00000056   0x002E             MOVS     R6,R5
    250          	}
    251          
    252          #if EFI_UNIT_TEST
    253          	int signal = waveIndex * 1000 + stateParam;
    254          	events[size] = signal;
    255          #endif
    256          
    257          	float engineCycle = getEngineCycle(operationMode);
   \                     ??addEvent_6:
   \   00000058   0xF641 0x3068      MOVW     R0,#+7016
   \   0000005C   0x5900             LDR      R0,[R0, R4]
   \   0000005E   0x.... 0x....      BL       _Z14getEngineCycle16operation_mode_e
   \   00000062   0xEEF0 0x8A40      VMOV.F32 S17,S0
    258          
    259          	/**
    260          	 * While '720' value works perfectly it has not much sense for crank sensor-only scenario.
    261          	 * todo: accept angle as a value in the 0..1 range?
    262          	 */
    263          	angle /= engineCycle;
   \   00000066   0xEE88 0x8A28      VDIV.F32 S16,S16,S17
    264          
    265          #if EFI_PROD_CODE
    266          // todo: PASS_ENGINE?
    267          	if (!engineConfiguration->useOnlyFrontForTrigger || stateParam == TV_HIGH) {
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF890 0x05E5      LDRB     R0,[R0, #+1509]
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x0980             LSRS     R0,R0,#+6
   \   00000078   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??addEvent_7
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x2D01             CMP      R5,#+1
   \   00000084   0xD10C             BNE.N    ??addEvent_8
    268          		expectedEventCount[waveIndex]++;
   \                     ??addEvent_7:
   \   00000086   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000008A   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   0000008E   0xF8D0 0x0B68      LDR      R0,[R0, #+2920]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   00000098   0xEB14 0x0181      ADDS     R1,R4,R1, LSL #+2
   \   0000009C   0xF8C1 0x0B68      STR      R0,[R1, #+2920]
    269          	}
    270          #endif
    271          
    272          	efiAssertVoid(angle > 0, "angle should be positive");
   \                     ??addEvent_8:
   \   000000A0   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   000000A4   0xEEF1 0xFA10      FMSTAT   
   \   000000A8   0xDC04             BGT.N    ??addEvent_9
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable7_15
   \   000000AE   0x.... 0x....      BL       firmwareError
   \   000000B2   0xE0E3             B.N      ??addEvent_2
    273          	if (size > 0) {
   \                     ??addEvent_9:
   \   000000B4   0xF241 0x406C      MOVW     R0,#+5228
   \   000000B8   0x5900             LDR      R0,[R0, R4]
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xDB1B             BLT.N    ??addEvent_10
    274          		if (angle <= previousAngle) {
   \   000000BE   0xF504 0x50D8      ADD      R0,R4,#+6912
   \   000000C2   0x3064             ADDS     R0,R0,#+100
   \   000000C4   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000C8   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   000000CC   0xEEF1 0xFA10      FMSTAT   
   \   000000D0   0xDB11             BLT.N    ??addEvent_10
    275          			firmwareError("invalid angle order: %f and %f", angle, previousAngle);
   \   000000D2   0xF641 0x3064      MOVW     R0,#+7012
   \   000000D6   0x5900             LDR      R0,[R0, R4]
   \   000000D8   0x.... 0x....      BL       __aeabi_f2d
   \   000000DC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000000E0   0xEE18 0x0A10      VMOV     R0,S16
   \   000000E4   0x.... 0x....      BL       __aeabi_f2d
   \   000000E8   0x0002             MOVS     R2,R0
   \   000000EA   0x000B             MOVS     R3,R1
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable7_16
   \   000000F0   0x.... 0x....      BL       firmwareError
    276          			return;
   \   000000F4   0xE0C2             B.N      ??addEvent_2
    277          		}
    278          	}
    279          	previousAngle = angle;
   \                     ??addEvent_10:
   \   000000F6   0xF504 0x50D8      ADD      R0,R4,#+6912
   \   000000FA   0x3064             ADDS     R0,R0,#+100
   \   000000FC   0xED80 0x8A00      VSTR     S16,[R0, #0]
    280          	if (size == 0) {
   \   00000100   0xF241 0x406C      MOVW     R0,#+5228
   \   00000104   0x5900             LDR      R0,[R0, R4]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD133             BNE.N    ??addEvent_11
    281          		size = 1;
   \   0000010A   0xF241 0x406C      MOVW     R0,#+5228
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x5101             STR      R1,[R0, R4]
    282          		for (int i = 0; i < PWM_PHASE_MAX_WAVE_PER_PWM; i++) {
   \   00000112   0x2700             MOVS     R7,#+0
   \                     ??addEvent_12:
   \   00000114   0x2F03             CMP      R7,#+3
   \   00000116   0xDA15             BGE.N    ??addEvent_13
    283          			single_wave_s *wave = &this->wave.waves[i];
   \   00000118   0xF8D4 0x0B78      LDR      R0,[R4, #+2936]
   \   0000011C   0xEB10 0x0887      ADDS     R8,R0,R7, LSL #+2
    284          
    285          			if (wave->pinStates == NULL) {
   \   00000120   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD104             BNE.N    ??addEvent_14
    286          				firmwareError("wave pinStates is NULL");
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   0000012C   0x.... 0x....      BL       firmwareError
    287          				return;
   \   00000130   0xE0A4             B.N      ??addEvent_2
    288          			}
    289          			wave->pinStates[0] = initialState[i];
   \                     ??addEvent_14:
   \   00000132   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000136   0xF8D0 0x0B80      LDR      R0,[R0, #+2944]
   \   0000013A   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   0000013E   0x7008             STRB     R0,[R1, #+0]
    290          		}
   \   00000140   0x1C7F             ADDS     R7,R7,#+1
   \   00000142   0xE7E7             B.N      ??addEvent_12
    291          
    292          		isFrontEvent[0] = TV_HIGH == stateParam;
   \                     ??addEvent_13:
   \   00000144   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000146   0x2D01             CMP      R5,#+1
   \   00000148   0xD101             BNE.N    ??addEvent_15
   \   0000014A   0x2001             MOVS     R0,#+1
   \   0000014C   0xE000             B.N      ??addEvent_16
   \                     ??addEvent_15:
   \   0000014E   0x2000             MOVS     R0,#+0
   \                     ??addEvent_16:
   \   00000150   0xF884 0x0F7C      STRB     R0,[R4, #+3964]
    293          		wave.setSwitchTime(0, angle);
   \   00000154   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000158   0x2100             MOVS     R1,#+0
   \   0000015A   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   0000015E   0x.... 0x....      BL       _ZN12multi_wave_s13setSwitchTimeEif
    294          		wave.waves[waveIndex].pinStates[0] = state;
   \   00000162   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000166   0xF8D4 0x1B78      LDR      R1,[R4, #+2936]
   \   0000016A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000016E   0x7006             STRB     R6,[R0, #+0]
    295          		return;
   \   00000170   0xE084             B.N      ??addEvent_2
    296          	}
    297          
    298          	int exactMatch = wave.findAngleMatch(angle, size);
   \                     ??addEvent_11:
   \   00000172   0xF241 0x406C      MOVW     R0,#+5228
   \   00000176   0x5901             LDR      R1,[R0, R4]
   \   00000178   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000017C   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   00000180   0x.... 0x....      BL       _ZNK12multi_wave_s14findAngleMatchEfi
   \   00000184   0x0007             MOVS     R7,R0
    299          	if (exactMatch != EFI_ERROR_CODE) {
   \   00000186   0xF117 0x0F01      CMN      R7,#+1
   \   0000018A   0xD004             BEQ.N    ??addEvent_17
    300          		firmwareError("same angle: not supported");
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable7_18
   \   00000190   0x.... 0x....      BL       firmwareError
    301          		return;
   \   00000194   0xE072             B.N      ??addEvent_2
    302          	}
    303          
    304          	int index = wave.waveIndertionAngle(angle, size);
   \                     ??addEvent_17:
   \   00000196   0xF241 0x406C      MOVW     R0,#+5228
   \   0000019A   0x5901             LDR      R1,[R0, R4]
   \   0000019C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001A0   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   000001A4   0x.... 0x....      BL       _ZNK12multi_wave_s18waveIndertionAngleEfi
   \   000001A8   0x4680             MOV      R8,R0
    305          
    306          	// shifting existing data
    307          	// todo: does this logic actually work? I think it does not!
    308          	for (int i = size - 1; i >= index; i--) {
   \   000001AA   0xF241 0x406C      MOVW     R0,#+5228
   \   000001AE   0x5900             LDR      R0,[R0, R4]
   \   000001B0   0xF1B0 0x0901      SUBS     R9,R0,#+1
   \                     ??addEvent_18:
   \   000001B4   0x45C1             CMP      R9,R8
   \   000001B6   0xDB23             BLT.N    ??addEvent_19
    309          		for (int j = 0; j < PWM_PHASE_MAX_WAVE_PER_PWM; j++) {
   \   000001B8   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??addEvent_20:
   \   000001BC   0xF1BA 0x0F03      CMP      R10,#+3
   \   000001C0   0xDA10             BGE.N    ??addEvent_21
    310          			wave.waves[j].pinStates[i + 1] = wave.getChannelState(j, index);
   \   000001C2   0xF8D4 0x0B78      LDR      R0,[R4, #+2936]
   \   000001C6   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \   000001CA   0xEB19 0x0B00      ADDS     R11,R9,R0
   \   000001CE   0x4642             MOV      R2,R8
   \   000001D0   0x4651             MOV      R1,R10
   \   000001D2   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   000001D6   0x.... 0x....      BL       _ZNK12multi_wave_s15getChannelStateEii
   \   000001DA   0xF88B 0x0001      STRB     R0,[R11, #+1]
    311          		}
   \   000001DE   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000001E2   0xE7EB             B.N      ??addEvent_20
    312          		wave.setSwitchTime(i + 1, wave.getSwitchTime(i));
   \                     ??addEvent_21:
   \   000001E4   0x4649             MOV      R1,R9
   \   000001E6   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   000001EA   0x.... 0x....      BL       _ZNK12multi_wave_s13getSwitchTimeEi
   \   000001EE   0xF119 0x0101      ADDS     R1,R9,#+1
   \   000001F2   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   000001F6   0x.... 0x....      BL       _ZN12multi_wave_s13setSwitchTimeEif
    313          	}
   \   000001FA   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   000001FE   0xE7D9             B.N      ??addEvent_18
    314          
    315          	isFrontEvent[index] = TV_HIGH == stateParam;
   \                     ??addEvent_19:
   \   00000200   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000202   0x2D01             CMP      R5,#+1
   \   00000204   0xD101             BNE.N    ??addEvent_22
   \   00000206   0x2001             MOVS     R0,#+1
   \   00000208   0xE000             B.N      ??addEvent_23
   \                     ??addEvent_22:
   \   0000020A   0x2000             MOVS     R0,#+0
   \                     ??addEvent_23:
   \   0000020C   0xEB18 0x0104      ADDS     R1,R8,R4
   \   00000210   0xF881 0x0F7C      STRB     R0,[R1, #+3964]
    316          
    317          	if (index != size) {
   \   00000214   0xF241 0x406C      MOVW     R0,#+5228
   \   00000218   0x5900             LDR      R0,[R0, R4]
   \   0000021A   0x4580             CMP      R8,R0
   \   0000021C   0xD003             BEQ.N    ??addEvent_24
    318          		firmwareError("are we ever here?");
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable7_19
   \   00000222   0x.... 0x....      BL       firmwareError
    319          	}
    320          
    321          //	int index = size;
    322          	size++;
   \                     ??addEvent_24:
   \   00000226   0xF241 0x406C      MOVW     R0,#+5228
   \   0000022A   0x5900             LDR      R0,[R0, R4]
   \   0000022C   0x1C40             ADDS     R0,R0,#+1
   \   0000022E   0xF241 0x416C      MOVW     R1,#+5228
   \   00000232   0x5108             STR      R0,[R1, R4]
    323          
    324          	for (int i = 0; i < PWM_PHASE_MAX_WAVE_PER_PWM; i++) {
   \   00000234   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??addEvent_25:
   \   00000238   0xF1B9 0x0F03      CMP      R9,#+3
   \   0000023C   0xDA0F             BGE.N    ??addEvent_26
    325          		wave.waves[i].pinStates[index] = wave.getChannelState(i, index - 1);
   \   0000023E   0xF8D4 0x0B78      LDR      R0,[R4, #+2936]
   \   00000242   0xF850 0xA029      LDR      R10,[R0, R9, LSL #+2]
   \   00000246   0xF1B8 0x0201      SUBS     R2,R8,#+1
   \   0000024A   0x4649             MOV      R1,R9
   \   0000024C   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   00000250   0x.... 0x....      BL       _ZNK12multi_wave_s15getChannelStateEii
   \   00000254   0xF808 0x000A      STRB     R0,[R8, R10]
    326          	}
   \   00000258   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000025C   0xE7EC             B.N      ??addEvent_25
    327          	wave.setSwitchTime(index, angle);
   \                     ??addEvent_26:
   \   0000025E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000262   0x4641             MOV      R1,R8
   \   00000264   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   00000268   0x.... 0x....      BL       _ZN12multi_wave_s13setSwitchTimeEif
    328          	wave.waves[waveIndex].pinStates[index] = state;
   \   0000026C   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000270   0xF8D4 0x1B78      LDR      R1,[R4, #+2936]
   \   00000274   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000278   0xF808 0x6000      STRB     R6,[R8, R0]
    329          }
   \                     ??addEvent_2:
   \   0000027C   0xB002             ADD      SP,SP,#+8
   \   0000027E   0xECBD 0x8B02      VPOP     {D8}
   \   00000282   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    330          

   \                                 In section .text, align 2, keep-with-next
    331          int TriggerShape::getCycleDuration() const {
    332          	return (operationMode == FOUR_STROKE_CAM_SENSOR) ? 720 : 360;
   \                     _ZNK12TriggerShape16getCycleDurationEv:
   \   00000000   0xF641 0x3168      MOVW     R1,#+7016
   \   00000004   0x5808             LDR      R0,[R1, R0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD102             BNE.N    ??getCycleDuration_0
   \   0000000A   0xF44F 0x7034      MOV      R0,#+720
   \   0000000E   0xE001             B.N      ??getCycleDuration_1
   \                     ??getCycleDuration_0:
   \   00000010   0xF44F 0x70B4      MOV      R0,#+360
   \                     ??getCycleDuration_1:
   \   00000014   0x4770             BX       LR               ;; return
    333          }
    334          

   \                                 In section .text, align 2, keep-with-next
    335          float TriggerShape::getSwitchAngle(int index) const {
   \                     _ZNK12TriggerShape14getSwitchAngleEi:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    336          	return getCycleDuration() * wave.getSwitchTime(index);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZNK12TriggerShape16getCycleDurationEv
   \   00000010   0xEE00 0x0A10      VMOV     S0,R0
   \   00000014   0xEEB8 0x8AC0      VCVT.F32.S32 S16,S0
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0xF604 0x3074      ADDW     R0,R4,#+2932
   \   0000001E   0x.... 0x....      BL       _ZNK12multi_wave_s13getSwitchTimeEi
   \   00000022   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   00000026   0xECBD 0x8B02      VPOP     {D8}
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    337          }
    338          

   \                                 In section .text, align 2, keep-with-next
    339          void multi_wave_s::checkSwitchTimes(int size) {
   \                     _ZN12multi_wave_s16checkSwitchTimesEi:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    340          	checkSwitchTimes2(size, switchTimes);
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       _Z17checkSwitchTimes2iPf
    341          }
   \   0000000E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    342          

   \                                 In section .text, align 4, keep-with-next
    343          void setVwConfiguration(TriggerShape *s) {
   \                     _Z18setVwConfigurationP12TriggerShape:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0x0004             MOVS     R4,R0
    344          	efiAssertVoid(s != NULL, "TriggerShape is NULL");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??setVwConfiguration_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7_20
   \   00000010   0x.... 0x....      BL       firmwareError
   \   00000014   0xE05C             B.N      ??setVwConfiguration_1
    345          	operation_mode_e operationMode = FOUR_STROKE_CRANK_SENSOR;
   \                     ??setVwConfiguration_0:
   \   00000016   0x2501             MOVS     R5,#+1
    346          
    347          	s->useRiseEdge = true;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF884 0x0B64      STRB     R0,[R4, #+2916]
    348          
    349          	initializeSkippedToothTriggerShapeExt(s, 60, 2,
    350          			operationMode);
   \   0000001E   0x002B             MOVS     R3,R5
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x213C             MOVS     R1,#+60
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       _Z37initializeSkippedToothTriggerShapeExtP12TriggerShapeii16operation_mode_e
    351          
    352          	s->isSynchronizationNeeded = true;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7020             STRB     R0,[R4, #+0]
    353          
    354          	s->reset(operationMode, false);
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       _ZN12TriggerShape5resetE16operation_mode_eb
    355          
    356          	int totalTeethCount = 60;
   \   00000038   0x263C             MOVS     R6,#+60
    357          	int skippedCount = 2;
   \   0000003A   0x2702             MOVS     R7,#+2
    358          
    359          	float engineCycle = getEngineCycle(operationMode);
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       _Z14getEngineCycle16operation_mode_e
   \   00000042   0xEEB0 0x8A40      VMOV.F32 S16,S0
    360          	float toothWidth = 0.5;
   \   00000046   0xEEF6 0x8A00      VMOV.F32 S17,#0.5
    361          
    362          	addSkippedToothTriggerEvents(T_PRIMARY, s, 60, 2, toothWidth, 0, engineCycle,
    363          			NO_LEFT_FILTER, 690);
   \   0000004A   0xED9F 0x....      VLDR.W   S4,??DataTable5  ;; 0x442c8000
   \   0000004E   0xEEFF 0x1A00      VMOV.F32 S3,#-1.0
   \   00000052   0xEEB0 0x1A48      VMOV.F32 S2,S16
   \   00000056   0xEDDF 0x....      VLDR.W   S1,??DataTable5_1  ;; 0x0
   \   0000005A   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000005E   0x2302             MOVS     R3,#+2
   \   00000060   0x223C             MOVS     R2,#+60
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x.... 0x....      BL       _Z28addSkippedToothTriggerEvents15trigger_wheel_eP12TriggerShapeiifffff
    364          
    365          	float angleDown = engineCycle / totalTeethCount * (totalTeethCount - skippedCount - 1 + (1 - toothWidth) );
   \   0000006A   0xEE00 0x6A10      VMOV     S0,R6
   \   0000006E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000072   0xEE88 0x0A00      VDIV.F32 S0,S16,S0
   \   00000076   0x1BF0             SUBS     R0,R6,R7
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0xEE00 0x0A90      VMOV     S1,R0
   \   0000007E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000082   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   00000086   0xEE31 0x1A68      VSUB.F32 S2,S2,S17
   \   0000008A   0xEE70 0x0A81      VADD.F32 S1,S1,S2
   \   0000008E   0xEE20 0x9A20      VMUL.F32 S18,S0,S1
    366          	s->addEvent(0 + angleDown + 12, T_PRIMARY, TV_HIGH, NO_LEFT_FILTER, NO_RIGHT_FILTER);
   \   00000092   0xED9F 0x....      VLDR.W   S2,??DataTable5_2  ;; 0x447a0000
   \   00000096   0xEEFF 0x0A00      VMOV.F32 S1,#-1.0
   \   0000009A   0x2201             MOVS     R2,#+1
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xEEB2 0x0A08      VMOV.F32 S0,#12.0
   \   000000A2   0xEE39 0x0A00      VADD.F32 S0,S18,S0
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_eff
    367          	s->addEvent(0 + engineCycle, T_PRIMARY, TV_LOW, NO_LEFT_FILTER, NO_RIGHT_FILTER);
   \   000000AC   0xED9F 0x....      VLDR.W   S2,??DataTable5_2  ;; 0x447a0000
   \   000000B0   0xEEFF 0x0A00      VMOV.F32 S1,#-1.0
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_eff
    368          
    369          	s->setTriggerSynchronizationGap2(1.6, 4);
   \   000000C2   0xEEF1 0x0A00      VMOV.F32 S1,#4.0
   \   000000C6   0xED9F 0x....      VLDR.W   S0,??DataTable6  ;; 0x3fcccccd
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       _ZN12TriggerShape29setTriggerSynchronizationGap2Eff
    370          }
   \                     ??setVwConfiguration_1:
   \   000000D0   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000000D4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    371          

   \                                 In section .text, align 2, keep-with-next
    372          void setToothedWheelConfiguration(TriggerShape *s, int total, int skipped,
    373          		operation_mode_e operationMode) {
   \                     _Z28setToothedWheelConfigurationP12TriggerShapeii16operation_mode_e:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    374          #if EFI_ENGINE_CONTROL
    375          
    376          	s->useRiseEdge = true;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xF884 0x0B64      STRB     R0,[R4, #+2916]
    377          
    378          	initializeSkippedToothTriggerShapeExt(s, total, skipped,
    379          			operationMode);
   \   00000010   0x003B             MOVS     R3,R7
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _Z37initializeSkippedToothTriggerShapeExtP12TriggerShapeii16operation_mode_e
    380          #endif
    381          }
   \   0000001C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    382          

   \                                 In section .text, align 2, keep-with-next
    383          void TriggerShape::setTriggerSynchronizationGap2(float syncRatioFrom, float syncRatioTo) {
    384          	isSynchronizationNeeded = true;
   \                     _ZN12TriggerShape29setTriggerSynchronizationGap2Eff:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    385          	this->syncRatioFrom = syncRatioFrom;
   \   00000004   0xF600 0x3158      ADDW     R1,R0,#+2904
   \   00000008   0xED81 0x0A00      VSTR     S0,[R1, #0]
    386          	this->syncRatioTo = syncRatioTo;
   \   0000000C   0xF600 0x315C      ADDW     R1,R0,#+2908
   \   00000010   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
    387          }
   \   00000014   0x4770             BX       LR               ;; return
    388          

   \                                 In section .text, align 2, keep-with-next
    389          void TriggerShape::setTriggerSynchronizationGap(float synchRatio) {
   \                     _ZN12TriggerShape28setTriggerSynchronizationGapEf:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
    390          	setTriggerSynchronizationGap2(synchRatio * 0.75f, synchRatio * 1.25f);
   \   0000000C   0xEEB7 0x0A04      VMOV.F32 S0,#1.25
   \   00000010   0xEE68 0x0A00      VMUL.F32 S1,S16,S0
   \   00000014   0xEEB6 0x0A08      VMOV.F32 S0,#0.75
   \   00000018   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN12TriggerShape29setTriggerSynchronizationGap2Eff
    391          }
   \   00000022   0xECBD 0x8B02      VPOP     {D8}
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    392          
    393          #define S24 (720.0f / 24 / 2)
    394          

   \                                 In section .text, align 2, keep-with-next
    395          static float addAccordPair(TriggerShape *s, float sb, trigger_wheel_e const waveIndex) {
   \                     _Z13addAccordPairP12TriggerShapef15trigger_wheel_e:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0x000D             MOVS     R5,R1
    396          	s->addEvent(sb, waveIndex, TV_HIGH);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    397          	sb += S24;
   \   0000001E   0xEEB2 0x0A0E      VMOV.F32 S0,#15.0
   \   00000022   0xEE38 0x8A00      VADD.F32 S16,S16,S0
    398          	s->addEvent(sb, waveIndex, TV_LOW);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    399          	sb += S24;
   \   00000036   0xEEB2 0x0A0E      VMOV.F32 S0,#15.0
   \   0000003A   0xEE38 0x8A00      VADD.F32 S16,S16,S0
    400          
    401          	return sb;
   \   0000003E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000042   0xECBD 0x8B02      VPOP     {D8}
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    402          }
    403          
    404          #define DIP 7.5f

   \                                 In section .text, align 2, keep-with-next
    405          static float addAccordPair3(TriggerShape *s, float sb) {
   \                     _Z14addAccordPair3P12TriggerShapef:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
    406          	sb += DIP;
   \   0000000C   0xEEB1 0x0A0E      VMOV.F32 S0,#7.5
   \   00000010   0xEE38 0x8A00      VADD.F32 S16,S16,S0
    407          	s->addEvent(sb, T_CHANNEL_3, TV_HIGH);
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    408          	sb += DIP;
   \   00000022   0xEEB1 0x0A0E      VMOV.F32 S0,#7.5
   \   00000026   0xEE38 0x8A00      VADD.F32 S16,S16,S0
    409          	s->addEvent(sb, T_CHANNEL_3, TV_LOW);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2102             MOVS     R1,#+2
   \   0000002E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    410          	sb += 2 * DIP;
   \   00000038   0xEEB2 0x0A0E      VMOV.F32 S0,#15.0
   \   0000003C   0xEE38 0x8A00      VADD.F32 S16,S16,S0
    411          	return sb;
   \   00000040   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000044   0xECBD 0x8B02      VPOP     {D8}
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    412          }
    413          
    414          /**
    415           * Thank you Dip!
    416           * http://forum.pgmfi.org/viewtopic.php?f=2&t=15570start=210#p139007
    417           */

   \                                 In section .text, align 4, keep-with-next
    418          void configureHondaAccordCDDip(TriggerShape *s) {
   \                     _Z25configureHondaAccordCDDipP12TriggerShape:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
    419          	s->reset(FOUR_STROKE_CAM_SENSOR, true);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       _ZN12TriggerShape5resetE16operation_mode_eb
    420          
    421          	s->initialState[T_SECONDARY] = TV_HIGH;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF8C4 0x0B84      STR      R0,[R4, #+2948]
    422          	float sb = 0;
   \   00000018   0xED9F 0x....      VLDR.W   S16,??DataTable6_1  ;; 0x0
    423          	sb = addAccordPair3(s, sb);
   \   0000001C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000026   0xEEB0 0x8A40      VMOV.F32 S16,S0
    424          	sb = addAccordPair3(s, sb);
   \   0000002A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000034   0xEEB0 0x8A40      VMOV.F32 S16,S0
    425          	sb = addAccordPair3(s, sb);
   \   00000038   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000042   0xEEB0 0x8A40      VMOV.F32 S16,S0
    426          
    427          	s->addEvent(90, T_SECONDARY, TV_LOW);
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xED9F 0x....      VLDR.W   S0,??DataTable6_2  ;; 0x42b40000
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    428          	sb = 90;
   \   00000054   0xED9F 0x....      VLDR.W   S0,??DataTable6_2  ;; 0x42b40000
   \   00000058   0xEEB0 0x8A40      VMOV.F32 S16,S0
    429          	sb = addAccordPair3(s, sb);
   \   0000005C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000066   0xEEB0 0x8A40      VMOV.F32 S16,S0
    430          	sb = addAccordPair3(s, sb);
   \   0000006A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000074   0xEEB0 0x8A40      VMOV.F32 S16,S0
    431          	sb = addAccordPair3(s, sb);
   \   00000078   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000082   0xEEB0 0x8A40      VMOV.F32 S16,S0
    432          
    433          	s->addEvent(180, T_SECONDARY, TV_HIGH);
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0xED9F 0x....      VLDR.W   S0,??DataTable6_3  ;; 0x43340000
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    434          	sb = 180;
   \   00000094   0xED9F 0x....      VLDR.W   S0,??DataTable6_3  ;; 0x43340000
   \   00000098   0xEEB0 0x8A40      VMOV.F32 S16,S0
    435          	sb = addAccordPair3(s, sb);
   \   0000009C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000000A6   0xEEB0 0x8A40      VMOV.F32 S16,S0
    436          	sb = addAccordPair3(s, sb);
   \   000000AA   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000000B4   0xEEB0 0x8A40      VMOV.F32 S16,S0
    437          	sb = addAccordPair3(s, sb);
   \   000000B8   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000000C2   0xEEB0 0x8A40      VMOV.F32 S16,S0
    438          
    439          	s->addEvent(270, T_SECONDARY, TV_LOW);
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x2101             MOVS     R1,#+1
   \   000000CA   0xED9F 0x....      VLDR.W   S0,??DataTable6_4  ;; 0x43870000
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    440          	sb = 270;
   \   000000D4   0xED9F 0x....      VLDR.W   S0,??DataTable6_4  ;; 0x43870000
   \   000000D8   0xEEB0 0x8A40      VMOV.F32 S16,S0
    441          	sb = addAccordPair3(s, sb);
   \   000000DC   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000000E6   0xEEB0 0x8A40      VMOV.F32 S16,S0
    442          	sb = addAccordPair3(s, sb);
   \   000000EA   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000000F4   0xEEB0 0x8A40      VMOV.F32 S16,S0
    443          	sb = addAccordPair3(s, sb);
   \   000000F8   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000102   0xEEB0 0x8A40      VMOV.F32 S16,S0
    444          
    445          
    446          	s->addEvent(360.0f - DIP, T_PRIMARY, TV_HIGH);
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0xED9F 0x....      VLDR.W   S0,??DataTable6_5  ;; 0x43b04000
   \   0000010E   0x0020             MOVS     R0,R4
   \   00000110   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    447          	s->addEvent(360, T_SECONDARY, TV_HIGH);
   \   00000114   0x2201             MOVS     R2,#+1
   \   00000116   0x2101             MOVS     R1,#+1
   \   00000118   0xED9F 0x....      VLDR.W   S0,??DataTable6_6  ;; 0x43b40000
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    448          	sb = 360;
   \   00000122   0xED9F 0x....      VLDR.W   S0,??DataTable6_6  ;; 0x43b40000
   \   00000126   0xEEB0 0x8A40      VMOV.F32 S16,S0
    449          	sb = addAccordPair3(s, sb);
   \   0000012A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000012E   0x0020             MOVS     R0,R4
   \   00000130   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000134   0xEEB0 0x8A40      VMOV.F32 S16,S0
    450          	sb = addAccordPair3(s, sb);
   \   00000138   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000142   0xEEB0 0x8A40      VMOV.F32 S16,S0
    451          	sb = addAccordPair3(s, sb);
   \   00000146   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000014A   0x0020             MOVS     R0,R4
   \   0000014C   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000150   0xEEB0 0x8A40      VMOV.F32 S16,S0
    452          
    453          	s->addEvent(450, T_SECONDARY, TV_LOW);
   \   00000154   0x2200             MOVS     R2,#+0
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0xED9F 0x....      VLDR.W   S0,??DataTable7  ;; 0x43e10000
   \   0000015C   0x0020             MOVS     R0,R4
   \   0000015E   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    454          	sb = 450;
   \   00000162   0xED9F 0x....      VLDR.W   S0,??DataTable7  ;; 0x43e10000
   \   00000166   0xEEB0 0x8A40      VMOV.F32 S16,S0
    455          	sb = addAccordPair3(s, sb);
   \   0000016A   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000016E   0x0020             MOVS     R0,R4
   \   00000170   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000174   0xEEB0 0x8A40      VMOV.F32 S16,S0
    456          	sb = addAccordPair3(s, sb);
   \   00000178   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000017C   0x0020             MOVS     R0,R4
   \   0000017E   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000182   0xEEB0 0x8A40      VMOV.F32 S16,S0
    457          	sb = addAccordPair3(s, sb);
   \   00000186   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000018A   0x0020             MOVS     R0,R4
   \   0000018C   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000190   0xEEB0 0x8A40      VMOV.F32 S16,S0
    458          
    459          	s->addEvent(540, T_SECONDARY, TV_HIGH);
   \   00000194   0x2201             MOVS     R2,#+1
   \   00000196   0x2101             MOVS     R1,#+1
   \   00000198   0xED9F 0x....      VLDR.W   S0,??DataTable7_2  ;; 0x44070000
   \   0000019C   0x0020             MOVS     R0,R4
   \   0000019E   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    460          	sb = 540;
   \   000001A2   0xED9F 0x....      VLDR.W   S0,??DataTable7_2  ;; 0x44070000
   \   000001A6   0xEEB0 0x8A40      VMOV.F32 S16,S0
    461          	sb = addAccordPair3(s, sb);
   \   000001AA   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001AE   0x0020             MOVS     R0,R4
   \   000001B0   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000001B4   0xEEB0 0x8A40      VMOV.F32 S16,S0
    462          	sb = addAccordPair3(s, sb);
   \   000001B8   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001BC   0x0020             MOVS     R0,R4
   \   000001BE   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000001C2   0xEEB0 0x8A40      VMOV.F32 S16,S0
    463          	sb = addAccordPair3(s, sb);
   \   000001C6   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001CA   0x0020             MOVS     R0,R4
   \   000001CC   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000001D0   0xEEB0 0x8A40      VMOV.F32 S16,S0
    464          
    465          	s->addEvent(630, T_SECONDARY, TV_LOW);
   \   000001D4   0x2200             MOVS     R2,#+0
   \   000001D6   0x2101             MOVS     R1,#+1
   \   000001D8   0xED9F 0x....      VLDR.W   S0,??DataTable7_3  ;; 0x441d8000
   \   000001DC   0x0020             MOVS     R0,R4
   \   000001DE   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    466          	sb = 630;
   \   000001E2   0xED9F 0x....      VLDR.W   S0,??DataTable7_3  ;; 0x441d8000
   \   000001E6   0xEEB0 0x8A40      VMOV.F32 S16,S0
    467          	sb = addAccordPair3(s, sb);
   \   000001EA   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001EE   0x0020             MOVS     R0,R4
   \   000001F0   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   000001F4   0xEEB0 0x8A40      VMOV.F32 S16,S0
    468          	sb = addAccordPair3(s, sb);
   \   000001F8   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000001FC   0x0020             MOVS     R0,R4
   \   000001FE   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000202   0xEEB0 0x8A40      VMOV.F32 S16,S0
    469          	sb = addAccordPair3(s, sb);
   \   00000206   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000020A   0x0020             MOVS     R0,R4
   \   0000020C   0x.... 0x....      BL       _Z14addAccordPair3P12TriggerShapef
   \   00000210   0xEEB0 0x8A40      VMOV.F32 S16,S0
    470          
    471          	s->addEvent(720.0f - DIP, T_PRIMARY, TV_LOW);
   \   00000214   0x2200             MOVS     R2,#+0
   \   00000216   0x2100             MOVS     R1,#+0
   \   00000218   0xED9F 0x....      VLDR.W   S0,??DataTable7_4  ;; 0x44322000
   \   0000021C   0x0020             MOVS     R0,R4
   \   0000021E   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    472          
    473          //	s->addEvent(720.0f - 12 * sb, T_SECONDARY, TV_LOW);
    474          //	s->addEvent(720.0f, T_SECONDARY, TV_LOW);
    475          
    476          	s->addEvent(720.0f, T_SECONDARY, TV_HIGH);
   \   00000222   0x2201             MOVS     R2,#+1
   \   00000224   0x2101             MOVS     R1,#+1
   \   00000226   0xED9F 0x....      VLDR.W   S0,??DataTable7_5  ;; 0x44340000
   \   0000022A   0x0020             MOVS     R0,R4
   \   0000022C   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    477          
    478          	s->isSynchronizationNeeded = false;
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0x7020             STRB     R0,[R4, #+0]
    479          }
   \   00000234   0xECBD 0x8B02      VPOP     {D8}
   \   00000238   0xBD10             POP      {R4,PC}          ;; return
    480          

   \                                 In section .text, align 4, keep-with-next
    481          void configureHondaAccordCD(TriggerShape *s, bool withOneEventSignal, bool withFourEventSignal,
    482          		trigger_wheel_e const oneEventWave,
    483          		trigger_wheel_e const fourEventWave,
    484          		float prefix) {
   \                     _Z22configureHondaAccordCDP12TriggerShapebb15trigger_wheel_eS1_f:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000008   0x0005             MOVS     R5,R0
   \   0000000A   0x000E             MOVS     R6,R1
   \   0000000C   0x0017             MOVS     R7,R2
   \   0000000E   0x4698             MOV      R8,R3
   \   00000010   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000014   0x9C0C             LDR      R4,[SP, #+48]
    485          	s->reset(FOUR_STROKE_CAM_SENSOR, true);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       _ZN12TriggerShape5resetE16operation_mode_eb
    486          
    487          //	trigger_wheel_e const oneEventWave = T_CHANNEL_3;
    488          //	bool withFourEventSignal = true;
    489          //	trigger_wheel_e const fourEventWave = T_PRIMARY;
    490          
    491          	float sb = 5.0f + prefix;
   \   00000020   0xEEB1 0x0A04      VMOV.F32 S0,#5.0
   \   00000024   0xEE78 0x8A00      VADD.F32 S17,S16,S0
    492          
    493          	float tdcWidth = 0.1854 * 720 / 4;
   \   00000028   0xED9F 0x....      VLDR.W   S18,??DataTable7_7  ;; 0x42057cee
    494          
    495          	s->isSynchronizationNeeded = false;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7028             STRB     R0,[R5, #+0]
    496          
    497          	sb = addAccordPair(s, sb, T_SECONDARY);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   0000003C   0xEEF0 0x8A40      VMOV.F32 S17,S0
    498          
    499          	if (withOneEventSignal)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD009             BEQ.N    ??configureHondaAccordCD_0
    500          		s->addEvent(sb - S24 / 2, oneEventWave, TV_HIGH);
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x4641             MOV      R1,R8
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0xEEB9 0x0A0E      VMOV.F32 S0,#-7.5
   \   00000050   0xEE38 0x0A80      VADD.F32 S0,S17,S0
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    501          
    502          	sb = addAccordPair(s, sb, T_SECONDARY);
   \                     ??configureHondaAccordCD_0:
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000066   0xEEF0 0x8A40      VMOV.F32 S17,S0
    503          	sb = addAccordPair(s, sb, T_SECONDARY);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000076   0xEEF0 0x8A40      VMOV.F32 S17,S0
    504          	if (withOneEventSignal)
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD009             BEQ.N    ??configureHondaAccordCD_1
    505          		s->addEvent(sb - S24 / 2, oneEventWave, TV_LOW);
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x4641             MOV      R1,R8
   \   00000084   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000086   0xEEB9 0x0A0E      VMOV.F32 S0,#-7.5
   \   0000008A   0xEE38 0x0A80      VADD.F32 S0,S17,S0
   \   0000008E   0x0028             MOVS     R0,R5
   \   00000090   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    506          	sb = addAccordPair(s, sb, T_SECONDARY);
   \                     ??configureHondaAccordCD_1:
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000000A0   0xEEF0 0x8A40      VMOV.F32 S17,S0
    507          	sb = addAccordPair(s, sb, T_SECONDARY);
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000000B0   0xEEF0 0x8A40      VMOV.F32 S17,S0
    508          	if (withFourEventSignal) {
   \   000000B4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B6   0x2F00             CMP      R7,#+0
   \   000000B8   0xD00B             BEQ.N    ??configureHondaAccordCD_2
    509          		s->addEvent(1 * 180.0f + prefix - tdcWidth, fourEventWave, TV_HIGH);
   \   000000BA   0x2201             MOVS     R2,#+1
   \   000000BC   0x0021             MOVS     R1,R4
   \   000000BE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C0   0xED9F 0x....      VLDR.W   S0,??DataTable7_10  ;; 0x43340000
   \   000000C4   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   000000C8   0xEE30 0x0A49      VSUB.F32 S0,S0,S18
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    510          	}
    511          	sb = addAccordPair(s, sb, T_SECONDARY);
   \                     ??configureHondaAccordCD_2:
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000000D8   0x0028             MOVS     R0,R5
   \   000000DA   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000000DE   0xEEF0 0x8A40      VMOV.F32 S17,S0
    512          	if (withFourEventSignal) {
   \   000000E2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E4   0x2F00             CMP      R7,#+0
   \   000000E6   0xD009             BEQ.N    ??configureHondaAccordCD_3
    513          		s->addEvent(1 * 180.0f + prefix, fourEventWave, TV_LOW);
   \   000000E8   0x2200             MOVS     R2,#+0
   \   000000EA   0x0021             MOVS     R1,R4
   \   000000EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EE   0xED9F 0x....      VLDR.W   S0,??DataTable7_10  ;; 0x43340000
   \   000000F2   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   000000F6   0x0028             MOVS     R0,R5
   \   000000F8   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    514          	}
    515          
    516          	sb = addAccordPair(s, sb, T_SECONDARY);
   \                     ??configureHondaAccordCD_3:
   \   000000FC   0x2101             MOVS     R1,#+1
   \   000000FE   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000102   0x0028             MOVS     R0,R5
   \   00000104   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000108   0xEEF0 0x8A40      VMOV.F32 S17,S0
    517          	sb = addAccordPair(s, sb,T_SECONDARY);
   \   0000010C   0x2101             MOVS     R1,#+1
   \   0000010E   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000112   0x0028             MOVS     R0,R5
   \   00000114   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000118   0xEEF0 0x8A40      VMOV.F32 S17,S0
    518          	sb = addAccordPair(s, sb, T_SECONDARY);
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000122   0x0028             MOVS     R0,R5
   \   00000124   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000128   0xEEF0 0x8A40      VMOV.F32 S17,S0
    519          	sb = addAccordPair(s, sb, T_SECONDARY);
   \   0000012C   0x2101             MOVS     R1,#+1
   \   0000012E   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000132   0x0028             MOVS     R0,R5
   \   00000134   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000138   0xEEF0 0x8A40      VMOV.F32 S17,S0
    520          	sb = addAccordPair(s, sb, T_SECONDARY);
   \   0000013C   0x2101             MOVS     R1,#+1
   \   0000013E   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000142   0x0028             MOVS     R0,R5
   \   00000144   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000148   0xEEF0 0x8A40      VMOV.F32 S17,S0
    521          
    522          	if (withFourEventSignal) {
   \   0000014C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000014E   0x2F00             CMP      R7,#+0
   \   00000150   0xD00B             BEQ.N    ??configureHondaAccordCD_4
    523          		s->addEvent(2 * 180.0f + prefix - tdcWidth, fourEventWave, TV_HIGH);
   \   00000152   0x2201             MOVS     R2,#+1
   \   00000154   0x0021             MOVS     R1,R4
   \   00000156   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000158   0xED9F 0x....      VLDR.W   S0,??DataTable7_12  ;; 0x43b40000
   \   0000015C   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   00000160   0xEE30 0x0A49      VSUB.F32 S0,S0,S18
   \   00000164   0x0028             MOVS     R0,R5
   \   00000166   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    524          	}
    525          	sb = addAccordPair(s, sb, T_SECONDARY);
   \                     ??configureHondaAccordCD_4:
   \   0000016A   0x2101             MOVS     R1,#+1
   \   0000016C   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000170   0x0028             MOVS     R0,R5
   \   00000172   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000176   0xEEF0 0x8A40      VMOV.F32 S17,S0
    526          	if (withFourEventSignal) {
   \   0000017A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000017C   0x2F00             CMP      R7,#+0
   \   0000017E   0xD009             BEQ.N    ??configureHondaAccordCD_5
    527          		s->addEvent(2 * 180.0f + prefix, fourEventWave, TV_LOW);
   \   00000180   0x2200             MOVS     R2,#+0
   \   00000182   0x0021             MOVS     R1,R4
   \   00000184   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000186   0xED9F 0x....      VLDR.W   S0,??DataTable7_12  ;; 0x43b40000
   \   0000018A   0xEE38 0x0A00      VADD.F32 S0,S16,S0
   \   0000018E   0x0028             MOVS     R0,R5
   \   00000190   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    528          	}
    529          
    530          	for (int i = 3; i <= 4; i++) {
   \                     ??configureHondaAccordCD_5:
   \   00000194   0xF05F 0x0903      MOVS     R9,#+3
   \                     ??configureHondaAccordCD_6:
   \   00000198   0xF1B9 0x0F05      CMP      R9,#+5
   \   0000019C   0xDA5A             BGE.N    ??configureHondaAccordCD_7
    531          		sb = addAccordPair(s, sb, T_SECONDARY);
   \   0000019E   0x2101             MOVS     R1,#+1
   \   000001A0   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001A4   0x0028             MOVS     R0,R5
   \   000001A6   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000001AA   0xEEF0 0x8A40      VMOV.F32 S17,S0
    532          		sb = addAccordPair(s, sb, T_SECONDARY);
   \   000001AE   0x2101             MOVS     R1,#+1
   \   000001B0   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001B4   0x0028             MOVS     R0,R5
   \   000001B6   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000001BA   0xEEF0 0x8A40      VMOV.F32 S17,S0
    533          		sb = addAccordPair(s, sb, T_SECONDARY);
   \   000001BE   0x2101             MOVS     R1,#+1
   \   000001C0   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001C4   0x0028             MOVS     R0,R5
   \   000001C6   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000001CA   0xEEF0 0x8A40      VMOV.F32 S17,S0
    534          		sb = addAccordPair(s, sb, T_SECONDARY);
   \   000001CE   0x2101             MOVS     R1,#+1
   \   000001D0   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001D4   0x0028             MOVS     R0,R5
   \   000001D6   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000001DA   0xEEF0 0x8A40      VMOV.F32 S17,S0
    535          		sb = addAccordPair(s, sb, T_SECONDARY);
   \   000001DE   0x2101             MOVS     R1,#+1
   \   000001E0   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001E4   0x0028             MOVS     R0,R5
   \   000001E6   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   000001EA   0xEEF0 0x8A40      VMOV.F32 S17,S0
    536          
    537          		if (withFourEventSignal) {
   \   000001EE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001F0   0x2F00             CMP      R7,#+0
   \   000001F2   0xD011             BEQ.N    ??configureHondaAccordCD_8
    538          			s->addEvent(i * 180.0f + prefix - tdcWidth, fourEventWave, TV_HIGH);
   \   000001F4   0x2201             MOVS     R2,#+1
   \   000001F6   0x0021             MOVS     R1,R4
   \   000001F8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001FA   0xEE00 0x9A10      VMOV     S0,R9
   \   000001FE   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000202   0xEDDF 0x....      VLDR.W   S1,??DataTable7_10  ;; 0x43340000
   \   00000206   0xEEB0 0x1A48      VMOV.F32 S2,S16
   \   0000020A   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   0000020E   0xEE31 0x0A49      VSUB.F32 S0,S2,S18
   \   00000212   0x0028             MOVS     R0,R5
   \   00000214   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    539          		}
    540          		sb = addAccordPair(s, sb, T_SECONDARY);
   \                     ??configureHondaAccordCD_8:
   \   00000218   0x2101             MOVS     R1,#+1
   \   0000021A   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000021E   0x0028             MOVS     R0,R5
   \   00000220   0x.... 0x....      BL       _Z13addAccordPairP12TriggerShapef15trigger_wheel_e
   \   00000224   0xEEF0 0x8A40      VMOV.F32 S17,S0
    541          		if (withFourEventSignal) {
   \   00000228   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000022A   0x2F00             CMP      R7,#+0
   \   0000022C   0xD00F             BEQ.N    ??configureHondaAccordCD_9
    542          			s->addEvent(i * 180.0f + prefix, fourEventWave, TV_LOW);
   \   0000022E   0x2200             MOVS     R2,#+0
   \   00000230   0x0021             MOVS     R1,R4
   \   00000232   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000234   0xEE00 0x9A10      VMOV     S0,R9
   \   00000238   0xEEF8 0x0AC0      VCVT.F32.S32 S1,S0
   \   0000023C   0xED9F 0x....      VLDR.W   S2,??DataTable7_10  ;; 0x43340000
   \   00000240   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000244   0xEE00 0x0A81      VMLA.F32 S0,S1,S2
   \   00000248   0x0028             MOVS     R0,R5
   \   0000024A   0x.... 0x....      BL       _ZN12TriggerShape8addEventEf15trigger_wheel_e15trigger_value_e
    543          		}
    544          	}
   \                     ??configureHondaAccordCD_9:
   \   0000024E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000252   0xE7A1             B.N      ??configureHondaAccordCD_6
    545          }
   \                     ??configureHondaAccordCD_7:
   \   00000254   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000258   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x43B40000         DC32     0x43b40000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x442C8000         DC32     0x442c8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x3FCCCCCD         DC32     0x3fcccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x42B40000         DC32     0x42b40000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x43340000         DC32     0x43340000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x43870000         DC32     0x43870000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x43B04000         DC32     0x43b04000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x43B40000         DC32     0x43b40000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x43E10000         DC32     0x43e10000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     _ZN13single_wave_sC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x44070000         DC32     0x44070000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x441D8000         DC32     0x441d8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x44322000         DC32     0x44322000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x44340000         DC32     0x44340000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x42057CEE         DC32     0x42057cee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     persistentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x43340000         DC32     0x43340000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x........         DC32     `?<Constant "zero engineCycle">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x43B40000         DC32     0x43b40000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     `?<Constant "operationMode not set">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     `?<Constant "secondary needed or not?">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     `?<Constant "angle should be positive">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x........         DC32     `?<Constant "invalid angle order: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \   00000000   0x........         DC32     `?<Constant "wave pinStates is NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \   00000000   0x........         DC32     `?<Constant "same angle: not suppo...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_19:
   \   00000000   0x........         DC32     `?<Constant "are we ever here?">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_20:
   \   00000000   0x........         DC32     `?<Constant "TriggerShape is NULL">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "TriggerShape is NULL">`:
   \   00000000   0x54 0x72          DC8 "TriggerShape is NULL"
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x53    
   \              0x68 0x61    
   \              0x70 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "operationMode not set">`:
   \   00000000   0x6F 0x70          DC8 "operationMode not set"
   \              0x65 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x73 0x65    
   \              0x74 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "secondary needed or not?">`:
   \   00000000   0x73 0x65          DC8 "secondary needed or not?"
   \              0x63 0x6F    
   \              0x6E 0x64    
   \              0x61 0x72    
   \              0x79 0x20    
   \              0x6E 0x65    
   \              0x65 0x64    
   \              0x65 0x64    
   \              0x20 0x6F    
   \              0x72 0x20    
   \              0x6E 0x6F    
   \              0x74 0x3F    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "angle should be positive">`:
   \   00000000   0x61 0x6E          DC8 "angle should be positive"
   \              0x67 0x6C    
   \              0x65 0x20    
   \              0x73 0x68    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x62    
   \              0x65 0x20    
   \              0x70 0x6F    
   \              0x73 0x69    
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid angle order: ...">`:
   \   00000000   0x69 0x6E          DC8 "invalid angle order: %f and %f"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x61 0x6E    
   \              0x67 0x6C    
   \              0x65 0x20    
   \              0x6F 0x72    
   \              0x64 0x65    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x66 0x20    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x25 0x66    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "wave pinStates is NULL">`:
   \   00000000   0x77 0x61          DC8 "wave pinStates is NULL"
   \              0x76 0x65    
   \              0x20 0x70    
   \              0x69 0x6E    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x65 0x73    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "same angle: not suppo...">`:
   \   00000000   0x73 0x61          DC8 "same angle: not supported"
   \              0x6D 0x65    
   \              0x20 0x61    
   \              0x6E 0x67    
   \              0x6C 0x65    
   \              0x3A 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6F 0x72    
   \              0x74 0x65    
   \              0x64 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "are we ever here?">`:
   \   00000000   0x61 0x72          DC8 "are we ever here?"
   \              0x65 0x20    
   \              0x77 0x65    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x72 0x20    
   \              0x68 0x65    
   \              0x72 0x65    
   \              0x3F 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "zero engineCycle">`:
   \   00000000   0x7A 0x65          DC8 "zero engineCycle"
   \              0x72 0x6F    
   \              0x20 0x65    
   \              0x6E 0x67    
   \              0x69 0x6E    
   \              0x65 0x43    
   \              0x79 0x63    
   \              0x6C 0x65    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   TriggerShape::TriggerShape()
         8   -> TriggerShape::reset(operation_mode_e, bool)
         8   -> memset
         8   -> multi_wave_s::multi_wave_s(float *, single_wave_s *)
         8   -> trigger_shape_helper::trigger_shape_helper()
      56   TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
        56   -> __aeabi_f2d
        56   -> firmwareError
        56   -> getEngineCycle(operation_mode_e)
        56   -> multi_wave_s::findAngleMatch(float, int) const
        56   -> multi_wave_s::getChannelState(int, int) const
        56   -> multi_wave_s::getSwitchTime(int) const
        56   -> multi_wave_s::setSwitchTime(int, float)
        56   -> multi_wave_s::waveIndertionAngle(float, int) const
      32   TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e, float, float)
        32   -> TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
      40   TriggerShape::calculateTriggerSynchPoint()
        40   -> TriggerShape::getAngle(int) const
        40   -> TriggerShape::getLength() const
        40   -> findTriggerZeroEventIndex(TriggerShape *, trigger_config_s const *)
        40   -> firmwareError
       8   TriggerShape::clear()
         8   -> TriggerShape::setTriggerSynchronizationGap(float)
      16   TriggerShape::getAngle(int) const
        16   -> TriggerShape::getSwitchAngle(int) const
       0   TriggerShape::getCycleDuration() const
       8   TriggerShape::getLength() const
         8   -> TriggerShape::getSize() const
       0   TriggerShape::getOperationMode()
       0   TriggerShape::getSize() const
      24   TriggerShape::getSwitchAngle(int) const
        24   -> TriggerShape::getCycleDuration() const
        24   -> multi_wave_s::getSwitchTime(int) const
       0   TriggerShape::getTriggerShapeSynchPointIndex()
      16   TriggerShape::reset(operation_mode_e, bool)
        16   -> memset
        16   -> multi_wave_s::reset()
      16   TriggerShape::setTriggerSynchronizationGap(float)
        16   -> TriggerShape::setTriggerSynchronizationGap2(float, float)
       0   TriggerShape::setTriggerSynchronizationGap2(float, float)
       8   TriggerShape::subobject TriggerShape()
         8   -> TriggerShape::TriggerShape()
       8   TriggerState::TriggerState()
         8   -> TriggerState::clear()
         8   -> TriggerState::resetRunningCounters()
         8   -> memset
       8   TriggerState::clear()
         8   -> memset
       0   TriggerState::getCurrentIndex()
       0   TriggerState::getStartOfRevolutionIndex()
       0   TriggerState::getTotalEventCounter()
       0   TriggerState::getTotalRevolutionCounter()
       0   TriggerState::resetRunningCounters()
       8   TriggerState::subobject TriggerState()
         8   -> TriggerState::TriggerState()
      24   addAccordPair(TriggerShape *, float, trigger_wheel_e)
        24   -> TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
      16   addAccordPair3(TriggerShape *, float)
        16   -> TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
      48   configureHondaAccordCD(TriggerShape *, bool, bool, trigger_wheel_e, trigger_wheel_e, float)
        48   -> TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
        48   -> TriggerShape::reset(operation_mode_e, bool)
        48   -> addAccordPair(TriggerShape *, float, trigger_wheel_e)
      16   configureHondaAccordCDDip(TriggerShape *)
        16   -> TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
        16   -> TriggerShape::reset(operation_mode_e, bool)
        16   -> addAccordPair3(TriggerShape *, float)
      16   memset
        16   -> __aeabi_memset
      16   multi_wave_s::checkSwitchTimes(int)
        16   -> checkSwitchTimes2(int, float *)
      24   multi_wave_s::findAngleMatch(float, int) const
        24   -> isSameF
       0   multi_wave_s::getChannelState(int, int) const
       0   multi_wave_s::setSwitchTime(int, float)
       0   multi_wave_s::waveIndertionAngle(float, int) const
      24   setToothedWheelConfiguration(TriggerShape *, int, int, operation_mode_e)
        24   -> initializeSkippedToothTriggerShapeExt(TriggerShape *, int, int, operation_mode_e)
      40   setVwConfiguration(TriggerShape *)
        40   -> TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e, float, float)
        40   -> TriggerShape::reset(operation_mode_e, bool)
        40   -> TriggerShape::setTriggerSynchronizationGap2(float, float)
        40   -> addSkippedToothTriggerEvents(trigger_wheel_e, TriggerShape *, int, int, float, float, float, float, float)
        40   -> firmwareError
        40   -> getEngineCycle(operation_mode_e)
        40   -> initializeSkippedToothTriggerShapeExt(TriggerShape *, int, int, operation_mode_e)
       8   trigger_shape_helper::subobject trigger_shape_helper()
         8   -> trigger_shape_helper::trigger_shape_helper()
      16   trigger_shape_helper::trigger_shape_helper()
        16   -> __aeabi_vec_ctor_nocookie_nodtor
        16   -> memset
        16   -> single_wave_s::init(int8_t *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "TriggerShape is NULL">
      28  ?<Constant "angle should be positive">
      20  ?<Constant "are we ever here?">
      32  ?<Constant "invalid angle order: ...">
      24  ?<Constant "operationMode not set">
      28  ?<Constant "same angle: not suppo...">
      28  ?<Constant "secondary needed or not?">
      24  ?<Constant "wave pinStates is NULL">
      20  ?<Constant "zero engineCycle">
       4  ??DataTable2
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_19
       4  ??DataTable7_2
       4  ??DataTable7_20
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
     166  TriggerShape::TriggerShape()
     646  TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e)
      68  TriggerShape::addEvent(float, trigger_wheel_e, trigger_value_e, float, float)
     364  TriggerShape::calculateTriggerSynchPoint()
      42  TriggerShape::clear()
      64  TriggerShape::getAngle(int) const
      22  TriggerShape::getCycleDuration() const
      32  TriggerShape::getLength() const
       8  TriggerShape::getOperationMode()
       8  TriggerShape::getSize() const
      44  TriggerShape::getSwitchAngle(int) const
       8  TriggerShape::getTriggerShapeSynchPointIndex()
      90  TriggerShape::reset(operation_mode_e, bool)
      40  TriggerShape::setTriggerSynchronizationGap(float)
      22  TriggerShape::setTriggerSynchronizationGap2(float, float)
      12  TriggerShape::subobject TriggerShape()
     112  TriggerState::TriggerState()
      58  TriggerState::clear()
       4  TriggerState::getCurrentIndex()
      10  TriggerState::getStartOfRevolutionIndex()
      14  TriggerState::getTotalEventCounter()
       6  TriggerState::getTotalRevolutionCounter()
      14  TriggerState::resetRunningCounters()
      12  TriggerState::subobject TriggerState()
      72  addAccordPair(TriggerShape *, float, trigger_wheel_e)
      74  addAccordPair3(TriggerShape *, float)
     604  configureHondaAccordCD(TriggerShape *, bool, bool, trigger_wheel_e, trigger_wheel_e, float)
     570  configureHondaAccordCDDip(TriggerShape *)
      22  memset
      16  multi_wave_s::checkSwitchTimes(int)
      60  multi_wave_s::findAngleMatch(float, int) const
      10  multi_wave_s::getChannelState(int, int) const
      12  multi_wave_s::setSwitchTime(int, float)
      40  multi_wave_s::waveIndertionAngle(float, int) const
      30  setToothedWheelConfiguration(TriggerShape *, int, int, operation_mode_e)
     214  setVwConfiguration(TriggerShape *)
      12  trigger_shape_helper::subobject trigger_shape_helper()
      64  trigger_shape_helper::trigger_shape_helper()

 
   228 bytes in section .rodata
 3 798 bytes in section .text
 
 3 776 bytes of CODE  memory (+ 22 bytes shared)
   228 bytes of CONST memory

Errors: none
Warnings: 1
