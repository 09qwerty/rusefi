###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:57 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\mmc_spi.c                                          #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\mmc_spi.c -lCN F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\fir #
#                       mware\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\Debug\Obj\ --no_cse --no_unroll          #
#                       --no_inline --no_code_motion --no_tbaa                #
#                       --no_clustering --no_scheduling --debug               #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\m #
#                       mc_spi.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\mm #
#                       c_spi.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\mmc_spi.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          /*
     28             Parts of this file have been contributed by Matthias Blaicher.
     29           */
     30          
     31          /**
     32           * @file    mmc_spi.c
     33           * @brief   MMC over SPI driver code.
     34           *
     35           * @addtogroup MMC_SPI
     36           * @{
     37           */
     38          
     39          #include <string.h>
     40          
     41          #include "ch.h"
     42          #include "hal.h"
     43          
     44          #if HAL_USE_MMC_SPI || defined(__DOXYGEN__)
     45          
     46          /*===========================================================================*/
     47          /* Driver local definitions.                                                 */
     48          /*===========================================================================*/
     49          
     50          /*===========================================================================*/
     51          /* Driver exported variables.                                                */
     52          /*===========================================================================*/
     53          
     54          /*===========================================================================*/
     55          /* Driver local variables and types.                                         */
     56          /*===========================================================================*/
     57          
     58          /* Forward declarations required by mmc_vmt.*/
     59          static bool_t mmc_read(void *instance, uint32_t startblk,
     60                                 uint8_t *buffer, uint32_t n);
     61          static bool_t mmc_write(void *instance, uint32_t startblk,
     62                                  const uint8_t *buffer, uint32_t n);
     63          
     64          /**
     65           * @brief   Virtual methods table.
     66           */

   \                                 In section .rodata, align 4
     67          static const struct MMCDriverVMT mmc_vmt = {
   \                     mmc_vmt:
   \   00000000   0x........         DC32 mmc_lld_is_card_inserted, mmc_lld_is_write_protected, mmcConnect
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 mmcDisconnect, mmc_read, mmc_write, mmcSync, mmcGetInfo
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
     68            (bool_t (*)(void *))mmc_lld_is_card_inserted,
     69            (bool_t (*)(void *))mmc_lld_is_write_protected,
     70            (bool_t (*)(void *))mmcConnect,
     71            (bool_t (*)(void *))mmcDisconnect,
     72            mmc_read,
     73            mmc_write,
     74            (bool_t (*)(void *))mmcSync,
     75            (bool_t (*)(void *, BlockDeviceInfo *))mmcGetInfo
     76          };
     77          
     78          /**
     79           * @brief   Lookup table for CRC-7 ( based on polynomial x^7 + x^3 + 1).
     80           */

   \                                 In section .rodata, align 4
     81          static const uint8_t crc7_lookup_table[256] = {
   \                     crc7_lookup_table:
   \   00000000   0x00 0x09          DC8 0, 9, 18, 27, 36, 45, 54, 63, 72, 65, 90, 83, 108, 101, 126, 119
   \              0x12 0x1B    
   \              0x24 0x2D    
   \              0x36 0x3F    
   \              0x48 0x41    
   \              0x5A 0x53    
   \              0x6C 0x65    
   \              0x7E 0x77    
   \   00000010   0x19 0x10          DC8 25, 16, 11, 2, 61, 52, 47, 38, 81, 88, 67, 74, 117, 124, 103, 110
   \              0x0B 0x02    
   \              0x3D 0x34    
   \              0x2F 0x26    
   \              0x51 0x58    
   \              0x43 0x4A    
   \              0x75 0x7C    
   \              0x67 0x6E    
   \   00000020   0x32 0x3B          DC8 50, 59, 32, 41, 22, 31, 4, 13, 122, 115, 104, 97, 94, 87, 76, 69
   \              0x20 0x29    
   \              0x16 0x1F    
   \              0x04 0x0D    
   \              0x7A 0x73    
   \              0x68 0x61    
   \              0x5E 0x57    
   \              0x4C 0x45    
   \   00000030   0x2B 0x22          DC8 43, 34, 57, 48, 15, 6, 29, 20, 99, 106, 113, 120, 71, 78, 85, 92
   \              0x39 0x30    
   \              0x0F 0x06    
   \              0x1D 0x14    
   \              0x63 0x6A    
   \              0x71 0x78    
   \              0x47 0x4E    
   \              0x55 0x5C    
   \   00000040   0x64 0x6D          DC8 100, 109, 118, 127, 64, 73, 82, 91, 44, 37, 62, 55, 8, 1, 26, 19
   \              0x76 0x7F    
   \              0x40 0x49    
   \              0x52 0x5B    
   \              0x2C 0x25    
   \              0x3E 0x37    
   \              0x08 0x01    
   \              0x1A 0x13    
   \   00000050   0x7D 0x74          DC8 125, 116, 111, 102, 89, 80, 75, 66, 53, 60, 39, 46, 17, 24, 3, 10
   \              0x6F 0x66    
   \              0x59 0x50    
   \              0x4B 0x42    
   \              0x35 0x3C    
   \              0x27 0x2E    
   \              0x11 0x18    
   \              0x03 0x0A    
   \   00000060   0x56 0x5F          DC8 86, 95, 68, 77, 114, 123, 96, 105, 30, 23, 12, 5, 58, 51, 40, 33
   \              0x44 0x4D    
   \              0x72 0x7B    
   \              0x60 0x69    
   \              0x1E 0x17    
   \              0x0C 0x05    
   \              0x3A 0x33    
   \              0x28 0x21    
   \   00000070   0x4F 0x46          DC8 79, 70, 93, 84, 107, 98, 121, 112, 7, 14, 21, 28, 35, 42, 49, 56
   \              0x5D 0x54    
   \              0x6B 0x62    
   \              0x79 0x70    
   \              0x07 0x0E    
   \              0x15 0x1C    
   \              0x23 0x2A    
   \              0x31 0x38    
   \   00000080   0x41 0x48          DC8 65, 72, 83, 90, 101, 108, 119, 126, 9, 0, 27, 18, 45, 36, 63, 54
   \              0x53 0x5A    
   \              0x65 0x6C    
   \              0x77 0x7E    
   \              0x09 0x00    
   \              0x1B 0x12    
   \              0x2D 0x24    
   \              0x3F 0x36    
   \   00000090   0x58 0x51          DC8 88, 81, 74, 67, 124, 117, 110, 103, 16, 25, 2, 11, 52, 61, 38, 47
   \              0x4A 0x43    
   \              0x7C 0x75    
   \              0x6E 0x67    
   \              0x10 0x19    
   \              0x02 0x0B    
   \              0x34 0x3D    
   \              0x26 0x2F    
   \   000000A0   0x73 0x7A          DC8 115, 122, 97, 104, 87, 94, 69, 76, 59, 50, 41, 32, 31, 22, 13, 4
   \              0x61 0x68    
   \              0x57 0x5E    
   \              0x45 0x4C    
   \              0x3B 0x32    
   \              0x29 0x20    
   \              0x1F 0x16    
   \              0x0D 0x04    
   \   000000B0   0x6A 0x63          DC8 106, 99, 120, 113, 78, 71, 92, 85, 34, 43, 48, 57, 6, 15, 20, 29
   \              0x78 0x71    
   \              0x4E 0x47    
   \              0x5C 0x55    
   \              0x22 0x2B    
   \              0x30 0x39    
   \              0x06 0x0F    
   \              0x14 0x1D    
   \   000000C0   0x25 0x2C          DC8 37, 44, 55, 62, 1, 8, 19, 26, 109, 100, 127, 118, 73, 64, 91, 82
   \              0x37 0x3E    
   \              0x01 0x08    
   \              0x13 0x1A    
   \              0x6D 0x64    
   \              0x7F 0x76    
   \              0x49 0x40    
   \              0x5B 0x52    
   \   000000D0   0x3C 0x35          DC8 60, 53, 46, 39, 24, 17, 10, 3, 116, 125, 102, 111, 80, 89, 66, 75
   \              0x2E 0x27    
   \              0x18 0x11    
   \              0x0A 0x03    
   \              0x74 0x7D    
   \              0x66 0x6F    
   \              0x50 0x59    
   \              0x42 0x4B    
   \   000000E0   0x17 0x1E          DC8 23, 30, 5, 12, 51, 58, 33, 40, 95, 86, 77, 68, 123, 114, 105, 96
   \              0x05 0x0C    
   \              0x33 0x3A    
   \              0x21 0x28    
   \              0x5F 0x56    
   \              0x4D 0x44    
   \              0x7B 0x72    
   \              0x69 0x60    
   \   000000F0   0x0E 0x07          DC8 14, 7, 28, 21, 42, 35, 56, 49, 70, 79, 84, 93, 98, 107, 112, 121
   \              0x1C 0x15    
   \              0x2A 0x23    
   \              0x38 0x31    
   \              0x46 0x4F    
   \              0x54 0x5D    
   \              0x62 0x6B    
   \              0x70 0x79    
     82            0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53,
     83            0x6c, 0x65, 0x7e, 0x77, 0x19, 0x10, 0x0b, 0x02, 0x3d, 0x34, 0x2f, 0x26,
     84            0x51, 0x58, 0x43, 0x4a, 0x75, 0x7c, 0x67, 0x6e, 0x32, 0x3b, 0x20, 0x29,
     85            0x16, 0x1f, 0x04, 0x0d, 0x7a, 0x73, 0x68, 0x61, 0x5e, 0x57, 0x4c, 0x45,
     86            0x2b, 0x22, 0x39, 0x30, 0x0f, 0x06, 0x1d, 0x14, 0x63, 0x6a, 0x71, 0x78,
     87            0x47, 0x4e, 0x55, 0x5c, 0x64, 0x6d, 0x76, 0x7f, 0x40, 0x49, 0x52, 0x5b,
     88            0x2c, 0x25, 0x3e, 0x37, 0x08, 0x01, 0x1a, 0x13, 0x7d, 0x74, 0x6f, 0x66,
     89            0x59, 0x50, 0x4b, 0x42, 0x35, 0x3c, 0x27, 0x2e, 0x11, 0x18, 0x03, 0x0a,
     90            0x56, 0x5f, 0x44, 0x4d, 0x72, 0x7b, 0x60, 0x69, 0x1e, 0x17, 0x0c, 0x05,
     91            0x3a, 0x33, 0x28, 0x21, 0x4f, 0x46, 0x5d, 0x54, 0x6b, 0x62, 0x79, 0x70,
     92            0x07, 0x0e, 0x15, 0x1c, 0x23, 0x2a, 0x31, 0x38, 0x41, 0x48, 0x53, 0x5a,
     93            0x65, 0x6c, 0x77, 0x7e, 0x09, 0x00, 0x1b, 0x12, 0x2d, 0x24, 0x3f, 0x36,
     94            0x58, 0x51, 0x4a, 0x43, 0x7c, 0x75, 0x6e, 0x67, 0x10, 0x19, 0x02, 0x0b,
     95            0x34, 0x3d, 0x26, 0x2f, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
     96            0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x6a, 0x63, 0x78, 0x71,
     97            0x4e, 0x47, 0x5c, 0x55, 0x22, 0x2b, 0x30, 0x39, 0x06, 0x0f, 0x14, 0x1d,
     98            0x25, 0x2c, 0x37, 0x3e, 0x01, 0x08, 0x13, 0x1a, 0x6d, 0x64, 0x7f, 0x76,
     99            0x49, 0x40, 0x5b, 0x52, 0x3c, 0x35, 0x2e, 0x27, 0x18, 0x11, 0x0a, 0x03,
    100            0x74, 0x7d, 0x66, 0x6f, 0x50, 0x59, 0x42, 0x4b, 0x17, 0x1e, 0x05, 0x0c,
    101            0x33, 0x3a, 0x21, 0x28, 0x5f, 0x56, 0x4d, 0x44, 0x7b, 0x72, 0x69, 0x60,
    102            0x0e, 0x07, 0x1c, 0x15, 0x2a, 0x23, 0x38, 0x31, 0x46, 0x4f, 0x54, 0x5d,
    103            0x62, 0x6b, 0x70, 0x79
    104          };
    105          
    106          /*===========================================================================*/
    107          /* Driver local functions.                                                   */
    108          /*===========================================================================*/
    109          

   \                                 In section .text, align 2, keep-with-next
    110          static bool_t mmc_read(void *instance, uint32_t startblk,
    111                          uint8_t *buffer, uint32_t n) {
   \                     mmc_read:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    112          
    113            if (mmcStartSequentialRead((MMCDriver *)instance, startblk))
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       mmcStartSequentialRead
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??mmc_read_0
    114              return CH_FAILED;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE015             B.N      ??mmc_read_1
    115            while (n > 0) {
   \                     ??mmc_read_0:
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD00B             BEQ.N    ??mmc_read_2
    116              if (mmcSequentialRead((MMCDriver *)instance, buffer))
   \   0000001E   0x0031             MOVS     R1,R6
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       mmcSequentialRead
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??mmc_read_3
    117                return CH_FAILED;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE00B             B.N      ??mmc_read_1
    118              buffer += MMCSD_BLOCK_SIZE;
   \                     ??mmc_read_3:
   \   0000002E   0xF516 0x7600      ADDS     R6,R6,#+512
    119              n--;
   \   00000032   0x1E7F             SUBS     R7,R7,#+1
   \   00000034   0xE7F1             B.N      ??mmc_read_0
    120            }
    121            if (mmcStopSequentialRead((MMCDriver *)instance))
   \                     ??mmc_read_2:
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       mmcStopSequentialRead
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??mmc_read_4
    122              return CH_FAILED;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??mmc_read_1
    123            return CH_SUCCESS;
   \                     ??mmc_read_4:
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??mmc_read_1:
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    124          }
    125          

   \                                 In section .text, align 2, keep-with-next
    126          static bool_t mmc_write(void *instance, uint32_t startblk,
    127                           const uint8_t *buffer, uint32_t n) {
   \                     mmc_write:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    128          
    129            if (mmcStartSequentialWrite((MMCDriver *)instance, startblk))
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       mmcStartSequentialWrite
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??mmc_write_0
    130              return CH_FAILED;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE015             B.N      ??mmc_write_1
    131            while (n > 0) {
   \                     ??mmc_write_0:
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD00B             BEQ.N    ??mmc_write_2
    132              if (mmcSequentialWrite((MMCDriver *)instance, buffer))
   \   0000001E   0x0031             MOVS     R1,R6
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       mmcSequentialWrite
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??mmc_write_3
    133                  return CH_FAILED;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE00B             B.N      ??mmc_write_1
    134              buffer += MMCSD_BLOCK_SIZE;
   \                     ??mmc_write_3:
   \   0000002E   0xF516 0x7600      ADDS     R6,R6,#+512
    135              n--;
   \   00000032   0x1E7F             SUBS     R7,R7,#+1
   \   00000034   0xE7F1             B.N      ??mmc_write_0
    136            }
    137            if (mmcStopSequentialWrite((MMCDriver *)instance))
   \                     ??mmc_write_2:
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       mmcStopSequentialWrite
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??mmc_write_4
    138              return CH_FAILED;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??mmc_write_1
    139            return CH_SUCCESS;
   \                     ??mmc_write_4:
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??mmc_write_1:
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    140          }
    141          
    142          /**
    143           * @brief Calculate the MMC standard CRC-7 based on a lookup table.
    144           *
    145           * @param[in] crc       start value for CRC
    146           * @param[in] buffer    pointer to data buffer
    147           * @param[in] len       length of data
    148           * @return              Calculated CRC
    149           */

   \                                 In section .text, align 2, keep-with-next
    150          static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {
    151          
    152            while (len--)
   \                     crc7:
   \                     ??crc7_0:
   \   00000000   0x0013             MOVS     R3,R2
   \   00000002   0x1E5A             SUBS     R2,R3,#+1
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD008             BEQ.N    ??crc7_1
    153              crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x780B             LDRB     R3,[R1, #+0]
   \   0000000C   0xEA93 0x0040      EORS     R0,R3,R0, LSL #+1
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable14
   \   00000014   0x5CC0             LDRB     R0,[R0, R3]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xE7F2             B.N      ??crc7_0
    154            return crc;
   \                     ??crc7_1:
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
    155          }
    156          
    157          /**
    158           * @brief   Waits an idle condition.
    159           *
    160           * @param[in] mmcp      pointer to the @p MMCDriver object
    161           *
    162           * @notapi
    163           */

   \                                 In section .text, align 2, keep-with-next
    164          static void wait(MMCDriver *mmcp) {
   \                     wait:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    165            int i;
    166            uint8_t buf[4];
    167          
    168            for (i = 0; i < 16; i++) {
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??wait_0:
   \   00000008   0x2D10             CMP      R5,#+16
   \   0000000A   0xDA0B             BGE.N    ??wait_1
    169              spiReceive(mmcp->config->spip, 1, buf);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x6AE0             LDR      R0,[R4, #+44]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       spiReceive
    170              if (buf[0] == 0xFF)
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x28FF             CMP      R0,#+255
   \   0000001E   0xD00F             BEQ.N    ??wait_2
    171                return;
    172            }
   \                     ??wait_3:
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0xE7F1             B.N      ??wait_0
    173            /* Looks like it is a long wait.*/
    174            while (TRUE) {
    175              spiReceive(mmcp->config->spip, 1, buf);
   \                     ??wait_1:
   \   00000024   0xAA00             ADD      R2,SP,#+0
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       spiReceive
    176              if (buf[0] == 0xFF)
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xD003             BEQ.N    ??wait_2
    177                break;
    178          #if MMC_NICE_WAITING
    179              /* Trying to be nice with the other threads.*/
    180              chThdSleep(1);
    181          #endif
    182            }
    183          }
   \                     ??wait_4:
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x.... 0x....      BL       chThdSleep
   \   0000003E   0xE7F1             B.N      ??wait_1
   \                     ??wait_2:
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    184          
    185          /**
    186           * @brief   Sends a command header.
    187           *
    188           * @param[in] mmcp      pointer to the @p MMCDriver object
    189           * @param[in] cmd       the command id
    190           * @param[in] arg       the command argument
    191           *
    192           * @notapi
    193           */

   \                                 In section .text, align 2, keep-with-next
    194          static void send_hdr(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
   \                     send_hdr:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    195            uint8_t buf[6];
    196          
    197            /* Wait for the bus to become idle if a write operation was in progress.*/
    198            wait(mmcp);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       wait
    199          
    200            buf[0] = 0x40 | cmd;
   \   0000000E   0xF055 0x0040      ORRS     R0,R5,#0x40
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    201            buf[1] = arg >> 24;
   \   00000016   0x0E30             LSRS     R0,R6,#+24
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    202            buf[2] = arg >> 16;
   \   0000001C   0x0C30             LSRS     R0,R6,#+16
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    203            buf[3] = arg >> 8;
   \   00000022   0x0A30             LSRS     R0,R6,#+8
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    204            buf[4] = arg;
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    205            /* Calculate CRC for command header, shift to right position, add stop bit.*/
    206            buf[5] = ((crc7(0, buf, 5) & 0x7F) << 1) | 0x01;
   \   0000002E   0x2205             MOVS     R2,#+5
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      BL       crc7
   \   00000038   0x0040             LSLS     R0,R0,#+1
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    207          
    208            spiSend(mmcp->config->spip, 6, buf);
   \   00000042   0xAA00             ADD      R2,SP,#+0
   \   00000044   0x2106             MOVS     R1,#+6
   \   00000046   0x6AE0             LDR      R0,[R4, #+44]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       spiSend
    209          }
   \   0000004E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    210          
    211          /**
    212           * @brief   Receives a single byte response.
    213           *
    214           * @param[in] mmcp      pointer to the @p MMCDriver object
    215           * @return              The response as an @p uint8_t value.
    216           * @retval 0xFF         timed out.
    217           *
    218           * @notapi
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          static uint8_t recvr1(MMCDriver *mmcp) {
   \                     recvr1:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    221            int i;
    222            uint8_t r1[1];
    223          
    224            for (i = 0; i < 9; i++) {
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??recvr1_0:
   \   00000008   0x2D09             CMP      R5,#+9
   \   0000000A   0xDA0E             BGE.N    ??recvr1_1
    225              spiReceive(mmcp->config->spip, 1, r1);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x6AE0             LDR      R0,[R4, #+44]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       spiReceive
    226              if (r1[0] != 0xFF)
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x28FF             CMP      R0,#+255
   \   0000001E   0xD002             BEQ.N    ??recvr1_2
    227                return r1[0];
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xE002             B.N      ??recvr1_3
    228            }
   \                     ??recvr1_2:
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \   00000028   0xE7EE             B.N      ??recvr1_0
    229            return 0xFF;
   \                     ??recvr1_1:
   \   0000002A   0x20FF             MOVS     R0,#+255
   \                     ??recvr1_3:
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    230          }
    231          
    232          /**
    233           * @brief   Receives a three byte response.
    234           *
    235           * @param[in] mmcp      pointer to the @p MMCDriver object
    236           * @param[out] buffer   pointer to four bytes wide buffer
    237           * @return              First response byte as an @p uint8_t value.
    238           * @retval 0xFF         timed out.
    239           *
    240           * @notapi
    241           */

   \                                 In section .text, align 2, keep-with-next
    242          static uint8_t recvr3(MMCDriver *mmcp, uint8_t* buffer) {
   \                     recvr3:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    243            uint8_t r1;
    244          
    245            r1 = recvr1(mmcp);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       recvr1
   \   0000000C   0x0006             MOVS     R6,R0
    246            spiReceive(mmcp->config->spip, 4, buffer);
   \   0000000E   0x002A             MOVS     R2,R5
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6AE0             LDR      R0,[R4, #+44]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       spiReceive
    247          
    248            return r1;
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    249          }
    250          
    251          /**
    252           * @brief   Sends a command an returns a single byte response.
    253           *
    254           * @param[in] mmcp      pointer to the @p MMCDriver object
    255           * @param[in] cmd       the command id
    256           * @param[in] arg       the command argument
    257           * @return              The response as an @p uint8_t value.
    258           * @retval 0xFF         timed out.
    259           *
    260           * @notapi
    261           */

   \                                 In section .text, align 2, keep-with-next
    262          static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
   \                     send_command_R1:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    263            uint8_t r1;
    264          
    265            spiSelect(mmcp->config->spip);
   \   00000008   0x6AE0             LDR      R0,[R4, #+44]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x.... 0x....      BL       spiSelect
    266            send_hdr(mmcp, cmd, arg);
   \   00000010   0x0032             MOVS     R2,R6
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       send_hdr
    267            r1 = recvr1(mmcp);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       recvr1
   \   00000022   0x0007             MOVS     R7,R0
    268            spiUnselect(mmcp->config->spip);
   \   00000024   0x6AE0             LDR      R0,[R4, #+44]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x.... 0x....      BL       spiUnselect
    269            return r1;
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    270          }
    271          
    272          /**
    273           * @brief   Sends a command which returns a five bytes response (R3).
    274           *
    275           * @param[in] mmcp      pointer to the @p MMCDriver object
    276           * @param[in] cmd       the command id
    277           * @param[in] arg       the command argument
    278           * @param[out] response pointer to four bytes wide uint8_t buffer
    279           * @return              The first byte of the response (R1) as an @p
    280           *                      uint8_t value.
    281           * @retval 0xFF         timed out.
    282           *
    283           * @notapi
    284           */

   \                                 In section .text, align 2, keep-with-next
    285          static uint8_t send_command_R3(MMCDriver *mmcp, uint8_t cmd, uint32_t arg,
    286                                         uint8_t *response) {
   \                     send_command_R3:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    287            uint8_t r1;
    288          
    289            spiSelect(mmcp->config->spip);
   \   0000000C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x.... 0x....      BL       spiSelect
    290            send_hdr(mmcp, cmd, arg);
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       send_hdr
    291            r1 = recvr3(mmcp, response);
   \   00000020   0x0039             MOVS     R1,R7
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       recvr3
   \   00000028   0x4680             MOV      R8,R0
    292            spiUnselect(mmcp->config->spip);
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       spiUnselect
    293            return r1;
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    294          }
    295          
    296          /**
    297           * @brief   Reads the CSD.
    298           *
    299           * @param[in] mmcp      pointer to the @p MMCDriver object
    300           * @param[out] csd       pointer to the CSD buffer
    301           *
    302           * @return              The operation status.
    303           * @retval CH_SUCCESS   the operation succeeded.
    304           * @retval CH_FAILED    the operation failed.
    305           *
    306           * @notapi
    307           */

   \                                 In section .text, align 2, keep-with-next
    308          static bool_t read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
   \                     read_CxD:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    309            unsigned i;
    310            uint8_t *bp, buf[16];
    311          
    312            spiSelect(mmcp->config->spip);
   \   0000000C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x.... 0x....      BL       spiSelect
    313            send_hdr(mmcp, cmd, 0);
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       send_hdr
    314            if (recvr1(mmcp) != 0x00) {
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       recvr1
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD005             BEQ.N    ??read_CxD_0
    315              spiUnselect(mmcp->config->spip);
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       spiUnselect
    316              return CH_FAILED;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE03F             B.N      ??read_CxD_1
    317            }
    318          
    319            /* Wait for data availability.*/
    320            for (i = 0; i < MMC_WAIT_DATA; i++) {
   \                     ??read_CxD_0:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0007             MOVS     R7,R0
   \                     ??read_CxD_2:
   \   0000003A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xD238             BCS.N    ??read_CxD_3
    321              spiReceive(mmcp->config->spip, 1, buf);
   \   00000042   0xAA00             ADD      R2,SP,#+0
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x6AE0             LDR      R0,[R4, #+44]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       spiReceive
    322              if (buf[0] == 0xFE) {
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0x28FE             CMP      R0,#+254
   \   00000054   0xD12C             BNE.N    ??read_CxD_4
    323                uint32_t *wp;
    324          
    325                spiReceive(mmcp->config->spip, 16, buf);
   \   00000056   0xAA00             ADD      R2,SP,#+0
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       spiReceive
    326                bp = buf;
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x4680             MOV      R8,R0
    327                for (wp = &cxd[3]; wp >= cxd; wp--) {
   \   00000066   0xF116 0x000C      ADDS     R0,R6,#+12
   \   0000006A   0x4681             MOV      R9,R0
   \                     ??read_CxD_5:
   \   0000006C   0x45B1             CMP      R9,R6
   \   0000006E   0xD314             BCC.N    ??read_CxD_6
    328                  *wp = ((uint32_t)bp[0] << 24) | ((uint32_t)bp[1] << 16) |
    329                        ((uint32_t)bp[2] << 8)  | (uint32_t)bp[3];
   \   00000070   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000074   0xF898 0x1001      LDRB     R1,[R8, #+1]
   \   00000078   0x0409             LSLS     R1,R1,#+16
   \   0000007A   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000007E   0xF898 0x1002      LDRB     R1,[R8, #+2]
   \   00000082   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000086   0xF898 0x1003      LDRB     R1,[R8, #+3]
   \   0000008A   0x4308             ORRS     R0,R1,R0
   \   0000008C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    330                  bp += 4;
   \   00000090   0xF118 0x0804      ADDS     R8,R8,#+4
    331                }
   \   00000094   0xF1B9 0x0904      SUBS     R9,R9,#+4
   \   00000098   0xE7E8             B.N      ??read_CxD_5
    332          
    333                /* CRC ignored then end of transaction. */
    334                spiIgnore(mmcp->config->spip, 2);
   \                     ??read_CxD_6:
   \   0000009A   0x2102             MOVS     R1,#+2
   \   0000009C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x.... 0x....      BL       spiIgnore
    335                spiUnselect(mmcp->config->spip);
   \   000000A4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x.... 0x....      BL       spiUnselect
    336          
    337                return CH_SUCCESS;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE002             B.N      ??read_CxD_1
    338              }
    339            }
   \                     ??read_CxD_4:
   \   000000B0   0x1C7F             ADDS     R7,R7,#+1
   \   000000B2   0xE7C2             B.N      ??read_CxD_2
    340            return CH_FAILED;
   \                     ??read_CxD_3:
   \   000000B4   0x2001             MOVS     R0,#+1
   \                     ??read_CxD_1:
   \   000000B6   0xB005             ADD      SP,SP,#+20
   \   000000B8   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    341          }
    342          
    343          /**
    344           * @brief   Waits that the card reaches an idle state.
    345           *
    346           * @param[in] mmcp      pointer to the @p MMCDriver object
    347           *
    348           * @notapi
    349           */

   \                                 In section .text, align 2, keep-with-next
    350          static void sync(MMCDriver *mmcp) {
   \                     sync:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    351            uint8_t buf[1];
    352          
    353            spiSelect(mmcp->config->spip);
   \   00000006   0x6AE0             LDR      R0,[R4, #+44]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x.... 0x....      BL       spiSelect
    354            while (TRUE) {
    355              spiReceive(mmcp->config->spip, 1, buf);
   \                     ??sync_0:
   \   0000000E   0xAA00             ADD      R2,SP,#+0
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x6AE0             LDR      R0,[R4, #+44]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       spiReceive
    356              if (buf[0] == 0xFF)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x28FF             CMP      R0,#+255
   \   00000020   0xD104             BNE.N    ??sync_1
    357                break;
    358          #if MMC_NICE_WAITING
    359              chThdSleep(1);      /* Trying to be nice with the other threads.*/
    360          #endif
    361            }
    362            spiUnselect(mmcp->config->spip);
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       spiUnselect
    363          }
   \   0000002A   0xE003             B.N      ??sync_2
   \                     ??sync_1:
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       chThdSleep
   \   00000032   0xE7EC             B.N      ??sync_0
   \                     ??sync_2:
   \   00000034   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    364          
    365          /*===========================================================================*/
    366          /* Driver exported functions.                                                */
    367          /*===========================================================================*/
    368          
    369          /**
    370           * @brief   MMC over SPI driver initialization.
    371           * @note    This function is implicitly invoked by @p halInit(), there is
    372           *          no need to explicitly initialize the driver.
    373           *
    374           * @init
    375           */

   \                                 In section .text, align 2, keep-with-next
    376          void mmcInit(void) {
    377          
    378          }
   \                     mmcInit:
   \   00000000   0x4770             BX       LR               ;; return
    379          
    380          /**
    381           * @brief   Initializes an instance.
    382           *
    383           * @param[out] mmcp         pointer to the @p MMCDriver object
    384           *
    385           * @init
    386           */

   \                                 In section .text, align 2, keep-with-next
    387          void mmcObjectInit(MMCDriver *mmcp) {
    388          
    389            mmcp->vmt = &mmc_vmt;
   \                     mmcObjectInit:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    390            mmcp->state = BLK_STOP;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    391            mmcp->config = NULL;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x62C1             STR      R1,[R0, #+44]
    392            mmcp->block_addresses = FALSE;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF880 0x1030      STRB     R1,[R0, #+48]
    393          }
   \   00000014   0x4770             BX       LR               ;; return
    394          
    395          /**
    396           * @brief   Configures and activates the MMC peripheral.
    397           *
    398           * @param[in] mmcp      pointer to the @p MMCDriver object
    399           * @param[in] config    pointer to the @p MMCConfig object.
    400           *
    401           * @api
    402           */

   \                                 In section .text, align 2, keep-with-next
    403          void mmcStart(MMCDriver *mmcp, const MMCConfig *config) {
   \                     mmcStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    404          
    405            chDbgCheck((mmcp != NULL) && (config != NULL), "mmcStart");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??mmcStart_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD107             BNE.N    ??mmcStart_1
   \                     ??mmcStart_0:
   \   0000000E   0xF240 0x1295      MOVW     R2,#+405
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000001A   0x.... 0x....      BL       chDbgPanic3
    406            chDbgAssert((mmcp->state == BLK_STOP) || (mmcp->state == BLK_ACTIVE),
    407                        "mmcStart(), #1", "invalid state");
   \                     ??mmcStart_1:
   \   0000001E   0x7920             LDRB     R0,[R4, #+4]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD006             BEQ.N    ??mmcStart_2
   \   00000024   0x7920             LDRB     R0,[R4, #+4]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD003             BEQ.N    ??mmcStart_2
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   0000002E   0x.... 0x....      BL       chDbgPanic
    408          
    409            mmcp->config = config;
   \                     ??mmcStart_2:
   \   00000032   0x62E5             STR      R5,[R4, #+44]
    410            mmcp->state = BLK_ACTIVE;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x7120             STRB     R0,[R4, #+4]
    411          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    412          
    413          /**
    414           * @brief   Disables the MMC peripheral.
    415           *
    416           * @param[in] mmcp      pointer to the @p MMCDriver object
    417           *
    418           * @api
    419           */

   \                                 In section .text, align 2, keep-with-next
    420          void mmcStop(MMCDriver *mmcp) {
   \                     mmcStop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    421          
    422            chDbgCheck(mmcp != NULL, "mmcStop");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD107             BNE.N    ??mmcStop_0
   \   00000008   0xF44F 0x72D3      MOV      R2,#+422
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    423            chDbgAssert((mmcp->state == BLK_STOP) || (mmcp->state == BLK_ACTIVE),
    424                        "mmcStop(), #1", "invalid state");
   \                     ??mmcStop_0:
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD006             BEQ.N    ??mmcStop_1
   \   0000001E   0x7920             LDRB     R0,[R4, #+4]
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD003             BEQ.N    ??mmcStop_1
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   00000028   0x.... 0x....      BL       chDbgPanic
    425          
    426            spiStop(mmcp->config->spip);
   \                     ??mmcStop_1:
   \   0000002C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x.... 0x....      BL       spiStop
    427            mmcp->state = BLK_STOP;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7120             STRB     R0,[R4, #+4]
    428          }
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    429          
    430          /**
    431           * @brief   Performs the initialization procedure on the inserted card.
    432           * @details This function should be invoked when a card is inserted and
    433           *          brings the driver in the @p MMC_READY state where it is possible
    434           *          to perform read and write operations.
    435           * @note    It is possible to invoke this function from the insertion event
    436           *          handler.
    437           *
    438           * @param[in] mmcp      pointer to the @p MMCDriver object
    439           *
    440           * @return              The operation status.
    441           * @retval CH_SUCCESS   the operation succeeded and the driver is now
    442           *                      in the @p MMC_READY state.
    443           * @retval CH_FAILED    the operation failed.
    444           *
    445           * @api
    446           */

   \                                 In section .text, align 2, keep-with-next
    447          bool_t mmcConnect(MMCDriver *mmcp) {
   \                     mmcConnect:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    448            unsigned i;
    449            uint8_t r3[4];
    450          
    451            chDbgCheck(mmcp != NULL, "mmcConnect");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD107             BNE.N    ??mmcConnect_0
   \   0000000A   0xF240 0x12C3      MOVW     R2,#+451
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_7
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    452          
    453            chDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
    454                        "mmcConnect(), #1", "invalid state");
   \                     ??mmcConnect_0:
   \   0000001A   0x7920             LDRB     R0,[R4, #+4]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD006             BEQ.N    ??mmcConnect_1
   \   00000020   0x7920             LDRB     R0,[R4, #+4]
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD003             BEQ.N    ??mmcConnect_1
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    455          
    456            /* Connection procedure in progress.*/
    457            mmcp->state = BLK_CONNECTING;
   \                     ??mmcConnect_1:
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x7120             STRB     R0,[R4, #+4]
    458            mmcp->block_addresses = FALSE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x0030      STRB     R0,[R4, #+48]
    459          
    460            /* Slow clock mode and 128 clock pulses.*/
    461            spiStart(mmcp->config->spip, mmcp->config->lscfg);
   \   00000038   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003A   0x6841             LDR      R1,[R0, #+4]
   \   0000003C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x.... 0x....      BL       spiStart
    462            spiIgnore(mmcp->config->spip, 16);
   \   00000044   0x2110             MOVS     R1,#+16
   \   00000046   0x6AE0             LDR      R0,[R4, #+44]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       spiIgnore
    463          
    464            /* SPI mode selection.*/
    465            i = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0005             MOVS     R5,R0
    466            while (TRUE) {
    467              if (send_command_R1(mmcp, MMCSD_CMD_GO_IDLE_STATE, 0) == 0x01)
   \                     ??mmcConnect_2:
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       send_command_R1
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD109             BNE.N    ??mmcConnect_3
    468                break;
    469              if (++i >= MMC_CMD0_RETRY)
    470                goto failed;
    471              chThdSleepMilliseconds(10);
    472            }
    473          
    474            /* Try to detect if this is a high capacity card and switch to block
    475               addresses if possible.
    476               This method is based on "How to support SDC Ver2 and high capacity cards"
    477               by ElmChan.*/
    478            if (send_command_R3(mmcp, MMCSD_CMD_SEND_IF_COND,
    479                                MMCSD_CMD8_PATTERN, r3) != 0x05) {
   \   00000060   0xAB00             ADD      R3,SP,#+0
   \   00000062   0xF44F 0x72D5      MOV      R2,#+426
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       send_command_R3
   \   0000006E   0x2805             CMP      R0,#+5
   \   00000070   0xD107             BNE.N    ??mmcConnect_4
   \   00000072   0xE02D             B.N      ??mmcConnect_5
   \                     ??mmcConnect_3:
   \   00000074   0x1C6D             ADDS     R5,R5,#+1
   \   00000076   0x2D0A             CMP      R5,#+10
   \   00000078   0xD26B             BCS.N    ??mmcConnect_6
   \                     ??mmcConnect_7:
   \   0000007A   0x200A             MOVS     R0,#+10
   \   0000007C   0x.... 0x....      BL       chThdSleep
   \   00000080   0xE7E7             B.N      ??mmcConnect_2
    480          
    481              /* Switch to SDHC mode.*/
    482              i = 0;
   \                     ??mmcConnect_4:
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0005             MOVS     R5,R0
    483              while (TRUE) {
    484                if ((send_command_R1(mmcp, MMCSD_CMD_APP_CMD, 0) == 0x01) &&
    485                    (send_command_R3(mmcp, MMCSD_CMD_APP_OP_COND,
    486                                     0x400001aa, r3) == 0x00))
   \                     ??mmcConnect_8:
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x2137             MOVS     R1,#+55
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       send_command_R1
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD113             BNE.N    ??mmcConnect_9
   \   00000094   0xAB00             ADD      R3,SP,#+0
   \   00000096   0x.... 0x....      LDR.W    R2,??DataTable14_9  ;; 0x400001aa
   \   0000009A   0x2129             MOVS     R1,#+41
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       send_command_R3
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD10A             BNE.N    ??mmcConnect_9
    487                  break;
    488          
    489                if (++i >= MMC_ACMD41_RETRY)
    490                  goto failed;
    491                chThdSleepMilliseconds(10);
    492              }
    493          
    494              /* Execute dedicated read on OCR register */
    495              send_command_R3(mmcp, MMCSD_CMD_READ_OCR, 0, r3);
   \   000000A6   0xAB00             ADD      R3,SP,#+0
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0x213A             MOVS     R1,#+58
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       send_command_R3
    496          
    497              /* Check if CCS is set in response. Card operates in block mode if set.*/
    498              if (r3[0] & 0x40)
   \   000000B2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B6   0x0640             LSLS     R0,R0,#+25
   \   000000B8   0xD407             BMI.N    ??mmcConnect_10
   \   000000BA   0xE009             B.N      ??mmcConnect_5
   \                     ??mmcConnect_9:
   \   000000BC   0x1C6D             ADDS     R5,R5,#+1
   \   000000BE   0x2D64             CMP      R5,#+100
   \   000000C0   0xD247             BCS.N    ??mmcConnect_6
   \                     ??mmcConnect_11:
   \   000000C2   0x200A             MOVS     R0,#+10
   \   000000C4   0x.... 0x....      BL       chThdSleep
   \   000000C8   0xE7DD             B.N      ??mmcConnect_8
    499                mmcp->block_addresses = TRUE;
   \                     ??mmcConnect_10:
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xF884 0x0030      STRB     R0,[R4, #+48]
    500            }
    501          
    502            /* Initialization.*/
    503            i = 0;
   \                     ??mmcConnect_5:
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x0005             MOVS     R5,R0
    504            while (TRUE) {
    505              uint8_t b = send_command_R1(mmcp, MMCSD_CMD_INIT, 0);
   \                     ??mmcConnect_12:
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0x2101             MOVS     R1,#+1
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       send_command_R1
   \   000000DE   0x0006             MOVS     R6,R0
    506              if (b == 0x00)
   \   000000E0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E2   0x2E00             CMP      R6,#+0
   \   000000E4   0xD10E             BNE.N    ??mmcConnect_13
    507                break;
    508              if (b != 0x01)
    509                goto failed;
    510              if (++i >= MMC_CMD1_RETRY)
    511                goto failed;
    512              chThdSleepMilliseconds(10);
    513            }
    514          
    515            /* Initialization complete, full speed.*/
    516            spiStart(mmcp->config->spip, mmcp->config->hscfg);
   \   000000E6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E8   0x6881             LDR      R1,[R0, #+8]
   \   000000EA   0x6AE0             LDR      R0,[R4, #+44]
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x.... 0x....      BL       spiStart
    517          
    518            /* Setting block size.*/
    519            if (send_command_R1(mmcp, MMCSD_CMD_SET_BLOCKLEN,
    520                                MMCSD_BLOCK_SIZE) != 0x00)
   \   000000F2   0xF44F 0x7200      MOV      R2,#+512
   \   000000F6   0x2110             MOVS     R1,#+16
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x.... 0x....      BL       send_command_R1
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD10A             BNE.N    ??mmcConnect_14
   \   00000102   0xE00A             B.N      ??mmcConnect_15
   \                     ??mmcConnect_13:
   \   00000104   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000106   0x2E01             CMP      R6,#+1
   \   00000108   0xD123             BNE.N    ??mmcConnect_6
   \                     ??mmcConnect_16:
   \   0000010A   0x1C6D             ADDS     R5,R5,#+1
   \   0000010C   0x2D64             CMP      R5,#+100
   \   0000010E   0xD220             BCS.N    ??mmcConnect_6
   \                     ??mmcConnect_17:
   \   00000110   0x200A             MOVS     R0,#+10
   \   00000112   0x.... 0x....      BL       chThdSleep
   \   00000116   0xE7DD             B.N      ??mmcConnect_12
    521              goto failed;
   \                     ??mmcConnect_14:
   \   00000118   0xE01B             B.N      ??mmcConnect_6
    522          
    523            /* Determine capacity.*/
    524            if (read_CxD(mmcp, MMCSD_CMD_SEND_CSD, mmcp->csd))
   \                     ??mmcConnect_15:
   \   0000011A   0xF114 0x0218      ADDS     R2,R4,#+24
   \   0000011E   0x2109             MOVS     R1,#+9
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x.... 0x....      BL       read_CxD
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD113             BNE.N    ??mmcConnect_6
    525              goto failed;
    526            mmcp->capacity = mmcsdGetCapacity(mmcp->csd);
   \                     ??mmcConnect_18:
   \   0000012A   0xF114 0x0018      ADDS     R0,R4,#+24
   \   0000012E   0x.... 0x....      BL       mmcsdGetCapacity
   \   00000132   0x62A0             STR      R0,[R4, #+40]
    527            if (mmcp->capacity == 0)
   \   00000134   0x6AA0             LDR      R0,[R4, #+40]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD00B             BEQ.N    ??mmcConnect_6
    528              goto failed;
    529          
    530            if (read_CxD(mmcp, MMCSD_CMD_SEND_CID, mmcp->cid))
   \                     ??mmcConnect_19:
   \   0000013A   0xF114 0x0208      ADDS     R2,R4,#+8
   \   0000013E   0x210A             MOVS     R1,#+10
   \   00000140   0x0020             MOVS     R0,R4
   \   00000142   0x.... 0x....      BL       read_CxD
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD103             BNE.N    ??mmcConnect_6
    531              goto failed;
    532          
    533            mmcp->state = BLK_READY;
   \                     ??mmcConnect_20:
   \   0000014A   0x2005             MOVS     R0,#+5
   \   0000014C   0x7120             STRB     R0,[R4, #+4]
    534            return CH_SUCCESS;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xE006             B.N      ??mmcConnect_21
    535          
    536            /* Connection failed, state reset to BLK_ACTIVE.*/
    537          failed:
    538            spiStop(mmcp->config->spip);
   \                     ??mmcConnect_6:
   \   00000152   0x6AE0             LDR      R0,[R4, #+44]
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0x.... 0x....      BL       spiStop
    539            mmcp->state = BLK_ACTIVE;
   \   0000015A   0x2002             MOVS     R0,#+2
   \   0000015C   0x7120             STRB     R0,[R4, #+4]
    540            return CH_FAILED;
   \   0000015E   0x2001             MOVS     R0,#+1
   \                     ??mmcConnect_21:
   \   00000160   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    541          }
    542          
    543          /**
    544           * @brief   Brings the driver in a state safe for card removal.
    545           *
    546           * @param[in] mmcp      pointer to the @p MMCDriver object
    547           * @return              The operation status.
    548           *
    549           * @retval CH_SUCCESS   the operation succeeded and the driver is now
    550           *                      in the @p MMC_INSERTED state.
    551           * @retval CH_FAILED    the operation failed.
    552           *
    553           * @api
    554           */

   \                                 In section .text, align 2, keep-with-next
    555          bool_t mmcDisconnect(MMCDriver *mmcp) {
   \                     mmcDisconnect:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    556          
    557            chDbgCheck(mmcp != NULL, "mmcDisconnect");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD107             BNE.N    ??mmcDisconnect_0
   \   00000008   0xF240 0x222D      MOVW     R2,#+557
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_10
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    558          
    559            chSysLock();
   \                     ??mmcDisconnect_0:
   \   00000018   0x2020             MOVS     R0,#+32
   \   0000001A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001E   0x.... 0x....      BL       dbg_check_lock
    560            chDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
    561                        "mmcDisconnect(), #1", "invalid state");
   \   00000022   0x7920             LDRB     R0,[R4, #+4]
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD006             BEQ.N    ??mmcDisconnect_1
   \   00000028   0x7920             LDRB     R0,[R4, #+4]
   \   0000002A   0x2805             CMP      R0,#+5
   \   0000002C   0xD003             BEQ.N    ??mmcDisconnect_1
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable14_11
   \   00000032   0x.... 0x....      BL       chDbgPanic
    562            if (mmcp->state == BLK_ACTIVE) {
   \                     ??mmcDisconnect_1:
   \   00000036   0x7920             LDRB     R0,[R4, #+4]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD106             BNE.N    ??mmcDisconnect_2
    563              chSysUnlock();
   \   0000003C   0x.... 0x....      BL       dbg_check_unlock
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF380 0x8811      MSR      BASEPRI,R0
    564              return CH_SUCCESS;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE016             B.N      ??mmcDisconnect_3
    565            }
    566            mmcp->state = BLK_DISCONNECTING;
   \                     ??mmcDisconnect_2:
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x7120             STRB     R0,[R4, #+4]
    567            chSysUnlock();
   \   0000004E   0x.... 0x....      BL       dbg_check_unlock
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF380 0x8811      MSR      BASEPRI,R0
    568          
    569            /* Wait for the pending write operations to complete.*/
    570            spiStart(mmcp->config->spip, mmcp->config->hscfg);
   \   00000058   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005A   0x6881             LDR      R1,[R0, #+8]
   \   0000005C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x.... 0x....      BL       spiStart
    571            sync(mmcp);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       sync
    572          
    573            spiStop(mmcp->config->spip);
   \   0000006A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       spiStop
    574            mmcp->state = BLK_ACTIVE;
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0x7120             STRB     R0,[R4, #+4]
    575            return CH_SUCCESS;
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??mmcDisconnect_3:
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    576          }
    577          
    578          /**
    579           * @brief   Starts a sequential read.
    580           *
    581           * @param[in] mmcp      pointer to the @p MMCDriver object
    582           * @param[in] startblk  first block to read
    583           *
    584           * @return              The operation status.
    585           * @retval CH_SUCCESS   the operation succeeded.
    586           * @retval CH_FAILED    the operation failed.
    587           *
    588           * @api
    589           */

   \                                 In section .text, align 2, keep-with-next
    590          bool_t mmcStartSequentialRead(MMCDriver *mmcp, uint32_t startblk) {
   \                     mmcStartSequentialRead:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    591          
    592            chDbgCheck(mmcp != NULL, "mmcStartSequentialRead");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD106             BNE.N    ??mmcStartSequentialRead_0
   \   0000000A   0xF44F 0x7214      MOV      R2,#+592
   \   0000000E   0x....             LDR.N    R1,??DataTable14_2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    593            chDbgAssert(mmcp->state == BLK_READY,
    594                        "mmcStartSequentialRead(), #1", "invalid state");
   \                     ??mmcStartSequentialRead_0:
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD003             BEQ.N    ??mmcStartSequentialRead_1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000022   0x.... 0x....      BL       chDbgPanic
    595          
    596            /* Read operation in progress.*/
    597            mmcp->state = BLK_READING;
   \                     ??mmcStartSequentialRead_1:
   \   00000026   0x2006             MOVS     R0,#+6
   \   00000028   0x7120             STRB     R0,[R4, #+4]
    598          
    599            /* (Re)starting the SPI in case it has been reprogrammed externally, it can
    600               happen if the SPI bus is shared among multiple peripherals.*/
    601            spiStart(mmcp->config->spip, mmcp->config->hscfg);
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6881             LDR      R1,[R0, #+8]
   \   0000002E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       spiStart
    602            spiSelect(mmcp->config->spip);
   \   00000036   0x6AE0             LDR      R0,[R4, #+44]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       spiSelect
    603          
    604            if (mmcp->block_addresses)
   \   0000003E   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD005             BEQ.N    ??mmcStartSequentialRead_2
    605              send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk);
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x2112             MOVS     R1,#+18
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       send_hdr
   \   00000050   0xE007             B.N      ??mmcStartSequentialRead_3
    606            else
    607              send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk * MMCSD_BLOCK_SIZE);
   \                     ??mmcStartSequentialRead_2:
   \   00000052   0xF44F 0x7000      MOV      R0,#+512
   \   00000056   0xFB00 0xF205      MUL      R2,R0,R5
   \   0000005A   0x2112             MOVS     R1,#+18
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       send_hdr
    608          
    609            if (recvr1(mmcp) != 0x00) {
   \                     ??mmcStartSequentialRead_3:
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       recvr1
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD007             BEQ.N    ??mmcStartSequentialRead_4
    610              spiStop(mmcp->config->spip);
   \   0000006C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x.... 0x....      BL       spiStop
    611              mmcp->state = BLK_READY;
   \   00000074   0x2005             MOVS     R0,#+5
   \   00000076   0x7120             STRB     R0,[R4, #+4]
    612              return CH_FAILED;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xE000             B.N      ??mmcStartSequentialRead_5
    613            }
    614            return CH_SUCCESS;
   \                     ??mmcStartSequentialRead_4:
   \   0000007C   0x2000             MOVS     R0,#+0
   \                     ??mmcStartSequentialRead_5:
   \   0000007E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    615          }
    616          
    617          /**
    618           * @brief   Reads a block within a sequential read operation.
    619           *
    620           * @param[in] mmcp      pointer to the @p MMCDriver object
    621           * @param[out] buffer   pointer to the read buffer
    622           *
    623           * @return              The operation status.
    624           * @retval CH_SUCCESS   the operation succeeded.
    625           * @retval CH_FAILED    the operation failed.
    626           *
    627           * @api
    628           */

   \                                 In section .text, align 2, keep-with-next
    629          bool_t mmcSequentialRead(MMCDriver *mmcp, uint8_t *buffer) {
   \                     mmcSequentialRead:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    630            int i;
    631          
    632            chDbgCheck((mmcp != NULL) && (buffer != NULL), "mmcSequentialRead");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??mmcSequentialRead_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD105             BNE.N    ??mmcSequentialRead_1
   \                     ??mmcSequentialRead_0:
   \   0000000E   0xF44F 0x721E      MOV      R2,#+632
   \   00000012   0x....             LDR.N    R1,??DataTable14_2
   \   00000014   0x....             LDR.N    R0,??DataTable14_14
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    633          
    634            if (mmcp->state != BLK_READING)
   \                     ??mmcSequentialRead_1:
   \   0000001A   0x7920             LDRB     R0,[R4, #+4]
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xD001             BEQ.N    ??mmcSequentialRead_2
    635              return CH_FAILED;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE029             B.N      ??mmcSequentialRead_3
    636          
    637            for (i = 0; i < MMC_WAIT_DATA; i++) {
   \                     ??mmcSequentialRead_2:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x0006             MOVS     R6,R0
   \                     ??mmcSequentialRead_4:
   \   00000028   0xF242 0x7010      MOVW     R0,#+10000
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xDA18             BGE.N    ??mmcSequentialRead_5
    638              spiReceive(mmcp->config->spip, 1, buffer);
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x6AE0             LDR      R0,[R4, #+44]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x.... 0x....      BL       spiReceive
    639              if (buffer[0] == 0xFE) {
   \   0000003C   0x7828             LDRB     R0,[R5, #+0]
   \   0000003E   0x28FE             CMP      R0,#+254
   \   00000040   0xD10D             BNE.N    ??mmcSequentialRead_6
    640                spiReceive(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);
   \   00000042   0x002A             MOVS     R2,R5
   \   00000044   0xF44F 0x7100      MOV      R1,#+512
   \   00000048   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      BL       spiReceive
    641                /* CRC ignored. */
    642                spiIgnore(mmcp->config->spip, 2);
   \   00000050   0x2102             MOVS     R1,#+2
   \   00000052   0x6AE0             LDR      R0,[R4, #+44]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x.... 0x....      BL       spiIgnore
    643                return CH_SUCCESS;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE00C             B.N      ??mmcSequentialRead_3
    644              }
    645            }
   \                     ??mmcSequentialRead_6:
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0xE7E2             B.N      ??mmcSequentialRead_4
    646            /* Timeout.*/
    647            spiUnselect(mmcp->config->spip);
   \                     ??mmcSequentialRead_5:
   \   00000062   0x6AE0             LDR      R0,[R4, #+44]
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x.... 0x....      BL       spiUnselect
    648            spiStop(mmcp->config->spip);
   \   0000006A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       spiStop
    649            mmcp->state = BLK_READY;
   \   00000072   0x2005             MOVS     R0,#+5
   \   00000074   0x7120             STRB     R0,[R4, #+4]
    650            return CH_FAILED;
   \   00000076   0x2001             MOVS     R0,#+1
   \                     ??mmcSequentialRead_3:
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    651          }
    652          
    653          /**
    654           * @brief   Stops a sequential read gracefully.
    655           *
    656           * @param[in] mmcp      pointer to the @p MMCDriver object
    657           *
    658           * @return              The operation status.
    659           * @retval CH_SUCCESS   the operation succeeded.
    660           * @retval CH_FAILED    the operation failed.
    661           *
    662           * @api
    663           */

   \                                 In section .text, align 2, keep-with-next
    664          bool_t mmcStopSequentialRead(MMCDriver *mmcp) {
   \                     mmcStopSequentialRead:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    665            static const uint8_t stopcmd[] = {0x40 | MMCSD_CMD_STOP_TRANSMISSION,
    666                                              0, 0, 0, 0, 1, 0xFF};
    667          
    668            chDbgCheck(mmcp != NULL, "mmcStopSequentialRead");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??mmcStopSequentialRead_0
   \   00000008   0xF44F 0x7227      MOV      R2,#+668
   \   0000000C   0x....             LDR.N    R1,??DataTable14_2
   \   0000000E   0x....             LDR.N    R0,??DataTable14_15
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    669          
    670            if (mmcp->state != BLK_READING)
   \                     ??mmcStopSequentialRead_0:
   \   00000014   0x7920             LDRB     R0,[R4, #+4]
   \   00000016   0x2806             CMP      R0,#+6
   \   00000018   0xD001             BEQ.N    ??mmcStopSequentialRead_1
    671              return CH_FAILED;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE010             B.N      ??mmcStopSequentialRead_2
    672          
    673            spiSend(mmcp->config->spip, sizeof(stopcmd), stopcmd);
   \                     ??mmcStopSequentialRead_1:
   \   0000001E   0x....             LDR.N    R2,??DataTable14_16
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       spiSend
    674          /*  result = recvr1(mmcp) != 0x00;*/
    675            /* Note, ignored r1 response, it can be not zero, unknown issue.*/
    676            (void) recvr1(mmcp);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       recvr1
   \   00000030   0x0005             MOVS     R5,R0
    677          
    678            /* Read operation finished.*/
    679            spiUnselect(mmcp->config->spip);
   \   00000032   0x6AE0             LDR      R0,[R4, #+44]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x.... 0x....      BL       spiUnselect
    680            mmcp->state = BLK_READY;
   \   0000003A   0x2005             MOVS     R0,#+5
   \   0000003C   0x7120             STRB     R0,[R4, #+4]
    681            return CH_SUCCESS;
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??mmcStopSequentialRead_2:
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    682          }

   \                                 In section .rodata, align 4
   \                     ??stopcmd:
   \   00000000   0x4C 0x00          DC8 76, 0, 0, 0, 0, 1, 255, 0
   \              0x00 0x00    
   \              0x00 0x01    
   \              0xFF 0x00    
    683          
    684          /**
    685           * @brief   Starts a sequential write.
    686           *
    687           * @param[in] mmcp      pointer to the @p MMCDriver object
    688           * @param[in] startblk  first block to write
    689           *
    690           * @return              The operation status.
    691           * @retval CH_SUCCESS   the operation succeeded.
    692           * @retval CH_FAILED    the operation failed.
    693           *
    694           * @api
    695           */

   \                                 In section .text, align 2, keep-with-next
    696          bool_t mmcStartSequentialWrite(MMCDriver *mmcp, uint32_t startblk) {
   \                     mmcStartSequentialWrite:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    697          
    698            chDbgCheck(mmcp != NULL, "mmcStartSequentialWrite");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD105             BNE.N    ??mmcStartSequentialWrite_0
   \   0000000A   0xF240 0x22BA      MOVW     R2,#+698
   \   0000000E   0x....             LDR.N    R1,??DataTable14_2
   \   00000010   0x....             LDR.N    R0,??DataTable14_17
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    699            chDbgAssert(mmcp->state == BLK_READY,
    700                        "mmcStartSequentialWrite(), #1", "invalid state");
   \                     ??mmcStartSequentialWrite_0:
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0x2805             CMP      R0,#+5
   \   0000001A   0xD002             BEQ.N    ??mmcStartSequentialWrite_1
   \   0000001C   0x....             LDR.N    R0,??DataTable14_18
   \   0000001E   0x.... 0x....      BL       chDbgPanic
    701          
    702            /* Write operation in progress.*/
    703            mmcp->state = BLK_WRITING;
   \                     ??mmcStartSequentialWrite_1:
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0x7120             STRB     R0,[R4, #+4]
    704          
    705            spiStart(mmcp->config->spip, mmcp->config->hscfg);
   \   00000026   0x6AE0             LDR      R0,[R4, #+44]
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       spiStart
    706            spiSelect(mmcp->config->spip);
   \   00000032   0x6AE0             LDR      R0,[R4, #+44]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x.... 0x....      BL       spiSelect
    707            if (mmcp->block_addresses)
   \   0000003A   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD005             BEQ.N    ??mmcStartSequentialWrite_2
    708              send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK, startblk);
   \   00000042   0x002A             MOVS     R2,R5
   \   00000044   0x2119             MOVS     R1,#+25
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       send_hdr
   \   0000004C   0xE007             B.N      ??mmcStartSequentialWrite_3
    709            else
    710              send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
    711                       startblk * MMCSD_BLOCK_SIZE);
   \                     ??mmcStartSequentialWrite_2:
   \   0000004E   0xF44F 0x7000      MOV      R0,#+512
   \   00000052   0xFB00 0xF205      MUL      R2,R0,R5
   \   00000056   0x2119             MOVS     R1,#+25
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       send_hdr
    712          
    713            if (recvr1(mmcp) != 0x00) {
   \                     ??mmcStartSequentialWrite_3:
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       recvr1
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD007             BEQ.N    ??mmcStartSequentialWrite_4
    714              spiStop(mmcp->config->spip);
   \   00000068   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       spiStop
    715              mmcp->state = BLK_READY;
   \   00000070   0x2005             MOVS     R0,#+5
   \   00000072   0x7120             STRB     R0,[R4, #+4]
    716              return CH_FAILED;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE000             B.N      ??mmcStartSequentialWrite_5
    717            }
    718            return CH_SUCCESS;
   \                     ??mmcStartSequentialWrite_4:
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??mmcStartSequentialWrite_5:
   \   0000007A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    719          }
    720          
    721          /**
    722           * @brief   Writes a block within a sequential write operation.
    723           *
    724           * @param[in] mmcp      pointer to the @p MMCDriver object
    725           * @param[out] buffer   pointer to the write buffer
    726           *
    727           * @return              The operation status.
    728           * @retval CH_SUCCESS   the operation succeeded.
    729           * @retval CH_FAILED    the operation failed.
    730           *
    731           * @api
    732           */

   \                                 In section .text, align 2, keep-with-next
    733          bool_t mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
   \                     mmcSequentialWrite:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    734            static const uint8_t start[] = {0xFF, 0xFC};
    735            uint8_t b[1];
    736          
    737            chDbgCheck((mmcp != NULL) && (buffer != NULL), "mmcSequentialWrite");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??mmcSequentialWrite_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD105             BNE.N    ??mmcSequentialWrite_1
   \                     ??mmcSequentialWrite_0:
   \   0000000E   0xF240 0x22E1      MOVW     R2,#+737
   \   00000012   0x....             LDR.N    R1,??DataTable14_2
   \   00000014   0x....             LDR.N    R0,??DataTable14_19
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    738          
    739            if (mmcp->state != BLK_WRITING)
   \                     ??mmcSequentialWrite_1:
   \   0000001A   0x7920             LDRB     R0,[R4, #+4]
   \   0000001C   0x2807             CMP      R0,#+7
   \   0000001E   0xD001             BEQ.N    ??mmcSequentialWrite_2
    740              return CH_FAILED;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE02D             B.N      ??mmcSequentialWrite_3
    741          
    742            spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
   \                     ??mmcSequentialWrite_2:
   \   00000024   0x....             LDR.N    R2,??DataTable14_20
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       spiSend
    743            spiSend(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);/* Data.            */
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0xF44F 0x7100      MOV      R1,#+512
   \   00000036   0x6AE0             LDR      R0,[R4, #+44]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       spiSend
    744            spiIgnore(mmcp->config->spip, 2);                     /* CRC ignored.     */
   \   0000003E   0x2102             MOVS     R1,#+2
   \   00000040   0x6AE0             LDR      R0,[R4, #+44]
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x.... 0x....      BL       spiIgnore
    745            spiReceive(mmcp->config->spip, 1, b);
   \   00000048   0xAA00             ADD      R2,SP,#+0
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x.... 0x....      BL       spiReceive
    746            if ((b[0] & 0x1F) == 0x05) {
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000005C   0x2805             CMP      R0,#+5
   \   0000005E   0xD104             BNE.N    ??mmcSequentialWrite_4
    747              wait(mmcp);
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       wait
    748              return CH_SUCCESS;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE00A             B.N      ??mmcSequentialWrite_3
    749            }
    750          
    751            /* Error.*/
    752            spiUnselect(mmcp->config->spip);
   \                     ??mmcSequentialWrite_4:
   \   0000006A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       spiUnselect
    753            spiStop(mmcp->config->spip);
   \   00000072   0x6AE0             LDR      R0,[R4, #+44]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x.... 0x....      BL       spiStop
    754            mmcp->state = BLK_READY;
   \   0000007A   0x2005             MOVS     R0,#+5
   \   0000007C   0x7120             STRB     R0,[R4, #+4]
    755            return CH_FAILED;
   \   0000007E   0x2001             MOVS     R0,#+1
   \                     ??mmcSequentialWrite_3:
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    756          }

   \                                 In section .rodata, align 2
   \                     ??start:
   \   00000000   0xFF 0xFC          DC8 255, 252
    757          
    758          /**
    759           * @brief   Stops a sequential write gracefully.
    760           *
    761           * @param[in] mmcp      pointer to the @p MMCDriver object
    762           *
    763           * @return              The operation status.
    764           * @retval CH_SUCCESS   the operation succeeded.
    765           * @retval CH_FAILED    the operation failed.
    766           *
    767           * @api
    768           */

   \                                 In section .text, align 2, keep-with-next
    769          bool_t mmcStopSequentialWrite(MMCDriver *mmcp) {
   \                     mmcStopSequentialWrite:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    770            static const uint8_t stop[] = {0xFD, 0xFF};
    771          
    772            chDbgCheck(mmcp != NULL, "mmcStopSequentialWrite");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??mmcStopSequentialWrite_0
   \   00000008   0xF44F 0x7241      MOV      R2,#+772
   \   0000000C   0x....             LDR.N    R1,??DataTable14_2
   \   0000000E   0x....             LDR.N    R0,??DataTable14_21
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    773          
    774            if (mmcp->state != BLK_WRITING)
   \                     ??mmcStopSequentialWrite_0:
   \   00000014   0x7920             LDRB     R0,[R4, #+4]
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD001             BEQ.N    ??mmcStopSequentialWrite_1
    775              return CH_FAILED;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE00C             B.N      ??mmcStopSequentialWrite_2
    776          
    777            spiSend(mmcp->config->spip, sizeof(stop), stop);
   \                     ??mmcStopSequentialWrite_1:
   \   0000001E   0x....             LDR.N    R2,??DataTable14_22
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       spiSend
    778            spiUnselect(mmcp->config->spip);
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       spiUnselect
    779          
    780            /* Write operation finished.*/
    781            mmcp->state = BLK_READY;
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0x7120             STRB     R0,[R4, #+4]
    782            return CH_SUCCESS;
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??mmcStopSequentialWrite_2:
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    783          }

   \                                 In section .rodata, align 2
   \                     ??stop:
   \   00000000   0xFD 0xFF          DC8 253, 255
    784          
    785          /**
    786           * @brief   Waits for card idle condition.
    787           *
    788           * @param[in] mmcp      pointer to the @p MMCDriver object
    789           *
    790           * @return              The operation status.
    791           * @retval CH_SUCCESS   the operation succeeded.
    792           * @retval CH_FAILED    the operation failed.
    793           *
    794           * @api
    795           */

   \                                 In section .text, align 2, keep-with-next
    796          bool_t mmcSync(MMCDriver *mmcp) {
   \                     mmcSync:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    797          
    798            chDbgCheck(mmcp != NULL, "mmcSync");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??mmcSync_0
   \   00000008   0xF240 0x321E      MOVW     R2,#+798
   \   0000000C   0x....             LDR.N    R1,??DataTable14_2
   \   0000000E   0x....             LDR.N    R0,??DataTable14_23
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    799          
    800            if (mmcp->state != BLK_READY)
   \                     ??mmcSync_0:
   \   00000014   0x7920             LDRB     R0,[R4, #+4]
   \   00000016   0x2805             CMP      R0,#+5
   \   00000018   0xD001             BEQ.N    ??mmcSync_1
    801              return CH_FAILED;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE00D             B.N      ??mmcSync_2
    802          
    803            /* Synchronization operation in progress.*/
    804            mmcp->state = BLK_SYNCING;
   \                     ??mmcSync_1:
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0x7120             STRB     R0,[R4, #+4]
    805          
    806            spiStart(mmcp->config->spip, mmcp->config->hscfg);
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x6881             LDR      R1,[R0, #+8]
   \   00000026   0x6AE0             LDR      R0,[R4, #+44]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       spiStart
    807            sync(mmcp);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       sync
    808          
    809            /* Synchronization operation finished.*/
    810            mmcp->state = BLK_READY;
   \   00000034   0x2005             MOVS     R0,#+5
   \   00000036   0x7120             STRB     R0,[R4, #+4]
    811            return CH_SUCCESS;
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??mmcSync_2:
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    812          }
    813          
    814          /**
    815           * @brief   Returns the media info.
    816           *
    817           * @param[in] mmcp      pointer to the @p MMCDriver object
    818           * @param[out] bdip     pointer to a @p BlockDeviceInfo structure
    819           *
    820           * @return              The operation status.
    821           * @retval CH_SUCCESS   the operation succeeded.
    822           * @retval CH_FAILED    the operation failed.
    823           *
    824           * @api
    825           */

   \                                 In section .text, align 2, keep-with-next
    826          bool_t mmcGetInfo(MMCDriver *mmcp, BlockDeviceInfo *bdip) {
   \                     mmcGetInfo:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    827          
    828            chDbgCheck((mmcp != NULL) && (bdip != NULL), "mmcGetInfo");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??mmcGetInfo_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD105             BNE.N    ??mmcGetInfo_1
   \                     ??mmcGetInfo_0:
   \   0000000E   0xF44F 0x724F      MOV      R2,#+828
   \   00000012   0x....             LDR.N    R1,??DataTable14_2
   \   00000014   0x....             LDR.N    R0,??DataTable14_24
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    829          
    830            if (mmcp->state != BLK_READY)
   \                     ??mmcGetInfo_1:
   \   0000001A   0x7920             LDRB     R0,[R4, #+4]
   \   0000001C   0x2805             CMP      R0,#+5
   \   0000001E   0xD001             BEQ.N    ??mmcGetInfo_2
    831              return CH_FAILED;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE005             B.N      ??mmcGetInfo_3
    832          
    833            bdip->blk_num  = mmcp->capacity;
   \                     ??mmcGetInfo_2:
   \   00000024   0x6AA0             LDR      R0,[R4, #+40]
   \   00000026   0x6068             STR      R0,[R5, #+4]
    834            bdip->blk_size = MMCSD_BLOCK_SIZE;
   \   00000028   0xF44F 0x7000      MOV      R0,#+512
   \   0000002C   0x6028             STR      R0,[R5, #+0]
    835          
    836            return CH_SUCCESS;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??mmcGetInfo_3:
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    837          }
    838          
    839          /**
    840           * @brief   Erases blocks.
    841           *
    842           * @param[in] mmcp      pointer to the @p MMCDriver object
    843           * @param[in] startblk  starting block number
    844           * @param[in] endblk    ending block number
    845           *
    846           * @return              The operation status.
    847           * @retval CH_SUCCESS   the operation succeeded.
    848           * @retval CH_FAILED    the operation failed.
    849           *
    850           * @api
    851           */

   \                                 In section .text, align 2, keep-with-next
    852          bool_t mmcErase(MMCDriver *mmcp, uint32_t startblk, uint32_t endblk) {
   \                     mmcErase:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    853          
    854            chDbgCheck((mmcp != NULL), "mmcErase");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD105             BNE.N    ??mmcErase_0
   \   0000000C   0xF240 0x3256      MOVW     R2,#+854
   \   00000010   0x....             LDR.N    R1,??DataTable14_2
   \   00000012   0x....             LDR.N    R0,??DataTable14_25
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    855          
    856            /* Erase operation in progress.*/
    857            mmcp->state = BLK_WRITING;
   \                     ??mmcErase_0:
   \   00000018   0x2007             MOVS     R0,#+7
   \   0000001A   0x7120             STRB     R0,[R4, #+4]
    858          
    859            /* Handling command differences between HC and normal cards.*/
    860            if (!mmcp->block_addresses) {
   \   0000001C   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD105             BNE.N    ??mmcErase_1
    861              startblk *= MMCSD_BLOCK_SIZE;
   \   00000024   0xF44F 0x7000      MOV      R0,#+512
   \   00000028   0x4345             MULS     R5,R0,R5
    862              endblk *= MMCSD_BLOCK_SIZE;
   \   0000002A   0xF44F 0x7000      MOV      R0,#+512
   \   0000002E   0x4346             MULS     R6,R0,R6
    863            }
    864          
    865            if (send_command_R1(mmcp, MMCSD_CMD_ERASE_RW_BLK_START, startblk))
   \                     ??mmcErase_1:
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0x2120             MOVS     R1,#+32
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       send_command_R1
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD111             BNE.N    ??mmcErase_2
    866              goto failed;
    867          
    868            if (send_command_R1(mmcp, MMCSD_CMD_ERASE_RW_BLK_END, endblk))
   \                     ??mmcErase_3:
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0x2121             MOVS     R1,#+33
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       send_command_R1
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD10A             BNE.N    ??mmcErase_2
    869              goto failed;
    870          
    871            if (send_command_R1(mmcp, MMCSD_CMD_ERASE, 0))
   \                     ??mmcErase_4:
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x2126             MOVS     R1,#+38
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       send_command_R1
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD103             BNE.N    ??mmcErase_2
    872              goto failed;
    873          
    874            mmcp->state = BLK_READY;
   \                     ??mmcErase_5:
   \   0000005A   0x2005             MOVS     R0,#+5
   \   0000005C   0x7120             STRB     R0,[R4, #+4]
    875            return CH_SUCCESS;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE006             B.N      ??mmcErase_6
    876          
    877            /* Command failed, state reset to BLK_ACTIVE.*/
    878          failed:
    879            spiStop(mmcp->config->spip);
   \                     ??mmcErase_2:
   \   00000062   0x6AE0             LDR      R0,[R4, #+44]
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x.... 0x....      BL       spiStop
    880            mmcp->state = BLK_READY;
   \   0000006A   0x2005             MOVS     R0,#+5
   \   0000006C   0x7120             STRB     R0,[R4, #+4]
    881            return CH_FAILED;
   \   0000006E   0x2001             MOVS     R0,#+1
   \                     ??mmcErase_6:
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    882          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     crc7_lookup_table

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     mmc_vmt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     `?<Constant "mmcStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     `?<Constant "mmcStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcConnect\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     `?<Constant "mmcConnect(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x400001AA         DC32     0x400001aa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcDisconnect\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     `?<Constant "mmcDisconnect(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcStartSequentialRe...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     `?<Constant "mmcStartSequentialRea...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcSequentialRead\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcStopSequentialRea...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     ??stopcmd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcStartSequentialWr...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \   00000000   0x........         DC32     `?<Constant "mmcStartSequentialWri...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcSequentialWrite\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \   00000000   0x........         DC32     ??start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcStopSequentialWri...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_22:
   \   00000000   0x........         DC32     ??stop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_23:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcSync\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_24:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcGetInfo\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_25:
   \   00000000   0x........         DC32     `?<Constant "\\"mmcErase\\"()">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcStart\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcStart\"()"
   \              0x6D 0x63    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x6D 0x6D          DC8 6DH, 6DH, 63H, 5FH, 73H, 70H, 69H, 2EH
   \              0x63 0x5F    
   \              0x73 0x70    
   \              0x69 0x2E    
   \   00000040   0x63 0x00          DC8 63H, 0
   \   00000042   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "mmcStart(), #1">`:
   \   00000000   0x6D 0x6D          DC8 "mmcStart(), #1"
   \              0x63 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcStop\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcStop\"()"
   \              0x6D 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "mmcStop(), #1">`:
   \   00000000   0x6D 0x6D          DC8 "mmcStop(), #1"
   \              0x63 0x53    
   \              0x74 0x6F    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcConnect\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcConnect\"()"
   \              0x6D 0x63    
   \              0x43 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "mmcConnect(), #1">`:
   \   00000000   0x6D 0x6D          DC8 "mmcConnect(), #1"
   \              0x63 0x43    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcDisconnect\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcDisconnect\"()"
   \              0x6D 0x63    
   \              0x44 0x69    
   \              0x73 0x63    
   \              0x6F 0x6E    
   \              0x6E 0x65    
   \              0x63 0x74    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "mmcDisconnect(), #1">`:
   \   00000000   0x6D 0x6D          DC8 "mmcDisconnect(), #1"
   \              0x63 0x44    
   \              0x69 0x73    
   \              0x63 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcStartSequentialRe...">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcStartSequentialRead\"()"
   \              0x6D 0x63    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x53    
   \              0x65 0x71    
   \              0x75 0x65    
   \              0x6E 0x74    
   \              0x69 0x61    
   \              0x6C 0x52    
   \              0x65 0x61    
   \              0x64 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "mmcStartSequentialRea...">`:
   \   00000000   0x6D 0x6D          DC8 "mmcStartSequentialRead(), #1"
   \              0x63 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x53 0x65    
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcSequentialRead\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcSequentialRead\"()"
   \              0x6D 0x63    
   \              0x53 0x65    
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcStopSequentialRea...">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcStopSequentialRead\"()"
   \              0x6D 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x53 0x65    
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x22 0x28    
   \              0x29 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcStartSequentialWr...">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcStartSequentialWrite\"()"
   \              0x6D 0x63    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x53    
   \              0x65 0x71    
   \              0x75 0x65    
   \              0x6E 0x74    
   \              0x69 0x61    
   \              0x6C 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "mmcStartSequentialWri...">`:
   \   00000000   0x6D 0x6D          DC8 "mmcStartSequentialWrite(), #1"
   \              0x63 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x53 0x65    
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcSequentialWrite\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcSequentialWrite\"()"
   \              0x6D 0x63    
   \              0x53 0x65    
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcStopSequentialWri...">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcStopSequentialWrite\"()"
   \              0x6D 0x63    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x53 0x65    
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcSync\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcSync\"()"
   \              0x6D 0x63    
   \              0x53 0x79    
   \              0x6E 0x63    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcGetInfo\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcGetInfo\"()"
   \              0x6D 0x63    
   \              0x47 0x65    
   \              0x74 0x49    
   \              0x6E 0x66    
   \              0x6F 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"mmcErase\\"()">`:
   \   00000000   0x22 0x6D          DC8 "\"mmcErase\"()"
   \              0x6D 0x63    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    883          
    884          #endif /* HAL_USE_MMC_SPI */
    885          
    886          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   crc7
      24   mmcConnect
        24   -> chDbgPanic
        24   -> chDbgPanic3
        24   -> chThdSleep
        24   -> mmcsdGetCapacity
        24   -> read_CxD
        24   -> send_command_R1
        24   -> send_command_R3
        24   -> spiIgnore
        24   -> spiStart
        24   -> spiStop
       8   mmcDisconnect
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
         8   -> spiStart
         8   -> spiStop
         8   -> sync
      16   mmcErase
        16   -> chDbgPanic3
        16   -> send_command_R1
        16   -> spiStop
      16   mmcGetInfo
        16   -> chDbgPanic3
       0   mmcInit
       0   mmcObjectInit
      16   mmcSequentialRead
        16   -> chDbgPanic3
        16   -> spiIgnore
        16   -> spiReceive
        16   -> spiStop
        16   -> spiUnselect
      16   mmcSequentialWrite
        16   -> chDbgPanic3
        16   -> spiIgnore
        16   -> spiReceive
        16   -> spiSend
        16   -> spiStop
        16   -> spiUnselect
        16   -> wait
      16   mmcStart
        16   -> chDbgPanic
        16   -> chDbgPanic3
      16   mmcStartSequentialRead
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> recvr1
        16   -> send_hdr
        16   -> spiSelect
        16   -> spiStart
        16   -> spiStop
      16   mmcStartSequentialWrite
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> recvr1
        16   -> send_hdr
        16   -> spiSelect
        16   -> spiStart
        16   -> spiStop
       8   mmcStop
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> spiStop
      16   mmcStopSequentialRead
        16   -> chDbgPanic3
        16   -> recvr1
        16   -> spiSend
        16   -> spiUnselect
       8   mmcStopSequentialWrite
         8   -> chDbgPanic3
         8   -> spiSend
         8   -> spiUnselect
       8   mmcSync
         8   -> chDbgPanic3
         8   -> spiStart
         8   -> sync
      24   mmc_read
        24   -> mmcSequentialRead
        24   -> mmcStartSequentialRead
        24   -> mmcStopSequentialRead
      24   mmc_write
        24   -> mmcSequentialWrite
        24   -> mmcStartSequentialWrite
        24   -> mmcStopSequentialWrite
      48   read_CxD
        48   -> recvr1
        48   -> send_hdr
        48   -> spiIgnore
        48   -> spiReceive
        48   -> spiSelect
        48   -> spiUnselect
      16   recvr1
        16   -> spiReceive
      16   recvr3
        16   -> recvr1
        16   -> spiReceive
      24   send_command_R1
        24   -> recvr1
        24   -> send_hdr
        24   -> spiSelect
        24   -> spiUnselect
      24   send_command_R3
        24   -> recvr3
        24   -> send_hdr
        24   -> spiSelect
        24   -> spiUnselect
      24   send_hdr
        24   -> crc7
        24   -> spiSend
        24   -> wait
      16   sync
        16   -> chThdSleep
        16   -> spiReceive
        16   -> spiSelect
        16   -> spiUnselect
      16   wait
        16   -> chThdSleep
        16   -> spiReceive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "F:\\stuff\\rusefi_sourc...">
      16  ?<Constant "\"mmcConnect\"()">
      20  ?<Constant "\"mmcDisconnect\"()">
      16  ?<Constant "\"mmcErase\"()">
      16  ?<Constant "\"mmcGetInfo\"()">
      24  ?<Constant "\"mmcSequentialRead\"()">
      24  ?<Constant "\"mmcSequentialWrite\"()">
      28  ?<Constant "\"mmcStartSequentialRe...">
      28  ?<Constant "\"mmcStartSequentialWr...">
      16  ?<Constant "\"mmcStart\"()">
      28  ?<Constant "\"mmcStopSequentialRea...">
      28  ?<Constant "\"mmcStopSequentialWri...">
      12  ?<Constant "\"mmcStop\"()">
      12  ?<Constant "\"mmcSync\"()">
      20  ?<Constant "mmcConnect(), #1">
      20  ?<Constant "mmcDisconnect(), #1">
      16  ?<Constant "mmcStart(), #1">
      32  ?<Constant "mmcStartSequentialRea...">
      32  ?<Constant "mmcStartSequentialWri...">
      16  ?<Constant "mmcStop(), #1">
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      30  crc7
     256  crc7_lookup_table
     354  mmcConnect
     122  mmcDisconnect
     114  mmcErase
      50  mmcGetInfo
       2  mmcInit
      22  mmcObjectInit
     122  mmcSequentialRead
     130  mmcSequentialWrite
      58  mmcStart
     128  mmcStartSequentialRead
     124  mmcStartSequentialWrite
      58  mmcStop
      66  mmcStopSequentialRead
      58  mmcStopSequentialWrite
      60  mmcSync
      72  mmc_read
      32  mmc_vmt
      72  mmc_write
     188  read_CxD
      46  recvr1
      32  recvr3
      50  send_command_R1
      58  send_command_R3
      80  send_hdr
       2  start
       2  stop
       8  stopcmd
      54  sync
      66  wait

 
   772 bytes in section .rodata
 2 320 bytes in section .text
 
 2 320 bytes of CODE  memory
   772 bytes of CONST memory

Errors: none
Warnings: none
