###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:25 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\TIMv1\pwm_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\TIMv1\pwm_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\p #
#                       wm_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\pw #
#                       m_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\TIMv1\pwm_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/pwm_lld.c
     19           * @brief   STM32 PWM subsystem low level driver header.
     20           *
     21           * @addtogroup PWM
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_PWM || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          /*===========================================================================*/
     35          /* Driver exported variables.                                                */
     36          /*===========================================================================*/
     37          
     38          /**
     39           * @brief   PWMD1 driver identifier.
     40           * @note    The driver PWMD1 allocates the complex timer TIM1 when enabled.
     41           */
     42          #if STM32_PWM_USE_TIM1 || defined(__DOXYGEN__)
     43          PWMDriver PWMD1;
     44          #endif
     45          
     46          /**
     47           * @brief   PWMD2 driver identifier.
     48           * @note    The driver PWMD2 allocates the timer TIM2 when enabled.
     49           */
     50          #if STM32_PWM_USE_TIM2 || defined(__DOXYGEN__)
     51          PWMDriver PWMD2;
     52          #endif
     53          
     54          /**
     55           * @brief   PWMD3 driver identifier.
     56           * @note    The driver PWMD3 allocates the timer TIM3 when enabled.
     57           */
     58          #if STM32_PWM_USE_TIM3 || defined(__DOXYGEN__)
     59          PWMDriver PWMD3;
     60          #endif
     61          
     62          /**
     63           * @brief   PWMD4 driver identifier.
     64           * @note    The driver PWMD4 allocates the timer TIM4 when enabled.
     65           */
     66          #if STM32_PWM_USE_TIM4 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     67          PWMDriver PWMD4;
   \                     PWMD4:
   \   00000000                      DS8 20
     68          #endif
     69          
     70          /**
     71           * @brief   PWMD5 driver identifier.
     72           * @note    The driver PWMD5 allocates the timer TIM5 when enabled.
     73           */
     74          #if STM32_PWM_USE_TIM5 || defined(__DOXYGEN__)
     75          PWMDriver PWMD5;
     76          #endif
     77          
     78          /**
     79           * @brief   PWMD8 driver identifier.
     80           * @note    The driver PWMD8 allocates the timer TIM8 when enabled.
     81           */
     82          #if STM32_PWM_USE_TIM8 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     83          PWMDriver PWMD8;
   \                     PWMD8:
   \   00000000                      DS8 20
     84          #endif
     85          
     86          /**
     87           * @brief   PWMD9 driver identifier.
     88           * @note    The driver PWMD9 allocates the timer TIM9 when enabled.
     89           */
     90          #if STM32_PWM_USE_TIM9 || defined(__DOXYGEN__)
     91          PWMDriver PWMD9;
     92          #endif
     93          
     94          /*===========================================================================*/
     95          /* Driver local variables and types.                                         */
     96          /*===========================================================================*/
     97          
     98          /*===========================================================================*/
     99          /* Driver local functions.                                                   */
    100          /*===========================================================================*/
    101          
    102          #if STM32_PWM_USE_TIM2 || STM32_PWM_USE_TIM3 || STM32_PWM_USE_TIM4 ||       \
    103              STM32_PWM_USE_TIM5 || STM32_PWM_USE_TIM9 || defined(__DOXYGEN__)
    104          /**
    105           * @brief   Common TIM2...TIM5,TIM9 IRQ handler.
    106           * @note    It is assumed that the various sources are only activated if the
    107           *          associated callback pointer is not equal to @p NULL in order to not
    108           *          perform an extra check in a potentially critical interrupt handler.
    109           *
    110           * @param[in] pwmp      pointer to a @p PWMDriver object
    111           */

   \                                 In section .text, align 2, keep-with-next
    112          static void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
   \                     pwm_lld_serve_interrupt:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    113            uint16_t sr;
    114          
    115            sr  = pwmp->tim->SR;
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0005             MOVS     R5,R0
    116            sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
   \   0000000A   0x6920             LDR      R0,[R4, #+16]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4005             ANDS     R5,R0,R5
    117            pwmp->tim->SR = ~sr;
   \   00000012   0x6920             LDR      R0,[R4, #+16]
   \   00000014   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   0x43E9             MVNS     R1,R5
   \   00000018   0x6101             STR      R1,[R0, #+16]
    118            if ((sr & STM32_TIM_SR_CC1IF) != 0)
   \   0000001A   0x07A8             LSLS     R0,R5,#+30
   \   0000001C   0xD503             BPL.N    ??pwm_lld_serve_interrupt_0
    119              pwmp->config->channels[0].callback(pwmp);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x6861             LDR      R1,[R4, #+4]
   \   00000022   0x6909             LDR      R1,[R1, #+16]
   \   00000024   0x4788             BLX      R1
    120            if ((sr & STM32_TIM_SR_CC2IF) != 0)
   \                     ??pwm_lld_serve_interrupt_0:
   \   00000026   0x0768             LSLS     R0,R5,#+29
   \   00000028   0xD503             BPL.N    ??pwm_lld_serve_interrupt_1
    121              pwmp->config->channels[1].callback(pwmp);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x6861             LDR      R1,[R4, #+4]
   \   0000002E   0x6989             LDR      R1,[R1, #+24]
   \   00000030   0x4788             BLX      R1
    122            if ((sr & STM32_TIM_SR_CC3IF) != 0)
   \                     ??pwm_lld_serve_interrupt_1:
   \   00000032   0x0728             LSLS     R0,R5,#+28
   \   00000034   0xD503             BPL.N    ??pwm_lld_serve_interrupt_2
    123              pwmp->config->channels[2].callback(pwmp);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0x6A09             LDR      R1,[R1, #+32]
   \   0000003C   0x4788             BLX      R1
    124            if ((sr & STM32_TIM_SR_CC4IF) != 0)
   \                     ??pwm_lld_serve_interrupt_2:
   \   0000003E   0x06E8             LSLS     R0,R5,#+27
   \   00000040   0xD503             BPL.N    ??pwm_lld_serve_interrupt_3
    125              pwmp->config->channels[3].callback(pwmp);
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x6861             LDR      R1,[R4, #+4]
   \   00000046   0x6A89             LDR      R1,[R1, #+40]
   \   00000048   0x4788             BLX      R1
    126            if ((sr & STM32_TIM_SR_UIF) != 0)
   \                     ??pwm_lld_serve_interrupt_3:
   \   0000004A   0x07E8             LSLS     R0,R5,#+31
   \   0000004C   0xD503             BPL.N    ??pwm_lld_serve_interrupt_4
    127              pwmp->config->callback(pwmp);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x6861             LDR      R1,[R4, #+4]
   \   00000052   0x6889             LDR      R1,[R1, #+8]
   \   00000054   0x4788             BLX      R1
    128          }
   \                     ??pwm_lld_serve_interrupt_4:
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    129          #endif /* STM32_PWM_USE_TIM2 || ... || STM32_PWM_USE_TIM5 */
    130          
    131          /*===========================================================================*/
    132          /* Driver interrupt handlers.                                                */
    133          /*===========================================================================*/
    134          
    135          #if STM32_PWM_USE_TIM1
    136          #if !defined(STM32_TIM1_UP_HANDLER)
    137          #error "STM32_TIM1_UP_HANDLER not defined"
    138          #endif
    139          /**
    140           * @brief   TIM1 update interrupt handler.
    141           * @note    It is assumed that this interrupt is only activated if the callback
    142           *          pointer is not equal to @p NULL in order to not perform an extra
    143           *          check in a potentially critical interrupt handler.
    144           *
    145           * @isr
    146           */
    147          CH_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
    148          
    149            CH_IRQ_PROLOGUE();
    150          
    151            STM32_TIM1->SR = ~STM32_TIM_SR_UIF;
    152            PWMD1.config->callback(&PWMD1);
    153          
    154            CH_IRQ_EPILOGUE();
    155          }
    156          
    157          #if !defined(STM32_TIM1_CC_HANDLER)
    158          #error "STM32_TIM1_CC_HANDLER not defined"
    159          #endif
    160          /**
    161           * @brief   TIM1 compare interrupt handler.
    162           * @note    It is assumed that the various sources are only activated if the
    163           *          associated callback pointer is not equal to @p NULL in order to not
    164           *          perform an extra check in a potentially critical interrupt handler.
    165           *
    166           * @isr
    167           */
    168          CH_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
    169            uint16_t sr;
    170          
    171            CH_IRQ_PROLOGUE();
    172          
    173            sr = STM32_TIM1->SR & STM32_TIM1->DIER & STM32_TIM_DIER_IRQ_MASK;
    174            STM32_TIM1->SR = ~sr;
    175            if ((sr & STM32_TIM_SR_CC1IF) != 0)
    176              PWMD1.config->channels[0].callback(&PWMD1);
    177            if ((sr & STM32_TIM_SR_CC2IF) != 0)
    178              PWMD1.config->channels[1].callback(&PWMD1);
    179            if ((sr & STM32_TIM_SR_CC3IF) != 0)
    180              PWMD1.config->channels[2].callback(&PWMD1);
    181            if ((sr & STM32_TIM_SR_CC4IF) != 0)
    182              PWMD1.config->channels[3].callback(&PWMD1);
    183          
    184            CH_IRQ_EPILOGUE();
    185          }
    186          #endif /* STM32_PWM_USE_TIM1 */
    187          
    188          #if STM32_PWM_USE_TIM2
    189          #if !defined(STM32_TIM2_HANDLER)
    190          #error "STM32_TIM2_HANDLER not defined"
    191          #endif
    192          /**
    193           * @brief   TIM2 interrupt handler.
    194           *
    195           * @isr
    196           */
    197          CH_IRQ_HANDLER(STM32_TIM2_HANDLER) {
    198          
    199            CH_IRQ_PROLOGUE();
    200          
    201            pwm_lld_serve_interrupt(&PWMD2);
    202          
    203            CH_IRQ_EPILOGUE();
    204          }
    205          #endif /* STM32_PWM_USE_TIM2 */
    206          
    207          #if STM32_PWM_USE_TIM3
    208          #if !defined(STM32_TIM3_HANDLER)
    209          #error "STM32_TIM3_HANDLER not defined"
    210          #endif
    211          /**
    212           * @brief   TIM3 interrupt handler.
    213           *
    214           * @isr
    215           */
    216          CH_IRQ_HANDLER(STM32_TIM3_HANDLER) {
    217          
    218            CH_IRQ_PROLOGUE();
    219          
    220            pwm_lld_serve_interrupt(&PWMD3);
    221          
    222            CH_IRQ_EPILOGUE();
    223          }
    224          #endif /* STM32_PWM_USE_TIM3 */
    225          
    226          #if STM32_PWM_USE_TIM4
    227          #if !defined(STM32_TIM4_HANDLER)
    228          #error "STM32_TIM4_HANDLER not defined"
    229          #endif
    230          /**
    231           * @brief   TIM4 interrupt handler.
    232           *
    233           * @isr
    234           */

   \                                 In section .text, align 2, keep-with-next
    235          CH_IRQ_HANDLER(STM32_TIM4_HANDLER) {
   \                     VectorB8:
   \   00000000   0xB580             PUSH     {R7,LR}
    236          
    237            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    238          
    239            pwm_lld_serve_interrupt(&PWMD4);
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x.... 0x....      BL       pwm_lld_serve_interrupt
    240          
    241            CH_IRQ_EPILOGUE();
   \   0000000C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000010   0x.... 0x....      BL       _port_irq_epilogue
    242          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    243          #endif /* STM32_PWM_USE_TIM4 */
    244          
    245          #if STM32_PWM_USE_TIM5
    246          #if !defined(STM32_TIM5_HANDLER)
    247          #error "STM32_TIM5_HANDLER not defined"
    248          #endif
    249          /**
    250           * @brief   TIM5 interrupt handler.
    251           *
    252           * @isr
    253           */
    254          CH_IRQ_HANDLER(STM32_TIM5_HANDLER) {
    255          
    256            CH_IRQ_PROLOGUE();
    257          
    258            pwm_lld_serve_interrupt(&PWMD5);
    259          
    260            CH_IRQ_EPILOGUE();
    261          }
    262          #endif /* STM32_PWM_USE_TIM5 */
    263          
    264          #if STM32_PWM_USE_TIM8
    265          #if !defined(STM32_TIM8_UP_HANDLER)
    266          #error "STM32_TIM8_UP_HANDLER not defined"
    267          #endif
    268          /**
    269           * @brief   TIM8 update interrupt handler.
    270           * @note    It is assumed that this interrupt is only activated if the callback
    271           *          pointer is not equal to @p NULL in order to not perform an extra
    272           *          check in a potentially critical interrupt handler.
    273           *
    274           * @isr
    275           */

   \                                 In section .text, align 2, keep-with-next
    276          CH_IRQ_HANDLER(STM32_TIM8_UP_HANDLER) {
   \                     VectorF0:
   \   00000000   0xB580             PUSH     {R7,LR}
    277          
    278            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    279          
    280            STM32_TIM8->SR = ~TIM_SR_UIF;
   \   00000006   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40010410
   \   00000008   0xF07F 0x0101      MVNS     R1,#+1
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    281            PWMD8.config->callback(&PWMD8);
   \   0000000E   0x....             LDR.N    R0,??DataTable5_2
   \   00000010   0x....             LDR.N    R1,??DataTable5_2
   \   00000012   0x6849             LDR      R1,[R1, #+4]
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x4788             BLX      R1
    282          
    283            CH_IRQ_EPILOGUE();
   \   00000018   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000001C   0x.... 0x....      BL       _port_irq_epilogue
    284          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    285          
    286          #if !defined(STM32_TIM8_CC_HANDLER)
    287          #error "STM32_TIM8_CC_HANDLER not defined"
    288          #endif
    289          /**
    290           * @brief   TIM8 compare interrupt handler.
    291           * @note    It is assumed that the various sources are only activated if the
    292           *          associated callback pointer is not equal to @p NULL in order to not
    293           *          perform an extra check in a potentially critical interrupt handler.
    294           *
    295           * @isr
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          CH_IRQ_HANDLER(STM32_TIM8_CC_HANDLER) {
   \                     VectorF8:
   \   00000000   0xB510             PUSH     {R4,LR}
    298            uint16_t sr;
    299          
    300            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    301          
    302            sr = STM32_TIM8->SR & STM32_TIM8->DIER & STM32_TIM_DIER_IRQ_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40010410
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x....             LDR.N    R1,??DataTable5_3  ;; 0x4001040c
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x4008             ANDS     R0,R1,R0
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x0004             MOVS     R4,R0
    303            STM32_TIM8->SR = ~sr;
   \   00000014   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40010410
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x43E1             MVNS     R1,R4
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    304            if ((sr & STM32_TIM_SR_CC1IF) != 0)
   \   0000001C   0x07A0             LSLS     R0,R4,#+30
   \   0000001E   0xD504             BPL.N    ??VectorF8_0
    305              PWMD8.config->channels[0].callback(&PWMD8);
   \   00000020   0x....             LDR.N    R0,??DataTable5_2
   \   00000022   0x....             LDR.N    R1,??DataTable5_2
   \   00000024   0x6849             LDR      R1,[R1, #+4]
   \   00000026   0x6909             LDR      R1,[R1, #+16]
   \   00000028   0x4788             BLX      R1
    306            if ((sr & STM32_TIM_SR_CC2IF) != 0)
   \                     ??VectorF8_0:
   \   0000002A   0x0760             LSLS     R0,R4,#+29
   \   0000002C   0xD504             BPL.N    ??VectorF8_1
    307              PWMD8.config->channels[1].callback(&PWMD8);
   \   0000002E   0x....             LDR.N    R0,??DataTable5_2
   \   00000030   0x....             LDR.N    R1,??DataTable5_2
   \   00000032   0x6849             LDR      R1,[R1, #+4]
   \   00000034   0x6989             LDR      R1,[R1, #+24]
   \   00000036   0x4788             BLX      R1
    308            if ((sr & STM32_TIM_SR_CC3IF) != 0)
   \                     ??VectorF8_1:
   \   00000038   0x0720             LSLS     R0,R4,#+28
   \   0000003A   0xD504             BPL.N    ??VectorF8_2
    309              PWMD8.config->channels[2].callback(&PWMD8);
   \   0000003C   0x....             LDR.N    R0,??DataTable5_2
   \   0000003E   0x....             LDR.N    R1,??DataTable5_2
   \   00000040   0x6849             LDR      R1,[R1, #+4]
   \   00000042   0x6A09             LDR      R1,[R1, #+32]
   \   00000044   0x4788             BLX      R1
    310            if ((sr & STM32_TIM_SR_CC4IF) != 0)
   \                     ??VectorF8_2:
   \   00000046   0x06E0             LSLS     R0,R4,#+27
   \   00000048   0xD504             BPL.N    ??VectorF8_3
    311              PWMD8.config->channels[3].callback(&PWMD8);
   \   0000004A   0x....             LDR.N    R0,??DataTable5_2
   \   0000004C   0x....             LDR.N    R1,??DataTable5_2
   \   0000004E   0x6849             LDR      R1,[R1, #+4]
   \   00000050   0x6A89             LDR      R1,[R1, #+40]
   \   00000052   0x4788             BLX      R1
    312          
    313            CH_IRQ_EPILOGUE();
   \                     ??VectorF8_3:
   \   00000054   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000058   0x.... 0x....      BL       _port_irq_epilogue
    314          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    315          #endif /* STM32_PWM_USE_TIM8 */
    316          
    317          #if STM32_PWM_USE_TIM9
    318          #if !defined(STM32_TIM9_HANDLER)
    319          #error "STM32_TIM9_HANDLER not defined"
    320          #endif
    321          /**
    322           * @brief   TIM9 interrupt handler.
    323           *
    324           * @isr
    325           */
    326          CH_IRQ_HANDLER(STM32_TIM9_HANDLER) {
    327          
    328            CH_IRQ_PROLOGUE();
    329          
    330            pwm_lld_serve_interrupt(&PWMD9);
    331          
    332            CH_IRQ_EPILOGUE();
    333          }
    334          #endif /* STM32_PWM_USE_TIM9 */
    335          
    336          /*===========================================================================*/
    337          /* Driver exported functions.                                                */
    338          /*===========================================================================*/
    339          
    340          /**
    341           * @brief   Low level PWM driver initialization.
    342           *
    343           * @notapi
    344           */

   \                                 In section .text, align 2, keep-with-next
    345          void pwm_lld_init(void) {
   \                     pwm_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    346          
    347          #if STM32_PWM_USE_TIM1
    348            /* Driver initialization.*/
    349            pwmObjectInit(&PWMD1);
    350            PWMD1.tim = STM32_TIM1;
    351          #endif
    352          
    353          #if STM32_PWM_USE_TIM2
    354            /* Driver initialization.*/
    355            pwmObjectInit(&PWMD2);
    356            PWMD2.tim = STM32_TIM2;
    357          #endif
    358          
    359          #if STM32_PWM_USE_TIM3
    360            /* Driver initialization.*/
    361            pwmObjectInit(&PWMD3);
    362            PWMD3.tim = STM32_TIM3;
    363          #endif
    364          
    365          #if STM32_PWM_USE_TIM4
    366            /* Driver initialization.*/
    367            pwmObjectInit(&PWMD4);
   \   00000002   0x....             LDR.N    R0,??DataTable5
   \   00000004   0x.... 0x....      BL       pwmObjectInit
    368            PWMD4.tim = STM32_TIM4;
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x....             LDR.N    R1,??DataTable5_4  ;; 0x40000800
   \   0000000C   0x6101             STR      R1,[R0, #+16]
    369          #endif
    370          
    371          #if STM32_PWM_USE_TIM5
    372            /* Driver initialization.*/
    373            pwmObjectInit(&PWMD5);
    374            PWMD5.tim = STM32_TIM5;
    375          #endif
    376          
    377          #if STM32_PWM_USE_TIM8
    378            /* Driver initialization.*/
    379            pwmObjectInit(&PWMD8);
   \   0000000E   0x....             LDR.N    R0,??DataTable5_2
   \   00000010   0x.... 0x....      BL       pwmObjectInit
    380            PWMD8.tim = STM32_TIM8;
   \   00000014   0x....             LDR.N    R0,??DataTable5_2
   \   00000016   0x....             LDR.N    R1,??DataTable5_5  ;; 0x40010400
   \   00000018   0x6101             STR      R1,[R0, #+16]
    381          #endif
    382          
    383          #if STM32_PWM_USE_TIM9
    384            /* Driver initialization.*/
    385            pwmObjectInit(&PWMD9);
    386            PWMD9.tim = STM32_TIM9;
    387          #endif
    388          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    389          
    390          /**
    391           * @brief   Configures and activates the PWM peripheral.
    392           * @note    Starting a driver that is already in the @p PWM_READY state
    393           *          disables all the active channels.
    394           *
    395           * @param[in] pwmp      pointer to a @p PWMDriver object
    396           *
    397           * @notapi
    398           */

   \                                 In section .text, align 2, keep-with-next
    399          void pwm_lld_start(PWMDriver *pwmp) {
   \                     pwm_lld_start:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    400            uint32_t psc;
    401            uint32_t ccer;
    402          
    403            if (pwmp->state == PWM_STOP) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD13C             BNE.N    ??pwm_lld_start_0
    404              /* Clock activation and timer reset.*/
    405          #if STM32_PWM_USE_TIM1
    406              if (&PWMD1 == pwmp) {
    407                rccEnableTIM1(FALSE);
    408                rccResetTIM1();
    409                nvicEnableVector(STM32_TIM1_UP_NUMBER,
    410                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM1_IRQ_PRIORITY));
    411                nvicEnableVector(STM32_TIM1_CC_NUMBER,
    412                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM1_IRQ_PRIORITY));
    413          #if defined(STM32_TIM1CLK)
    414                pwmp->clock = STM32_TIM1CLK;
    415          #else
    416                pwmp->clock = STM32_TIMCLK2;
    417          #endif
    418              }
    419          #endif
    420          #if STM32_PWM_USE_TIM2
    421              if (&PWMD2 == pwmp) {
    422                rccEnableTIM2(FALSE);
    423                rccResetTIM2();
    424                nvicEnableVector(STM32_TIM2_NUMBER,
    425                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM2_IRQ_PRIORITY));
    426                pwmp->clock = STM32_TIMCLK1;
    427              }
    428          #endif
    429          #if STM32_PWM_USE_TIM3
    430              if (&PWMD3 == pwmp) {
    431                rccEnableTIM3(FALSE);
    432                rccResetTIM3();
    433                nvicEnableVector(STM32_TIM3_NUMBER,
    434                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM3_IRQ_PRIORITY));
    435                pwmp->clock = STM32_TIMCLK1;
    436              }
    437          #endif
    438          #if STM32_PWM_USE_TIM4
    439              if (&PWMD4 == pwmp) {
   \   0000000A   0x....             LDR.N    R0,??DataTable5
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD114             BNE.N    ??pwm_lld_start_1
    440                rccEnableTIM4(FALSE);
   \   00000010   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40023840
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000018   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40023840
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    441                rccResetTIM4();
   \   0000001C   0x....             LDR.N    R0,??DataTable5_7  ;; 0x40023820
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000024   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40023820
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0x....             LDR.N    R0,??DataTable5_7  ;; 0x40023820
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    442                nvicEnableVector(STM32_TIM4_NUMBER,
    443                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM4_IRQ_PRIORITY));
   \   0000002E   0x2170             MOVS     R1,#+112
   \   00000030   0x201E             MOVS     R0,#+30
   \   00000032   0x.... 0x....      BL       nvicEnableVector
    444                pwmp->clock = STM32_TIMCLK1;
   \   00000036   0x....             LDR.N    R0,??DataTable5_8  ;; 0x501bd00
   \   00000038   0x60E0             STR      R0,[R4, #+12]
    445              }
    446          #endif
    447          
    448          #if STM32_PWM_USE_TIM5
    449              if (&PWMD5 == pwmp) {
    450                rccEnableTIM5(FALSE);
    451                rccResetTIM5();
    452                nvicEnableVector(STM32_TIM5_NUMBER,
    453                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM5_IRQ_PRIORITY));
    454                pwmp->clock = STM32_TIMCLK1;
    455              }
    456          #endif
    457          #if STM32_PWM_USE_TIM8
    458              if (&PWMD8 == pwmp) {
   \                     ??pwm_lld_start_1:
   \   0000003A   0x....             LDR.N    R0,??DataTable5_2
   \   0000003C   0x42A0             CMP      R0,R4
   \   0000003E   0xD118             BNE.N    ??pwm_lld_start_2
    459                rccEnableTIM8(FALSE);
   \   00000040   0x....             LDR.N    R0,??DataTable5_9  ;; 0x40023844
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000048   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40023844
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    460                rccResetTIM8();
   \   0000004C   0x....             LDR.N    R0,??DataTable5_10  ;; 0x40023824
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable5_10  ;; 0x40023824
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \   00000058   0x....             LDR.N    R0,??DataTable5_10  ;; 0x40023824
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    461                nvicEnableVector(STM32_TIM8_UP_NUMBER,
    462                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM8_IRQ_PRIORITY));
   \   0000005E   0x2170             MOVS     R1,#+112
   \   00000060   0x202C             MOVS     R0,#+44
   \   00000062   0x.... 0x....      BL       nvicEnableVector
    463                nvicEnableVector(STM32_TIM8_CC_NUMBER,
    464                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM8_IRQ_PRIORITY));
   \   00000066   0x2170             MOVS     R1,#+112
   \   00000068   0x202E             MOVS     R0,#+46
   \   0000006A   0x.... 0x....      BL       nvicEnableVector
    465          #if defined(STM32_TIM8CLK)
    466                pwmp->clock = STM32_TIM8CLK;
    467          #else
    468                pwmp->clock = STM32_TIMCLK2;
   \   0000006E   0x....             LDR.N    R0,??DataTable5_11  ;; 0xa037a00
   \   00000070   0x60E0             STR      R0,[R4, #+12]
    469          #endif
    470              }
    471          #endif
    472          #if STM32_PWM_USE_TIM9
    473              if (&PWMD9 == pwmp) {
    474                rccEnableTIM9(FALSE);
    475                rccResetTIM9();
    476                nvicEnableVector(STM32_TIM9_NUMBER,
    477                                 CORTEX_PRIORITY_MASK(STM32_PWM_TIM9_IRQ_PRIORITY));
    478                pwmp->clock = STM32_TIMCLK2;
    479              }
    480          #endif
    481          
    482              /* All channels configured in PWM1 mode with preload enabled and will
    483                 stay that way until the driver is stopped.*/
    484              pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
    485                                 STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
   \                     ??pwm_lld_start_2:
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0xF646 0x0168      MOVW     R1,#+26728
   \   00000078   0x6181             STR      R1,[R0, #+24]
    486              pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
    487                                 STM32_TIM_CCMR2_OC4M(6) | STM32_TIM_CCMR2_OC4PE;
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0xF646 0x0168      MOVW     R1,#+26728
   \   00000080   0x61C1             STR      R1,[R0, #+28]
   \   00000082   0xE011             B.N      ??pwm_lld_start_3
    488            }
    489            else {
    490              /* Driver re-configuration scenario, it must be stopped first.*/
    491              pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
   \                     ??pwm_lld_start_0:
   \   00000084   0x6920             LDR      R0,[R4, #+16]
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6001             STR      R1,[R0, #+0]
    492              pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
   \   0000008A   0x6920             LDR      R0,[R4, #+16]
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x6341             STR      R1,[R0, #+52]
    493              pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
   \   00000090   0x6920             LDR      R0,[R4, #+16]
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x6381             STR      R1,[R0, #+56]
    494              pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
   \   00000096   0x6920             LDR      R0,[R4, #+16]
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x63C1             STR      R1,[R0, #+60]
    495              pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
   \   0000009C   0x6920             LDR      R0,[R4, #+16]
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x6401             STR      R1,[R0, #+64]
    496              pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
   \   000000A2   0x6920             LDR      R0,[R4, #+16]
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x6241             STR      R1,[R0, #+36]
    497            }
    498          
    499            /* Timer configuration.*/
    500            psc = (pwmp->clock / pwmp->config->frequency) - 1;
   \                     ??pwm_lld_start_3:
   \   000000A8   0x68E0             LDR      R0,[R4, #+12]
   \   000000AA   0x6861             LDR      R1,[R4, #+4]
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000B2   0x1E40             SUBS     R0,R0,#+1
   \   000000B4   0x0005             MOVS     R5,R0
    501            chDbgAssert((psc <= 0xFFFF) &&
    502                        ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
    503                        "pwm_lld_start(), #1", "invalid frequency");
   \   000000B6   0xF5B5 0x3F80      CMP      R5,#+65536
   \   000000BA   0xD206             BCS.N    ??pwm_lld_start_4
   \   000000BC   0x1C68             ADDS     R0,R5,#+1
   \   000000BE   0x6861             LDR      R1,[R4, #+4]
   \   000000C0   0x6809             LDR      R1,[R1, #+0]
   \   000000C2   0x4348             MULS     R0,R1,R0
   \   000000C4   0x68E1             LDR      R1,[R4, #+12]
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xD002             BEQ.N    ??pwm_lld_start_5
   \                     ??pwm_lld_start_4:
   \   000000CA   0x....             LDR.N    R0,??DataTable5_12
   \   000000CC   0x.... 0x....      BL       chDbgPanic
    504            pwmp->tim->PSC  = (uint16_t)psc;
   \                     ??pwm_lld_start_5:
   \   000000D0   0x6920             LDR      R0,[R4, #+16]
   \   000000D2   0x0029             MOVS     R1,R5
   \   000000D4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D6   0x6281             STR      R1,[R0, #+40]
    505            pwmp->tim->ARR  = (uint16_t)(pwmp->period - 1);
   \   000000D8   0x6920             LDR      R0,[R4, #+16]
   \   000000DA   0x8921             LDRH     R1,[R4, #+8]
   \   000000DC   0x1E49             SUBS     R1,R1,#+1
   \   000000DE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E0   0x62C1             STR      R1,[R0, #+44]
    506            pwmp->tim->CR2  = pwmp->config->cr2;
   \   000000E2   0x6920             LDR      R0,[R4, #+16]
   \   000000E4   0x6861             LDR      R1,[R4, #+4]
   \   000000E6   0x6AC9             LDR      R1,[R1, #+44]
   \   000000E8   0x6041             STR      R1,[R0, #+4]
    507          
    508            /* Output enables and polarities setup.*/
    509            ccer = 0;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x0006             MOVS     R6,R0
    510            switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
   \   000000EE   0x6860             LDR      R0,[R4, #+4]
   \   000000F0   0x7B00             LDRB     R0,[R0, #+12]
   \   000000F2   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xD003             BEQ.N    ??pwm_lld_start_6
   \   000000FA   0x2802             CMP      R0,#+2
   \   000000FC   0xD103             BNE.N    ??pwm_lld_start_7
    511            case PWM_OUTPUT_ACTIVE_LOW:
    512              ccer |= STM32_TIM_CCER_CC1P;
   \                     ??pwm_lld_start_8:
   \   000000FE   0xF056 0x0602      ORRS     R6,R6,#0x2
    513            case PWM_OUTPUT_ACTIVE_HIGH:
    514              ccer |= STM32_TIM_CCER_CC1E;
   \                     ??pwm_lld_start_6:
   \   00000102   0xF056 0x0601      ORRS     R6,R6,#0x1
    515            default:
    516              ;
    517            }
    518            switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
   \                     ??pwm_lld_start_7:
   \   00000106   0x6860             LDR      R0,[R4, #+4]
   \   00000108   0x7D00             LDRB     R0,[R0, #+20]
   \   0000010A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000010E   0x2801             CMP      R0,#+1
   \   00000110   0xD003             BEQ.N    ??pwm_lld_start_9
   \   00000112   0x2802             CMP      R0,#+2
   \   00000114   0xD103             BNE.N    ??pwm_lld_start_10
    519            case PWM_OUTPUT_ACTIVE_LOW:
    520              ccer |= STM32_TIM_CCER_CC2P;
   \                     ??pwm_lld_start_11:
   \   00000116   0xF056 0x0620      ORRS     R6,R6,#0x20
    521            case PWM_OUTPUT_ACTIVE_HIGH:
    522              ccer |= STM32_TIM_CCER_CC2E;
   \                     ??pwm_lld_start_9:
   \   0000011A   0xF056 0x0610      ORRS     R6,R6,#0x10
    523            default:
    524              ;
    525            }
    526            switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
   \                     ??pwm_lld_start_10:
   \   0000011E   0x6860             LDR      R0,[R4, #+4]
   \   00000120   0x7F00             LDRB     R0,[R0, #+28]
   \   00000122   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000126   0x2801             CMP      R0,#+1
   \   00000128   0xD003             BEQ.N    ??pwm_lld_start_12
   \   0000012A   0x2802             CMP      R0,#+2
   \   0000012C   0xD103             BNE.N    ??pwm_lld_start_13
    527            case PWM_OUTPUT_ACTIVE_LOW:
    528              ccer |= STM32_TIM_CCER_CC3P;
   \                     ??pwm_lld_start_14:
   \   0000012E   0xF456 0x7600      ORRS     R6,R6,#0x200
    529            case PWM_OUTPUT_ACTIVE_HIGH:
    530              ccer |= STM32_TIM_CCER_CC3E;
   \                     ??pwm_lld_start_12:
   \   00000132   0xF456 0x7680      ORRS     R6,R6,#0x100
    531            default:
    532              ;
    533            }
    534            switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
   \                     ??pwm_lld_start_13:
   \   00000136   0x6860             LDR      R0,[R4, #+4]
   \   00000138   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   0000013C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD003             BEQ.N    ??pwm_lld_start_15
   \   00000144   0x2802             CMP      R0,#+2
   \   00000146   0xD103             BNE.N    ??pwm_lld_start_16
    535            case PWM_OUTPUT_ACTIVE_LOW:
    536              ccer |= STM32_TIM_CCER_CC4P;
   \                     ??pwm_lld_start_17:
   \   00000148   0xF456 0x5600      ORRS     R6,R6,#0x2000
    537            case PWM_OUTPUT_ACTIVE_HIGH:
    538              ccer |= STM32_TIM_CCER_CC4E;
   \                     ??pwm_lld_start_15:
   \   0000014C   0xF456 0x5680      ORRS     R6,R6,#0x1000
    539            default:
    540              ;
    541            }
    542          #if STM32_PWM_USE_ADVANCED
    543          #if STM32_PWM_USE_TIM1 && !STM32_PWM_USE_TIM8
    544            if (&PWMD1 == pwmp) {
    545          #endif
    546          #if !STM32_PWM_USE_TIM1 && STM32_PWM_USE_TIM8
    547            if (&PWMD8 == pwmp) {
    548          #endif
    549          #if STM32_PWM_USE_TIM1 && STM32_PWM_USE_TIM8
    550            if ((&PWMD1 == pwmp) || (&PWMD8 == pwmp)) {
    551          #endif
    552              switch (pwmp->config->channels[0].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
    553              case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
    554                ccer |= STM32_TIM_CCER_CC1NP;
    555              case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
    556                ccer |= STM32_TIM_CCER_CC1NE;
    557              default:
    558                ;
    559              }
    560              switch (pwmp->config->channels[1].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
    561              case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
    562                ccer |= STM32_TIM_CCER_CC2NP;
    563              case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
    564                ccer |= STM32_TIM_CCER_CC2NE;
    565              default:
    566                ;
    567              }
    568              switch (pwmp->config->channels[2].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
    569              case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
    570                ccer |= STM32_TIM_CCER_CC3NP;
    571              case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
    572                ccer |= STM32_TIM_CCER_CC3NE;
    573              default:
    574                ;
    575              }
    576            }
    577          #endif /* STM32_PWM_USE_ADVANCED*/
    578          
    579            pwmp->tim->CCER  = ccer;
   \                     ??pwm_lld_start_16:
   \   00000150   0x6920             LDR      R0,[R4, #+16]
   \   00000152   0x6206             STR      R6,[R0, #+32]
    580            pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
   \   00000154   0x6920             LDR      R0,[R4, #+16]
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0x6141             STR      R1,[R0, #+20]
    581            pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
   \   0000015A   0x6920             LDR      R0,[R4, #+16]
   \   0000015C   0x2100             MOVS     R1,#+0
   \   0000015E   0x6101             STR      R1,[R0, #+16]
    582            pwmp->tim->DIER  = (pwmp->config->callback == NULL ? 0 : STM32_TIM_DIER_UIE) |
    583                               (pwmp->config->dier & ~STM32_TIM_DIER_IRQ_MASK);
   \   00000160   0x6860             LDR      R0,[R4, #+4]
   \   00000162   0x6880             LDR      R0,[R0, #+8]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD101             BNE.N    ??pwm_lld_start_18
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0xE000             B.N      ??pwm_lld_start_19
   \                     ??pwm_lld_start_18:
   \   0000016C   0x2001             MOVS     R0,#+1
   \                     ??pwm_lld_start_19:
   \   0000016E   0x6861             LDR      R1,[R4, #+4]
   \   00000170   0x6B09             LDR      R1,[R1, #+48]
   \   00000172   0x0A09             LSRS     R1,R1,#+8
   \   00000174   0x0209             LSLS     R1,R1,#+8
   \   00000176   0x4308             ORRS     R0,R1,R0
   \   00000178   0x6921             LDR      R1,[R4, #+16]
   \   0000017A   0x60C8             STR      R0,[R1, #+12]
    584          #if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    585          #if STM32_PWM_USE_ADVANCED
    586            pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
    587          #else
    588            pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
   \   0000017C   0x6920             LDR      R0,[R4, #+16]
   \   0000017E   0xF44F 0x4100      MOV      R1,#+32768
   \   00000182   0x6441             STR      R1,[R0, #+68]
    589          #endif
    590          #endif
    591            /* Timer configured and started.*/
    592            pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
    593                               STM32_TIM_CR1_CEN;
   \   00000184   0x6920             LDR      R0,[R4, #+16]
   \   00000186   0x2185             MOVS     R1,#+133
   \   00000188   0x6001             STR      R1,[R0, #+0]
    594          }
   \   0000018A   0xBD70             POP      {R4-R6,PC}       ;; return
    595          
    596          /**
    597           * @brief   Deactivates the PWM peripheral.
    598           *
    599           * @param[in] pwmp      pointer to a @p PWMDriver object
    600           *
    601           * @notapi
    602           */

   \                                 In section .text, align 2, keep-with-next
    603          void pwm_lld_stop(PWMDriver *pwmp) {
   \                     pwm_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    604          
    605            /* If in ready state then disables the PWM clock.*/
    606            if (pwmp->state == PWM_READY) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD126             BNE.N    ??pwm_lld_stop_0
    607              pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
   \   0000000A   0x6920             LDR      R0,[R4, #+16]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    608              pwmp->tim->DIER = 0;                    /* All IRQs disabled.           */
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x60C1             STR      R1,[R0, #+12]
    609              pwmp->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
   \   00000016   0x6920             LDR      R0,[R4, #+16]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6101             STR      R1,[R0, #+16]
    610          #if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
    611              pwmp->tim->BDTR  = 0;
   \   0000001C   0x6920             LDR      R0,[R4, #+16]
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6441             STR      R1,[R0, #+68]
    612          #endif
    613          
    614          #if STM32_PWM_USE_TIM1
    615              if (&PWMD1 == pwmp) {
    616                nvicDisableVector(STM32_TIM1_UP_NUMBER);
    617                nvicDisableVector(STM32_TIM1_CC_NUMBER);
    618                rccDisableTIM1(FALSE);
    619              }
    620          #endif
    621          #if STM32_PWM_USE_TIM2
    622              if (&PWMD2 == pwmp) {
    623                nvicDisableVector(STM32_TIM2_NUMBER);
    624                rccDisableTIM2(FALSE);
    625              }
    626          #endif
    627          #if STM32_PWM_USE_TIM3
    628              if (&PWMD3 == pwmp) {
    629                nvicDisableVector(STM32_TIM3_NUMBER);
    630                rccDisableTIM3(FALSE);
    631              }
    632          #endif
    633          #if STM32_PWM_USE_TIM4
    634              if (&PWMD4 == pwmp) {
   \   00000022   0x....             LDR.N    R0,??DataTable5
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD108             BNE.N    ??pwm_lld_stop_1
    635                nvicDisableVector(STM32_TIM4_NUMBER);
   \   00000028   0x201E             MOVS     R0,#+30
   \   0000002A   0x.... 0x....      BL       nvicDisableVector
    636                rccDisableTIM4(FALSE);
   \   0000002E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40023840
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000036   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40023840
   \   00000038   0x6008             STR      R0,[R1, #+0]
    637              }
    638          #endif
    639          #if STM32_PWM_USE_TIM5
    640              if (&PWMD5 == pwmp) {
    641                nvicDisableVector(STM32_TIM5_NUMBER);
    642                rccDisableTIM5(FALSE);
    643              }
    644          #endif
    645          #if STM32_PWM_USE_TIM8
    646              if (&PWMD8 == pwmp) {
   \                     ??pwm_lld_stop_1:
   \   0000003A   0x....             LDR.N    R0,??DataTable5_2
   \   0000003C   0x42A0             CMP      R0,R4
   \   0000003E   0xD10B             BNE.N    ??pwm_lld_stop_0
    647                nvicDisableVector(STM32_TIM8_UP_NUMBER);
   \   00000040   0x202C             MOVS     R0,#+44
   \   00000042   0x.... 0x....      BL       nvicDisableVector
    648                nvicDisableVector(STM32_TIM8_CC_NUMBER);
   \   00000046   0x202E             MOVS     R0,#+46
   \   00000048   0x.... 0x....      BL       nvicDisableVector
    649                rccDisableTIM8(FALSE);
   \   0000004C   0x....             LDR.N    R0,??DataTable5_9  ;; 0x40023844
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000054   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40023844
   \   00000056   0x6008             STR      R0,[R1, #+0]
    650              }
    651          #endif
    652          #if STM32_PWM_USE_TIM9
    653              if (&PWMD9 == pwmp) {
    654                nvicDisableVector(STM32_TIM9_NUMBER);
    655                rccDisableTIM9(FALSE);
    656              }
    657          #endif
    658            }
    659          }
   \                     ??pwm_lld_stop_0:
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    660          
    661          /**
    662           * @brief   Enables a PWM channel.
    663           * @pre     The PWM unit must have been activated using @p pwmStart().
    664           * @post    The channel is active using the specified configuration.
    665           * @note    The function has effect at the next cycle start.
    666           *
    667           * @param[in] pwmp      pointer to a @p PWMDriver object
    668           * @param[in] channel   PWM channel identifier (0...PWM_CHANNELS-1)
    669           * @param[in] width     PWM pulse width as clock pulses number
    670           *
    671           * @notapi
    672           */

   \                                 In section .text, align 2, keep-with-next
    673          void pwm_lld_enable_channel(PWMDriver *pwmp,
    674                                      pwmchannel_t channel,
    675                                      pwmcnt_t width) {
   \                     pwm_lld_enable_channel:
   \   00000000   0xB430             PUSH     {R4,R5}
    676          
    677            pwmp->tim->CCR[channel] = width;                  /* New duty cycle.      */
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x6903             LDR      R3,[R0, #+16]
   \   00000006   0xEB13 0x0381      ADDS     R3,R3,R1, LSL #+2
   \   0000000A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000C   0x635A             STR      R2,[R3, #+52]
    678            /* If there is a callback defined for the channel then the associated
    679               interrupt must be enabled.*/
    680            if (pwmp->config->channels[channel].callback != NULL) {
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x6843             LDR      R3,[R0, #+4]
   \   00000012   0xEB13 0x03C1      ADDS     R3,R3,R1, LSL #+3
   \   00000016   0x691B             LDR      R3,[R3, #+16]
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xD00F             BEQ.N    ??pwm_lld_enable_channel_0
    681              uint32_t dier = pwmp->tim->DIER;
   \   0000001C   0x6903             LDR      R3,[R0, #+16]
   \   0000001E   0x68DB             LDR      R3,[R3, #+12]
    682              /* If the IRQ is not already enabled care must be taken to clear it,
    683                 it is probably already pending because the timer is running.*/
    684              if ((dier & (2 << channel)) == 0) {
   \   00000020   0x2402             MOVS     R4,#+2
   \   00000022   0x408C             LSLS     R4,R4,R1
   \   00000024   0x4223             TST      R3,R4
   \   00000026   0xD109             BNE.N    ??pwm_lld_enable_channel_0
    685                pwmp->tim->DIER = dier | (2 << channel);
   \   00000028   0x2402             MOVS     R4,#+2
   \   0000002A   0x408C             LSLS     R4,R4,R1
   \   0000002C   0x431C             ORRS     R4,R4,R3
   \   0000002E   0x6905             LDR      R5,[R0, #+16]
   \   00000030   0x60EC             STR      R4,[R5, #+12]
    686                pwmp->tim->SR   = ~(2 << channel);
   \   00000032   0x6904             LDR      R4,[R0, #+16]
   \   00000034   0x2502             MOVS     R5,#+2
   \   00000036   0x408D             LSLS     R5,R5,R1
   \   00000038   0x43ED             MVNS     R5,R5
   \   0000003A   0x6125             STR      R5,[R4, #+16]
    687              }
    688            }
    689          }
   \                     ??pwm_lld_enable_channel_0:
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    690          
    691          /**
    692           * @brief   Disables a PWM channel.
    693           * @pre     The PWM unit must have been activated using @p pwmStart().
    694           * @post    The channel is disabled and its output line returned to the
    695           *          idle state.
    696           * @note    The function has effect at the next cycle start.
    697           *
    698           * @param[in] pwmp      pointer to a @p PWMDriver object
    699           * @param[in] channel   PWM channel identifier (0...PWM_CHANNELS-1)
    700           *
    701           * @notapi
    702           */

   \                                 In section .text, align 2, keep-with-next
    703          void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel) {
    704          
    705            pwmp->tim->CCR[channel] = 0;
   \                     pwm_lld_disable_channel:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6902             LDR      R2,[R0, #+16]
   \   00000004   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x6353             STR      R3,[R2, #+52]
    706            pwmp->tim->DIER &= ~(2 << channel);
   \   0000000C   0x6902             LDR      R2,[R0, #+16]
   \   0000000E   0x68D2             LDR      R2,[R2, #+12]
   \   00000010   0x2302             MOVS     R3,#+2
   \   00000012   0x408B             LSLS     R3,R3,R1
   \   00000014   0x439A             BICS     R2,R2,R3
   \   00000016   0x6903             LDR      R3,[R0, #+16]
   \   00000018   0x60DA             STR      R2,[R3, #+12]
    707          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     PWMD4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40010410         DC32     0x40010410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     PWMD8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x4001040C         DC32     0x4001040c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x0501BD00         DC32     0x501bd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x0A037A00         DC32     0xa037a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     `?<Constant "pwm_lld_start(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "pwm_lld_start(), #1">`:
   \   00000000   0x70 0x77          DC8 "pwm_lld_start(), #1"
   \              0x6D 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
    708          
    709          #endif /* HAL_USE_PWM */
    710          
    711          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   VectorB8
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> pwm_lld_serve_interrupt
       8   VectorF0
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   VectorF8
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       0   pwm_lld_disable_channel
       8   pwm_lld_enable_channel
       8   pwm_lld_init
         8   -> pwmObjectInit
      16   pwm_lld_serve_interrupt
        16   -- Indirect call
      16   pwm_lld_start
        16   -> chDbgPanic
        16   -> nvicEnableVector
       8   pwm_lld_stop
         8   -> nvicDisableVector


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "pwm_lld_start(), #1">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      20  PWMD4
      20  PWMD8
      22  VectorB8
      34  VectorF0
      94  VectorF8
      28  pwm_lld_disable_channel
      64  pwm_lld_enable_channel
      28  pwm_lld_init
      88  pwm_lld_serve_interrupt
     396  pwm_lld_start
      90  pwm_lld_stop

 
  40 bytes in section .bss
  20 bytes in section .rodata
 896 bytes in section .text
 
 896 bytes of CODE  memory
  20 bytes of CONST memory
  40 bytes of DATA  memory

Errors: none
Warnings: 1
