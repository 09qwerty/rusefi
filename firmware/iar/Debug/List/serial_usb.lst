###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:01 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\serial_usb.c                                       #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\serial_usb.c -lCN F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\Debug\List\ -o                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\s #
#                       erial_usb.lst                                         #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\se #
#                       rial_usb.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\serial_usb.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    serial_usb.c
     30           * @brief   Serial over USB Driver code.
     31           *
     32           * @addtogroup SERIAL_USB
     33           * @{
     34           */
     35          
     36          #include "ch.h"
     37          #include "hal.h"
     38          
     39          #if HAL_USE_SERIAL_USB || defined(__DOXYGEN__)
     40          
     41          /*===========================================================================*/
     42          /* Driver local definitions.                                                 */
     43          /*===========================================================================*/
     44          
     45          /*===========================================================================*/
     46          /* Driver exported variables.                                                */
     47          /*===========================================================================*/
     48          
     49          /*===========================================================================*/
     50          /* Driver local variables and types.                                         */
     51          /*===========================================================================*/
     52          
     53          /*
     54           * Current Line Coding.
     55           */

   \                                 In section .data, align 4
     56          static cdc_linecoding_t linecoding = {
   \                     linecoding:
   \   00000000   0x00 0x96          DC8 0, 150, 0, 0, 0, 0, 8, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x08 0x00    
     57            {0x00, 0x96, 0x00, 0x00},             /* 38400.                           */
     58            LC_STOP_1, LC_PARITY_NONE, 8
     59          };
     60          
     61          /*===========================================================================*/
     62          /* Driver local functions.                                                   */
     63          /*===========================================================================*/
     64          
     65          /*
     66           * Interface implementation.
     67           */
     68          

   \                                 In section .text, align 2, keep-with-next
     69          static size_t write(void *ip, const uint8_t *bp, size_t n) {
   \                     write:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     70          
     71            return chOQWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp,
     72                                    n, TIME_INFINITE);
   \   00000008   0xF05F 0x33FF      MOVS     R3,#-1
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000014   0x.... 0x....      BL       chOQWriteTimeout
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
     73          }
     74          

   \                                 In section .text, align 2, keep-with-next
     75          static size_t read(void *ip, uint8_t *bp, size_t n) {
   \                     read:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     76          
     77            return chIQReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp,
     78                                   n, TIME_INFINITE);
   \   00000008   0xF05F 0x33FF      MOVS     R3,#-1
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000014   0x.... 0x....      BL       chIQReadTimeout
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
     79          }
     80          

   \                                 In section .text, align 2, keep-with-next
     81          static msg_t put(void *ip, uint8_t b) {
   \                     put:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     82          
     83            return chOQPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000012   0x.... 0x....      BL       chOQPutTimeout
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     84          }
     85          

   \                                 In section .text, align 2, keep-with-next
     86          static msg_t get(void *ip) {
   \                     get:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     87          
     88            return chIQGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
   \   00000004   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000008   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000000C   0x.... 0x....      BL       chIQGetTimeout
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
     89          }
     90          

   \                                 In section .text, align 2, keep-with-next
     91          static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
   \                     putt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     92          
     93            return chOQPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000012   0x.... 0x....      BL       chOQPutTimeout
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          static msg_t gett(void *ip, systime_t timeout) {
   \                     gett:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     97          
     98            return chIQGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000000C   0x.... 0x....      BL       chIQGetTimeout
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     99          }
    100          

   \                                 In section .text, align 2, keep-with-next
    101          static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {
   \                     writet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    102          
    103            return chOQWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, time);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000014   0x.... 0x....      BL       chOQWriteTimeout
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    104          }
    105          

   \                                 In section .text, align 2, keep-with-next
    106          static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {
   \                     readt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    107          
    108            return chIQReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp, n, time);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000014   0x.... 0x....      BL       chIQReadTimeout
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    109          }
    110          

   \                                 In section .rodata, align 4
    111          static const struct SerialUSBDriverVMT vmt = {
   \                     vmt:
   \   00000000   0x........         DC32 write, read, put, get, putt, gett, writet, readt
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
    112            write, read, put, get,
    113            putt, gett, writet, readt
    114          };
    115          
    116          /**
    117           * @brief   Notification of data removed from the input queue.
    118           */

   \                                 In section .text, align 2, keep-with-next
    119          static void inotify(GenericQueue *qp) {
   \                     inotify:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    120            size_t n, maxsize;
    121            SerialUSBDriver *sdup = chQGetLink(qp);
   \   00000004   0x6A27             LDR      R7,[R4, #+32]
    122          
    123            /* If the USB driver is not in the appropriate state then transactions
    124               must not be started.*/
    125            if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
    126                (sdup->state != SDU_READY))
   \   00000006   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD102             BNE.N    ??inotify_0
   \   00000012   0x7A38             LDRB     R0,[R7, #+8]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD000             BEQ.N    ??inotify_1
    127              return;
   \                     ??inotify_0:
   \   00000018   0xE03E             B.N      ??inotify_2
    128          
    129            /* If there is in the queue enough space to hold at least one packet and
    130               a transaction is not yet started then a new transaction is started for
    131               the available space.*/
    132            maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
   \                     ??inotify_1:
   \   0000001A   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   0000001E   0x7940             LDRB     R0,[R0, #+5]
   \   00000020   0xF8D7 0x1254      LDR      R1,[R7, #+596]
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0x8A40             LDRH     R0,[R0, #+18]
   \   0000002E   0x0006             MOVS     R6,R0
    133            if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out) &&
    134                ((n = chIQGetEmptyI(&sdup->iqueue)) >= maxsize)) {
   \   00000030   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x8940             LDRH     R0,[R0, #+10]
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xF8D7 0x2254      LDR      R2,[R7, #+596]
   \   0000003E   0xF992 0x2005      LDRSB    R2,[R2, #+5]
   \   00000042   0x4091             LSLS     R1,R1,R2
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD127             BNE.N    ??inotify_3
   \   00000048   0x69F8             LDR      R0,[R7, #+28]
   \   0000004A   0x69B9             LDR      R1,[R7, #+24]
   \   0000004C   0x1A40             SUBS     R0,R0,R1
   \   0000004E   0x6979             LDR      R1,[R7, #+20]
   \   00000050   0x1A45             SUBS     R5,R0,R1
   \   00000052   0x42B5             CMP      R5,R6
   \   00000054   0xD320             BCC.N    ??inotify_3
    135              chSysUnlock();
   \   00000056   0x.... 0x....      BL       dbg_check_unlock
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF380 0x8811      MSR      BASEPRI,R0
    136          
    137              n = (n / maxsize) * maxsize;
   \   00000060   0xFBB5 0xF0F6      UDIV     R0,R5,R6
   \   00000064   0xFB06 0xF500      MUL      R5,R6,R0
    138              usbPrepareQueuedReceive(sdup->config->usbp,
    139                                      sdup->config->bulk_out,
    140                                      &sdup->iqueue, n);
   \   00000068   0x002B             MOVS     R3,R5
   \   0000006A   0xF117 0x020C      ADDS     R2,R7,#+12
   \   0000006E   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   00000072   0x7941             LDRB     R1,[R0, #+5]
   \   00000074   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x.... 0x....      BL       usbPrepareQueuedReceive
    141          
    142              chSysLock();
   \   0000007E   0x2020             MOVS     R0,#+32
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000084   0x.... 0x....      BL       dbg_check_lock
    143              usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
   \   00000088   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   0000008C   0x7941             LDRB     R1,[R0, #+5]
   \   0000008E   0xF8D7 0x0254      LDR      R0,[R7, #+596]
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x.... 0x....      BL       usbStartReceiveI
    144            }
    145          }
   \                     ??inotify_3:
   \                     ??inotify_2:
   \   00000098   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    146          
    147          /**
    148           * @brief   Notification of data inserted into the output queue.
    149           */

   \                                 In section .text, align 2, keep-with-next
    150          static void onotify(GenericQueue *qp) {
   \                     onotify:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    151            size_t n;
    152            SerialUSBDriver *sdup = chQGetLink(qp);
   \   00000004   0x6A26             LDR      R6,[R4, #+32]
    153          
    154            /* If the USB driver is not in the appropriate state then transactions
    155               must not be started.*/
    156            if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
    157                (sdup->state != SDU_READY))
   \   00000006   0xF8D6 0x0254      LDR      R0,[R6, #+596]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD102             BNE.N    ??onotify_0
   \   00000012   0x7A30             LDRB     R0,[R6, #+8]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD000             BEQ.N    ??onotify_1
    158              return;
   \                     ??onotify_0:
   \   00000018   0xE02F             B.N      ??onotify_2
    159          
    160            /* If there is not an ongoing transaction and the output queue contains
    161               data then a new transaction is started.*/
    162            if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in) &&
    163                ((n = chOQGetFullI(&sdup->oqueue)) > 0)) {
   \                     ??onotify_1:
   \   0000001A   0xF8D6 0x0254      LDR      R0,[R6, #+596]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x8900             LDRH     R0,[R0, #+8]
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF8D6 0x2254      LDR      R2,[R6, #+596]
   \   00000028   0xF992 0x2004      LDRSB    R2,[R2, #+4]
   \   0000002C   0x4091             LSLS     R1,R1,R2
   \   0000002E   0x4208             TST      R0,R1
   \   00000030   0xD123             BNE.N    ??onotify_3
   \   00000032   0x6C30             LDR      R0,[R6, #+64]
   \   00000034   0x6BF1             LDR      R1,[R6, #+60]
   \   00000036   0x1A40             SUBS     R0,R0,R1
   \   00000038   0x6BB1             LDR      R1,[R6, #+56]
   \   0000003A   0x1A45             SUBS     R5,R0,R1
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD01C             BEQ.N    ??onotify_3
    164              chSysUnlock();
   \   00000040   0x.... 0x....      BL       dbg_check_unlock
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF380 0x8811      MSR      BASEPRI,R0
    165          
    166              usbPrepareQueuedTransmit(sdup->config->usbp,
    167                                       sdup->config->bulk_in,
    168                                       &sdup->oqueue, n);
   \   0000004A   0x002B             MOVS     R3,R5
   \   0000004C   0xF116 0x0230      ADDS     R2,R6,#+48
   \   00000050   0xF8D6 0x0254      LDR      R0,[R6, #+596]
   \   00000054   0x7901             LDRB     R1,[R0, #+4]
   \   00000056   0xF8D6 0x0254      LDR      R0,[R6, #+596]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x.... 0x....      BL       usbPrepareQueuedTransmit
    169          
    170              chSysLock();
   \   00000060   0x2020             MOVS     R0,#+32
   \   00000062   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000066   0x.... 0x....      BL       dbg_check_lock
    171              usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
   \   0000006A   0xF8D6 0x0254      LDR      R0,[R6, #+596]
   \   0000006E   0x7901             LDRB     R1,[R0, #+4]
   \   00000070   0xF8D6 0x0254      LDR      R0,[R6, #+596]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x.... 0x....      BL       usbStartTransmitI
    172            }
    173          }
   \                     ??onotify_3:
   \                     ??onotify_2:
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    174          
    175          /*===========================================================================*/
    176          /* Driver exported functions.                                                */
    177          /*===========================================================================*/
    178          
    179          /**
    180           * @brief   Serial Driver initialization.
    181           * @note    This function is implicitly invoked by @p halInit(), there is
    182           *          no need to explicitly initialize the driver.
    183           *
    184           * @init
    185           */

   \                                 In section .text, align 2, keep-with-next
    186          void sduInit(void) {
    187          }
   \                     sduInit:
   \   00000000   0x4770             BX       LR               ;; return
    188          
    189          /**
    190           * @brief   Initializes a generic full duplex driver object.
    191           * @details The HW dependent part of the initialization has to be performed
    192           *          outside, usually in the hardware initialization code.
    193           *
    194           * @param[out] sdup     pointer to a @p SerialUSBDriver structure
    195           *
    196           * @init
    197           */

   \                                 In section .text, align 2, keep-with-next
    198          void sduObjectInit(SerialUSBDriver *sdup) {
   \                     sduObjectInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    199          
    200            sdup->vmt = &vmt;
   \   00000006   0x....             LDR.N    R0,??DataTable3
   \   00000008   0x6020             STR      R0,[R4, #+0]
    201            chEvtInit(&sdup->event);
   \   0000000A   0x1D20             ADDS     R0,R4,#+4
   \   0000000C   0x6060             STR      R0,[R4, #+4]
    202            sdup->state = SDU_STOP;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7220             STRB     R0,[R4, #+8]
    203            chIQInit(&sdup->iqueue, sdup->ib, SERIAL_USB_BUFFERS_SIZE, inotify, sdup);
   \   00000012   0x9400             STR      R4,[SP, #+0]
   \   00000014   0x....             LDR.N    R3,??DataTable3_1
   \   00000016   0xF44F 0x7280      MOV      R2,#+256
   \   0000001A   0xF114 0x0154      ADDS     R1,R4,#+84
   \   0000001E   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000022   0x.... 0x....      BL       chIQInit
    204            chOQInit(&sdup->oqueue, sdup->ob, SERIAL_USB_BUFFERS_SIZE, onotify, sdup);
   \   00000026   0x9400             STR      R4,[SP, #+0]
   \   00000028   0x....             LDR.N    R3,??DataTable3_2
   \   0000002A   0xF44F 0x7280      MOV      R2,#+256
   \   0000002E   0xF514 0x71AA      ADDS     R1,R4,#+340
   \   00000032   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000036   0x.... 0x....      BL       chOQInit
    205          }
   \   0000003A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    206          
    207          /**
    208           * @brief   Configures and starts the driver.
    209           *
    210           * @param[in] sdup      pointer to a @p SerialUSBDriver object
    211           * @param[in] config    the serial over USB driver configuration
    212           *
    213           * @api
    214           */

   \                                 In section .text, align 2, keep-with-next
    215          void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
   \                     sduStart:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    216            USBDriver *usbp = config->usbp;
   \   00000006   0x682E             LDR      R6,[R5, #+0]
    217          
    218            chDbgCheck(sdup != NULL, "sduStart");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??sduStart_0
   \   0000000C   0x22DA             MOVS     R2,#+218
   \   0000000E   0x....             LDR.N    R1,??DataTable3_3
   \   00000010   0x....             LDR.N    R0,??DataTable3_4
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    219          
    220            chSysLock();
   \                     ??sduStart_0:
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001C   0x.... 0x....      BL       dbg_check_lock
    221            chDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
    222                        "sduStart(), #1",
    223                        "invalid state");
   \   00000020   0x7A20             LDRB     R0,[R4, #+8]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD005             BEQ.N    ??sduStart_1
   \   00000026   0x7A20             LDRB     R0,[R4, #+8]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD002             BEQ.N    ??sduStart_1
   \   0000002C   0x....             LDR.N    R0,??DataTable3_5
   \   0000002E   0x.... 0x....      BL       chDbgPanic
    224            usbp->in_params[config->bulk_in - 1]   = sdup;
   \                     ??sduStart_1:
   \   00000032   0x7928             LDRB     R0,[R5, #+4]
   \   00000034   0xEB16 0x0080      ADDS     R0,R6,R0, LSL #+2
   \   00000038   0x6184             STR      R4,[R0, #+24]
    225            usbp->out_params[config->bulk_out - 1] = sdup;
   \   0000003A   0x7968             LDRB     R0,[R5, #+5]
   \   0000003C   0xEB16 0x0080      ADDS     R0,R6,R0, LSL #+2
   \   00000040   0x6244             STR      R4,[R0, #+36]
    226            usbp->in_params[config->int_in - 1]    = sdup;
   \   00000042   0x79A8             LDRB     R0,[R5, #+6]
   \   00000044   0xEB16 0x0080      ADDS     R0,R6,R0, LSL #+2
   \   00000048   0x6184             STR      R4,[R0, #+24]
    227            sdup->config = config;
   \   0000004A   0xF8C4 0x5254      STR      R5,[R4, #+596]
    228            sdup->state = SDU_READY;
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x7220             STRB     R0,[R4, #+8]
    229            chSysUnlock();
   \   00000052   0x.... 0x....      BL       dbg_check_unlock
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF380 0x8811      MSR      BASEPRI,R0
    230          }
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    231          
    232          /**
    233           * @brief   Stops the driver.
    234           * @details Any thread waiting on the driver's queues will be awakened with
    235           *          the message @p Q_RESET.
    236           *
    237           * @param[in] sdup      pointer to a @p SerialUSBDriver object
    238           *
    239           * @api
    240           */

   \                                 In section .text, align 2, keep-with-next
    241          void sduStop(SerialUSBDriver *sdup) {
   \                     sduStop:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    242            USBDriver *usbp = sdup->config->usbp;
   \   00000004   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000008   0x6805             LDR      R5,[R0, #+0]
    243          
    244            chDbgCheck(sdup != NULL, "sdStop");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??sduStop_0
   \   0000000E   0x22F4             MOVS     R2,#+244
   \   00000010   0x....             LDR.N    R1,??DataTable3_3
   \   00000012   0x....             LDR.N    R0,??DataTable3_6
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    245          
    246            chSysLock();
   \                     ??sduStop_0:
   \   00000018   0x2020             MOVS     R0,#+32
   \   0000001A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001E   0x.... 0x....      BL       dbg_check_lock
    247          
    248            chDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
    249                        "sduStop(), #1",
    250                        "invalid state");
   \   00000022   0x7A20             LDRB     R0,[R4, #+8]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD005             BEQ.N    ??sduStop_1
   \   00000028   0x7A20             LDRB     R0,[R4, #+8]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD002             BEQ.N    ??sduStop_1
   \   0000002E   0x....             LDR.N    R0,??DataTable3_7
   \   00000030   0x.... 0x....      BL       chDbgPanic
    251          
    252            /* Driver in stopped state.*/
    253            usbp->in_params[sdup->config->bulk_in - 1]   = NULL;
   \                     ??sduStop_1:
   \   00000034   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000038   0x7900             LDRB     R0,[R0, #+4]
   \   0000003A   0xEB15 0x0080      ADDS     R0,R5,R0, LSL #+2
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6181             STR      R1,[R0, #+24]
    254            usbp->out_params[sdup->config->bulk_out - 1] = NULL;
   \   00000042   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000046   0x7940             LDRB     R0,[R0, #+5]
   \   00000048   0xEB15 0x0080      ADDS     R0,R5,R0, LSL #+2
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6241             STR      R1,[R0, #+36]
    255            usbp->in_params[sdup->config->int_in - 1]    = NULL;
   \   00000050   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000054   0x7980             LDRB     R0,[R0, #+6]
   \   00000056   0xEB15 0x0080      ADDS     R0,R5,R0, LSL #+2
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x6181             STR      R1,[R0, #+24]
    256            sdup->state = SDU_STOP;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x7220             STRB     R0,[R4, #+8]
    257          
    258            /* Queues reset in order to signal the driver stop to the application.*/
    259            chnAddFlagsI(sdup, CHN_DISCONNECTED);
   \   00000062   0x2102             MOVS     R1,#+2
   \   00000064   0x1D20             ADDS     R0,R4,#+4
   \   00000066   0x.... 0x....      BL       chEvtBroadcastFlagsI
    260            chIQResetI(&sdup->iqueue);
   \   0000006A   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000006E   0x.... 0x....      BL       chIQResetI
    261            chOQResetI(&sdup->oqueue);
   \   00000072   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000076   0x.... 0x....      BL       chOQResetI
    262            chSchRescheduleS();
   \   0000007A   0x.... 0x....      BL       chSchRescheduleS
    263          
    264            chSysUnlock();
   \   0000007E   0x.... 0x....      BL       dbg_check_unlock
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF380 0x8811      MSR      BASEPRI,R0
    265          }
   \   00000088   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    266          
    267          /**
    268           * @brief   USB device configured handler.
    269           *
    270           * @param[in] sdup      pointer to a @p SerialUSBDriver object
    271           *
    272           * @iclass
    273           */

   \                                 In section .text, align 2, keep-with-next
    274          void sduConfigureHookI(SerialUSBDriver *sdup) {
   \                     sduConfigureHookI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    275            USBDriver *usbp = sdup->config->usbp;
   \   00000004   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000008   0x6805             LDR      R5,[R0, #+0]
    276          
    277            chIQResetI(&sdup->iqueue);
   \   0000000A   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000000E   0x.... 0x....      BL       chIQResetI
    278            chOQResetI(&sdup->oqueue);
   \   00000012   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000016   0x.... 0x....      BL       chOQResetI
    279            chnAddFlagsI(sdup, CHN_CONNECTED);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x1D20             ADDS     R0,R4,#+4
   \   0000001E   0x.... 0x....      BL       chEvtBroadcastFlagsI
    280          
    281            /* Starts the first OUT transaction immediately.*/
    282            usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
    283                                    usbp->epc[sdup->config->bulk_out]->out_maxsize);
   \   00000022   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000026   0x7940             LDRB     R0,[R0, #+5]
   \   00000028   0xEB15 0x0080      ADDS     R0,R5,R0, LSL #+2
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0x8A43             LDRH     R3,[R0, #+18]
   \   00000030   0xF114 0x020C      ADDS     R2,R4,#+12
   \   00000034   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000038   0x7941             LDRB     R1,[R0, #+5]
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       usbPrepareQueuedReceive
    284            usbStartReceiveI(usbp, sdup->config->bulk_out);
   \   00000040   0xF8D4 0x0254      LDR      R0,[R4, #+596]
   \   00000044   0x7941             LDRB     R1,[R0, #+5]
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       usbStartReceiveI
    285          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    286          
    287          /**
    288           * @brief   Default requests hook.
    289           * @details Applications wanting to use the Serial over USB driver can use
    290           *          this function as requests hook in the USB configuration.
    291           *          The following requests are emulated:
    292           *          - CDC_GET_LINE_CODING.
    293           *          - CDC_SET_LINE_CODING.
    294           *          - CDC_SET_CONTROL_LINE_STATE.
    295           *          .
    296           *
    297           * @param[in] usbp      pointer to the @p USBDriver object
    298           * @return              The hook status.
    299           * @retval TRUE         Message handled internally.
    300           * @retval FALSE        Message not handled.
    301           */

   \                                 In section .text, align 2, keep-with-next
    302          bool_t sduRequestsHook(USBDriver *usbp) {
   \                     sduRequestsHook:
   \   00000000   0x0001             MOVS     R1,R0
    303          
    304            if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
   \   00000002   0xF891 0x0044      LDRB     R0,[R1, #+68]
   \   00000006   0xF010 0x0060      ANDS     R0,R0,#0x60
   \   0000000A   0x2820             CMP      R0,#+32
   \   0000000C   0xD121             BNE.N    ??sduRequestsHook_0
    305              switch (usbp->setup[1]) {
   \   0000000E   0xF891 0x0045      LDRB     R0,[R1, #+69]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD00B             BEQ.N    ??sduRequestsHook_1
   \   00000016   0xD31A             BCC.N    ??sduRequestsHook_2
   \   00000018   0x2822             CMP      R0,#+34
   \   0000001A   0xD010             BEQ.N    ??sduRequestsHook_3
   \   0000001C   0xD217             BCS.N    ??sduRequestsHook_2
    306              case CDC_GET_LINE_CODING:
    307                usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
   \                     ??sduRequestsHook_4:
   \   0000001E   0x....             LDR.N    R0,??DataTable3_8
   \   00000020   0x6388             STR      R0,[R1, #+56]
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0x63C8             STR      R0,[R1, #+60]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6408             STR      R0,[R1, #+64]
    308                return TRUE;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE012             B.N      ??sduRequestsHook_5
    309              case CDC_SET_LINE_CODING:
    310                usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
   \                     ??sduRequestsHook_1:
   \   0000002E   0x....             LDR.N    R0,??DataTable3_8
   \   00000030   0x6388             STR      R0,[R1, #+56]
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0x63C8             STR      R0,[R1, #+60]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6408             STR      R0,[R1, #+64]
    311                return TRUE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE00A             B.N      ??sduRequestsHook_5
    312              case CDC_SET_CONTROL_LINE_STATE:
    313                /* Nothing to do, there are no control lines.*/
    314                usbSetupTransfer(usbp, NULL, 0, NULL);
   \                     ??sduRequestsHook_3:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6388             STR      R0,[R1, #+56]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63C8             STR      R0,[R1, #+60]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6408             STR      R0,[R1, #+64]
    315                return TRUE;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE002             B.N      ??sduRequestsHook_5
    316              default:
    317                return FALSE;
   \                     ??sduRequestsHook_2:
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE000             B.N      ??sduRequestsHook_5
    318              }
    319            }
    320            return FALSE;
   \                     ??sduRequestsHook_0:
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??sduRequestsHook_5:
   \   00000054   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /**
    324           * @brief   Default data transmitted callback.
    325           * @details The application must use this function as callback for the IN
    326           *          data endpoint.
    327           *
    328           * @param[in] usbp      pointer to the @p USBDriver object
    329           * @param[in] ep        endpoint number
    330           */

   \                                 In section .text, align 2, keep-with-next
    331          void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
   \                     sduDataTransmitted:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    332            size_t n;
    333            SerialUSBDriver *sdup = usbp->in_params[ep - 1];
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000000C   0x6987             LDR      R7,[R0, #+24]
    334          
    335            if (sdup == NULL)
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD05A             BEQ.N    ??sduDataTransmitted_0
    336              return;
    337          
    338            chSysLockFromIsr();
   \                     ??sduDataTransmitted_1:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock_from_isr
    339            chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x1D38             ADDS     R0,R7,#+4
   \   00000020   0x.... 0x....      BL       chEvtBroadcastFlagsI
    340          
    341            if ((n = chOQGetFullI(&sdup->oqueue)) > 0) {
   \   00000024   0x6C38             LDR      R0,[R7, #+64]
   \   00000026   0x6BF9             LDR      R1,[R7, #+60]
   \   00000028   0x1A40             SUBS     R0,R0,R1
   \   0000002A   0x6BB9             LDR      R1,[R7, #+56]
   \   0000002C   0x1A40             SUBS     R0,R0,R1
   \   0000002E   0x0006             MOVS     R6,R0
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD017             BEQ.N    ??sduDataTransmitted_2
    342              /* The endpoint cannot be busy, we are in the context of the callback,
    343                 so it is safe to transmit without a check.*/
    344              chSysUnlockFromIsr();
   \   00000034   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF380 0x8811      MSR      BASEPRI,R0
    345          
    346              usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);
   \   0000003E   0x0033             MOVS     R3,R6
   \   00000040   0xF117 0x0230      ADDS     R2,R7,#+48
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       usbPrepareQueuedTransmit
    347          
    348              chSysLockFromIsr();
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000054   0x.... 0x....      BL       dbg_check_lock_from_isr
    349              usbStartTransmitI(usbp, ep);
   \   00000058   0x0029             MOVS     R1,R5
   \   0000005A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       usbStartTransmitI
   \   00000062   0xE02C             B.N      ??sduDataTransmitted_3
    350            }
    351            else if ((usbp->epc[ep]->in_state->txsize > 0) &&
    352                     !(usbp->epc[ep]->in_state->txsize &
    353                       (usbp->epc[ep]->in_maxsize - 1))) {
   \                     ??sduDataTransmitted_2:
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0x6940             LDR      R0,[R0, #+20]
   \   0000006E   0x6840             LDR      R0,[R0, #+4]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD024             BEQ.N    ??sduDataTransmitted_3
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000007A   0x68C0             LDR      R0,[R0, #+12]
   \   0000007C   0x6940             LDR      R0,[R0, #+20]
   \   0000007E   0x6840             LDR      R0,[R0, #+4]
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000086   0x68C9             LDR      R1,[R1, #+12]
   \   00000088   0x8A09             LDRH     R1,[R1, #+16]
   \   0000008A   0x1E49             SUBS     R1,R1,#+1
   \   0000008C   0x4208             TST      R0,R1
   \   0000008E   0xD116             BNE.N    ??sduDataTransmitted_3
    354              /* Transmit zero sized packet in case the last one has maximum allowed
    355                 size. Otherwise the recipient may expect more data coming soon and
    356                 not return buffered data to app. See section 5.8.3 Bulk Transfer
    357                 Packet Size Constraints of the USB Specification document.*/
    358              chSysUnlockFromIsr();
   \   00000090   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF380 0x8811      MSR      BASEPRI,R0
    359          
    360              usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);
   \   0000009A   0x2300             MOVS     R3,#+0
   \   0000009C   0xF117 0x0230      ADDS     R2,R7,#+48
   \   000000A0   0x0029             MOVS     R1,R5
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       usbPrepareQueuedTransmit
    361          
    362              chSysLockFromIsr();
   \   000000AA   0x2020             MOVS     R0,#+32
   \   000000AC   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000B0   0x.... 0x....      BL       dbg_check_lock_from_isr
    363              usbStartTransmitI(usbp, ep);
   \   000000B4   0x0029             MOVS     R1,R5
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       usbStartTransmitI
    364            }
    365          
    366            chSysUnlockFromIsr();
   \                     ??sduDataTransmitted_3:
   \   000000BE   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF380 0x8811      MSR      BASEPRI,R0
    367          }
   \                     ??sduDataTransmitted_0:
   \   000000C8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    368          
    369          /**
    370           * @brief   Default data received callback.
    371           * @details The application must use this function as callback for the OUT
    372           *          data endpoint.
    373           *
    374           * @param[in] usbp      pointer to the @p USBDriver object
    375           * @param[in] ep        endpoint number
    376           */

   \                                 In section .text, align 2, keep-with-next
    377          void sduDataReceived(USBDriver *usbp, usbep_t ep) {
   \                     sduDataReceived:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    378            size_t n, maxsize;
    379            SerialUSBDriver *sdup = usbp->out_params[ep - 1];
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000000E   0xF8D0 0x8024      LDR      R8,[R0, #+36]
    380          
    381            if (sdup == NULL)
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD03A             BEQ.N    ??sduDataReceived_0
    382              return;
    383          
    384            chSysLockFromIsr();
   \                     ??sduDataReceived_1:
   \   00000018   0x2020             MOVS     R0,#+32
   \   0000001A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001E   0x.... 0x....      BL       dbg_check_lock_from_isr
    385            chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0xF118 0x0004      ADDS     R0,R8,#+4
   \   00000028   0x.... 0x....      BL       chEvtBroadcastFlagsI
    386          
    387            /* Writes to the input queue can only happen when there is enough space
    388               to hold at least one packet.*/
    389            maxsize = usbp->epc[ep]->out_maxsize;
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x8A40             LDRH     R0,[R0, #+18]
   \   00000036   0x0007             MOVS     R7,R0
    390            if ((n = chIQGetEmptyI(&sdup->iqueue)) >= maxsize) {
   \   00000038   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   0000003C   0xF8D8 0x1018      LDR      R1,[R8, #+24]
   \   00000040   0x1A40             SUBS     R0,R0,R1
   \   00000042   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \   00000046   0x1A40             SUBS     R0,R0,R1
   \   00000048   0x0006             MOVS     R6,R0
   \   0000004A   0x42B8             CMP      R0,R7
   \   0000004C   0xD31A             BCC.N    ??sduDataReceived_2
    391              /* The endpoint cannot be busy, we are in the context of the callback,
    392                 so a packet is in the buffer for sure.*/
    393              chSysUnlockFromIsr();
   \   0000004E   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF380 0x8811      MSR      BASEPRI,R0
    394          
    395              n = (n / maxsize) * maxsize;
   \   00000058   0xFBB6 0xF0F7      UDIV     R0,R6,R7
   \   0000005C   0xFB07 0xF600      MUL      R6,R7,R0
    396              usbPrepareQueuedReceive(usbp, ep, &sdup->iqueue, n);
   \   00000060   0x0033             MOVS     R3,R6
   \   00000062   0xF118 0x020C      ADDS     R2,R8,#+12
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       usbPrepareQueuedReceive
    397          
    398              chSysLockFromIsr();
   \   00000070   0x2020             MOVS     R0,#+32
   \   00000072   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000076   0x.... 0x....      BL       dbg_check_lock_from_isr
    399              usbStartReceiveI(usbp, ep);
   \   0000007A   0x0029             MOVS     R1,R5
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       usbStartReceiveI
    400            }
    401          
    402            chSysUnlockFromIsr();
   \                     ??sduDataReceived_2:
   \   00000084   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF380 0x8811      MSR      BASEPRI,R0
    403          }
   \                     ??sduDataReceived_0:
   \   0000008E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    404          
    405          /**
    406           * @brief   Default data received callback.
    407           * @details The application must use this function as callback for the IN
    408           *          interrupt endpoint.
    409           *
    410           * @param[in] usbp      pointer to the @p USBDriver object
    411           * @param[in] ep        endpoint number
    412           */

   \                                 In section .text, align 2, keep-with-next
    413          void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
    414          
    415            (void)usbp;
    416            (void)ep;
    417          }
   \                     sduInterruptTransmitted:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     vmt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     inotify

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     onotify

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     `?<Constant "\\"sduStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     `?<Constant "sduStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     `?<Constant "\\"sdStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     `?<Constant "sduStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     linecoding

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"sduStart\\"()">`:
   \   00000000   0x22 0x73          DC8 "\"sduStart\"()"
   \              0x64 0x75    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x73 0x65          DC8 73H, 65H, 72H, 69H, 61H, 6CH, 5FH, 75H
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x5F 0x75    
   \   00000040   0x73 0x62          DC8 73H, 62H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "sduStart(), #1">`:
   \   00000000   0x73 0x64          DC8 "sduStart(), #1"
   \              0x75 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"sdStop\\"()">`:
   \   00000000   0x22 0x73          DC8 "\"sdStop\"()"
   \              0x64 0x53    
   \              0x74 0x6F    
   \              0x70 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "sduStop(), #1">`:
   \   00000000   0x73 0x64          DC8 "sduStop(), #1"
   \              0x75 0x53    
   \              0x74 0x6F    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
    418          
    419          #endif /* HAL_USE_SERIAL */
    420          
    421          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   get
         8   -> chIQGetTimeout
      16   gett
        16   -> chIQGetTimeout
      24   inotify
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
        24   -> usbPrepareQueuedReceive
        24   -> usbStartReceiveI
      16   onotify
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
        16   -> usbPrepareQueuedTransmit
        16   -> usbStartTransmitI
      16   put
        16   -> chOQPutTimeout
      16   putt
        16   -> chOQPutTimeout
      16   read
        16   -> chIQReadTimeout
      24   readt
        24   -> chIQReadTimeout
      16   sduConfigureHookI
        16   -> chEvtBroadcastFlagsI
        16   -> chIQResetI
        16   -> chOQResetI
        16   -> usbPrepareQueuedReceive
        16   -> usbStartReceiveI
      24   sduDataReceived
        24   -> chEvtBroadcastFlagsI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> usbPrepareQueuedReceive
        24   -> usbStartReceiveI
      24   sduDataTransmitted
        24   -> chEvtBroadcastFlagsI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> usbPrepareQueuedTransmit
        24   -> usbStartTransmitI
       0   sduInit
       0   sduInterruptTransmitted
      16   sduObjectInit
        16   -> chIQInit
        16   -> chOQInit
       0   sduRequestsHook
      16   sduStart
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   sduStop
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chEvtBroadcastFlagsI
        16   -> chIQResetI
        16   -> chOQResetI
        16   -> chSchRescheduleS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   write
        16   -> chOQWriteTimeout
      24   writet
        24   -> chOQWriteTimeout


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  ?<Constant "F:\\stuff\\rusefi_sourc...">
      12  ?<Constant "\"sdStop\"()">
      16  ?<Constant "\"sduStart\"()">
      16  ?<Constant "sduStart(), #1">
      16  ?<Constant "sduStop(), #1">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
      18  get
      18  gett
     154  inotify
       8  linecoding
     124  onotify
      24  put
      24  putt
      26  read
      26  readt
      78  sduConfigureHookI
     146  sduDataReceived
     202  sduDataTransmitted
       2  sduInit
       2  sduInterruptTransmitted
      60  sduObjectInit
      86  sduRequestsHook
      94  sduStart
     138  sduStop
      32  vmt
      26  write
      26  writet

 
     8 bytes in section .data
   164 bytes in section .rodata
 1 310 bytes in section .text
 
 1 310 bytes of CODE  memory
   164 bytes of CONST memory
     8 bytes of DATA  memory

Errors: none
Warnings: none
