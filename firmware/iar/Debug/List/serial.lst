###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:07 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\serial.c                                           #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\serial.c -lCN F:\stuff\rusefi_sourceforge\firmware #
#                       \iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\Obj\ --no_cse --no_unroll           #
#                       --no_inline --no_code_motion --no_tbaa                #
#                       --no_clustering --no_scheduling --debug               #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\s #
#                       erial.lst                                             #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\se #
#                       rial.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\serial.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    serial.c
     30           * @brief   Serial Driver code.
     31           *
     32           * @addtogroup SERIAL
     33           * @{
     34           */
     35          
     36          #include "ch.h"
     37          #include "hal.h"
     38          
     39          #if HAL_USE_SERIAL || defined(__DOXYGEN__)
     40          
     41          /*===========================================================================*/
     42          /* Driver local definitions.                                                 */
     43          /*===========================================================================*/
     44          
     45          /*===========================================================================*/
     46          /* Driver exported variables.                                                */
     47          /*===========================================================================*/
     48          
     49          /*===========================================================================*/
     50          /* Driver local variables and types.                                         */
     51          /*===========================================================================*/
     52          
     53          /*===========================================================================*/
     54          /* Driver local functions.                                                   */
     55          /*===========================================================================*/
     56          
     57          /*
     58           * Interface implementation, the following functions just invoke the equivalent
     59           * queue-level function or macro.
     60           */
     61          

   \                                 In section .text, align 2, keep-with-next
     62          static size_t write(void *ip, const uint8_t *bp, size_t n) {
   \                     write:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     63          
     64            return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
     65                                    n, TIME_INFINITE);
   \   00000008   0xF05F 0x33FF      MOVS     R3,#-1
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000014   0x.... 0x....      BL       chOQWriteTimeout
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
     66          }
     67          

   \                                 In section .text, align 2, keep-with-next
     68          static size_t read(void *ip, uint8_t *bp, size_t n) {
   \                     read:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     69          
     70            return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
     71                                   n, TIME_INFINITE);
   \   00000008   0xF05F 0x33FF      MOVS     R3,#-1
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000014   0x.... 0x....      BL       chIQReadTimeout
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
     72          }
     73          

   \                                 In section .text, align 2, keep-with-next
     74          static msg_t put(void *ip, uint8_t b) {
   \                     put:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     75          
     76            return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000012   0x.... 0x....      BL       chOQPutTimeout
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     77          }
     78          

   \                                 In section .text, align 2, keep-with-next
     79          static msg_t get(void *ip) {
   \                     get:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     80          
     81            return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
   \   00000004   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000008   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000000C   0x.... 0x....      BL       chIQGetTimeout
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
     82          }
     83          

   \                                 In section .text, align 2, keep-with-next
     84          static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
   \                     putt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     85          
     86            return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000012   0x.... 0x....      BL       chOQPutTimeout
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
     87          }
     88          

   \                                 In section .text, align 2, keep-with-next
     89          static msg_t gett(void *ip, systime_t timeout) {
   \                     gett:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     90          
     91            return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000000C   0x.... 0x....      BL       chIQGetTimeout
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     92          }
     93          

   \                                 In section .text, align 2, keep-with-next
     94          static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {
   \                     writet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
     95          
     96            return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000014   0x.... 0x....      BL       chOQWriteTimeout
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     97          }
     98          

   \                                 In section .text, align 2, keep-with-next
     99          static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {
   \                     readt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    100          
    101            return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
   \   0000000A   0x003B             MOVS     R3,R7
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000014   0x.... 0x....      BL       chIQReadTimeout
   \   00000018   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    102          }
    103          

   \                                 In section .rodata, align 4
    104          static const struct SerialDriverVMT vmt = {
   \                     vmt:
   \   00000000   0x........         DC32 write, read, put, get, putt, gett, writet, readt
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
    105            write, read, put, get,
    106            putt, gett, writet, readt
    107          };
    108          
    109          /*===========================================================================*/
    110          /* Driver exported functions.                                                */
    111          /*===========================================================================*/
    112          
    113          /**
    114           * @brief   Serial Driver initialization.
    115           * @note    This function is implicitly invoked by @p halInit(), there is
    116           *          no need to explicitly initialize the driver.
    117           *
    118           * @init
    119           */

   \                                 In section .text, align 2, keep-with-next
    120          void sdInit(void) {
   \                     sdInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    121          
    122            sd_lld_init();
   \   00000002   0x.... 0x....      BL       sd_lld_init
    123          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    124          
    125          /**
    126           * @brief   Initializes a generic full duplex driver object.
    127           * @details The HW dependent part of the initialization has to be performed
    128           *          outside, usually in the hardware initialization code.
    129           *
    130           * @param[out] sdp      pointer to a @p SerialDriver structure
    131           * @param[in] inotify   pointer to a callback function that is invoked when
    132           *                      some data is read from the Queue. The value can be
    133           *                      @p NULL.
    134           * @param[in] onotify   pointer to a callback function that is invoked when
    135           *                      some data is written in the Queue. The value can be
    136           *                      @p NULL.
    137           *
    138           * @init
    139           */

   \                                 In section .text, align 2, keep-with-next
    140          void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
   \                     sdObjectInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    141          
    142            sdp->vmt = &vmt;
   \   0000000A   0x....             LDR.N    R0,??DataTable4
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    143            chEvtInit(&sdp->event);
   \   0000000E   0x1D20             ADDS     R0,R4,#+4
   \   00000010   0x6060             STR      R0,[R4, #+4]
    144            sdp->state = SD_STOP;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7220             STRB     R0,[R4, #+8]
    145            chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
   \   00000016   0x9400             STR      R4,[SP, #+0]
   \   00000018   0x002B             MOVS     R3,R5
   \   0000001A   0x2210             MOVS     R2,#+16
   \   0000001C   0xF114 0x0154      ADDS     R1,R4,#+84
   \   00000020   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000024   0x.... 0x....      BL       chIQInit
    146            chOQInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
   \   00000028   0x9400             STR      R4,[SP, #+0]
   \   0000002A   0x0033             MOVS     R3,R6
   \   0000002C   0x2210             MOVS     R2,#+16
   \   0000002E   0xF114 0x0164      ADDS     R1,R4,#+100
   \   00000032   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000036   0x.... 0x....      BL       chOQInit
    147          }
   \   0000003A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    148          
    149          /**
    150           * @brief   Configures and starts the driver.
    151           *
    152           * @param[in] sdp       pointer to a @p SerialDriver object
    153           * @param[in] config    the architecture-dependent serial driver configuration.
    154           *                      If this parameter is set to @p NULL then a default
    155           *                      configuration is used.
    156           *
    157           * @api
    158           */

   \                                 In section .text, align 2, keep-with-next
    159          void sdStart(SerialDriver *sdp, const SerialConfig *config) {
   \                     sdStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    160          
    161            chDbgCheck(sdp != NULL, "sdStart");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD104             BNE.N    ??sdStart_0
   \   0000000A   0x22A1             MOVS     R2,#+161
   \   0000000C   0x....             LDR.N    R1,??DataTable4_1
   \   0000000E   0x....             LDR.N    R0,??DataTable4_2
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    162          
    163            chSysLock();
   \                     ??sdStart_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    164            chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    165                        "sdStart(), #1",
    166                        "invalid state");
   \   0000001E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD005             BEQ.N    ??sdStart_1
   \   00000024   0x7A20             LDRB     R0,[R4, #+8]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD002             BEQ.N    ??sdStart_1
   \   0000002A   0x....             LDR.N    R0,??DataTable4_3
   \   0000002C   0x.... 0x....      BL       chDbgPanic
    167            sd_lld_start(sdp, config);
   \                     ??sdStart_1:
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       sd_lld_start
    168            sdp->state = SD_READY;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x7220             STRB     R0,[R4, #+8]
    169            chSysUnlock();
   \   0000003C   0x.... 0x....      BL       dbg_check_unlock
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF380 0x8811      MSR      BASEPRI,R0
    170          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    171          
    172          /**
    173           * @brief   Stops the driver.
    174           * @details Any thread waiting on the driver's queues will be awakened with
    175           *          the message @p Q_RESET.
    176           *
    177           * @param[in] sdp       pointer to a @p SerialDriver object
    178           *
    179           * @api
    180           */

   \                                 In section .text, align 2, keep-with-next
    181          void sdStop(SerialDriver *sdp) {
   \                     sdStop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    182          
    183            chDbgCheck(sdp != NULL, "sdStop");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??sdStop_0
   \   00000008   0x22B7             MOVS     R2,#+183
   \   0000000A   0x....             LDR.N    R1,??DataTable4_1
   \   0000000C   0x....             LDR.N    R0,??DataTable4_4
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    184          
    185            chSysLock();
   \                     ??sdStop_0:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock
    186            chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
    187                        "sdStop(), #1",
    188                        "invalid state");
   \   0000001C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD005             BEQ.N    ??sdStop_1
   \   00000022   0x7A20             LDRB     R0,[R4, #+8]
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD002             BEQ.N    ??sdStop_1
   \   00000028   0x....             LDR.N    R0,??DataTable4_5
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    189            sd_lld_stop(sdp);
   \                     ??sdStop_1:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       sd_lld_stop
    190            sdp->state = SD_STOP;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7220             STRB     R0,[R4, #+8]
    191            chOQResetI(&sdp->oqueue);
   \   00000038   0xF114 0x0030      ADDS     R0,R4,#+48
   \   0000003C   0x.... 0x....      BL       chOQResetI
    192            chIQResetI(&sdp->iqueue);
   \   00000040   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000044   0x.... 0x....      BL       chIQResetI
    193            chSchRescheduleS();
   \   00000048   0x.... 0x....      BL       chSchRescheduleS
    194            chSysUnlock();
   \   0000004C   0x.... 0x....      BL       dbg_check_unlock
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF380 0x8811      MSR      BASEPRI,R0
    195          }
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    196          
    197          /**
    198           * @brief   Handles incoming data.
    199           * @details This function must be called from the input interrupt service
    200           *          routine in order to enqueue incoming data and generate the
    201           *          related events.
    202           * @note    The incoming data event is only generated when the input queue
    203           *          becomes non-empty.
    204           * @note    In order to gain some performance it is suggested to not use
    205           *          this function directly but copy this code directly into the
    206           *          interrupt service routine.
    207           *
    208           * @param[in] sdp       pointer to a @p SerialDriver structure
    209           * @param[in] b         the byte to be written in the driver's Input Queue
    210           *
    211           * @iclass
    212           */

   \                                 In section .text, align 2, keep-with-next
    213          void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
   \                     sdIncomingDataI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    214          
    215            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    216            chDbgCheck(sdp != NULL, "sdIncomingDataI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??sdIncomingDataI_0
   \   0000000E   0x22D8             MOVS     R2,#+216
   \   00000010   0x....             LDR.N    R1,??DataTable4_1
   \   00000012   0x....             LDR.N    R0,??DataTable4_6
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    217          
    218            if (chIQIsEmptyI(&sdp->iqueue))
   \                     ??sdIncomingDataI_0:
   \   00000018   0x6960             LDR      R0,[R4, #+20]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD103             BNE.N    ??sdIncomingDataI_1
    219              chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
   \   0000001E   0x2104             MOVS     R1,#+4
   \   00000020   0x1D20             ADDS     R0,R4,#+4
   \   00000022   0x.... 0x....      BL       chEvtBroadcastFlagsI
    220            if (chIQPutI(&sdp->iqueue, b) < Q_OK)
   \                     ??sdIncomingDataI_1:
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000002E   0x.... 0x....      BL       chIQPutI
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD503             BPL.N    ??sdIncomingDataI_2
    221              chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
   \   00000036   0x2180             MOVS     R1,#+128
   \   00000038   0x1D20             ADDS     R0,R4,#+4
   \   0000003A   0x.... 0x....      BL       chEvtBroadcastFlagsI
    222          }
   \                     ??sdIncomingDataI_2:
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    223          
    224          /**
    225           * @brief   Handles outgoing data.
    226           * @details Must be called from the output interrupt service routine in order
    227           *          to get the next byte to be transmitted.
    228           * @note    In order to gain some performance it is suggested to not use
    229           *          this function directly but copy this code directly into the
    230           *          interrupt service routine.
    231           *
    232           * @param[in] sdp       pointer to a @p SerialDriver structure
    233           * @return              The byte value read from the driver's output queue.
    234           * @retval Q_EMPTY      if the queue is empty (the lower driver usually
    235           *                      disables the interrupt source when this happens).
    236           *
    237           * @iclass
    238           */

   \                                 In section .text, align 2, keep-with-next
    239          msg_t sdRequestDataI(SerialDriver *sdp) {
   \                     sdRequestDataI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240            msg_t  b;
    241          
    242            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    243            chDbgCheck(sdp != NULL, "sdRequestDataI");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??sdRequestDataI_0
   \   0000000C   0x22F3             MOVS     R2,#+243
   \   0000000E   0x....             LDR.N    R1,??DataTable4_1
   \   00000010   0x....             LDR.N    R0,??DataTable4_7
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    244          
    245            b = chOQGetI(&sdp->oqueue);
   \                     ??sdRequestDataI_0:
   \   00000016   0xF114 0x0030      ADDS     R0,R4,#+48
   \   0000001A   0x.... 0x....      BL       chOQGetI
   \   0000001E   0x0005             MOVS     R5,R0
    246            if (b < Q_OK)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD503             BPL.N    ??sdRequestDataI_1
    247              chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x.... 0x....      BL       chEvtBroadcastFlagsI
    248            return b;
   \                     ??sdRequestDataI_1:
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    249          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     vmt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     `?<Constant "\\"sdStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     `?<Constant "sdStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     `?<Constant "\\"sdStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     `?<Constant "sdStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     `?<Constant "\\"sdIncomingDataI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     `?<Constant "\\"sdRequestDataI\\"()">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"sdStart\\"()">`:
   \   00000000   0x22 0x73          DC8 "\"sdStart\"()"
   \              0x64 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x73 0x65          DC8 73H, 65H, 72H, 69H, 61H, 6CH, 2EH, 63H
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x2E 0x63    
   \   00000040   0x00               DC8 0
   \   00000041   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "sdStart(), #1">`:
   \   00000000   0x73 0x64          DC8 "sdStart(), #1"
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"sdStop\\"()">`:
   \   00000000   0x22 0x73          DC8 "\"sdStop\"()"
   \              0x64 0x53    
   \              0x74 0x6F    
   \              0x70 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "sdStop(), #1">`:
   \   00000000   0x73 0x64          DC8 "sdStop(), #1"
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"sdIncomingDataI\\"()">`:
   \   00000000   0x22 0x73          DC8 "\"sdIncomingDataI\"()"
   \              0x64 0x49    
   \              0x6E 0x63    
   \              0x6F 0x6D    
   \              0x69 0x6E    
   \              0x67 0x44    
   \              0x61 0x74    
   \              0x61 0x49    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"sdRequestDataI\\"()">`:
   \   00000000   0x22 0x73          DC8 "\"sdRequestDataI\"()"
   \              0x64 0x52    
   \              0x65 0x71    
   \              0x75 0x65    
   \              0x73 0x74    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000013   0x00               DC8 0
    250          
    251          #endif /* HAL_USE_SERIAL */
    252          
    253          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   get
         8   -> chIQGetTimeout
      16   gett
        16   -> chIQGetTimeout
      16   put
        16   -> chOQPutTimeout
      16   putt
        16   -> chOQPutTimeout
      16   read
        16   -> chIQReadTimeout
      24   readt
        24   -> chIQReadTimeout
      16   sdIncomingDataI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> chEvtBroadcastFlagsI
        16   -> chIQPutI
       8   sdInit
         8   -> sd_lld_init
      24   sdObjectInit
        24   -> chIQInit
        24   -> chOQInit
      16   sdRequestDataI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> chEvtBroadcastFlagsI
        16   -> chOQGetI
      16   sdStart
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
        16   -> sd_lld_start
       8   sdStop
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> chIQResetI
         8   -> chOQResetI
         8   -> chSchRescheduleS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
         8   -> sd_lld_stop
      16   write
        16   -> chOQWriteTimeout
      24   writet
        24   -> chOQWriteTimeout


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "F:\\stuff\\rusefi_sourc...">
      20  ?<Constant "\"sdIncomingDataI\"()">
      20  ?<Constant "\"sdRequestDataI\"()">
      12  ?<Constant "\"sdStart\"()">
      12  ?<Constant "\"sdStop\"()">
      16  ?<Constant "sdStart(), #1">
      16  ?<Constant "sdStop(), #1">
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
      18  get
      18  gett
      24  put
      24  putt
      26  read
      26  readt
      64  sdIncomingDataI
       8  sdInit
      60  sdObjectInit
      48  sdRequestDataI
      72  sdStart
      88  sdStop
      32  vmt
      26  write
      26  writet

 
 196 bytes in section .rodata
 560 bytes in section .text
 
 560 bytes of CODE  memory
 196 bytes of CONST memory

Errors: none
Warnings: none
