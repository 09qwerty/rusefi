###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:12 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\syst #
#                       em\SingleTimerExecutor.cpp                            #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\syst #
#                       em\SingleTimerExecutor.cpp -lCN                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\S #
#                       ingleTimerExecutor.lst                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\Si #
#                       ngleTimerExecutor.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\system\SingleTimerExecutor.cpp
      1          /**
      2           * @file SingleTimerExecutor.cpp
      3           *
      4           * This class combines the powers of a 1MHz hardware timer from microsecond_timer.c
      5           * and pending events queue event_queue.cpp
      6           *
      7           * As of version 2.6.x, ChibiOS tick-based kernel is not capable of scheduling events
      8           * with the level of precision we need, and realistically it should not.
      9           *
     10           * http://sourceforge.net/p/rusefi/tickets/24/
     11           *
     12           * @date: Apr 18, 2014
     13           * @author Andrey Belomutskiy, (c) 2012-2015
     14           */
     15          
     16          #include "SingleTimerExecutor.h"
     17          #include "efitime.h"
     18          #include "efilib2.h"
     19          
     20          #if EFI_PROD_CODE
     21          #include "microsecond_timer.h"
     22          #endif
     23          
     24          #if (EFI_SIGNAL_EXECUTOR_ONE_TIMER && EFI_PROD_CODE )|| defined(__DOXYGEN__)
     25          #include "rfiutil.h"
     26          

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine:
   \   00000000   0xB580             PUSH     {R7,LR}
     27          static Executor instance;
   \   00000002   0x....             LDR.N    R0,??DataTable6
   \   00000004   0x.... 0x....      BL       _ZN8ExecutorC1Ev
   \   00000008   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 8
   \                     instance:
   \   00000000                      DS8 24
     28          
     29          extern schfunc_t globalTimerCallback;
     30          
     31          //static int timerIsLate = 0;
     32          //static efitime_t callbackTime = 0;
     33          /**
     34           * these fields are global in order to facilitate debugging
     35           */

   \                                 In section .bss, align 8
     36          static efitime_t nextEventTimeNt = 0;
   \                     nextEventTimeNt:
   \   00000000                      DS8 8
     37          

   \                                 In section .bss, align 4
     38          uint32_t beforeHwSetTimer;
   \                     beforeHwSetTimer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     39          uint32_t hwSetTimerTime;
   \                     hwSetTimerTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     40          uint32_t lastExecutionCount;
   \                     lastExecutionCount:
   \   00000000                      DS8 4
     41          

   \                                 In section .text, align 2, keep-with-next
     42          static void executorCallback(void *arg) {
   \                     _Z16executorCallbackPv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     43          	(void)arg;
     44          	efiAssertVoid(getRemainingStack(chThdSelf()) > 256, "lowstck#2y");
   \   00000004   0x....             LDR.N    R0,??DataTable6_1
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x.... 0x....      BL       getRemainingStack
   \   0000000C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000010   0xDC03             BGT.N    ??executorCallback_0
   \   00000012   0x....             LDR.N    R0,??DataTable6_2
   \   00000014   0x.... 0x....      BL       firmwareError
   \   00000018   0xE002             B.N      ??executorCallback_1
     45          
     46          //	callbackTime = getTimeNowNt();
     47          //	if((callbackTime > nextEventTimeNt) && (callbackTime - nextEventTimeNt > US2NT(5000))) {
     48          //		timerIsLate++;
     49          //	}
     50          
     51          	instance.onTimerCallback();
   \                     ??executorCallback_0:
   \   0000001A   0x....             LDR.N    R0,??DataTable6
   \   0000001C   0x.... 0x....      BL       _ZN8Executor15onTimerCallbackEv
     52          }
   \                     ??executorCallback_1:
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     53          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Executor::subobject Executor()
   \                     _ZN8ExecutorC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN8ExecutorC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     54          Executor::Executor() {
   \                     _ZN8ExecutorC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10EventQueueC1Ev
     55          	reentrantFlag = false;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7420             STRB     R0,[R4, #+16]
     56          	/**
     57          	 * todo: a good comment
     58          	 */
     59          	queue.setLateDelay(US2NT(100));
   \   0000000E   0xF244 0x11A0      MOVW     R1,#+16800
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       _ZN10EventQueue12setLateDelayEi
     60          }
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
     61          

   \                                 In section .text, align 2, keep-with-next
     62          void Executor::scheduleByTime(scheduling_s *scheduling, efitimeus_t timeUs, schfunc_t callback,
     63          		void *param) {
   \                     _ZN8Executor14scheduleByTimeEP12scheduling_sxPFvPvES2_:
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
   \   0000000C   0x9F0A             LDR      R7,[SP, #+40]
   \   0000000E   0xF8DD 0x802C      LDR      R8,[SP, #+44]
     64          //	if (delayUs < 0) {
     65          //		firmwareError("Negative delayUs %s: %d", prefix, delayUs);
     66          //		return;
     67          //	}
     68          //	if (delayUs == 0) {
     69          //		callback(param);
     70          //		return;
     71          //	}
     72          	if (!reentrantFlag) {
   \   00000012   0x7C30             LDRB     R0,[R6, #+16]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??scheduleByTime_0
     73          		// this would guard the queue and disable interrupts
     74          		lockAnyContext();
   \   00000018   0x.... 0x....      BL       lockAnyContext
     75          	}
     76          	bool_t needToResetTimer = queue.insertTask(scheduling, US2NT(timeUs), callback, param);
   \                     ??scheduleByTime_0:
   \   0000001C   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000020   0x9700             STR      R7,[SP, #+0]
   \   00000022   0x20A8             MOVS     R0,#+168
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xFBA0 0x2304      UMULL    R2,R3,R0,R4
   \   0000002A   0xFB00 0x3305      MLA      R3,R0,R5,R3
   \   0000002E   0xFB01 0x3304      MLA      R3,R1,R4,R3
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       _ZN10EventQueue10insertTaskEP12scheduling_sxPFvPvES2_
   \   0000003A   0x4682             MOV      R10,R0
     77          	if (!reentrantFlag) {
   \   0000003C   0x7C30             LDRB     R0,[R6, #+16]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10C             BNE.N    ??scheduleByTime_1
     78          		doExecute();
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       _ZN8Executor9doExecuteEv
     79          		if (needToResetTimer) {
   \   00000048   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000004C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000050   0xD002             BEQ.N    ??scheduleByTime_2
     80          			scheduleTimerCallback();
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x.... 0x....      BL       _ZN8Executor21scheduleTimerCallbackEv
     81          		}
     82          		unlockAnyContext();
   \                     ??scheduleByTime_2:
   \   00000058   0x.... 0x....      BL       unlockAnyContext
     83          	}
     84          }
   \                     ??scheduleByTime_1:
   \   0000005C   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
     85          

   \                                 In section .text, align 2, keep-with-next
     86          void Executor::schedule(scheduling_s *scheduling, efitime_t nowUs, int delayUs, schfunc_t callback,
     87          		void *param) {
   \                     _ZN8Executor8scheduleEP12scheduling_sxiPFvPvES2_:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x4692             MOV      R10,R2
   \   0000000C   0x469B             MOV      R11,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000012   0x9E0D             LDR      R6,[SP, #+52]
   \   00000014   0x9F0E             LDR      R7,[SP, #+56]
     88          	scheduleByTime(scheduling, nowUs + delayUs, callback, param);
   \   00000016   0x9701             STR      R7,[SP, #+4]
   \   00000018   0x9600             STR      R6,[SP, #+0]
   \   0000001A   0xEA5F 0x79E8      ASRS     R9,R8,#+31
   \   0000001E   0xEB1A 0x0208      ADDS     R2,R10,R8
   \   00000022   0xEB5B 0x0309      ADCS     R3,R11,R9
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN8Executor14scheduleByTimeEP12scheduling_sxPFvPvES2_
     89          }
   \   0000002E   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
     90          

   \                                 In section .text, align 2, keep-with-next
     91          void Executor::onTimerCallback() {
   \                     _ZN8Executor15onTimerCallbackEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     92          	lockAnyContext();
   \   00000004   0x.... 0x....      BL       lockAnyContext
     93          	doExecute();
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       _ZN8Executor9doExecuteEv
     94          	scheduleTimerCallback();
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZN8Executor21scheduleTimerCallbackEv
     95          	unlockAnyContext();
   \   00000014   0x.... 0x....      BL       unlockAnyContext
     96          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     97          
     98          /*
     99           * this private method is executed under lock
    100           */

   \                                 In section .text, align 2, keep-with-next
    101          void Executor::doExecute() {
   \                     _ZN8Executor9doExecuteEv:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
    102          	/**
    103          	 * Let's execute actions we should execute at this point.
    104          	 * reentrantFlag takes care of the use case where the actions we are executing are scheduling
    105          	 * further invocations
    106          	 */
    107          	reentrantFlag = true;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF888 0x0010      STRB     R0,[R8, #+16]
    108          	int shouldExecute = 1;
   \   0000000C   0x2601             MOVS     R6,#+1
    109          	/**
    110          	 * in real life it could be that while we executing listeners time passes and it's already time to execute
    111          	 * next listeners.
    112          	 * TODO: add a counter & figure out a limit of iterations?
    113          	 */
    114          	int totalExecuted = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
    115          	while (shouldExecute > 0) {
   \                     ??doExecute_0:
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xDB0B             BLT.N    ??doExecute_1
    116          		/**
    117          		 * It's worth noting that that the actions might be adding new actions into the queue
    118          		 */
    119          		efitick_t nowNt = getTimeNowNt();
   \   00000014   0x.... 0x....      BL       getTimeNowNt
   \   00000018   0x0004             MOVS     R4,R0
   \   0000001A   0x000D             MOVS     R5,R1
    120          		shouldExecute = queue.executeAll(nowNt);
   \   0000001C   0x0022             MOVS     R2,R4
   \   0000001E   0x002B             MOVS     R3,R5
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x.... 0x....      BL       _ZN10EventQueue10executeAllEx
   \   00000026   0x0006             MOVS     R6,R0
    121          		totalExecuted += shouldExecute;
   \   00000028   0x19F7             ADDS     R7,R6,R7
   \   0000002A   0xE7F1             B.N      ??doExecute_0
    122          	}
    123          	lastExecutionCount = totalExecuted;
   \                     ??doExecute_1:
   \   0000002C   0x....             LDR.N    R0,??DataTable6_3
   \   0000002E   0x6007             STR      R7,[R0, #+0]
    124          	if (!isLocked()) {
   \   00000030   0x....             LDR.N    R0,??DataTable6_4
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xDA03             BGE.N    ??doExecute_2
    125          		firmwareError("Someone has stolen my lock");
   \   00000038   0x....             LDR.N    R0,??DataTable6_5
   \   0000003A   0x.... 0x....      BL       firmwareError
    126          		return;
   \   0000003E   0xE002             B.N      ??doExecute_3
    127          	}
    128          	reentrantFlag = false;
   \                     ??doExecute_2:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF888 0x0010      STRB     R0,[R8, #+16]
    129          }
   \                     ??doExecute_3:
   \   00000046   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    130          
    131          /**
    132           * This method is always invoked under a lock
    133           */

   \                                 In section .text, align 2, keep-with-next
    134          void Executor::scheduleTimerCallback() {
   \                     _ZN8Executor21scheduleTimerCallbackEv:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
    135          	/**
    136          	 * Let's grab fresh time value
    137          	 */
    138          	efitick_t nowNt = getTimeNowNt();
   \   00000004   0x.... 0x....      BL       getTimeNowNt
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
    139          	nextEventTimeNt = queue.getNextEventTime(nowNt);
   \   0000000C   0x0022             MOVS     R2,R4
   \   0000000E   0x002B             MOVS     R3,R5
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x.... 0x....      BL       _ZN10EventQueue16getNextEventTimeEx
   \   00000016   0x....             LDR.N    R2,??DataTable6_6
   \   00000018   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    140          	efiAssertVoid(nextEventTimeNt > nowNt, "setTimer constraint");
   \   0000001C   0x....             LDR.N    R0,??DataTable6_6
   \   0000001E   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000022   0x429D             CMP      R5,R3
   \   00000024   0xDB06             BLT.N    ??scheduleTimerCallback_0
   \   00000026   0xDC01             BGT.N    ??scheduleTimerCallback_1
   \   00000028   0x4294             CMP      R4,R2
   \   0000002A   0xD303             BCC.N    ??scheduleTimerCallback_0
   \                     ??scheduleTimerCallback_1:
   \   0000002C   0x....             LDR.N    R0,??DataTable6_7
   \   0000002E   0x.... 0x....      BL       firmwareError
   \   00000032   0xE023             B.N      ??scheduleTimerCallback_2
    141          	if (nextEventTimeNt == EMPTY_QUEUE)
   \                     ??scheduleTimerCallback_0:
   \   00000034   0x....             LDR.N    R0,??DataTable6_6
   \   00000036   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000003A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003E   0xF07F 0x4170      MVNS     R1,#-268435456
   \   00000042   0x428B             CMP      R3,R1
   \   00000044   0xD101             BNE.N    ??scheduleTimerCallback_3
   \   00000046   0x4282             CMP      R2,R0
   \   00000048   0xD018             BEQ.N    ??scheduleTimerCallback_2
    142          		return; // no pending events in the queue
    143          	int32_t hwAlarmTime = NT2US((int32_t)nextEventTimeNt - (int32_t)nowNt);
   \                     ??scheduleTimerCallback_3:
   \   0000004A   0x....             LDR.N    R2,??DataTable6_6
   \   0000004C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   00000050   0x1B00             SUBS     R0,R0,R4
   \   00000052   0x21A8             MOVS     R1,#+168
   \   00000054   0xFB90 0xF7F1      SDIV     R7,R0,R1
    144          	beforeHwSetTimer = GET_TIMESTAMP();
   \   00000058   0x....             LDR.N    R0,??DataTable6_8
   \   0000005A   0x....             LDR.N    R1,??DataTable6_9  ;; 0xe0001004
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    145          	setHardwareUsTimer(hwAlarmTime == 0 ? 1 : hwAlarmTime);
   \   00000060   0x2F00             CMP      R7,#+0
   \   00000062   0xD101             BNE.N    ??scheduleTimerCallback_4
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE000             B.N      ??scheduleTimerCallback_5
   \                     ??scheduleTimerCallback_4:
   \   00000068   0x0038             MOVS     R0,R7
   \                     ??scheduleTimerCallback_5:
   \   0000006A   0x.... 0x....      BL       setHardwareUsTimer
    146          	hwSetTimerTime = GET_TIMESTAMP() - beforeHwSetTimer;
   \   0000006E   0x....             LDR.N    R0,??DataTable6_9  ;; 0xe0001004
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x....             LDR.N    R1,??DataTable6_8
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x1A40             SUBS     R0,R0,R1
   \   00000078   0x....             LDR.N    R1,??DataTable6_10
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    147          }
   \                     ??scheduleTimerCallback_2:
   \   0000007C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    148          
    149          /**
    150           * @brief Schedule an event
    151           *
    152           * Invokes event callback after the specified amount of time.
    153           *
    154           * @param [in, out] scheduling Data structure to keep this event in the collection.
    155           * @param [in] delayUs the number of microseconds before the output signal immediate output if delay is zero.
    156           * @param [in] dwell the number of ticks of output duration.
    157           */

   \                                 In section .text, align 2, keep-with-next
    158          void scheduleTask(const char *prefix, scheduling_s *scheduling, int delayUs, schfunc_t callback, void *param) {
   \                     _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001D             MOVS     R5,R3
   \   0000000C   0x9F08             LDR      R7,[SP, #+32]
    159          //	scheduling->name = prefix;
    160          	instance.scheduleByTime(scheduling, getTimeNowUs() + delayUs, callback, param);
   \   0000000E   0x.... 0x....      BL       getTimeNowUs
   \   00000012   0x9701             STR      R7,[SP, #+4]
   \   00000014   0x9500             STR      R5,[SP, #+0]
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0x17F3             ASRS     R3,R6,#+31
   \   0000001A   0x1882             ADDS     R2,R0,R2
   \   0000001C   0x414B             ADCS     R3,R1,R3
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x....             LDR.N    R0,??DataTable6
   \   00000022   0x.... 0x....      BL       _ZN8Executor14scheduleByTimeEP12scheduling_sxPFvPvES2_
    161          }
   \   00000026   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void scheduleByTime(const char *prefix, scheduling_s *scheduling, efitimeus_t time, schfunc_t callback, void *param) {
   \                     _Z14scheduleByTimePKcP12scheduling_sxPFvPvES3_:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0x001D             MOVS     R5,R3
   \   0000000E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000012   0xF8DD 0x902C      LDR      R9,[SP, #+44]
    164          //	scheduling->name = prefix;
    165          	instance.scheduleByTime(scheduling, time, callback, param);
   \   00000016   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   0000001A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000001E   0x0022             MOVS     R2,R4
   \   00000020   0x002B             MOVS     R3,R5
   \   00000022   0x0039             MOVS     R1,R7
   \   00000024   0x....             LDR.N    R0,??DataTable6
   \   00000026   0x.... 0x....      BL       _ZN8Executor14scheduleByTimeEP12scheduling_sxPFvPvES2_
    166          }
   \   0000002A   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void initSignalExecutorImpl(void) {
   \                     _Z22initSignalExecutorImplv:
   \   00000000   0xB580             PUSH     {R7,LR}
    169          	globalTimerCallback = executorCallback;
   \   00000002   0x....             LDR.N    R0,??DataTable6_11
   \   00000004   0x....             LDR.N    R1,??DataTable6_12
   \   00000006   0x6001             STR      R1,[R0, #+0]
    170          #if EFI_PROD_CODE
    171          	initMicrosecondTimer();
   \   00000008   0x.... 0x....      BL       initMicrosecondTimer
    172          #endif /* EFI_PROD_CODE */
    173          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     instance

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     `?<Constant "lowstck#2y">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     lastExecutionCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     dbg_lock_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     `?<Constant "Someone has stolen my...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     nextEventTimeNt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     `?<Constant "setTimer constraint">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     beforeHwSetTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     hwSetTimerTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     globalTimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     _Z16executorCallbackPv

   \                                 In section .init_array, align 4, keep-with-next, root
   \   00000000   0x........         DC32    RELOC_ARM_TARGET1 __sti__routine

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#2y">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#2y"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x32 0x79    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Someone has stolen my...">`:
   \   00000000   0x53 0x6F          DC8 "Someone has stolen my lock"
   \              0x6D 0x65    
   \              0x6F 0x6E    
   \              0x65 0x20    
   \              0x68 0x61    
   \              0x73 0x20    
   \              0x73 0x74    
   \              0x6F 0x6C    
   \              0x65 0x6E    
   \              0x20 0x6D    
   \              0x79 0x20    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "setTimer constraint">`:
   \   00000000   0x73 0x65          DC8 "setTimer constraint"
   \              0x74 0x54    
   \              0x69 0x6D    
   \              0x65 0x72    
   \              0x20 0x63    
   \              0x6F 0x6E    
   \              0x73 0x74    
   \              0x72 0x61    
   \              0x69 0x6E    
   \              0x74 0x00    
    174          
    175          #endif
    176          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Executor::Executor()
         8   -> EventQueue::EventQueue()
         8   -> EventQueue::setLateDelay(int)
      24   Executor::doExecute()
        24   -> EventQueue::executeAll(int64_t)
        24   -> firmwareError
        24   -> getTimeNowNt
       8   Executor::onTimerCallback()
         8   -> Executor::doExecute()
         8   -> Executor::scheduleTimerCallback()
         8   -> lockAnyContext
         8   -> unlockAnyContext
      48   Executor::schedule(scheduling_s *, int64_t, int, schfunc_t, void *)
        48   -> Executor::scheduleByTime(scheduling_s *, int64_t, schfunc_t, void *)
      40   Executor::scheduleByTime(scheduling_s *, int64_t, schfunc_t, void *)
        40   -> EventQueue::insertTask(scheduling_s *, int64_t, schfunc_t, void *)
        40   -> Executor::doExecute()
        40   -> Executor::scheduleTimerCallback()
        40   -> lockAnyContext
        40   -> unlockAnyContext
      24   Executor::scheduleTimerCallback()
        24   -> EventQueue::getNextEventTime(int64_t)
        24   -> firmwareError
        24   -> getTimeNowNt
        24   -> setHardwareUsTimer
       8   Executor::subobject Executor()
         8   -> Executor::Executor()
       8   __sti__routine()
         8   -> Executor::Executor()
       8   executorCallback(void *)
         8   -> Executor::onTimerCallback()
         8   -> firmwareError
         8   -> getRemainingStack
       8   initSignalExecutorImpl()
         8   -> initMicrosecondTimer
      40   scheduleByTime(char const *, scheduling_s *, int64_t, schfunc_t, void *)
        40   -> Executor::scheduleByTime(scheduling_s *, int64_t, schfunc_t, void *)
      32   scheduleTask(char const *, scheduling_s *, int, schfunc_t, void *)
        32   -> Executor::scheduleByTime(scheduling_s *, int64_t, schfunc_t, void *)
        32   -> getTimeNowUs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Constant "Someone has stolen my...">
      12  ?<Constant "lowstck#2y">
      20  ?<Constant "setTimer constraint">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      28  Executor::Executor()
      74  Executor::doExecute()
      26  Executor::onTimerCallback()
      50  Executor::schedule(scheduling_s *, int64_t, int, schfunc_t, void *)
      96  Executor::scheduleByTime(scheduling_s *, int64_t, schfunc_t, void *)
     126  Executor::scheduleTimerCallback()
      12  Executor::subobject Executor()
      10  __sti__routine()
       4  beforeHwSetTimer
      34  executorCallback(void *)
       4  hwSetTimerTime
      14  initSignalExecutorImpl()
      24  instance
       4  lastExecutionCount
       8  nextEventTimeNt
      46  scheduleByTime(char const *, scheduling_s *, int64_t, schfunc_t, void *)
      42  scheduleTask(char const *, scheduling_s *, int, schfunc_t, void *)
       4  -- Other

 
  44 bytes in section .bss
   4 bytes in section .init_array
  60 bytes in section .rodata
 610 bytes in section .text
 
 614 bytes of CODE  memory
  60 bytes of CONST memory
  44 bytes of DATA  memory

Errors: none
Warnings: 1
