###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:00 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chthreads.c                                     #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chthreads.c -lCN F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -lA                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hthreads.lst                                          #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       threads.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chthreads.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chthreads.c
     30           * @brief   Threads code.
     31           *
     32           * @addtogroup threads
     33           * @details Threads related APIs and services.
     34           *
     35           *          <h2>Operation mode</h2>
     36           *          A thread is an abstraction of an independent instructions flow.
     37           *          In ChibiOS/RT a thread is represented by a "C" function owning
     38           *          a processor context, state informations and a dedicated stack
     39           *          area. In this scenario static variables are shared among all
     40           *          threads while automatic variables are local to the thread.<br>
     41           *          Operations defined for threads:
     42           *          - <b>Create</b>, a thread is started on the specified thread
     43           *            function. This operation is available in multiple variants,
     44           *            both static and dynamic.
     45           *          - <b>Exit</b>, a thread terminates by returning from its top
     46           *            level function or invoking a specific API, the thread can
     47           *            return a value that can be retrieved by other threads.
     48           *          - <b>Wait</b>, a thread waits for the termination of another
     49           *            thread and retrieves its return value.
     50           *          - <b>Resume</b>, a thread created in suspended state is started.
     51           *          - <b>Sleep</b>, the execution of a thread is suspended for the
     52           *            specified amount of time or the specified future absolute time
     53           *            is reached.
     54           *          - <b>SetPriority</b>, a thread changes its own priority level.
     55           *          - <b>Yield</b>, a thread voluntarily renounces to its time slot.
     56           *          .
     57           *          The threads subsystem is implicitly included in kernel however
     58           *          some of its part may be excluded by disabling them in @p chconf.h,
     59           *          see the @p CH_USE_WAITEXIT and @p CH_USE_DYNAMIC configuration
     60           *          options.
     61           * @{
     62           */
     63          
     64          #include "ch.h"
     65          
     66          /**
     67           * @brief   Initializes a thread structure.
     68           * @note    This is an internal functions, do not use it in application code.
     69           *
     70           * @param[in] tp        pointer to the thread
     71           * @param[in] prio      the priority level for the new thread
     72           * @return              The same thread pointer passed as parameter.
     73           *
     74           * @notapi
     75           */

   \                                 In section .text, align 2, keep-with-next
     76          Thread *_thread_init(Thread *tp, tprio_t prio) {
     77          
     78            tp->p_prio = prio;
   \                     _thread_init:
   \   00000000   0x6081             STR      R1,[R0, #+8]
     79            tp->p_state = THD_STATE_SUSPENDED;
   \   00000002   0x2202             MOVS     R2,#+2
   \   00000004   0xF880 0x2020      STRB     R2,[R0, #+32]
     80            tp->p_flags = THD_MEM_MODE_STATIC;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF880 0x2021      STRB     R2,[R0, #+33]
     81          #if CH_TIME_QUANTUM > 0
     82            tp->p_preempt = CH_TIME_QUANTUM;
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0xF880 0x2022      STRB     R2,[R0, #+34]
     83          #endif
     84          #if CH_USE_MUTEXES
     85            tp->p_realprio = prio;
   \   00000014   0x6401             STR      R1,[R0, #+64]
     86            tp->p_mtxlist = NULL;
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x63C2             STR      R2,[R0, #+60]
     87          #endif
     88          #if CH_USE_EVENTS
     89            tp->p_epending = 0;
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x6382             STR      R2,[R0, #+56]
     90          #endif
     91          #if CH_DBG_THREADS_PROFILING
     92            tp->p_time = 0;
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x6242             STR      R2,[R0, #+36]
     93          #endif
     94          #if CH_USE_DYNAMIC
     95            tp->p_refs = 1;
     96          #endif
     97          #if CH_USE_REGISTRY
     98            tp->p_name = NULL;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x6182             STR      R2,[R0, #+24]
     99            REG_INSERT(tp);
   \   00000026   0x....             LDR.N    R2,??DataTable7
   \   00000028   0x6102             STR      R2,[R0, #+16]
   \   0000002A   0x....             LDR.N    R2,??DataTable7
   \   0000002C   0x6952             LDR      R2,[R2, #+20]
   \   0000002E   0x6142             STR      R2,[R0, #+20]
   \   00000030   0x....             LDR.N    R2,??DataTable7
   \   00000032   0x6150             STR      R0,[R2, #+20]
   \   00000034   0x6942             LDR      R2,[R0, #+20]
   \   00000036   0x6110             STR      R0,[R2, #+16]
    100          #endif
    101          #if CH_USE_WAITEXIT
    102            list_init(&tp->p_waiting);
    103          #endif
    104          #if CH_USE_MESSAGES
    105            queue_init(&tp->p_msgqueue);
   \   00000038   0xF110 0x022C      ADDS     R2,R0,#+44
   \   0000003C   0x6302             STR      R2,[R0, #+48]
   \   0000003E   0x62C2             STR      R2,[R0, #+44]
    106          #endif
    107          #if CH_DBG_ENABLE_STACK_CHECK
    108            tp->p_stklimit = (stkalign_t *)(tp + 1);
   \   00000040   0xF110 0x024C      ADDS     R2,R0,#+76
   \   00000044   0x61C2             STR      R2,[R0, #+28]
    109          #endif
    110          #if defined(THREAD_EXT_INIT_HOOK)
    111            THREAD_EXT_INIT_HOOK(tp);
    112          #endif
    113            return tp;
   \   00000046   0x4770             BX       LR               ;; return
    114          }
    115          
    116          #if CH_DBG_FILL_THREADS || defined(__DOXYGEN__)
    117          /**
    118           * @brief   Memory fill utility.
    119           *
    120           * @param[in] startp    first address to fill
    121           * @param[in] endp      last address to fill +1
    122           * @param[in] v         filler value
    123           *
    124           * @notapi
    125           */

   \                                 In section .text, align 2, keep-with-next
    126          void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
    127          
    128            while (startp < endp)
   \                     _thread_memfill:
   \                     ??_thread_memfill_0:
   \   00000000   0x4288             CMP      R0,R1
   \   00000002   0xD202             BCS.N    ??_thread_memfill_1
    129              *startp++ = v;
   \   00000004   0x7002             STRB     R2,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0xE7FA             B.N      ??_thread_memfill_0
    130          }
   \                     ??_thread_memfill_1:
   \   0000000A   0x4770             BX       LR               ;; return
    131          #endif /* CH_DBG_FILL_THREADS */
    132          
    133          /**
    134           * @brief   Creates a new thread into a static memory area.
    135           * @details The new thread is initialized but not inserted in the ready list,
    136           *          the initial state is @p THD_STATE_SUSPENDED.
    137           * @post    The initialized thread can be subsequently started by invoking
    138           *          @p chThdResume(), @p chThdResumeI() or @p chSchWakeupS()
    139           *          depending on the execution context.
    140           * @note    A thread can terminate by calling @p chThdExit() or by simply
    141           *          returning from its main function.
    142           * @note    Threads created using this function do not obey to the
    143           *          @p CH_DBG_FILL_THREADS debug option because it would keep
    144           *          the kernel locked for too much time.
    145           *
    146           * @param[out] wsp      pointer to a working area dedicated to the thread stack
    147           * @param[in] size      size of the working area
    148           * @param[in] prio      the priority level for the new thread
    149           * @param[in] pf        the thread function
    150           * @param[in] arg       an argument passed to the thread function. It can be
    151           *                      @p NULL.
    152           * @return              The pointer to the @p Thread structure allocated for
    153           *                      the thread into the working space area.
    154           *
    155           * @iclass
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          Thread *chThdCreateI(void *wsp, size_t size,
    158                               tprio_t prio, tfunc_t pf, void *arg) {
   \                     chThdCreateI:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    159            /* Thread structure is laid out in the lower part of the thread workspace.*/
    160            Thread *tp = wsp;
   \   00000010   0x46A1             MOV      R9,R4
    161          
    162            chDbgCheckClassI();
   \   00000012   0x.... 0x....      BL       chDbgCheckClassI
    163          
    164            chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
    165                       (prio <= HIGHPRIO) && (pf != NULL),
    166                       "chThdCreateI");
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD007             BEQ.N    ??chThdCreateI_0
   \   0000001A   0xF5B5 0x7F9C      CMP      R5,#+312
   \   0000001E   0xD304             BCC.N    ??chThdCreateI_0
   \   00000020   0x2E80             CMP      R6,#+128
   \   00000022   0xD202             BCS.N    ??chThdCreateI_0
   \   00000024   0x0038             MOVS     R0,R7
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD104             BNE.N    ??chThdCreateI_1
   \                     ??chThdCreateI_0:
   \   0000002A   0x22A6             MOVS     R2,#+166
   \   0000002C   0x....             LDR.N    R1,??DataTable7_1
   \   0000002E   0x....             LDR.N    R0,??DataTable7_2
   \   00000030   0x.... 0x....      BL       chDbgPanic3
    167            SETUP_CONTEXT(wsp, size, pf, arg);
   \                     ??chThdCreateI_1:
   \   00000034   0x1928             ADDS     R0,R5,R4
   \   00000036   0x3864             SUBS     R0,R0,#+100
   \   00000038   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   0000003C   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   00000040   0x6407             STR      R7,[R0, #+64]
   \   00000042   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   00000046   0xF8C0 0x8044      STR      R8,[R0, #+68]
   \   0000004A   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   0000004E   0x....             LDR.N    R1,??DataTable7_3
   \   00000050   0x6601             STR      R1,[R0, #+96]
    168            return _thread_init(tp, prio);
   \   00000052   0x0031             MOVS     R1,R6
   \   00000054   0x4648             MOV      R0,R9
   \   00000056   0x.... 0x....      BL       _thread_init
   \   0000005A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    169          }
    170          
    171          /**
    172           * @brief   Creates a new thread into a static memory area.
    173           * @note    A thread can terminate by calling @p chThdExit() or by simply
    174           *          returning from its main function.
    175           *
    176           * @param[out] wsp      pointer to a working area dedicated to the thread stack
    177           * @param[in] size      size of the working area
    178           * @param[in] prio      the priority level for the new thread
    179           * @param[in] pf        the thread function
    180           * @param[in] arg       an argument passed to the thread function. It can be
    181           *                      @p NULL.
    182           * @return              The pointer to the @p Thread structure allocated for
    183           *                      the thread into the working space area.
    184           *
    185           * @api
    186           */

   \                                 In section .text, align 2, keep-with-next
    187          Thread *chThdCreateStatic(void *wsp, size_t size,
    188                                    tprio_t prio, tfunc_t pf, void *arg) {
   \                     chThdCreateStatic:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    189            Thread *tp;
    190            
    191          #if CH_DBG_FILL_THREADS
    192            _thread_memfill((uint8_t *)wsp,
    193                            (uint8_t *)wsp + sizeof(Thread),
    194                            CH_THREAD_FILL_VALUE);
   \   00000010   0x22FF             MOVS     R2,#+255
   \   00000012   0xF114 0x014C      ADDS     R1,R4,#+76
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _thread_memfill
    195            _thread_memfill((uint8_t *)wsp + sizeof(Thread),
    196                            (uint8_t *)wsp + size,
    197                            CH_STACK_FILL_VALUE);
   \   0000001C   0x2255             MOVS     R2,#+85
   \   0000001E   0x1929             ADDS     R1,R5,R4
   \   00000020   0xF114 0x004C      ADDS     R0,R4,#+76
   \   00000024   0x.... 0x....      BL       _thread_memfill
    198          #endif
    199            chSysLock();
   \   00000028   0x2020             MOVS     R0,#+32
   \   0000002A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000002E   0x.... 0x....      BL       dbg_check_lock
    200            chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
   \   00000032   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000036   0x003B             MOVS     R3,R7
   \   00000038   0x0032             MOVS     R2,R6
   \   0000003A   0x0029             MOVS     R1,R5
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       chThdCreateI
   \   00000042   0x4681             MOV      R9,R0
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x.... 0x....      BL       chSchWakeupS
    201            chSysUnlock();
   \   0000004A   0x.... 0x....      BL       dbg_check_unlock
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF380 0x8811      MSR      BASEPRI,R0
    202            return tp;
   \   00000054   0x4648             MOV      R0,R9
   \   00000056   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    203          }
    204          
    205          /**
    206           * @brief   Changes the running thread priority level then reschedules if
    207           *          necessary.
    208           * @note    The function returns the real thread priority regardless of the
    209           *          current priority that could be higher than the real priority
    210           *          because the priority inheritance mechanism.
    211           *
    212           * @param[in] newprio   the new priority level of the running thread
    213           * @return              The old priority level.
    214           *
    215           * @api
    216           */

   \                                 In section .text, align 2, keep-with-next
    217          tprio_t chThdSetPriority(tprio_t newprio) {
   \                     chThdSetPriority:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    218            tprio_t oldprio;
    219          
    220            chDbgCheck(newprio <= HIGHPRIO, "chThdSetPriority");
   \   00000004   0x2C80             CMP      R4,#+128
   \   00000006   0xD304             BCC.N    ??chThdSetPriority_0
   \   00000008   0x22DC             MOVS     R2,#+220
   \   0000000A   0x....             LDR.N    R1,??DataTable7_1
   \   0000000C   0x....             LDR.N    R0,??DataTable7_4
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    221          
    222            chSysLock();
   \                     ??chThdSetPriority_0:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock
    223          #if CH_USE_MUTEXES
    224            oldprio = currp->p_realprio;
   \   0000001C   0x....             LDR.N    R0,??DataTable7
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x6C00             LDR      R0,[R0, #+64]
   \   00000022   0x0005             MOVS     R5,R0
    225            if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio))
   \   00000024   0x....             LDR.N    R0,??DataTable7
   \   00000026   0x6980             LDR      R0,[R0, #+24]
   \   00000028   0x6880             LDR      R0,[R0, #+8]
   \   0000002A   0x....             LDR.N    R1,??DataTable7
   \   0000002C   0x6989             LDR      R1,[R1, #+24]
   \   0000002E   0x6C09             LDR      R1,[R1, #+64]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??chThdSetPriority_1
   \   00000034   0x....             LDR.N    R0,??DataTable7
   \   00000036   0x6980             LDR      R0,[R0, #+24]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x42A0             CMP      R0,R4
   \   0000003C   0xD202             BCS.N    ??chThdSetPriority_2
    226              currp->p_prio = newprio;
   \                     ??chThdSetPriority_1:
   \   0000003E   0x....             LDR.N    R0,??DataTable7
   \   00000040   0x6980             LDR      R0,[R0, #+24]
   \   00000042   0x6084             STR      R4,[R0, #+8]
    227            currp->p_realprio = newprio;
   \                     ??chThdSetPriority_2:
   \   00000044   0x....             LDR.N    R0,??DataTable7
   \   00000046   0x6980             LDR      R0,[R0, #+24]
   \   00000048   0x6404             STR      R4,[R0, #+64]
    228          #else
    229            oldprio = currp->p_prio;
    230            currp->p_prio = newprio;
    231          #endif
    232            chSchRescheduleS();
   \   0000004A   0x.... 0x....      BL       chSchRescheduleS
    233            chSysUnlock();
   \   0000004E   0x.... 0x....      BL       dbg_check_unlock
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF380 0x8811      MSR      BASEPRI,R0
    234            return oldprio;
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    235          }
    236          
    237          /**
    238           * @brief   Resumes a suspended thread.
    239           * @pre     The specified thread pointer must refer to an initialized thread
    240           *          in the @p THD_STATE_SUSPENDED state.
    241           * @post    The specified thread is immediately started or put in the ready
    242           *          list depending on the relative priority levels.
    243           * @note    Use this function to start threads created with @p chThdCreateI().
    244           *
    245           * @param[in] tp        pointer to the thread
    246           * @return              The pointer to the thread.
    247           *
    248           * @api
    249           */

   \                                 In section .text, align 2, keep-with-next
    250          Thread *chThdResume(Thread *tp) {
   \                     chThdResume:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    251          
    252            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    253            chDbgAssert(tp->p_state == THD_STATE_SUSPENDED,
    254                        "chThdResume(), #1",
    255                        "thread not in THD_STATE_SUSPENDED state");
   \   0000000E   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD002             BEQ.N    ??chThdResume_0
   \   00000016   0x....             LDR.N    R0,??DataTable7_5
   \   00000018   0x.... 0x....      BL       chDbgPanic
    256            chSchWakeupS(tp, RDY_OK);
   \                     ??chThdResume_0:
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       chSchWakeupS
    257            chSysUnlock();
   \   00000024   0x.... 0x....      BL       dbg_check_unlock
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF380 0x8811      MSR      BASEPRI,R0
    258            return tp;
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    259          }
    260          
    261          /**
    262           * @brief   Requests a thread termination.
    263           * @pre     The target thread must be written to invoke periodically
    264           *          @p chThdShouldTerminate() and terminate cleanly if it returns
    265           *          @p TRUE.
    266           * @post    The specified thread will terminate after detecting the termination
    267           *          condition.
    268           *
    269           * @param[in] tp        pointer to the thread
    270           *
    271           * @api
    272           */

   \                                 In section .text, align 2, keep-with-next
    273          void chThdTerminate(Thread *tp) {
   \                     chThdTerminate:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    274          
    275            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    276            tp->p_flags |= THD_TERMINATE;
   \   0000000E   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \   00000012   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000016   0xF884 0x0021      STRB     R0,[R4, #+33]
    277            chSysUnlock();
   \   0000001A   0x.... 0x....      BL       dbg_check_unlock
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF380 0x8811      MSR      BASEPRI,R0
    278          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    279          
    280          /**
    281           * @brief   Suspends the invoking thread for the specified time.
    282           *
    283           * @param[in] time      the delay in system ticks, the special values are
    284           *                      handled as follow:
    285           *                      - @a TIME_INFINITE the thread enters an infinite sleep
    286           *                        state.
    287           *                      - @a TIME_IMMEDIATE this value is not allowed.
    288           *                      .
    289           *
    290           * @api
    291           */

   \                                 In section .text, align 2, keep-with-next
    292          void chThdSleep(systime_t time) {
   \                     chThdSleep:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    293          
    294            chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??chThdSleep_0
   \   00000008   0xF44F 0x7293      MOV      R2,#+294
   \   0000000C   0x....             LDR.N    R1,??DataTable7_1
   \   0000000E   0x....             LDR.N    R0,??DataTable7_6
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    295          
    296            chSysLock();
   \                     ??chThdSleep_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    297            chThdSleepS(time);
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x2006             MOVS     R0,#+6
   \   00000022   0x.... 0x....      BL       chSchGoSleepTimeoutS
    298            chSysUnlock();
   \   00000026   0x.... 0x....      BL       dbg_check_unlock
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF380 0x8811      MSR      BASEPRI,R0
    299          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    300          
    301          /**
    302           * @brief   Suspends the invoking thread until the system time arrives to the
    303           *          specified value.
    304           *
    305           * @param[in] time      absolute system time
    306           *
    307           * @api
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          void chThdSleepUntil(systime_t time) {
   \                     chThdSleepUntil:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    310          
    311            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    312            if ((time -= chTimeNow()) > 0)
   \   0000000E   0x....             LDR.N    R0,??DataTable7_7
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0x1A24             SUBS     R4,R4,R0
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD003             BEQ.N    ??chThdSleepUntil_0
    313              chThdSleepS(time);
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x2006             MOVS     R0,#+6
   \   0000001C   0x.... 0x....      BL       chSchGoSleepTimeoutS
    314            chSysUnlock();
   \                     ??chThdSleepUntil_0:
   \   00000020   0x.... 0x....      BL       dbg_check_unlock
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
    315          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    316          
    317          /**
    318           * @brief   Yields the time slot.
    319           * @details Yields the CPU control to the next thread in the ready list with
    320           *          equal priority, if any.
    321           *
    322           * @api
    323           */

   \                                 In section .text, align 2, keep-with-next
    324          void chThdYield(void) {
   \                     chThdYield:
   \   00000000   0xB580             PUSH     {R7,LR}
    325          
    326            chSysLock();
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000008   0x.... 0x....      BL       dbg_check_lock
    327            chSchDoYieldS();
   \   0000000C   0x....             LDR.N    R0,??DataTable7
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x....             LDR.N    R1,??DataTable7
   \   00000014   0x6989             LDR      R1,[R1, #+24]
   \   00000016   0x6889             LDR      R1,[R1, #+8]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD301             BCC.N    ??chThdYield_0
   \   0000001C   0x.... 0x....      BL       chSchDoRescheduleBehind
    328            chSysUnlock();
   \                     ??chThdYield_0:
   \   00000020   0x.... 0x....      BL       dbg_check_unlock
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
    329          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    330          
    331          /**
    332           * @brief   Terminates the current thread.
    333           * @details The thread goes in the @p THD_STATE_FINAL state holding the
    334           *          specified exit status code, other threads can retrieve the
    335           *          exit status code by invoking the function @p chThdWait().
    336           * @post    Eventual code after this function will never be executed,
    337           *          this function never returns. The compiler has no way to
    338           *          know this so do not assume that the compiler would remove
    339           *          the dead code.
    340           *
    341           * @param[in] msg       thread exit code
    342           *
    343           * @api
    344           */

   \                                 In section .text, align 2, keep-with-next
    345          void chThdExit(msg_t msg) {
   \                     chThdExit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    346          
    347            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    348            chThdExitS(msg);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       chThdExitS
    349            /* The thread never returns here.*/
    350          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    351          
    352          /**
    353           * @brief   Terminates the current thread.
    354           * @details The thread goes in the @p THD_STATE_FINAL state holding the
    355           *          specified exit status code, other threads can retrieve the
    356           *          exit status code by invoking the function @p chThdWait().
    357           * @post    Eventual code after this function will never be executed,
    358           *          this function never returns. The compiler has no way to
    359           *          know this so do not assume that the compiler would remove
    360           *          the dead code.
    361           *
    362           * @param[in] msg       thread exit code
    363           *
    364           * @sclass
    365           */

   \                                 In section .text, align 2, keep-with-next
    366          void chThdExitS(msg_t msg) {
   \                     chThdExitS:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    367            Thread *tp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable7
   \   00000006   0x6985             LDR      R5,[R0, #+24]
    368          
    369            tp->p_u.exitcode = msg;
   \   00000008   0x62AC             STR      R4,[R5, #+40]
    370          #if defined(THREAD_EXT_EXIT_HOOK)
    371            THREAD_EXT_EXIT_HOOK(tp);
    372          #endif
    373          #if CH_USE_WAITEXIT
    374            while (notempty(&tp->p_waiting))
    375              chSchReadyI(list_remove(&tp->p_waiting));
    376          #endif
    377          #if CH_USE_REGISTRY
    378            /* Static threads are immediately removed from the registry because
    379               there is no memory to recover.*/
    380            if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
   \   0000000A   0xF895 0x0021      LDRB     R0,[R5, #+33]
   \   0000000E   0x2103             MOVS     R1,#+3
   \   00000010   0x4208             TST      R0,R1
   \   00000012   0xD105             BNE.N    ??chThdExitS_0
    381              REG_REMOVE(tp);
   \   00000014   0x6968             LDR      R0,[R5, #+20]
   \   00000016   0x6929             LDR      R1,[R5, #+16]
   \   00000018   0x6101             STR      R1,[R0, #+16]
   \   0000001A   0x6928             LDR      R0,[R5, #+16]
   \   0000001C   0x6969             LDR      R1,[R5, #+20]
   \   0000001E   0x6141             STR      R1,[R0, #+20]
    382          #endif
    383            chSchGoSleepS(THD_STATE_FINAL);
   \                     ??chThdExitS_0:
   \   00000020   0x200E             MOVS     R0,#+14
   \   00000022   0x.... 0x....      BL       chSchGoSleepS
    384            /* The thread never returns here.*/
    385            chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
   \   00000026   0x....             LDR.N    R0,??DataTable7_8
   \   00000028   0x.... 0x....      BL       chDbgPanic
    386          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     `?<Constant "\\"chThdCreateI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     _port_thread_start

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     `?<Constant "\\"chThdSetPriority\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     `?<Constant "chThdResume(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     `?<Constant "\\"chThdSleep\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     vtlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     `?<Constant "chThdExitS(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chThdCreateI\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chThdCreateI\"()"
   \              0x68 0x54    
   \              0x68 0x64    
   \              0x43 0x72    
   \              0x65 0x61    
   \              0x74 0x65    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x6B 0x65          DC8 6BH, 65H, 72H, 6EH, 65H, 6CH, 5CH, 73H
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x5C 0x73    
   \   00000038   0x72 0x63          DC8 72H, 63H, 5CH, 63H, 68H, 74H, 68H, 72H
   \              0x5C 0x63    
   \              0x68 0x74    
   \              0x68 0x72    
   \   00000040   0x65 0x61          DC8 65H, 61H, 64H, 73H, 2EH, 63H, 0
   \              0x64 0x73    
   \              0x2E 0x63    
   \              0x00         
   \   00000047   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chThdSetPriority\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chThdSetPriority\"()"
   \              0x68 0x54    
   \              0x68 0x64    
   \              0x53 0x65    
   \              0x74 0x50    
   \              0x72 0x69    
   \              0x6F 0x72    
   \              0x69 0x74    
   \              0x79 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "chThdResume(), #1">`:
   \   00000000   0x63 0x68          DC8 "chThdResume(), #1"
   \              0x54 0x68    
   \              0x64 0x52    
   \              0x65 0x73    
   \              0x75 0x6D    
   \              0x65 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chThdSleep\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chThdSleep\"()"
   \              0x68 0x54    
   \              0x68 0x64    
   \              0x53 0x6C    
   \              0x65 0x65    
   \              0x70 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chThdExitS(), #1">`:
   \   00000000   0x63 0x68          DC8 "chThdExitS(), #1"
   \              0x54 0x68    
   \              0x64 0x45    
   \              0x78 0x69    
   \              0x74 0x53    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    387          
    388          #if CH_USE_WAITEXIT || defined(__DOXYGEN__)
    389          /**
    390           * @brief   Blocks the execution of the invoking thread until the specified
    391           *          thread terminates then the exit code is returned.
    392           * @details This function waits for the specified thread to terminate then
    393           *          decrements its reference counter, if the counter reaches zero then
    394           *          the thread working area is returned to the proper allocator.<br>
    395           *          The memory used by the exited thread is handled in different ways
    396           *          depending on the API that spawned the thread:
    397           *          - If the thread was spawned by @p chThdCreateStatic() or by
    398           *            @p chThdCreateI() then nothing happens and the thread working
    399           *            area is not released or modified in any way. This is the
    400           *            default, totally static, behavior.
    401           *          - If the thread was spawned by @p chThdCreateFromHeap() then
    402           *            the working area is returned to the system heap.
    403           *          - If the thread was spawned by @p chThdCreateFromMemoryPool()
    404           *            then the working area is returned to the owning memory pool.
    405           *          .
    406           * @pre     The configuration option @p CH_USE_WAITEXIT must be enabled in
    407           *          order to use this function.
    408           * @post    Enabling @p chThdWait() requires 2-4 (depending on the
    409           *          architecture) extra bytes in the @p Thread structure.
    410           * @post    After invoking @p chThdWait() the thread pointer becomes invalid
    411           *          and must not be used as parameter for further system calls.
    412           * @note    If @p CH_USE_DYNAMIC is not specified this function just waits for
    413           *          the thread termination, no memory allocators are involved.
    414           *
    415           * @param[in] tp        pointer to the thread
    416           * @return              The exit code from the terminated thread.
    417           *
    418           * @api
    419           */
    420          msg_t chThdWait(Thread *tp) {
    421            msg_t msg;
    422          
    423            chDbgCheck(tp != NULL, "chThdWait");
    424          
    425            chSysLock();
    426            chDbgAssert(tp != currp, "chThdWait(), #1", "waiting self");
    427          #if CH_USE_DYNAMIC
    428            chDbgAssert(tp->p_refs > 0, "chThdWait(), #2", "not referenced");
    429          #endif
    430            if (tp->p_state != THD_STATE_FINAL) {
    431              list_insert(currp, &tp->p_waiting);
    432              chSchGoSleepS(THD_STATE_WTEXIT);
    433            }
    434            msg = tp->p_u.exitcode;
    435            chSysUnlock();
    436          #if CH_USE_DYNAMIC
    437            chThdRelease(tp);
    438          #endif
    439            return msg;
    440          }
    441          #endif /* CH_USE_WAITEXIT */
    442          
    443          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _thread_init
       0   _thread_memfill
      32   chThdCreateI
        32   -> _thread_init
        32   -> chDbgCheckClassI
        32   -> chDbgPanic3
      32   chThdCreateStatic
        32   -> _thread_memfill
        32   -> chSchWakeupS
        32   -> chThdCreateI
        32   -> dbg_check_lock
        32   -> dbg_check_unlock
       8   chThdExit
         8   -> chThdExitS
         8   -> dbg_check_lock
      16   chThdExitS
        16   -> chDbgPanic
        16   -> chSchGoSleepS
       8   chThdResume
         8   -> chDbgPanic
         8   -> chSchWakeupS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
      16   chThdSetPriority
        16   -> chDbgPanic3
        16   -> chSchRescheduleS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
       8   chThdSleep
         8   -> chDbgPanic3
         8   -> chSchGoSleepTimeoutS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
       8   chThdSleepUntil
         8   -> chSchGoSleepTimeoutS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
       8   chThdTerminate
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
       8   chThdYield
         8   -> chSchDoRescheduleBehind
         8   -> dbg_check_lock
         8   -> dbg_check_unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  ?<Constant "F:\\stuff\\rusefi_sourc...">
      20  ?<Constant "\"chThdCreateI\"()">
      24  ?<Constant "\"chThdSetPriority\"()">
      16  ?<Constant "\"chThdSleep\"()">
      20  ?<Constant "chThdExitS(), #1">
      20  ?<Constant "chThdResume(), #1">
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
      72  _thread_init
      12  _thread_memfill
      94  chThdCreateI
      90  chThdCreateStatic
      22  chThdExit
      46  chThdExitS
      50  chThdResume
      92  chThdSetPriority
      50  chThdSleep
      44  chThdSleepUntil
      38  chThdTerminate
      44  chThdYield

 
 172 bytes in section .rodata
 690 bytes in section .text
 
 690 bytes of CODE  memory
 172 bytes of CONST memory

Errors: none
Warnings: none
