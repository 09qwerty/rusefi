###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:47 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\I2Cv1\i2c_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\I2Cv1\i2c_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\i #
#                       2c_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\i2 #
#                       c_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\I2Cv1\i2c_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          /*
     17             Concepts and parts of this file have been contributed by Uladzimir Pylinsky
     18             aka barthess.
     19           */
     20          
     21          /**
     22           * @file    STM32/I2Cv1/i2c_lld.c
     23           * @brief   STM32 I2C subsystem low level driver source.
     24           *
     25           * @addtogroup I2C
     26           * @{
     27           */
     28          
     29          #include "ch.h"
     30          #include "hal.h"
     31          
     32          #if HAL_USE_I2C || defined(__DOXYGEN__)
     33          
     34          /*===========================================================================*/
     35          /* Driver local definitions.                                                 */
     36          /*===========================================================================*/
     37          
     38          #define I2C1_RX_DMA_CHANNEL                                                 \
     39            STM32_DMA_GETCHANNEL(STM32_I2C_I2C1_RX_DMA_STREAM,                        \
     40                                 STM32_I2C1_RX_DMA_CHN)
     41          
     42          #define I2C1_TX_DMA_CHANNEL                                                 \
     43            STM32_DMA_GETCHANNEL(STM32_I2C_I2C1_TX_DMA_STREAM,                        \
     44                                 STM32_I2C1_TX_DMA_CHN)
     45          
     46          #define I2C2_RX_DMA_CHANNEL                                                 \
     47            STM32_DMA_GETCHANNEL(STM32_I2C_I2C2_RX_DMA_STREAM,                        \
     48                                 STM32_I2C2_RX_DMA_CHN)
     49          
     50          #define I2C2_TX_DMA_CHANNEL                                                 \
     51            STM32_DMA_GETCHANNEL(STM32_I2C_I2C2_TX_DMA_STREAM,                        \
     52                                 STM32_I2C2_TX_DMA_CHN)
     53          
     54          #define I2C3_RX_DMA_CHANNEL                                                 \
     55            STM32_DMA_GETCHANNEL(STM32_I2C_I2C3_RX_DMA_STREAM,                        \
     56                                 STM32_I2C3_RX_DMA_CHN)
     57          
     58          #define I2C3_TX_DMA_CHANNEL                                                 \
     59            STM32_DMA_GETCHANNEL(STM32_I2C_I2C3_TX_DMA_STREAM,                        \
     60                                 STM32_I2C3_TX_DMA_CHN)
     61          
     62          /*===========================================================================*/
     63          /* Driver constants.                                                         */
     64          /*===========================================================================*/
     65          
     66          #define I2C_EV5_MASTER_MODE_SELECT                                          \
     67            ((uint32_t)(((I2C_SR2_MSL | I2C_SR2_BUSY) << 16) | I2C_SR1_SB))
     68          
     69          #define I2C_EV6_MASTER_TRA_MODE_SELECTED                                    \
     70            ((uint32_t)(((I2C_SR2_MSL | I2C_SR2_BUSY | I2C_SR2_TRA) << 16) |          \
     71                        I2C_SR1_ADDR | I2C_SR1_TXE))
     72          
     73          #define I2C_EV6_MASTER_REC_MODE_SELECTED                                    \
     74            ((uint32_t)(((I2C_SR2_MSL | I2C_SR2_BUSY)<< 16) | I2C_SR1_ADDR))
     75          
     76          #define I2C_EV8_2_MASTER_BYTE_TRANSMITTED                                   \
     77            ((uint32_t)(((I2C_SR2_MSL | I2C_SR2_BUSY | I2C_SR2_TRA) << 16) |          \
     78                        I2C_SR1_BTF | I2C_SR1_TXE))
     79          
     80          #define I2C_EV9_MASTER_ADD10                                                \
     81            ((uint32_t)(((I2C_SR2_MSL | I2C_SR2_BUSY) << 16) | I2C_SR1_ADD10))
     82          
     83          #define I2C_EV_MASK 0x00FFFFFF
     84          
     85          #define I2C_ERROR_MASK                                                      \
     86            ((uint16_t)(I2C_SR1_BERR | I2C_SR1_ARLO | I2C_SR1_AF | I2C_SR1_OVR |      \
     87                        I2C_SR1_PECERR | I2C_SR1_TIMEOUT | I2C_SR1_SMBALERT))
     88          
     89          /*===========================================================================*/
     90          /* Driver exported variables.                                                */
     91          /*===========================================================================*/
     92          
     93          /** @brief I2C1 driver identifier.*/
     94          #if STM32_I2C_USE_I2C1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     95          I2CDriver I2CD1;
   \                     I2CD1:
   \   00000000                      DS8 56
     96          #endif
     97          
     98          /** @brief I2C2 driver identifier.*/
     99          #if STM32_I2C_USE_I2C2 || defined(__DOXYGEN__)
    100          I2CDriver I2CD2;
    101          #endif
    102          
    103          /** @brief I2C3 driver identifier.*/
    104          #if STM32_I2C_USE_I2C3 || defined(__DOXYGEN__)
    105          I2CDriver I2CD3;
    106          #endif
    107          
    108          /*===========================================================================*/
    109          /* Driver local variables and types.                                         */
    110          /*===========================================================================*/
    111          
    112          /*===========================================================================*/
    113          /* Driver local functions.                                                   */
    114          /*===========================================================================*/
    115          
    116          /**
    117           * @brief   Wakes up the waiting thread.
    118           *
    119           * @param[in] i2cp      pointer to the @p I2CDriver object
    120           * @param[in] msg       wakeup message
    121           *
    122           * @notapi
    123           */
    124          #define wakeup_isr(i2cp, msg) {                                             \
    125            chSysLockFromIsr();                                                       \
    126            if ((i2cp)->thread != NULL) {                                             \
    127              Thread *tp = (i2cp)->thread;                                            \
    128              (i2cp)->thread = NULL;                                                  \
    129              tp->p_u.rdymsg = (msg);                                                 \
    130              chSchReadyI(tp);                                                        \
    131            }                                                                         \
    132            chSysUnlockFromIsr();                                                     \
    133          }
    134          
    135          /**
    136           * @brief   Aborts an I2C transaction.
    137           *
    138           * @param[in] i2cp      pointer to the @p I2CDriver object
    139           *
    140           * @notapi
    141           */

   \                                 In section .text, align 2, keep-with-next
    142          static void i2c_lld_abort_operation(I2CDriver *i2cp) {
    143            I2C_TypeDef *dp = i2cp->i2c;
   \                     i2c_lld_abort_operation:
   \   00000000   0x6B41             LDR      R1,[R0, #+52]
    144          
    145            /* Stops the I2C peripheral.*/
    146            dp->CR1 = I2C_CR1_SWRST;
   \   00000002   0xF44F 0x4200      MOV      R2,#+32768
   \   00000006   0x800A             STRH     R2,[R1, #+0]
    147            dp->CR1 = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x800A             STRH     R2,[R1, #+0]
    148            dp->CR2 = 0;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x808A             STRH     R2,[R1, #+4]
    149            dp->SR1 = 0;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x828A             STRH     R2,[R1, #+20]
    150          
    151            /* Stops the associated DMA streams.*/
    152            dmaStreamDisable(i2cp->dmatx);
   \   00000014   0x6B02             LDR      R2,[R0, #+48]
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x0952             LSRS     R2,R2,#+5
   \   0000001C   0x0152             LSLS     R2,R2,#+5
   \   0000001E   0x6B03             LDR      R3,[R0, #+48]
   \   00000020   0x681B             LDR      R3,[R3, #+0]
   \   00000022   0x601A             STR      R2,[R3, #+0]
   \                     ??i2c_lld_abort_operation_0:
   \   00000024   0x6B02             LDR      R2,[R0, #+48]
   \   00000026   0x6812             LDR      R2,[R2, #+0]
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x07D2             LSLS     R2,R2,#+31
   \   0000002C   0xD4FA             BMI.N    ??i2c_lld_abort_operation_0
   \   0000002E   0x223D             MOVS     R2,#+61
   \   00000030   0x6B03             LDR      R3,[R0, #+48]
   \   00000032   0xF993 0x3008      LDRSB    R3,[R3, #+8]
   \   00000036   0x409A             LSLS     R2,R2,R3
   \   00000038   0x6B03             LDR      R3,[R0, #+48]
   \   0000003A   0x685B             LDR      R3,[R3, #+4]
   \   0000003C   0x601A             STR      R2,[R3, #+0]
    153            dmaStreamDisable(i2cp->dmarx);
   \   0000003E   0x6AC2             LDR      R2,[R0, #+44]
   \   00000040   0x6812             LDR      R2,[R2, #+0]
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x0952             LSRS     R2,R2,#+5
   \   00000046   0x0152             LSLS     R2,R2,#+5
   \   00000048   0x6AC3             LDR      R3,[R0, #+44]
   \   0000004A   0x681B             LDR      R3,[R3, #+0]
   \   0000004C   0x601A             STR      R2,[R3, #+0]
   \                     ??i2c_lld_abort_operation_1:
   \   0000004E   0x6AC2             LDR      R2,[R0, #+44]
   \   00000050   0x6812             LDR      R2,[R2, #+0]
   \   00000052   0x6812             LDR      R2,[R2, #+0]
   \   00000054   0x07D2             LSLS     R2,R2,#+31
   \   00000056   0xD4FA             BMI.N    ??i2c_lld_abort_operation_1
   \   00000058   0x223D             MOVS     R2,#+61
   \   0000005A   0x6AC3             LDR      R3,[R0, #+44]
   \   0000005C   0xF993 0x3008      LDRSB    R3,[R3, #+8]
   \   00000060   0x409A             LSLS     R2,R2,R3
   \   00000062   0x6AC3             LDR      R3,[R0, #+44]
   \   00000064   0x685B             LDR      R3,[R3, #+4]
   \   00000066   0x601A             STR      R2,[R3, #+0]
    154          }
   \   00000068   0x4770             BX       LR               ;; return
    155          
    156          /**
    157           * @brief   Handling of stalled I2C transactions.
    158           *
    159           * @param[in] i2cp      pointer to the @p I2CDriver object
    160           *
    161           * @notapi
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          static void i2c_lld_safety_timeout(void *p) {
   \                     i2c_lld_safety_timeout:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    164            I2CDriver *i2cp = (I2CDriver *)p;
   \   00000004   0x0025             MOVS     R5,R4
    165          
    166            chSysLockFromIsr();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock_from_isr
    167            if (i2cp->thread) {
   \   00000010   0x69E8             LDR      R0,[R5, #+28]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00B             BEQ.N    ??i2c_lld_safety_timeout_0
    168              Thread *tp = i2cp->thread;
   \   00000016   0x69EE             LDR      R6,[R5, #+28]
    169              i2c_lld_abort_operation(i2cp);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       i2c_lld_abort_operation
    170              i2cp->thread = NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x61E8             STR      R0,[R5, #+28]
    171              tp->p_u.rdymsg = RDY_TIMEOUT;
   \   00000022   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000026   0x62B0             STR      R0,[R6, #+40]
    172              chSchReadyI(tp);
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       chSchReadyI
    173            }
    174            chSysUnlockFromIsr();
   \                     ??i2c_lld_safety_timeout_0:
   \   0000002E   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF380 0x8811      MSR      BASEPRI,R0
    175          }
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    176          
    177          /**
    178           * @brief   Set clock speed.
    179           *
    180           * @param[in] i2cp      pointer to the @p I2CDriver object
    181           *
    182           * @notapi
    183           */

   \                                 In section .text, align 2, keep-with-next
    184          static void i2c_lld_set_clock(I2CDriver *i2cp) {
   \                     i2c_lld_set_clock:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    185            I2C_TypeDef *dp = i2cp->i2c;
   \   00000006   0x6B65             LDR      R5,[R4, #+52]
    186            uint16_t regCCR, clock_div;
    187            int32_t clock_speed = i2cp->config->clock_speed;
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x6847             LDR      R7,[R0, #+4]
    188            i2cdutycycle_t duty = i2cp->config->duty_cycle;
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0xF890 0x8008      LDRB     R8,[R0, #+8]
    189          
    190            chDbgCheck((i2cp != NULL) && (clock_speed > 0) && (clock_speed <= 4000000),
    191                       "i2c_lld_set_clock");
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD005             BEQ.N    ??i2c_lld_set_clock_0
   \   00000016   0x2F01             CMP      R7,#+1
   \   00000018   0xDB03             BLT.N    ??i2c_lld_set_clock_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x3d0901
   \   0000001E   0x4287             CMP      R7,R0
   \   00000020   0xDB06             BLT.N    ??i2c_lld_set_clock_1
   \                     ??i2c_lld_set_clock_0:
   \   00000022   0x22BF             MOVS     R2,#+191
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000002C   0x.... 0x....      BL       chDbgPanic3
    192          
    193            /* CR2 Configuration.*/
    194            dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
   \                     ??i2c_lld_set_clock_1:
   \   00000030   0x88A8             LDRH     R0,[R5, #+4]
   \   00000032   0xF64F 0x71C0      MOVW     R1,#+65472
   \   00000036   0x4008             ANDS     R0,R1,R0
   \   00000038   0x80A8             STRH     R0,[R5, #+4]
    195            dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
   \   0000003A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000003C   0xF050 0x002A      ORRS     R0,R0,#0x2A
   \   00000040   0x80A8             STRH     R0,[R5, #+4]
    196          
    197            /* CCR Configuration.*/
    198            regCCR = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x4681             MOV      R9,R0
    199            clock_div = I2C_CCR_CCR;
   \   00000046   0xF640 0x70FF      MOVW     R0,#+4095
   \   0000004A   0x0006             MOVS     R6,R0
    200          
    201            if (clock_speed <= 100000) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x186a1
   \   00000050   0x4287             CMP      R7,R0
   \   00000052   0xDA29             BGE.N    ??i2c_lld_set_clock_2
    202              /* Configure clock_div in standard mode.*/
    203              chDbgAssert(duty == STD_DUTY_CYCLE,
    204                          "i2c_lld_set_clock(), #1",
    205                          "Invalid standard mode duty cycle");
   \   00000054   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000058   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000005C   0xD003             BEQ.N    ??i2c_lld_set_clock_3
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000062   0x.... 0x....      BL       chDbgPanic
    206          
    207              /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    208              chDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
    209                          "i2c_lld_set_clock(), #2",
    210                          "PCLK1 must be divided without remainder");
   \                     ??i2c_lld_set_clock_3:
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x280de80
   \   0000006A   0x0079             LSLS     R1,R7,#+1
   \   0000006C   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000070   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD003             BEQ.N    ??i2c_lld_set_clock_4
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   0000007C   0x.... 0x....      BL       chDbgPanic
    211              clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
   \                     ??i2c_lld_set_clock_4:
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x280de80
   \   00000084   0x0079             LSLS     R1,R7,#+1
   \   00000086   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000008A   0x0006             MOVS     R6,R0
    212          
    213              chDbgAssert(clock_div >= 0x04,
    214                          "i2c_lld_set_clock(), #3",
    215                          "Clock divider less then 0x04 not allowed");
   \   0000008C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000008E   0x2E04             CMP      R6,#+4
   \   00000090   0xDA03             BGE.N    ??i2c_lld_set_clock_5
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000096   0x.... 0x....      BL       chDbgPanic
    216              regCCR |= (clock_div & I2C_CCR_CCR);
   \                     ??i2c_lld_set_clock_5:
   \   0000009A   0x0530             LSLS     R0,R6,#+20       ;; ZeroExtS R0,R6,#+20,#+20
   \   0000009C   0x0D00             LSRS     R0,R0,#+20
   \   0000009E   0xEA50 0x0909      ORRS     R9,R0,R9
    217          
    218              /* Sets the Maximum Rise Time for standard mode.*/
    219              dp->TRISE = I2C_CLK_FREQ + 1;
   \   000000A2   0x202B             MOVS     R0,#+43
   \   000000A4   0x8428             STRH     R0,[R5, #+32]
   \   000000A6   0xE05B             B.N      ??i2c_lld_set_clock_6
    220            }
    221            else if (clock_speed <= 400000) {
   \                     ??i2c_lld_set_clock_2:
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x61a81
   \   000000AC   0x4287             CMP      R7,R0
   \   000000AE   0xDA57             BGE.N    ??i2c_lld_set_clock_6
    222              /* Configure clock_div in fast mode.*/
    223              chDbgAssert((duty == FAST_DUTY_CYCLE_2) || (duty == FAST_DUTY_CYCLE_16_9),
    224                          "i2c_lld_set_clock(), #4",
    225                          "Invalid fast mode duty cycle");
   \   000000B0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B4   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000B8   0xD008             BEQ.N    ??i2c_lld_set_clock_7
   \   000000BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BE   0xF1B8 0x0F03      CMP      R8,#+3
   \   000000C2   0xD003             BEQ.N    ??i2c_lld_set_clock_7
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \   000000C8   0x.... 0x....      BL       chDbgPanic
    226          
    227              if (duty == FAST_DUTY_CYCLE_2) {
   \                     ??i2c_lld_set_clock_7:
   \   000000CC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D0   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000D4   0xD117             BNE.N    ??i2c_lld_set_clock_8
    228                /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
    229                chDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
    230                            "i2c_lld_set_clock(), #5",
    231                            "PCLK1 must be divided without remainder");
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x280de80
   \   000000DA   0x2103             MOVS     R1,#+3
   \   000000DC   0xFB01 0xF107      MUL      R1,R1,R7
   \   000000E0   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   000000E4   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD003             BEQ.N    ??i2c_lld_set_clock_9
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \   000000F0   0x.... 0x....      BL       chDbgPanic
    232                clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
   \                     ??i2c_lld_set_clock_9:
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x280de80
   \   000000F8   0x2103             MOVS     R1,#+3
   \   000000FA   0xFB01 0xF107      MUL      R1,R1,R7
   \   000000FE   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000102   0x0006             MOVS     R6,R0
   \   00000104   0xE01D             B.N      ??i2c_lld_set_clock_10
    233              }
    234              else if (duty == FAST_DUTY_CYCLE_16_9) {
   \                     ??i2c_lld_set_clock_8:
   \   00000106   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000010A   0xF1B8 0x0F03      CMP      R8,#+3
   \   0000010E   0xD118             BNE.N    ??i2c_lld_set_clock_10
    235                /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
    236                chDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
    237                            "i2c_lld_set_clock(), #6",
    238                            "PCLK1 must be divided without remainder");
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x280de80
   \   00000114   0x2119             MOVS     R1,#+25
   \   00000116   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000011A   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000011E   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD003             BEQ.N    ??i2c_lld_set_clock_11
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable8_11
   \   0000012A   0x.... 0x....      BL       chDbgPanic
    239                clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
   \                     ??i2c_lld_set_clock_11:
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x280de80
   \   00000132   0x2119             MOVS     R1,#+25
   \   00000134   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000138   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000013C   0x0006             MOVS     R6,R0
    240                regCCR |= I2C_CCR_DUTY;
   \   0000013E   0xF459 0x4980      ORRS     R9,R9,#0x4000
    241              }
    242          
    243              chDbgAssert(clock_div >= 0x01,
    244                              "i2c_lld_set_clock(), #7",
    245                              "Clock divider less then 0x04 not allowed");
   \                     ??i2c_lld_set_clock_10:
   \   00000142   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000144   0x2E00             CMP      R6,#+0
   \   00000146   0xD103             BNE.N    ??i2c_lld_set_clock_12
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable8_12
   \   0000014C   0x.... 0x....      BL       chDbgPanic
    246              regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
   \                     ??i2c_lld_set_clock_12:
   \   00000150   0x0530             LSLS     R0,R6,#+20       ;; ZeroExtS R0,R6,#+20,#+20
   \   00000152   0x0D00             LSRS     R0,R0,#+20
   \   00000154   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000158   0xEA50 0x0909      ORRS     R9,R0,R9
    247          
    248              /* Sets the Maximum Rise Time for fast mode.*/
    249              dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
   \   0000015C   0x200D             MOVS     R0,#+13
   \   0000015E   0x8428             STRH     R0,[R5, #+32]
    250            }
    251          
    252            chDbgAssert((clock_div <= I2C_CCR_CCR),
    253                        "i2c_lld_set_clock(), #8", "the selected clock is too low");
   \                     ??i2c_lld_set_clock_6:
   \   00000160   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000162   0xF5B6 0x5F80      CMP      R6,#+4096
   \   00000166   0xDB03             BLT.N    ??i2c_lld_set_clock_13
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable8_13
   \   0000016C   0x.... 0x....      BL       chDbgPanic
    254          
    255            dp->CCR = regCCR;
   \                     ??i2c_lld_set_clock_13:
   \   00000170   0xF8A5 0x901C      STRH     R9,[R5, #+28]
    256          }
   \   00000174   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    257          
    258          /**
    259           * @brief   Set operation mode of I2C hardware.
    260           *
    261           * @param[in] i2cp      pointer to the @p I2CDriver object
    262           *
    263           * @notapi
    264           */

   \                                 In section .text, align 2, keep-with-next
    265          static void i2c_lld_set_opmode(I2CDriver *i2cp) {
   \                     i2c_lld_set_opmode:
   \   00000000   0xB410             PUSH     {R4}
    266            I2C_TypeDef *dp = i2cp->i2c;
   \   00000002   0x6B41             LDR      R1,[R0, #+52]
    267            i2copmode_t opmode = i2cp->config->op_mode;
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
    268            uint16_t regCR1;
    269          
    270            regCR1 = dp->CR1;
   \   00000008   0x880C             LDRH     R4,[R1, #+0]
   \   0000000A   0x0023             MOVS     R3,R4
    271            switch (opmode) {
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD004             BEQ.N    ??i2c_lld_set_opmode_0
   \   00000012   0xD30F             BCC.N    ??i2c_lld_set_opmode_1
   \   00000014   0x2A03             CMP      R2,#+3
   \   00000016   0xD00B             BEQ.N    ??i2c_lld_set_opmode_2
   \   00000018   0xD304             BCC.N    ??i2c_lld_set_opmode_3
   \   0000001A   0xE00B             B.N      ??i2c_lld_set_opmode_1
    272            case OPMODE_I2C:
    273              regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
   \                     ??i2c_lld_set_opmode_0:
   \   0000001C   0xF64F 0x74F5      MOVW     R4,#+65525
   \   00000020   0x4023             ANDS     R3,R4,R3
    274              break;
   \   00000022   0xE007             B.N      ??i2c_lld_set_opmode_1
    275            case OPMODE_SMBUS_DEVICE:
    276              regCR1 |= I2C_CR1_SMBUS;
   \                     ??i2c_lld_set_opmode_3:
   \   00000024   0xF053 0x0302      ORRS     R3,R3,#0x2
    277              regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
   \   00000028   0xF64F 0x74F7      MOVW     R4,#+65527
   \   0000002C   0x4023             ANDS     R3,R4,R3
    278              break;
   \   0000002E   0xE001             B.N      ??i2c_lld_set_opmode_1
    279            case OPMODE_SMBUS_HOST:
    280              regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
   \                     ??i2c_lld_set_opmode_2:
   \   00000030   0xF053 0x030A      ORRS     R3,R3,#0xA
    281              break;
    282            }
    283            dp->CR1 = regCR1;
   \                     ??i2c_lld_set_opmode_1:
   \   00000034   0x800B             STRH     R3,[R1, #+0]
    284          }
   \   00000036   0xBC10             POP      {R4}
   \   00000038   0x4770             BX       LR               ;; return
    285          
    286          /**
    287           * @brief   I2C shared ISR code.
    288           *
    289           * @param[in] i2cp      pointer to the @p I2CDriver object
    290           *
    291           * @notapi
    292           */

   \                                 In section .text, align 2, keep-with-next
    293          static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
   \                     i2c_lld_serve_event_interrupt:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    294            I2C_TypeDef *dp = i2cp->i2c;
   \   00000006   0x6B65             LDR      R5,[R4, #+52]
    295            uint32_t regSR2 = dp->SR2;
   \   00000008   0x8B2E             LDRH     R6,[R5, #+24]
    296            uint32_t event = dp->SR1;
   \   0000000A   0x8AAF             LDRH     R7,[R5, #+20]
    297          
    298            /* Interrupts are disabled just before dmaStreamEnable() because there
    299               is no need of interrupts until next transaction begin. All the work is
    300               done by the DMA.*/
    301            switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
   \   0000000C   0xEA57 0x4006      ORRS     R0,R7,R6, LSL #+16
   \   00000010   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000012   0x0A00             LSRS     R0,R0,#+8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable8_14  ;; 0x30001
   \   00000018   0x1A40             SUBS     R0,R0,R1
   \   0000001A   0xD00A             BEQ.N    ??i2c_lld_serve_event_interrupt_0
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0xD024             BEQ.N    ??i2c_lld_serve_event_interrupt_1
   \   00000020   0x1F80             SUBS     R0,R0,#+6
   \   00000022   0xD01D             BEQ.N    ??i2c_lld_serve_event_interrupt_2
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable8_15  ;; 0x4007a
   \   00000028   0x1A40             SUBS     R0,R0,R1
   \   0000002A   0xD03A             BEQ.N    ??i2c_lld_serve_event_interrupt_3
   \   0000002C   0x1E80             SUBS     R0,R0,#+2
   \   0000002E   0xD046             BEQ.N    ??i2c_lld_serve_event_interrupt_4
   \   00000030   0xE074             B.N      ??i2c_lld_serve_event_interrupt_5
    302            case I2C_EV5_MASTER_MODE_SELECT:
    303              if ((i2cp->addr >> 8) > 0) { 
   \                     ??i2c_lld_serve_event_interrupt_0:
   \   00000032   0x8C20             LDRH     R0,[R4, #+32]
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xDB0D             BLT.N    ??i2c_lld_serve_event_interrupt_6
    304                /* 10-bit address: 1 1 1 1 0 X X R/W */
    305                dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
   \   0000003E   0x8C20             LDRH     R0,[R4, #+32]
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x0A00             LSRS     R0,R0,#+8
   \   00000044   0xF010 0x0006      ANDS     R0,R0,#0x6
   \   00000048   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \   0000004C   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000050   0x4308             ORRS     R0,R1,R0
   \   00000052   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \   00000056   0x8228             STRH     R0,[R5, #+16]
   \   00000058   0xE001             B.N      ??i2c_lld_serve_event_interrupt_7
    306              } else {
    307                dp->DR = i2cp->addr;
   \                     ??i2c_lld_serve_event_interrupt_6:
   \   0000005A   0x8C20             LDRH     R0,[R4, #+32]
   \   0000005C   0x8228             STRH     R0,[R5, #+16]
    308              }
    309              break;
   \                     ??i2c_lld_serve_event_interrupt_7:
   \   0000005E   0xE05D             B.N      ??i2c_lld_serve_event_interrupt_8
    310            case I2C_EV9_MASTER_ADD10:
    311              /* Set second addr byte (10-bit addressing)*/
    312              dp->DR = (0xFF & (i2cp->addr >> 1));
   \                     ??i2c_lld_serve_event_interrupt_2:
   \   00000060   0x8C20             LDRH     R0,[R4, #+32]
   \   00000062   0xF3C0 0x0047      UBFX     R0,R0,#+1,#+8
   \   00000066   0x8228             STRH     R0,[R5, #+16]
    313              break;
   \   00000068   0xE058             B.N      ??i2c_lld_serve_event_interrupt_8
    314            case I2C_EV6_MASTER_REC_MODE_SELECTED:
    315              dp->CR2 &= ~I2C_CR2_ITEVTEN;
   \                     ??i2c_lld_serve_event_interrupt_1:
   \   0000006A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006C   0xF64F 0x51FF      MOVW     R1,#+65023
   \   00000070   0x4008             ANDS     R0,R1,R0
   \   00000072   0x80A8             STRH     R0,[R5, #+4]
    316              dmaStreamEnable(i2cp->dmarx);
   \   00000074   0x6AE0             LDR      R0,[R4, #+44]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000007E   0x6AE1             LDR      R1,[R4, #+44]
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0x6008             STR      R0,[R1, #+0]
    317              dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
   \   00000084   0x88A8             LDRH     R0,[R5, #+4]
   \   00000086   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000008A   0x80A8             STRH     R0,[R5, #+4]
    318              if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
   \   0000008C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x6840             LDR      R0,[R0, #+4]
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD204             BCS.N    ??i2c_lld_serve_event_interrupt_9
    319                dp->CR1 &= ~I2C_CR1_ACK;
   \   00000096   0x8828             LDRH     R0,[R5, #+0]
   \   00000098   0xF64F 0x31FF      MOVW     R1,#+64511
   \   0000009C   0x4008             ANDS     R0,R1,R0
   \   0000009E   0x8028             STRH     R0,[R5, #+0]
    320              break;
   \                     ??i2c_lld_serve_event_interrupt_9:
   \   000000A0   0xE03C             B.N      ??i2c_lld_serve_event_interrupt_8
    321            case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    322              dp->CR2 &= ~I2C_CR2_ITEVTEN;
   \                     ??i2c_lld_serve_event_interrupt_3:
   \   000000A2   0x88A8             LDRH     R0,[R5, #+4]
   \   000000A4   0xF64F 0x51FF      MOVW     R1,#+65023
   \   000000A8   0x4008             ANDS     R0,R1,R0
   \   000000AA   0x80A8             STRH     R0,[R5, #+4]
    323              dmaStreamEnable(i2cp->dmatx);
   \   000000AC   0x6B20             LDR      R0,[R4, #+48]
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000B6   0x6B21             LDR      R1,[R4, #+48]
   \   000000B8   0x6809             LDR      R1,[R1, #+0]
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    324              break;
   \   000000BC   0xE02E             B.N      ??i2c_lld_serve_event_interrupt_8
    325            case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    326              /* Catches BTF event after the end of transmission.*/
    327              if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
   \                     ??i2c_lld_serve_event_interrupt_4:
   \   000000BE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0x6840             LDR      R0,[R0, #+4]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD008             BEQ.N    ??i2c_lld_serve_event_interrupt_10
    328                /* Starts "read after write" operation, LSB = 1 -> receive.*/
    329                i2cp->addr |= 0x01;
   \   000000C8   0x8C20             LDRH     R0,[R4, #+32]
   \   000000CA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000CE   0x8420             STRH     R0,[R4, #+32]
    330                dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
   \   000000D0   0x8828             LDRH     R0,[R5, #+0]
   \   000000D2   0xF450 0x60A0      ORRS     R0,R0,#0x500
   \   000000D6   0x8028             STRH     R0,[R5, #+0]
    331                return;
   \   000000D8   0xE024             B.N      ??i2c_lld_serve_event_interrupt_11
    332              }
    333              dp->CR2 &= ~I2C_CR2_ITEVTEN;
   \                     ??i2c_lld_serve_event_interrupt_10:
   \   000000DA   0x88A8             LDRH     R0,[R5, #+4]
   \   000000DC   0xF64F 0x51FF      MOVW     R1,#+65023
   \   000000E0   0x4008             ANDS     R0,R1,R0
   \   000000E2   0x80A8             STRH     R0,[R5, #+4]
    334              dp->CR1 |= I2C_CR1_STOP;
   \   000000E4   0x8828             LDRH     R0,[R5, #+0]
   \   000000E6   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000EA   0x8028             STRH     R0,[R5, #+0]
    335              wakeup_isr(i2cp, RDY_OK);
   \   000000EC   0x2020             MOVS     R0,#+32
   \   000000EE   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000F2   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   000000F6   0x69E0             LDR      R0,[R4, #+28]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD009             BEQ.N    ??i2c_lld_serve_event_interrupt_12
   \   000000FC   0x69E0             LDR      R0,[R4, #+28]
   \   000000FE   0x4680             MOV      R8,R0
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x61E0             STR      R0,[R4, #+28]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF8C8 0x0028      STR      R0,[R8, #+40]
   \   0000010A   0x4640             MOV      R0,R8
   \   0000010C   0x.... 0x....      BL       chSchReadyI
   \                     ??i2c_lld_serve_event_interrupt_12:
   \   00000110   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF380 0x8811      MSR      BASEPRI,R0
    336              break;
   \   0000011A   0xE7FF             B.N      ??i2c_lld_serve_event_interrupt_8
    337            default:
    338              break;
    339            }
    340            /* Clear ADDR flag. */
    341            if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
   \                     ??i2c_lld_serve_event_interrupt_5:
   \                     ??i2c_lld_serve_event_interrupt_8:
   \   0000011C   0xF017 0x0F0A      TST      R7,#0xA
   \   00000120   0xD000             BEQ.N    ??i2c_lld_serve_event_interrupt_13
    342              (void)dp->SR2;
   \   00000122   0x8B28             LDRH     R0,[R5, #+24]
    343          }
   \                     ??i2c_lld_serve_event_interrupt_13:
   \                     ??i2c_lld_serve_event_interrupt_11:
   \   00000124   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    344          
    345          /**
    346           * @brief   DMA RX end IRQ handler.
    347           *
    348           * @param[in] i2cp      pointer to the @p I2CDriver object
    349           * @param[in] flags     pre-shifted content of the ISR register
    350           *
    351           * @notapi
    352           */

   \                                 In section .text, align 2, keep-with-next
    353          static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
   \                     i2c_lld_serve_rx_end_irq:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    354            I2C_TypeDef *dp = i2cp->i2c;
   \   00000006   0x6B66             LDR      R6,[R4, #+52]
    355          
    356            /* DMA errors handling.*/
    357          #if defined(STM32_I2C_DMA_ERROR_HOOK)
    358            if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
   \   00000008   0xF015 0x0F0C      TST      R5,#0xC
   \   0000000C   0xD001             BEQ.N    ??i2c_lld_serve_rx_end_irq_0
    359              STM32_I2C_DMA_ERROR_HOOK(i2cp);
   \   0000000E   0x.... 0x....      BL       port_halt
    360            }
    361          #else
    362            (void)flags;
    363          #endif
    364          
    365            dmaStreamDisable(i2cp->dmarx);
   \                     ??i2c_lld_serve_rx_end_irq_0:
   \   00000012   0x6AE0             LDR      R0,[R4, #+44]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0940             LSRS     R0,R0,#+5
   \   0000001A   0x0140             LSLS     R0,R0,#+5
   \   0000001C   0x6AE1             LDR      R1,[R4, #+44]
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \                     ??i2c_lld_serve_rx_end_irq_1:
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD4FA             BMI.N    ??i2c_lld_serve_rx_end_irq_1
   \   0000002C   0x203D             MOVS     R0,#+61
   \   0000002E   0x6AE1             LDR      R1,[R4, #+44]
   \   00000030   0xF991 0x1008      LDRSB    R1,[R1, #+8]
   \   00000034   0x4088             LSLS     R0,R0,R1
   \   00000036   0x6AE1             LDR      R1,[R4, #+44]
   \   00000038   0x6849             LDR      R1,[R1, #+4]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    366          
    367            dp->CR2 &= ~I2C_CR2_LAST;
   \   0000003C   0x88B0             LDRH     R0,[R6, #+4]
   \   0000003E   0xF64E 0x71FF      MOVW     R1,#+61439
   \   00000042   0x4008             ANDS     R0,R1,R0
   \   00000044   0x80B0             STRH     R0,[R6, #+4]
    368            dp->CR1 &= ~I2C_CR1_ACK;
   \   00000046   0x8830             LDRH     R0,[R6, #+0]
   \   00000048   0xF64F 0x31FF      MOVW     R1,#+64511
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x8030             STRH     R0,[R6, #+0]
    369            dp->CR1 |= I2C_CR1_STOP;
   \   00000050   0x8830             LDRH     R0,[R6, #+0]
   \   00000052   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    370            wakeup_isr(i2cp, RDY_OK);
   \   00000058   0x2020             MOVS     R0,#+32
   \   0000005A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000005E   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   00000062   0x69E0             LDR      R0,[R4, #+28]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD008             BEQ.N    ??i2c_lld_serve_rx_end_irq_2
   \   00000068   0x69E0             LDR      R0,[R4, #+28]
   \   0000006A   0x0007             MOVS     R7,R0
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x61E0             STR      R0,[R4, #+28]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x62B8             STR      R0,[R7, #+40]
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       chSchReadyI
   \                     ??i2c_lld_serve_rx_end_irq_2:
   \   0000007A   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
    371          }
   \   00000084   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    372          
    373          /**
    374           * @brief    DMA TX end IRQ handler.
    375           *
    376           * @param[in] i2cp      pointer to the @p I2CDriver object
    377           *
    378           * @notapi
    379           */

   \                                 In section .text, align 2, keep-with-next
    380          static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
   \                     i2c_lld_serve_tx_end_irq:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    381            I2C_TypeDef *dp = i2cp->i2c;
   \   00000006   0x6B66             LDR      R6,[R4, #+52]
    382          
    383            /* DMA errors handling.*/
    384          #if defined(STM32_I2C_DMA_ERROR_HOOK)
    385            if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
   \   00000008   0xF015 0x0F0C      TST      R5,#0xC
   \   0000000C   0xD001             BEQ.N    ??i2c_lld_serve_tx_end_irq_0
    386              STM32_I2C_DMA_ERROR_HOOK(i2cp);
   \   0000000E   0x.... 0x....      BL       port_halt
    387            }
    388          #else
    389            (void)flags;
    390          #endif
    391          
    392            dmaStreamDisable(i2cp->dmatx);
   \                     ??i2c_lld_serve_tx_end_irq_0:
   \   00000012   0x6B20             LDR      R0,[R4, #+48]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0940             LSRS     R0,R0,#+5
   \   0000001A   0x0140             LSLS     R0,R0,#+5
   \   0000001C   0x6B21             LDR      R1,[R4, #+48]
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \                     ??i2c_lld_serve_tx_end_irq_1:
   \   00000022   0x6B20             LDR      R0,[R4, #+48]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD4FA             BMI.N    ??i2c_lld_serve_tx_end_irq_1
   \   0000002C   0x203D             MOVS     R0,#+61
   \   0000002E   0x6B21             LDR      R1,[R4, #+48]
   \   00000030   0xF991 0x1008      LDRSB    R1,[R1, #+8]
   \   00000034   0x4088             LSLS     R0,R0,R1
   \   00000036   0x6B21             LDR      R1,[R4, #+48]
   \   00000038   0x6849             LDR      R1,[R1, #+4]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    393            /* Enables interrupts to catch BTF event meaning transmission part complete.
    394               Interrupt handler will decide to generate STOP or to begin receiving part
    395               of R/W transaction itself.*/
    396            dp->CR2 |= I2C_CR2_ITEVTEN;
   \   0000003C   0x88B0             LDRH     R0,[R6, #+4]
   \   0000003E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000042   0x80B0             STRH     R0,[R6, #+4]
    397          }
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    398          
    399          /**
    400           * @brief   I2C error handler.
    401           *
    402           * @param[in] i2cp      pointer to the @p I2CDriver object
    403           * @param[in]  sr       content of the SR1 register to be decoded
    404           *
    405           * @notapi
    406           */

   \                                 In section .text, align 2, keep-with-next
    407          static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
   \                     i2c_lld_serve_error_interrupt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    408          
    409            /* Clears interrupt flags just to be safe.*/
    410            dmaStreamDisable(i2cp->dmatx);
   \   00000006   0x6B20             LDR      R0,[R4, #+48]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0x0140             LSLS     R0,R0,#+5
   \   00000010   0x6B21             LDR      R1,[R4, #+48]
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6008             STR      R0,[R1, #+0]
   \                     ??i2c_lld_serve_error_interrupt_0:
   \   00000016   0x6B20             LDR      R0,[R4, #+48]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD4FA             BMI.N    ??i2c_lld_serve_error_interrupt_0
   \   00000020   0x203D             MOVS     R0,#+61
   \   00000022   0x6B21             LDR      R1,[R4, #+48]
   \   00000024   0xF991 0x1008      LDRSB    R1,[R1, #+8]
   \   00000028   0x4088             LSLS     R0,R0,R1
   \   0000002A   0x6B21             LDR      R1,[R4, #+48]
   \   0000002C   0x6849             LDR      R1,[R1, #+4]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    411            dmaStreamDisable(i2cp->dmarx);
   \   00000030   0x6AE0             LDR      R0,[R4, #+44]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0940             LSRS     R0,R0,#+5
   \   00000038   0x0140             LSLS     R0,R0,#+5
   \   0000003A   0x6AE1             LDR      R1,[R4, #+44]
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \                     ??i2c_lld_serve_error_interrupt_1:
   \   00000040   0x6AE0             LDR      R0,[R4, #+44]
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x07C0             LSLS     R0,R0,#+31
   \   00000048   0xD4FA             BMI.N    ??i2c_lld_serve_error_interrupt_1
   \   0000004A   0x203D             MOVS     R0,#+61
   \   0000004C   0x6AE1             LDR      R1,[R4, #+44]
   \   0000004E   0xF991 0x1008      LDRSB    R1,[R1, #+8]
   \   00000052   0x4088             LSLS     R0,R0,R1
   \   00000054   0x6AE1             LDR      R1,[R4, #+44]
   \   00000056   0x6849             LDR      R1,[R1, #+4]
   \   00000058   0x6008             STR      R0,[R1, #+0]
    412          
    413            i2cp->errors = I2CD_NO_ERROR;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    414          
    415            if (sr & I2C_SR1_BERR)                            /* Bus error.           */
   \   0000005E   0x05E8             LSLS     R0,R5,#+23
   \   00000060   0xD503             BPL.N    ??i2c_lld_serve_error_interrupt_2
    416              i2cp->errors |= I2CD_BUS_ERROR;
   \   00000062   0x68A0             LDR      R0,[R4, #+8]
   \   00000064   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000068   0x60A0             STR      R0,[R4, #+8]
    417          
    418            if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
   \                     ??i2c_lld_serve_error_interrupt_2:
   \   0000006A   0x05A8             LSLS     R0,R5,#+22
   \   0000006C   0xD503             BPL.N    ??i2c_lld_serve_error_interrupt_3
    419              i2cp->errors |= I2CD_ARBITRATION_LOST;
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000074   0x60A0             STR      R0,[R4, #+8]
    420          
    421            if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
   \                     ??i2c_lld_serve_error_interrupt_3:
   \   00000076   0x0568             LSLS     R0,R5,#+21
   \   00000078   0xD510             BPL.N    ??i2c_lld_serve_error_interrupt_4
    422              i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
   \   0000007A   0x6B60             LDR      R0,[R4, #+52]
   \   0000007C   0x8880             LDRH     R0,[R0, #+4]
   \   0000007E   0xF64F 0x51FF      MOVW     R1,#+65023
   \   00000082   0x4008             ANDS     R0,R1,R0
   \   00000084   0x6B61             LDR      R1,[R4, #+52]
   \   00000086   0x8088             STRH     R0,[R1, #+4]
    423              i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
   \   00000088   0x6B60             LDR      R0,[R4, #+52]
   \   0000008A   0x8800             LDRH     R0,[R0, #+0]
   \   0000008C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000090   0x6B61             LDR      R1,[R4, #+52]
   \   00000092   0x8008             STRH     R0,[R1, #+0]
    424              i2cp->errors |= I2CD_ACK_FAILURE;
   \   00000094   0x68A0             LDR      R0,[R4, #+8]
   \   00000096   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000009A   0x60A0             STR      R0,[R4, #+8]
    425            }
    426          
    427            if (sr & I2C_SR1_OVR)                             /* Overrun.             */
   \                     ??i2c_lld_serve_error_interrupt_4:
   \   0000009C   0x0528             LSLS     R0,R5,#+20
   \   0000009E   0xD503             BPL.N    ??i2c_lld_serve_error_interrupt_5
    428              i2cp->errors |= I2CD_OVERRUN;
   \   000000A0   0x68A0             LDR      R0,[R4, #+8]
   \   000000A2   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000000A6   0x60A0             STR      R0,[R4, #+8]
    429          
    430            if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
   \                     ??i2c_lld_serve_error_interrupt_5:
   \   000000A8   0x0468             LSLS     R0,R5,#+17
   \   000000AA   0xD503             BPL.N    ??i2c_lld_serve_error_interrupt_6
    431              i2cp->errors |= I2CD_TIMEOUT;
   \   000000AC   0x68A0             LDR      R0,[R4, #+8]
   \   000000AE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000B2   0x60A0             STR      R0,[R4, #+8]
    432          
    433            if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
   \                     ??i2c_lld_serve_error_interrupt_6:
   \   000000B4   0x04E8             LSLS     R0,R5,#+19
   \   000000B6   0xD503             BPL.N    ??i2c_lld_serve_error_interrupt_7
    434              i2cp->errors |= I2CD_PEC_ERROR;
   \   000000B8   0x68A0             LDR      R0,[R4, #+8]
   \   000000BA   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000BE   0x60A0             STR      R0,[R4, #+8]
    435          
    436            if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
   \                     ??i2c_lld_serve_error_interrupt_7:
   \   000000C0   0x0428             LSLS     R0,R5,#+16
   \   000000C2   0xD503             BPL.N    ??i2c_lld_serve_error_interrupt_8
    437              i2cp->errors |= I2CD_SMB_ALERT;
   \   000000C4   0x68A0             LDR      R0,[R4, #+8]
   \   000000C6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000CA   0x60A0             STR      R0,[R4, #+8]
    438          
    439            /* If some error has been identified then sends wakes the waiting thread.*/
    440            if (i2cp->errors != I2CD_NO_ERROR)
   \                     ??i2c_lld_serve_error_interrupt_8:
   \   000000CC   0x68A0             LDR      R0,[R4, #+8]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD016             BEQ.N    ??i2c_lld_serve_error_interrupt_9
    441              wakeup_isr(i2cp, RDY_RESET);
   \   000000D2   0x2020             MOVS     R0,#+32
   \   000000D4   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000D8   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   000000DC   0x69E0             LDR      R0,[R4, #+28]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD009             BEQ.N    ??i2c_lld_serve_error_interrupt_10
   \   000000E2   0x69E0             LDR      R0,[R4, #+28]
   \   000000E4   0x0006             MOVS     R6,R0
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x61E0             STR      R0,[R4, #+28]
   \   000000EA   0xF07F 0x0001      MVNS     R0,#+1
   \   000000EE   0x62B0             STR      R0,[R6, #+40]
   \   000000F0   0x0030             MOVS     R0,R6
   \   000000F2   0x.... 0x....      BL       chSchReadyI
   \                     ??i2c_lld_serve_error_interrupt_10:
   \   000000F6   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF380 0x8811      MSR      BASEPRI,R0
    442          }
   \                     ??i2c_lld_serve_error_interrupt_9:
   \   00000100   0xBD70             POP      {R4-R6,PC}       ;; return
    443          
    444          /*===========================================================================*/
    445          /* Driver interrupt handlers.                                                */
    446          /*===========================================================================*/
    447          
    448          #if STM32_I2C_USE_I2C1 || defined(__DOXYGEN__)
    449          /**
    450           * @brief   I2C1 event interrupt handler.
    451           *
    452           * @notapi
    453           */

   \                                 In section .text, align 2, keep-with-next
    454          CH_IRQ_HANDLER(I2C1_EV_IRQHandler) {
   \                     VectorBC:
   \   00000000   0xB580             PUSH     {R7,LR}
    455          
    456            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    457          
    458            i2c_lld_serve_event_interrupt(&I2CD1);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   0000000A   0x.... 0x....      BL       i2c_lld_serve_event_interrupt
    459          
    460            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    461          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    462          
    463          /**
    464           * @brief   I2C1 error interrupt handler.
    465           */

   \                                 In section .text, align 2, keep-with-next
    466          CH_IRQ_HANDLER(I2C1_ER_IRQHandler) {
   \                     VectorC0:
   \   00000000   0xB510             PUSH     {R4,LR}
    467            uint16_t sr = I2CD1.i2c->SR1;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   00000006   0x6B40             LDR      R0,[R0, #+52]
   \   00000008   0x8A84             LDRH     R4,[R0, #+20]
    468          
    469            CH_IRQ_PROLOGUE();
   \   0000000A   0x.... 0x....      BL       dbg_check_enter_isr
    470          
    471            I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   00000012   0x6B40             LDR      R0,[R0, #+52]
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0xF414 0x415F      ANDS     R1,R4,#0xDF00
   \   0000001A   0x43C9             MVNS     R1,R1
   \   0000001C   0x8281             STRH     R1,[R0, #+20]
    472            i2c_lld_serve_error_interrupt(&I2CD1, sr);
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0x....             LDR.N    R0,??DataTable8_16
   \   00000024   0x.... 0x....      BL       i2c_lld_serve_error_interrupt
    473          
    474            CH_IRQ_EPILOGUE();
   \   00000028   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000002C   0x.... 0x....      BL       _port_irq_epilogue
    475          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    476          #endif /* STM32_I2C_USE_I2C1 */
    477          
    478          #if STM32_I2C_USE_I2C2 || defined(__DOXYGEN__)
    479          /**
    480           * @brief   I2C2 event interrupt handler.
    481           *
    482           * @notapi
    483           */
    484          CH_IRQ_HANDLER(I2C2_EV_IRQHandler) {
    485          
    486            CH_IRQ_PROLOGUE();
    487          
    488            i2c_lld_serve_event_interrupt(&I2CD2);
    489          
    490            CH_IRQ_EPILOGUE();
    491          }
    492          
    493          /**
    494           * @brief   I2C2 error interrupt handler.
    495           *
    496           * @notapi
    497           */
    498          CH_IRQ_HANDLER(I2C2_ER_IRQHandler) {
    499            uint16_t sr = I2CD2.i2c->SR1;
    500          
    501            CH_IRQ_PROLOGUE();
    502          
    503            I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
    504            i2c_lld_serve_error_interrupt(&I2CD2, sr);
    505          
    506            CH_IRQ_EPILOGUE();
    507          }
    508          #endif /* STM32_I2C_USE_I2C2 */
    509          
    510          #if STM32_I2C_USE_I2C3 || defined(__DOXYGEN__)
    511          /**
    512           * @brief   I2C3 event interrupt handler.
    513           *
    514           * @notapi
    515           */
    516          CH_IRQ_HANDLER(I2C3_EV_IRQHandler) {
    517          
    518            CH_IRQ_PROLOGUE();
    519          
    520            i2c_lld_serve_event_interrupt(&I2CD3);
    521          
    522            CH_IRQ_EPILOGUE();
    523          }
    524          
    525          /**
    526           * @brief   I2C3 error interrupt handler.
    527           *
    528           * @notapi
    529           */
    530          CH_IRQ_HANDLER(I2C3_ER_IRQHandler) {
    531            uint16_t sr = I2CD3.i2c->SR1;
    532          
    533            CH_IRQ_PROLOGUE();
    534          
    535            I2CD3.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
    536            i2c_lld_serve_error_interrupt(&I2CD3, sr);
    537          
    538            CH_IRQ_EPILOGUE();
    539          }
    540          #endif /* STM32_I2C_USE_I2C3 */
    541          
    542          /*===========================================================================*/
    543          /* Driver exported functions.                                                */
    544          /*===========================================================================*/
    545          
    546          /**
    547           * @brief   Low level I2C driver initialization.
    548           *
    549           * @notapi
    550           */

   \                                 In section .text, align 2, keep-with-next
    551          void i2c_lld_init(void) {
   \                     i2c_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    552          
    553          #if STM32_I2C_USE_I2C1
    554            i2cObjectInit(&I2CD1);
   \   00000002   0x....             LDR.N    R0,??DataTable8_16
   \   00000004   0x.... 0x....      BL       i2cObjectInit
    555            I2CD1.thread = NULL;
   \   00000008   0x....             LDR.N    R0,??DataTable8_16
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x61C1             STR      R1,[R0, #+28]
    556            I2CD1.i2c    = I2C1;
   \   0000000E   0x....             LDR.N    R0,??DataTable8_16
   \   00000010   0x....             LDR.N    R1,??DataTable8_17  ;; 0x40005400
   \   00000012   0x6341             STR      R1,[R0, #+52]
    557            I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
   \   00000014   0x....             LDR.N    R0,??DataTable8_16
   \   00000016   0x....             LDR.N    R1,??DataTable8_18
   \   00000018   0x62C1             STR      R1,[R0, #+44]
    558            I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
   \   0000001A   0x....             LDR.N    R0,??DataTable8_16
   \   0000001C   0x....             LDR.N    R1,??DataTable8_19
   \   0000001E   0x6301             STR      R1,[R0, #+48]
    559          #endif /* STM32_I2C_USE_I2C1 */
    560          
    561          #if STM32_I2C_USE_I2C2
    562            i2cObjectInit(&I2CD2);
    563            I2CD2.thread = NULL;
    564            I2CD2.i2c    = I2C2;
    565            I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
    566            I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
    567          #endif /* STM32_I2C_USE_I2C2 */
    568          
    569          #if STM32_I2C_USE_I2C3
    570            i2cObjectInit(&I2CD3);
    571            I2CD3.thread = NULL;
    572            I2CD3.i2c    = I2C3;
    573            I2CD3.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C3_RX_DMA_STREAM);
    574            I2CD3.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C3_TX_DMA_STREAM);
    575          #endif /* STM32_I2C_USE_I2C3 */
    576          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    577          
    578          /**
    579           * @brief   Configures and activates the I2C peripheral.
    580           *
    581           * @param[in] i2cp      pointer to the @p I2CDriver object
    582           *
    583           * @notapi
    584           */

   \                                 In section .text, align 2, keep-with-next
    585          void i2c_lld_start(I2CDriver *i2cp) {
   \                     i2c_lld_start:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    586            I2C_TypeDef *dp = i2cp->i2c;
   \   00000004   0x6B65             LDR      R5,[R4, #+52]
    587          
    588            i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
    589                              STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
    590                              STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
    591                              STM32_DMA_CR_DIR_M2P;
   \   00000006   0xF240 0x4056      MOVW     R0,#+1110
   \   0000000A   0x62A0             STR      R0,[R4, #+40]
    592            i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
    593                              STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
    594                              STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
    595                              STM32_DMA_CR_DIR_P2M;
   \   0000000C   0xF240 0x4016      MOVW     R0,#+1046
   \   00000010   0x6260             STR      R0,[R4, #+36]
    596          
    597            /* If in stopped state then enables the I2C and DMA clocks.*/
    598            if (i2cp->state == I2C_STOP) {
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD13B             BNE.N    ??i2c_lld_start_0
    599          
    600          #if STM32_I2C_USE_I2C1
    601              if (&I2CD1 == i2cp) {
   \   00000018   0x....             LDR.N    R0,??DataTable8_16
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD138             BNE.N    ??i2c_lld_start_0
    602                bool_t b;
    603          
    604                rccResetI2C1();
   \   0000001E   0x....             LDR.N    R0,??DataTable8_20  ;; 0x40023820
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   00000026   0x....             LDR.N    R1,??DataTable8_20  ;; 0x40023820
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable8_20  ;; 0x40023820
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    605                b = dmaStreamAllocate(i2cp->dmarx,
    606                                      STM32_I2C_I2C1_IRQ_PRIORITY,
    607                                      (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
    608                                      (void *)i2cp);
   \   00000030   0x0023             MOVS     R3,R4
   \   00000032   0x....             LDR.N    R2,??DataTable8_21
   \   00000034   0x2105             MOVS     R1,#+5
   \   00000036   0x6AE0             LDR      R0,[R4, #+44]
   \   00000038   0x.... 0x....      BL       dmaStreamAllocate
   \   0000003C   0x0006             MOVS     R6,R0
    609                chDbgAssert(!b, "i2c_lld_start(), #1", "stream already allocated");
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD002             BEQ.N    ??i2c_lld_start_1
   \   00000044   0x....             LDR.N    R0,??DataTable8_22
   \   00000046   0x.... 0x....      BL       chDbgPanic
    610                b = dmaStreamAllocate(i2cp->dmatx,
    611                                      STM32_I2C_I2C1_IRQ_PRIORITY,
    612                                      (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
    613                                      (void *)i2cp);
   \                     ??i2c_lld_start_1:
   \   0000004A   0x0023             MOVS     R3,R4
   \   0000004C   0x....             LDR.N    R2,??DataTable8_23
   \   0000004E   0x2105             MOVS     R1,#+5
   \   00000050   0x6B20             LDR      R0,[R4, #+48]
   \   00000052   0x.... 0x....      BL       dmaStreamAllocate
   \   00000056   0x0006             MOVS     R6,R0
    614                chDbgAssert(!b, "i2c_lld_start(), #2", "stream already allocated");
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x2E00             CMP      R6,#+0
   \   0000005C   0xD002             BEQ.N    ??i2c_lld_start_2
   \   0000005E   0x....             LDR.N    R0,??DataTable8_24
   \   00000060   0x.... 0x....      BL       chDbgPanic
    615                rccEnableI2C1(FALSE);
   \                     ??i2c_lld_start_2:
   \   00000064   0x....             LDR.N    R0,??DataTable8_25  ;; 0x40023840
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000006C   0x....             LDR.N    R1,??DataTable8_25  ;; 0x40023840
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    616                nvicEnableVector(I2C1_EV_IRQn,
    617                    CORTEX_PRIORITY_MASK(STM32_I2C_I2C1_IRQ_PRIORITY));
   \   00000070   0x2150             MOVS     R1,#+80
   \   00000072   0x201F             MOVS     R0,#+31
   \   00000074   0x.... 0x....      BL       nvicEnableVector
    618                nvicEnableVector(I2C1_ER_IRQn,
    619                    CORTEX_PRIORITY_MASK(STM32_I2C_I2C1_IRQ_PRIORITY));
   \   00000078   0x2150             MOVS     R1,#+80
   \   0000007A   0x2020             MOVS     R0,#+32
   \   0000007C   0x.... 0x....      BL       nvicEnableVector
    620          
    621                i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
    622                                 STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
   \   00000080   0x6A60             LDR      R0,[R4, #+36]
   \   00000082   0x....             LDR.N    R1,??DataTable8_26  ;; 0x2030000
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x6260             STR      R0,[R4, #+36]
    623                i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
    624                                 STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
   \   00000088   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008A   0x....             LDR.N    R1,??DataTable8_26  ;; 0x2030000
   \   0000008C   0x4308             ORRS     R0,R1,R0
   \   0000008E   0x62A0             STR      R0,[R4, #+40]
    625              }
    626          #endif /* STM32_I2C_USE_I2C1 */
    627          
    628          #if STM32_I2C_USE_I2C2
    629              if (&I2CD2 == i2cp) {
    630                bool_t b;
    631          
    632                rccResetI2C2();
    633                b = dmaStreamAllocate(i2cp->dmarx,
    634                                      STM32_I2C_I2C2_IRQ_PRIORITY,
    635                                      (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
    636                                      (void *)i2cp);
    637                chDbgAssert(!b, "i2c_lld_start(), #3", "stream already allocated");
    638                b = dmaStreamAllocate(i2cp->dmatx,
    639                                      STM32_I2C_I2C2_IRQ_PRIORITY,
    640                                      (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
    641                                      (void *)i2cp);
    642                chDbgAssert(!b, "i2c_lld_start(), #4", "stream already allocated");
    643                rccEnableI2C2(FALSE);
    644                nvicEnableVector(I2C2_EV_IRQn,
    645                    CORTEX_PRIORITY_MASK(STM32_I2C_I2C2_IRQ_PRIORITY));
    646                nvicEnableVector(I2C2_ER_IRQn,
    647                    CORTEX_PRIORITY_MASK(STM32_I2C_I2C2_IRQ_PRIORITY));
    648          
    649                i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
    650                                 STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
    651                i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
    652                                 STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
    653              }
    654          #endif /* STM32_I2C_USE_I2C2 */
    655          
    656          #if STM32_I2C_USE_I2C3
    657              if (&I2CD3 == i2cp) {
    658                bool_t b;
    659          
    660                rccResetI2C3();
    661                b = dmaStreamAllocate(i2cp->dmarx,
    662                                      STM32_I2C_I2C3_IRQ_PRIORITY,
    663                                      (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
    664                                      (void *)i2cp);
    665                chDbgAssert(!b, "i2c_lld_start(), #5", "stream already allocated");
    666                b = dmaStreamAllocate(i2cp->dmatx,
    667                                      STM32_I2C_I2C3_IRQ_PRIORITY,
    668                                      (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
    669                                      (void *)i2cp);
    670                chDbgAssert(!b, "i2c_lld_start(), #6", "stream already allocated");
    671                rccEnableI2C3(FALSE);
    672                nvicEnableVector(I2C3_EV_IRQn,
    673                    CORTEX_PRIORITY_MASK(STM32_I2C_I2C3_IRQ_PRIORITY));
    674                nvicEnableVector(I2C3_ER_IRQn,
    675                    CORTEX_PRIORITY_MASK(STM32_I2C_I2C3_IRQ_PRIORITY));
    676          
    677                i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C3_RX_DMA_CHANNEL) |
    678                                 STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
    679                i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C3_TX_DMA_CHANNEL) |
    680                                 STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
    681              }
    682          #endif /* STM32_I2C_USE_I2C3 */
    683            }
    684          
    685            /* I2C registers pointed by the DMA.*/
    686            dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
   \                     ??i2c_lld_start_0:
   \   00000090   0x6AE0             LDR      R0,[R4, #+44]
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xF115 0x0110      ADDS     R1,R5,#+16
   \   00000098   0x6081             STR      R1,[R0, #+8]
    687            dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
   \   0000009A   0x6B20             LDR      R0,[R4, #+48]
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0xF115 0x0110      ADDS     R1,R5,#+16
   \   000000A2   0x6081             STR      R1,[R0, #+8]
    688          
    689            /* Reset i2c peripheral.*/
    690            dp->CR1 = I2C_CR1_SWRST;
   \   000000A4   0xF44F 0x4000      MOV      R0,#+32768
   \   000000A8   0x8028             STRH     R0,[R5, #+0]
    691            dp->CR1 = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8028             STRH     R0,[R5, #+0]
    692            dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
   \   000000AE   0xF44F 0x6010      MOV      R0,#+2304
   \   000000B2   0x80A8             STRH     R0,[R5, #+4]
    693          
    694            /* Setup I2C parameters.*/
    695            i2c_lld_set_clock(i2cp);
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       i2c_lld_set_clock
    696            i2c_lld_set_opmode(i2cp);
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       i2c_lld_set_opmode
    697          
    698            /* Ready to go.*/
    699            dp->CR1 |= I2C_CR1_PE;
   \   000000C0   0x8828             LDRH     R0,[R5, #+0]
   \   000000C2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000C6   0x8028             STRH     R0,[R5, #+0]
    700          }
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
    701          
    702          /**
    703           * @brief   Deactivates the I2C peripheral.
    704           *
    705           * @param[in] i2cp      pointer to the @p I2CDriver object
    706           *
    707           * @notapi
    708           */

   \                                 In section .text, align 2, keep-with-next
    709          void i2c_lld_stop(I2CDriver *i2cp) {
   \                     i2c_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    710          
    711            /* If not in stopped state then disables the I2C clock.*/
    712            if (i2cp->state != I2C_STOP) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD017             BEQ.N    ??i2c_lld_stop_0
    713          
    714              /* I2C disable.*/
    715              i2c_lld_abort_operation(i2cp);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       i2c_lld_abort_operation
    716              dmaStreamRelease(i2cp->dmatx);
   \   00000010   0x6B20             LDR      R0,[R4, #+48]
   \   00000012   0x.... 0x....      BL       dmaStreamRelease
    717              dmaStreamRelease(i2cp->dmarx);
   \   00000016   0x6AE0             LDR      R0,[R4, #+44]
   \   00000018   0x.... 0x....      BL       dmaStreamRelease
    718          
    719          #if STM32_I2C_USE_I2C1
    720              if (&I2CD1 == i2cp) {
   \   0000001C   0x....             LDR.N    R0,??DataTable8_16
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD10B             BNE.N    ??i2c_lld_stop_0
    721                nvicDisableVector(I2C1_EV_IRQn);
   \   00000022   0x201F             MOVS     R0,#+31
   \   00000024   0x.... 0x....      BL       nvicDisableVector
    722                nvicDisableVector(I2C1_ER_IRQn);
   \   00000028   0x2020             MOVS     R0,#+32
   \   0000002A   0x.... 0x....      BL       nvicDisableVector
    723                rccDisableI2C1(FALSE);
   \   0000002E   0x....             LDR.N    R0,??DataTable8_25  ;; 0x40023840
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000036   0x....             LDR.N    R1,??DataTable8_25  ;; 0x40023840
   \   00000038   0x6008             STR      R0,[R1, #+0]
    724              }
    725          #endif
    726          
    727          #if STM32_I2C_USE_I2C2
    728              if (&I2CD2 == i2cp) {
    729                nvicDisableVector(I2C2_EV_IRQn);
    730                nvicDisableVector(I2C2_ER_IRQn);
    731                rccDisableI2C2(FALSE);
    732              }
    733          #endif
    734          
    735          #if STM32_I2C_USE_I2C3
    736              if (&I2CD3 == i2cp) {
    737                nvicDisableVector(I2C3_EV_IRQn);
    738                nvicDisableVector(I2C3_ER_IRQn);
    739                rccDisableI2C3(FALSE);
    740              }
    741          #endif
    742            }
    743          }
   \                     ??i2c_lld_stop_0:
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    744          
    745          /**
    746           * @brief   Receives data via the I2C bus as master.
    747           * @details Number of receiving bytes must be more than 1 on STM32F1x. This is
    748           *          hardware restriction.
    749           *
    750           * @param[in] i2cp      pointer to the @p I2CDriver object
    751           * @param[in] addr      slave device address
    752           * @param[out] rxbuf    pointer to the receive buffer
    753           * @param[in] rxbytes   number of bytes to be received
    754           * @param[in] timeout   the number of ticks before the operation timeouts,
    755           *                      the following special values are allowed:
    756           *                      - @a TIME_INFINITE no timeout.
    757           *                      .
    758           * @return              The operation status.
    759           * @retval RDY_OK       if the function succeeded.
    760           * @retval RDY_RESET    if one or more I2C errors occurred, the errors can
    761           *                      be retrieved using @p i2cGetErrors().
    762           * @retval RDY_TIMEOUT  if a timeout occurred before operation end. <b>After a
    763           *                      timeout the driver must be stopped and restarted
    764           *                      because the bus is in an uncertain state</b>.
    765           *
    766           * @notapi
    767           */

   \                                 In section .text, align 2, keep-with-next
    768          msg_t i2c_lld_master_receive_timeout(I2CDriver *i2cp, i2caddr_t addr,
    769                                               uint8_t *rxbuf, size_t rxbytes,
    770                                               systime_t timeout) {
   \                     i2c_lld_master_receive_timeout:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    771            I2C_TypeDef *dp = i2cp->i2c;
   \   00000012   0xF8D4 0x9034      LDR      R9,[R4, #+52]
    772            VirtualTimer vt;
    773          
    774          #if defined(STM32F1XX_I2C)
    775            chDbgCheck((rxbytes > 1), "i2c_lld_master_receive_timeout");
    776          #endif
    777          
    778            /* Global timeout for the whole operation.*/
    779            if (timeout != TIME_INFINITE)
   \   00000016   0xF118 0x0F01      CMN      R8,#+1
   \   0000001A   0xD005             BEQ.N    ??i2c_lld_master_receive_timeout_0
    780              chVTSetI(&vt, timeout, i2c_lld_safety_timeout, (void *)i2cp);
   \   0000001C   0x0023             MOVS     R3,R4
   \   0000001E   0x....             LDR.N    R2,??DataTable8_27
   \   00000020   0x4641             MOV      R1,R8
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       chVTSetI
    781          
    782            /* Releases the lock from high level driver.*/
    783            chSysUnlock();
   \                     ??i2c_lld_master_receive_timeout_0:
   \   00000028   0x.... 0x....      BL       dbg_check_unlock
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF380 0x8811      MSR      BASEPRI,R0
    784          
    785            /* Initializes driver fields, LSB = 1 -> receive.*/
    786            i2cp->addr = (addr << 1) | 0x01;
   \   00000032   0x0068             LSLS     R0,R5,#+1
   \   00000034   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000038   0x8420             STRH     R0,[R4, #+32]
    787            i2cp->errors = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x60A0             STR      R0,[R4, #+8]
    788          
    789            /* RX DMA setup.*/
    790            dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
   \   0000003E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x6A61             LDR      R1,[R4, #+36]
   \   00000044   0x6001             STR      R1,[R0, #+0]
    791            dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
   \   00000046   0x6AE0             LDR      R0,[R4, #+44]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x60C6             STR      R6,[R0, #+12]
    792            dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
   \   0000004C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x6047             STR      R7,[R0, #+4]
    793          
    794            /* Waits until BUSY flag is reset and the STOP from the previous operation
    795               is completed, alternatively for a timeout condition.*/
    796            while ((dp->SR2 & I2C_SR2_BUSY) || (dp->CR1 & I2C_CR1_STOP)) {
   \                     ??i2c_lld_master_receive_timeout_1:
   \   00000052   0xF8B9 0x0018      LDRH     R0,[R9, #+24]
   \   00000056   0x0780             LSLS     R0,R0,#+30
   \   00000058   0xD403             BMI.N    ??i2c_lld_master_receive_timeout_2
   \   0000005A   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   0000005E   0x0580             LSLS     R0,R0,#+22
   \   00000060   0xD513             BPL.N    ??i2c_lld_master_receive_timeout_3
    797              chSysLock();
   \                     ??i2c_lld_master_receive_timeout_2:
   \   00000062   0x2020             MOVS     R0,#+32
   \   00000064   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000068   0x.... 0x....      BL       dbg_check_lock
    798              if ((timeout != TIME_INFINITE) && !chVTIsArmedI(&vt))
   \   0000006C   0xF118 0x0F01      CMN      R8,#+1
   \   00000070   0xD005             BEQ.N    ??i2c_lld_master_receive_timeout_4
   \   00000072   0x9803             LDR      R0,[SP, #+12]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD102             BNE.N    ??i2c_lld_master_receive_timeout_4
    799                return RDY_TIMEOUT;
   \   00000078   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000007C   0xE031             B.N      ??i2c_lld_master_receive_timeout_5
    800              chSysUnlock();
   \                     ??i2c_lld_master_receive_timeout_4:
   \   0000007E   0x.... 0x....      BL       dbg_check_unlock
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000088   0xE7E3             B.N      ??i2c_lld_master_receive_timeout_1
    801            }
    802          
    803            /* This lock will be released in high level driver.*/
    804            chSysLock();
   \                     ??i2c_lld_master_receive_timeout_3:
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000090   0x.... 0x....      BL       dbg_check_lock
    805          
    806            /* Atomic check on the timer in order to make sure that a timeout didn't
    807               happen outside the critical zone.*/
    808            if ((timeout != TIME_INFINITE) && !chVTIsArmedI(&vt))
   \   00000094   0xF118 0x0F01      CMN      R8,#+1
   \   00000098   0xD005             BEQ.N    ??i2c_lld_master_receive_timeout_6
   \   0000009A   0x9803             LDR      R0,[SP, #+12]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD102             BNE.N    ??i2c_lld_master_receive_timeout_6
    809              return RDY_TIMEOUT;
   \   000000A0   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000A4   0xE01D             B.N      ??i2c_lld_master_receive_timeout_5
    810          
    811            /* Starts the operation.*/
    812            dp->CR2 |= I2C_CR2_ITEVTEN;
   \                     ??i2c_lld_master_receive_timeout_6:
   \   000000A6   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   000000AA   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000AE   0xF8A9 0x0004      STRH     R0,[R9, #+4]
    813            dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
   \   000000B2   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000B6   0xF450 0x60A0      ORRS     R0,R0,#0x500
   \   000000BA   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    814          
    815            /* Waits for the operation completion or a timeout.*/
    816            i2cp->thread = chThdSelf();
   \   000000BE   0x....             LDR.N    R0,??DataTable8_28
   \   000000C0   0x6980             LDR      R0,[R0, #+24]
   \   000000C2   0x61E0             STR      R0,[R4, #+28]
    817            chSchGoSleepS(THD_STATE_SUSPENDED);
   \   000000C4   0x2002             MOVS     R0,#+2
   \   000000C6   0x.... 0x....      BL       chSchGoSleepS
    818            if ((timeout != TIME_INFINITE) && chVTIsArmedI(&vt))
   \   000000CA   0xF118 0x0F01      CMN      R8,#+1
   \   000000CE   0xD005             BEQ.N    ??i2c_lld_master_receive_timeout_7
   \   000000D0   0x9803             LDR      R0,[SP, #+12]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD002             BEQ.N    ??i2c_lld_master_receive_timeout_7
    819              chVTResetI(&vt);
   \   000000D6   0xA800             ADD      R0,SP,#+0
   \   000000D8   0x.... 0x....      BL       chVTResetI
    820          
    821            return chThdSelf()->p_u.rdymsg;
   \                     ??i2c_lld_master_receive_timeout_7:
   \   000000DC   0x....             LDR.N    R0,??DataTable8_28
   \   000000DE   0x6980             LDR      R0,[R0, #+24]
   \   000000E0   0x6A80             LDR      R0,[R0, #+40]
   \                     ??i2c_lld_master_receive_timeout_5:
   \   000000E2   0xB005             ADD      SP,SP,#+20
   \   000000E4   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    822          }
    823          
    824          /**
    825           * @brief   Transmits data via the I2C bus as master.
    826           * @details Number of receiving bytes must be 0 or more than 1 on STM32F1x.
    827           *          This is hardware restriction.
    828           *
    829           * @param[in] i2cp      pointer to the @p I2CDriver object
    830           * @param[in] addr      slave device address
    831           * @param[in] txbuf     pointer to the transmit buffer
    832           * @param[in] txbytes   number of bytes to be transmitted
    833           * @param[out] rxbuf    pointer to the receive buffer
    834           * @param[in] rxbytes   number of bytes to be received
    835           * @param[in] timeout   the number of ticks before the operation timeouts,
    836           *                      the following special values are allowed:
    837           *                      - @a TIME_INFINITE no timeout.
    838           *                      .
    839           * @return              The operation status.
    840           * @retval RDY_OK       if the function succeeded.
    841           * @retval RDY_RESET    if one or more I2C errors occurred, the errors can
    842           *                      be retrieved using @p i2cGetErrors().
    843           * @retval RDY_TIMEOUT  if a timeout occurred before operation end. <b>After a
    844           *                      timeout the driver must be stopped and restarted
    845           *                      because the bus is in an uncertain state</b>.
    846           *
    847           * @notapi
    848           */

   \                                 In section .text, align 2, keep-with-next
    849          msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
    850                                                const uint8_t *txbuf, size_t txbytes,
    851                                                uint8_t *rxbuf, size_t rxbytes,
    852                                                systime_t timeout) {
   \                     i2c_lld_master_transmit_timeout:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \   00000012   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   \   00000016   0xF8DD 0xA040      LDR      R10,[SP, #+64]
    853            I2C_TypeDef *dp = i2cp->i2c;
   \   0000001A   0xF8D4 0xB034      LDR      R11,[R4, #+52]
    854            VirtualTimer vt;
    855          
    856          #if defined(STM32F1XX_I2C)
    857            chDbgCheck(((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL))),
    858                       "i2c_lld_master_transmit_timeout");
    859          #endif
    860          
    861            /* Global timeout for the whole operation.*/
    862            if (timeout != TIME_INFINITE)
   \   0000001E   0xF11A 0x0F01      CMN      R10,#+1
   \   00000022   0xD005             BEQ.N    ??i2c_lld_master_transmit_timeout_0
    863              chVTSetI(&vt, timeout, i2c_lld_safety_timeout, (void *)i2cp);
   \   00000024   0x0023             MOVS     R3,R4
   \   00000026   0x....             LDR.N    R2,??DataTable8_27
   \   00000028   0x4651             MOV      R1,R10
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       chVTSetI
    864          
    865            /* Releases the lock from high level driver.*/
    866            chSysUnlock();
   \                     ??i2c_lld_master_transmit_timeout_0:
   \   00000030   0x.... 0x....      BL       dbg_check_unlock
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF380 0x8811      MSR      BASEPRI,R0
    867          
    868            /* Initializes driver fields, LSB = 0 -> write.*/
    869            i2cp->addr = addr << 1;
   \   0000003A   0x0068             LSLS     R0,R5,#+1
   \   0000003C   0x8420             STRH     R0,[R4, #+32]
    870            i2cp->errors = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60A0             STR      R0,[R4, #+8]
    871          
    872            /* TX DMA setup.*/
    873            dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
   \   00000042   0x6B20             LDR      R0,[R4, #+48]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x6AA1             LDR      R1,[R4, #+40]
   \   00000048   0x6001             STR      R1,[R0, #+0]
    874            dmaStreamSetMemory0(i2cp->dmatx, txbuf);
   \   0000004A   0x6B20             LDR      R0,[R4, #+48]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x60C6             STR      R6,[R0, #+12]
    875            dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
   \   00000050   0x6B20             LDR      R0,[R4, #+48]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x6047             STR      R7,[R0, #+4]
    876          
    877            /* RX DMA setup.*/
    878            dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
   \   00000056   0x6AE0             LDR      R0,[R4, #+44]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x6A61             LDR      R1,[R4, #+36]
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    879            dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
   \   0000005E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF8C0 0x800C      STR      R8,[R0, #+12]
    880            dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
   \   00000066   0x6AE0             LDR      R0,[R4, #+44]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF8C0 0x9004      STR      R9,[R0, #+4]
    881          
    882            /* Waits until BUSY flag is reset and the STOP from the previous operation
    883               is completed, alternatively for a timeout condition.*/
    884            while ((dp->SR2 & I2C_SR2_BUSY) || (dp->CR1 & I2C_CR1_STOP)) {
   \                     ??i2c_lld_master_transmit_timeout_1:
   \   0000006E   0xF8BB 0x0018      LDRH     R0,[R11, #+24]
   \   00000072   0x0780             LSLS     R0,R0,#+30
   \   00000074   0xD403             BMI.N    ??i2c_lld_master_transmit_timeout_2
   \   00000076   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \   0000007A   0x0580             LSLS     R0,R0,#+22
   \   0000007C   0xD513             BPL.N    ??i2c_lld_master_transmit_timeout_3
    885              chSysLock();
   \                     ??i2c_lld_master_transmit_timeout_2:
   \   0000007E   0x2020             MOVS     R0,#+32
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000084   0x.... 0x....      BL       dbg_check_lock
    886              if ((timeout != TIME_INFINITE) && !chVTIsArmedI(&vt))
   \   00000088   0xF11A 0x0F01      CMN      R10,#+1
   \   0000008C   0xD005             BEQ.N    ??i2c_lld_master_transmit_timeout_4
   \   0000008E   0x9803             LDR      R0,[SP, #+12]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD102             BNE.N    ??i2c_lld_master_transmit_timeout_4
    887                return RDY_TIMEOUT;
   \   00000094   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000098   0xE031             B.N      ??i2c_lld_master_transmit_timeout_5
    888              chSysUnlock();
   \                     ??i2c_lld_master_transmit_timeout_4:
   \   0000009A   0x.... 0x....      BL       dbg_check_unlock
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000A4   0xE7E3             B.N      ??i2c_lld_master_transmit_timeout_1
    889            }
    890          
    891            /* This lock will be released in high level driver.*/
    892            chSysLock();
   \                     ??i2c_lld_master_transmit_timeout_3:
   \   000000A6   0x2020             MOVS     R0,#+32
   \   000000A8   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000AC   0x.... 0x....      BL       dbg_check_lock
    893          
    894            /* Atomic check on the timer in order to make sure that a timeout didn't
    895               happen outside the critical zone.*/
    896            if ((timeout != TIME_INFINITE) && !chVTIsArmedI(&vt))
   \   000000B0   0xF11A 0x0F01      CMN      R10,#+1
   \   000000B4   0xD005             BEQ.N    ??i2c_lld_master_transmit_timeout_6
   \   000000B6   0x9803             LDR      R0,[SP, #+12]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD102             BNE.N    ??i2c_lld_master_transmit_timeout_6
    897              return RDY_TIMEOUT;
   \   000000BC   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000C0   0xE01D             B.N      ??i2c_lld_master_transmit_timeout_5
    898          
    899            /* Starts the operation.*/
    900            dp->CR2 |= I2C_CR2_ITEVTEN;
   \                     ??i2c_lld_master_transmit_timeout_6:
   \   000000C2   0xF8BB 0x0004      LDRH     R0,[R11, #+4]
   \   000000C6   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000CA   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    901            dp->CR1 |= I2C_CR1_START;
   \   000000CE   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \   000000D2   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000000D6   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    902          
    903            /* Waits for the operation completion or a timeout.*/
    904            i2cp->thread = chThdSelf();
   \   000000DA   0x....             LDR.N    R0,??DataTable8_28
   \   000000DC   0x6980             LDR      R0,[R0, #+24]
   \   000000DE   0x61E0             STR      R0,[R4, #+28]
    905            chSchGoSleepS(THD_STATE_SUSPENDED);
   \   000000E0   0x2002             MOVS     R0,#+2
   \   000000E2   0x.... 0x....      BL       chSchGoSleepS
    906            if ((timeout != TIME_INFINITE) && chVTIsArmedI(&vt))
   \   000000E6   0xF11A 0x0F01      CMN      R10,#+1
   \   000000EA   0xD005             BEQ.N    ??i2c_lld_master_transmit_timeout_7
   \   000000EC   0x9803             LDR      R0,[SP, #+12]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD002             BEQ.N    ??i2c_lld_master_transmit_timeout_7
    907              chVTResetI(&vt);
   \   000000F2   0xA800             ADD      R0,SP,#+0
   \   000000F4   0x.... 0x....      BL       chVTResetI
    908          
    909            return chThdSelf()->p_u.rdymsg;
   \                     ??i2c_lld_master_transmit_timeout_7:
   \   000000F8   0x....             LDR.N    R0,??DataTable8_28
   \   000000FA   0x6980             LDR      R0,[R0, #+24]
   \   000000FC   0x6A80             LDR      R0,[R0, #+40]
   \                     ??i2c_lld_master_transmit_timeout_5:
   \   000000FE   0xB005             ADD      SP,SP,#+20
   \   00000100   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    910          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x003D0901         DC32     0x3d0901

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     `?<Constant "\\"i2c_lld_set_clock\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x0280DE80         DC32     0x280de80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #3">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x00061A81         DC32     0x61a81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #4">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #5">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #6">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #7">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_set_clock(), #8">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x00030001         DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x0004007A         DC32     0x4007a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     I2CD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x3C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x........         DC32     i2c_lld_serve_rx_end_irq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_start(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   0x........         DC32     i2c_lld_serve_tx_end_irq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \   00000000   0x........         DC32     `?<Constant "i2c_lld_start(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_26:
   \   00000000   0x02030000         DC32     0x2030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_27:
   \   00000000   0x........         DC32     i2c_lld_safety_timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_28:
   \   00000000   0x........         DC32     rlist

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"i2c_lld_set_clock\\"()">`:
   \   00000000   0x22 0x69          DC8 "\"i2c_lld_set_clock\"()"
   \              0x32 0x63    
   \              0x5F 0x6C    
   \              0x6C 0x64    
   \              0x5F 0x73    
   \              0x65 0x74    
   \              0x5F 0x63    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 70H, 6CH, 61H, 74H
   \              0x6C 0x5C    
   \              0x70 0x6C    
   \              0x61 0x74    
   \   00000038   0x66 0x6F          DC8 66H, 6FH, 72H, 6DH, 73H, 5CH, 53H, 54H
   \              0x72 0x6D    
   \              0x73 0x5C    
   \              0x53 0x54    
   \   00000040   0x4D 0x33          DC8 4DH, 33H, 32H, 5CH, 49H, 32H, 43H, 76H
   \              0x32 0x5C    
   \              0x49 0x32    
   \              0x43 0x76    
   \   00000048   0x31 0x5C          DC8 31H, 5CH, 69H, 32H, 63H, 5FH, 6CH, 6CH
   \              0x69 0x32    
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \   00000050   0x64 0x2E          DC8 64H, 2EH, 63H, 0
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #1">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #1"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #2">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #2"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x32 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #3">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #3"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x33 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #4">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #4"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x34 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #5">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #5"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x35 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #6">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #6"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x36 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #7">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #7"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x37 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_set_clock(), #8">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_set_clock(), #8"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x38 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_start(), #1">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_start(), #1"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "i2c_lld_start(), #2">`:
   \   00000000   0x69 0x32          DC8 "i2c_lld_start(), #2"
   \              0x63 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x32 0x00    
    911          
    912          #endif /* HAL_USE_I2C */
    913          
    914          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   VectorBC
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> i2c_lld_serve_event_interrupt
       8   VectorC0
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> i2c_lld_serve_error_interrupt
       0   i2c_lld_abort_operation
       8   i2c_lld_init
         8   -> i2cObjectInit
      48   i2c_lld_master_receive_timeout
        48   -> chSchGoSleepS
        48   -> chVTResetI
        48   -> chVTSetI
        48   -> dbg_check_lock
        48   -> dbg_check_unlock
      56   i2c_lld_master_transmit_timeout
        56   -> chSchGoSleepS
        56   -> chVTResetI
        56   -> chVTSetI
        56   -> dbg_check_lock
        56   -> dbg_check_unlock
      16   i2c_lld_safety_timeout
        16   -> chSchReadyI
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
        16   -> i2c_lld_abort_operation
      16   i2c_lld_serve_error_interrupt
        16   -> chSchReadyI
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
      24   i2c_lld_serve_event_interrupt
        24   -> chSchReadyI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
      24   i2c_lld_serve_rx_end_irq
        24   -> chSchReadyI
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> port_halt
      16   i2c_lld_serve_tx_end_irq
        16   -> port_halt
      32   i2c_lld_set_clock
        32   -> chDbgPanic
        32   -> chDbgPanic3
       4   i2c_lld_set_opmode
      16   i2c_lld_start
        16   -> chDbgPanic
        16   -> dmaStreamAllocate
        16   -> i2c_lld_set_clock
        16   -> i2c_lld_set_opmode
        16   -> nvicEnableVector
       8   i2c_lld_stop
         8   -> dmaStreamRelease
         8   -> i2c_lld_abort_operation
         8   -> nvicDisableVector


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      84  ?<Constant "F:\\stuff\\rusefi_sourc...">
      24  ?<Constant "\"i2c_lld_set_clock\"()">
      24  ?<Constant "i2c_lld_set_clock(), #1">
      24  ?<Constant "i2c_lld_set_clock(), #2">
      24  ?<Constant "i2c_lld_set_clock(), #3">
      24  ?<Constant "i2c_lld_set_clock(), #4">
      24  ?<Constant "i2c_lld_set_clock(), #5">
      24  ?<Constant "i2c_lld_set_clock(), #6">
      24  ?<Constant "i2c_lld_set_clock(), #7">
      24  ?<Constant "i2c_lld_set_clock(), #8">
      20  ?<Constant "i2c_lld_start(), #1">
      20  ?<Constant "i2c_lld_start(), #2">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_24
       4  ??DataTable8_25
       4  ??DataTable8_26
       4  ??DataTable8_27
       4  ??DataTable8_28
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      56  I2CD1
      24  VectorBC
      50  VectorC0
     106  i2c_lld_abort_operation
      34  i2c_lld_init
     232  i2c_lld_master_receive_timeout
     260  i2c_lld_master_transmit_timeout
      58  i2c_lld_safety_timeout
     258  i2c_lld_serve_error_interrupt
     296  i2c_lld_serve_event_interrupt
     134  i2c_lld_serve_rx_end_irq
      70  i2c_lld_serve_tx_end_irq
     376  i2c_lld_set_clock
      58  i2c_lld_set_opmode
     202  i2c_lld_start
      60  i2c_lld_stop

 
    56 bytes in section .bss
   340 bytes in section .rodata
 2 334 bytes in section .text
 
 2 334 bytes of CODE  memory
   340 bytes of CONST memory
    56 bytes of DATA  memory

Errors: none
Warnings: none
