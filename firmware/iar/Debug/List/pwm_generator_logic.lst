###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:59 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\syst #
#                       em\pwm_generator_logic.cpp                            #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\syst #
#                       em\pwm_generator_logic.cpp -lCN                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\p #
#                       wm_generator_logic.lst                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\pw #
#                       m_generator_logic.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\system\pwm_generator_logic.cpp
      1          /**
      2           * @file    pwm_generator_logic.cpp
      3           *
      4           * This PWM implementation keep track of when it would be the next time to toggle the signal.
      5           * It constantly sets timer to that next toggle time, then sets the timer again from the callback, and so on.
      6           *
      7           * @date Mar 2, 2014
      8           * @author Andrey Belomutskiy, (c) 2012-2015
      9           */
     10          
     11          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     12          #include "pwm_generator_logic.h"
     13          
     14          /**
     15           * We need to limit the number of iterations in order to avoid precision loss while calculating
     16           * next toggle time
     17           */
     18          #define ITERATION_LIMIT 1000
     19          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp SimplePwm::subobject SimplePwm()
   \                     _ZN9SimplePwmC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9SimplePwmC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     20          SimplePwm::SimplePwm() {
   \                     _ZN9SimplePwmC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9PwmConfigC2Ev
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x....             LDR.N    R1,??DataTable5_1
   \   00000010   0xF114 0x0060      ADDS     R0,R4,#+96
   \   00000014   0x.... 0x....      BL       __aeabi_vec_ctor_nocookie_nodtor
   \   00000018   0xF114 0x006C      ADDS     R0,R4,#+108
   \   0000001C   0x.... 0x....      BL       _ZN13single_wave_sC1Ev
     21          	waveInstance.init(pinStates);
   \   00000020   0xF114 0x015C      ADDS     R1,R4,#+92
   \   00000024   0xF114 0x006C      ADDS     R0,R4,#+108
   \   00000028   0x.... 0x....      BL       _ZN13single_wave_s4initEPa
     22          	sr[0] = waveInstance;
   \   0000002C   0x6EE0             LDR      R0,[R4, #+108]
   \   0000002E   0x6620             STR      R0,[R4, #+96]
     23          	init(_switchTimes, sr);
   \   00000030   0xF114 0x0260      ADDS     R2,R4,#+96
   \   00000034   0xF114 0x0164      ADDS     R1,R4,#+100
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       _ZN9PwmConfig4initEPfP13single_wave_s
     24          }
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     25          void PwmConfig::baseConstructor() {
   \                     _ZN9PwmConfig15baseConstructorEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     26          	memset(&scheduling, 0, sizeof(scheduling));
   \   00000004   0x2218             MOVS     R2,#+24
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000000C   0x.... 0x....      BL       memset
     27          	memset(&safe, 0, sizeof(safe));
   \   00000010   0x2218             MOVS     R2,#+24
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000018   0x.... 0x....      BL       memset
     28          	dbgNestingLevel = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61E0             STR      R0,[R4, #+28]
     29          	periodNt = NAN;
   \   00000020   0xF07F 0x4000      MVNS     R0,#-2147483648
   \   00000024   0x61A0             STR      R0,[R4, #+24]
     30          	memset(&outputPins, 0, sizeof(outputPins));
   \   00000026   0x220C             MOVS     R2,#+12
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       memset
     31          	phaseCount = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6520             STR      R0,[R4, #+80]
     32          	cycleCallback = NULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6560             STR      R0,[R4, #+84]
     33          	stateChangeCallback = NULL;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x65A0             STR      R0,[R4, #+88]
     34          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
     35          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp PwmConfig::subobject PwmConfig()
   \                     _ZN9PwmConfigC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9PwmConfigC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     36          PwmConfig::PwmConfig() {
   \                     _ZN9PwmConfigC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000008   0x.... 0x....      BL       _ZN12multi_wave_sC1Ev
   \   0000000C   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000010   0x.... 0x....      BL       _ZN12scheduling_sC1Ev
     37          	baseConstructor();
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       _ZN9PwmConfig15baseConstructorEv
     38          }
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     39          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp PwmConfig::subobject PwmConfig(float *, single_wave_s *)
   \                     _ZN9PwmConfigC2EPfP13single_wave_s:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9PwmConfigC1EPfP13single_wave_s
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     40          PwmConfig::PwmConfig(float *st, single_wave_s *waves) {
   \                     _ZN9PwmConfigC1EPfP13single_wave_s:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000000C   0x.... 0x....      BL       _ZN12multi_wave_sC1Ev
   \   00000010   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000014   0x.... 0x....      BL       _ZN12scheduling_sC1Ev
     41          	baseConstructor();
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN9PwmConfig15baseConstructorEv
     42          	multiWave.init(st, waves);
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000026   0x.... 0x....      BL       _ZN12multi_wave_s4initEPfP13single_wave_s
     43          }
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void PwmConfig::init(float *st, single_wave_s *waves) {
   \                     _ZN9PwmConfig4initEPfP13single_wave_s:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     46          	multiWave.init(st, waves);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000010   0x.... 0x....      BL       _ZN12multi_wave_s4initEPfP13single_wave_s
     47          }
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     48          
     49          /**
     50           * @param dutyCycle value between 0 and 1
     51           */

   \                                 In section .text, align 2, keep-with-next
     52          void SimplePwm::setSimplePwmDutyCycle(float dutyCycle) {
   \                     _ZN9SimplePwm21setSimplePwmDutyCycleEf:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
     53          	multiWave.setSwitchTime(0, dutyCycle);
   \   0000000C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000016   0x.... 0x....      BL       _ZN12multi_wave_s13setSwitchTimeEif
     54          }
   \   0000001A   0xECBD 0x8B02      VPOP     {D8}
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     55          

   \                                 In section .text, align 2, keep-with-next
     56          static efitimeus_t getNextSwitchTimeUs(PwmConfig *state) {
   \                     _Z19getNextSwitchTimeUsP9PwmConfig:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0x0004             MOVS     R4,R0
     57          	efiAssert(state->safe.phaseIndex < PWM_PHASE_MAX_COUNT, "phaseIndex range", 0);
   \   00000008   0x6CA0             LDR      R0,[R4, #+72]
   \   0000000A   0x28FC             CMP      R0,#+252
   \   0000000C   0xDB05             BLT.N    ??getNextSwitchTimeUs_0
   \   0000000E   0x....             LDR.N    R0,??DataTable5_2
   \   00000010   0x.... 0x....      BL       firmwareError
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xE01C             B.N      ??getNextSwitchTimeUs_1
     58          	int iteration = state->safe.iteration;
   \                     ??getNextSwitchTimeUs_0:
   \   0000001A   0xED94 0x8A0F      VLDR     S16,[R4, #+60]
     59          	float switchTime = state->multiWave.getSwitchTime(state->safe.phaseIndex);
   \   0000001E   0x6CA1             LDR      R1,[R4, #+72]
   \   00000020   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000024   0x.... 0x....      BL       _ZNK12multi_wave_s13getSwitchTimeEi
   \   00000028   0xEEF0 0x8A40      VMOV.F32 S17,S0
     60          	float periodNt = state->safe.periodNt;
   \   0000002C   0xED94 0x9A0E      VLDR     S18,[R4, #+56]
     61          #if DEBUG_PWM
     62          	scheduleMsg(&logger, "iteration=%d switchTime=%f period=%f", iteration, switchTime, period);
     63          #endif
     64          
     65          	/**
     66          	 * Once 'iteration' gets relatively high, we might lose calculation precision here.
     67          	 * This is addressed by ITERATION_LIMIT
     68          	 */
     69          	efitime_t timeToSwitchNt = (efitime_t) ((iteration + switchTime) * periodNt);
   \   00000030   0xEEB8 0x0AC8      VCVT.F32.S32 S0,S16
   \   00000034   0xEE30 0x0A28      VADD.F32 S0,S0,S17
   \   00000038   0xEE20 0x0A09      VMUL.F32 S0,S0,S18
   \   0000003C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000040   0x.... 0x....      BL       __aeabi_f2lz
     70          
     71          #if DEBUG_PWM
     72          	scheduleMsg(&logger, "start=%d timeToSwitch=%d", state->safe.start, timeToSwitch);
     73          #endif
     74          	return NT2US(state->safe.startNt + timeToSwitchNt);
   \   00000044   0xE9D4 0x2310      LDRD     R2,R3,[R4, #+64]
   \   00000048   0x1810             ADDS     R0,R2,R0
   \   0000004A   0x4159             ADCS     R1,R3,R1
   \   0000004C   0x22A8             MOVS     R2,#+168
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x.... 0x....      BL       __aeabi_ldivmod
   \                     ??getNextSwitchTimeUs_1:
   \   00000054   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
     75          }
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void PwmConfig::handleCycleStart() {
   \                     _ZN9PwmConfig16handleCycleStartEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     78          	if (safe.phaseIndex == 0) {
   \   00000004   0x6CA0             LDR      R0,[R4, #+72]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD125             BNE.N    ??handleCycleStart_0
     79          		if (cycleCallback != NULL) {
   \   0000000A   0x6D60             LDR      R0,[R4, #+84]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ.N    ??handleCycleStart_1
     80          			cycleCallback(this);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x6D61             LDR      R1,[R4, #+84]
   \   00000014   0x4788             BLX      R1
     81          		}
     82          		efiAssertVoid(periodNt != 0, "period not initialized");
   \                     ??handleCycleStart_1:
   \   00000016   0xED94 0x0A06      VLDR     S0,[R4, #+24]
   \   0000001A   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000001E   0xEEF1 0xFA10      FMSTAT   
   \   00000022   0xD103             BNE.N    ??handleCycleStart_2
   \   00000024   0x....             LDR.N    R0,??DataTable5_3
   \   00000026   0x.... 0x....      BL       firmwareError
   \   0000002A   0xE014             B.N      ??handleCycleStart_3
     83          		if (safe.periodNt != periodNt || safe.iteration == ITERATION_LIMIT) {
   \                     ??handleCycleStart_2:
   \   0000002C   0xED94 0x0A0E      VLDR     S0,[R4, #+56]
   \   00000030   0xEDD4 0x0A06      VLDR     S1,[R4, #+24]
   \   00000034   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000038   0xEEF1 0xFA10      FMSTAT   
   \   0000003C   0xD103             BNE.N    ??handleCycleStart_4
   \   0000003E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000040   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000044   0xD107             BNE.N    ??handleCycleStart_0
     84          			/**
     85          			 * period length has changed - we need to reset internal state
     86          			 */
     87          			safe.startNt = getTimeNowNt();
   \                     ??handleCycleStart_4:
   \   00000046   0x.... 0x....      BL       getTimeNowNt
   \   0000004A   0xE9C4 0x0110      STRD     R0,R1,[R4, #+64]
     88          			safe.iteration = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x63E0             STR      R0,[R4, #+60]
     89          			safe.periodNt = periodNt;
   \   00000052   0x69A0             LDR      R0,[R4, #+24]
   \   00000054   0x63A0             STR      R0,[R4, #+56]
     90          #if DEBUG_PWM
     91          			scheduleMsg(&logger, "state reset start=%d iteration=%d", state->safe.start, state->safe.iteration);
     92          #endif
     93          		}
     94          	}
     95          }
   \                     ??handleCycleStart_0:
   \                     ??handleCycleStart_3:
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
     96          
     97          /**
     98           * @return Next time for signal toggle
     99           */

   \                                 In section .text, align 2, keep-with-next
    100          static efitimeus_t togglePwmState(PwmConfig *state) {
   \                     _Z14togglePwmStateP9PwmConfig:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    101          #if DEBUG_PWM
    102          	scheduleMsg(&logger, "togglePwmState phaseIndex=%d iteration=%d", state->safe.phaseIndex, state->safe.iteration);
    103          	scheduleMsg(&logger, "state->period=%f state->safe.period=%f", state->period, state->safe.period);
    104          #endif
    105          
    106          	if (cisnan(state->periodNt)) {
   \   00000004   0xED94 0x0A06      VLDR     S0,[R4, #+24]
   \   00000008   0x.... 0x....      BL       __iar_FDtest
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD106             BNE.N    ??togglePwmState_0
    107          		/**
    108          		 * NaN period means PWM is paused
    109          		 */
    110          		return getTimeNowUs() + MS2US(100);
   \   00000010   0x.... 0x....      BL       getTimeNowUs
   \   00000014   0x....             LDR.N    R2,??DataTable5_4  ;; 0x186a0
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x1880             ADDS     R0,R0,R2
   \   0000001A   0x4159             ADCS     R1,R1,R3
   \   0000001C   0xE01D             B.N      ??togglePwmState_1
    111          	}
    112          
    113          	state->handleCycleStart();
   \                     ??togglePwmState_0:
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       _ZN9PwmConfig16handleCycleStartEv
    114          
    115          	/**
    116          	 * Here is where the 'business logic' - the actual pin state change is happening
    117          	 */
    118          	// callback state index is offset by one. todo: why? can we simplify this?
    119          	int cbStateIndex = state->safe.phaseIndex == 0 ? state->phaseCount - 1 : state->safe.phaseIndex - 1;
   \   00000024   0x6CA0             LDR      R0,[R4, #+72]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD102             BNE.N    ??togglePwmState_2
   \   0000002A   0x6D20             LDR      R0,[R4, #+80]
   \   0000002C   0x1E45             SUBS     R5,R0,#+1
   \   0000002E   0xE001             B.N      ??togglePwmState_3
   \                     ??togglePwmState_2:
   \   00000030   0x6CA0             LDR      R0,[R4, #+72]
   \   00000032   0x1E45             SUBS     R5,R0,#+1
    120          	state->stateChangeCallback(state, cbStateIndex);
   \                     ??togglePwmState_3:
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x6DA2             LDR      R2,[R4, #+88]
   \   0000003A   0x4790             BLX      R2
    121          
    122          	efitimeus_t nextSwitchTimeUs = getNextSwitchTimeUs(state);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       _Z19getNextSwitchTimeUsP9PwmConfig
    123          #if DEBUG_PWM
    124          	scheduleMsg(&logger, "%s: nextSwitchTime %d", state->name, nextSwitchTime);
    125          #endif
    126          	// signed value is needed here
    127          //	int64_t timeToSwitch = nextSwitchTimeUs - getTimeNowUs();
    128          //	if (timeToSwitch < 1) {
    129          //		/**
    130          //		 * We are here if we are late for a state transition.
    131          //		 * At 12000RPM=200Hz with a 60 toothed wheel we need to change state every
    132          //		 * 1000000 / 200 / 120 = ~41 uS. We are kind of OK.
    133          //		 *
    134          //		 * We are also here after a flash write. Flash write freezes the whole chip for a couple of seconds,
    135          //		 * so PWM generation and trigger simulation generation would have to recover from this time lag.
    136          //		 */
    137          //		//todo: introduce error and test this error handling		warning(OBD_PCM_Processor_Fault, "PWM: negative switch time");
    138          //		timeToSwitch = 10;
    139          //	}
    140          
    141          	state->safe.phaseIndex++;
   \   00000042   0x6CA2             LDR      R2,[R4, #+72]
   \   00000044   0x1C52             ADDS     R2,R2,#+1
   \   00000046   0x64A2             STR      R2,[R4, #+72]
    142          	if (state->safe.phaseIndex == state->phaseCount) {
   \   00000048   0x6CA2             LDR      R2,[R4, #+72]
   \   0000004A   0x6D23             LDR      R3,[R4, #+80]
   \   0000004C   0x429A             CMP      R2,R3
   \   0000004E   0xD104             BNE.N    ??togglePwmState_4
    143          		state->safe.phaseIndex = 0; // restart
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x64A2             STR      R2,[R4, #+72]
    144          		state->safe.iteration++;
   \   00000054   0x6BE2             LDR      R2,[R4, #+60]
   \   00000056   0x1C52             ADDS     R2,R2,#+1
   \   00000058   0x63E2             STR      R2,[R4, #+60]
    145          	}
    146          	return nextSwitchTimeUs;
   \                     ??togglePwmState_4:
   \                     ??togglePwmState_1:
   \   0000005A   0xBD34             POP      {R2,R4,R5,PC}    ;; return
    147          }
    148          
    149          /**
    150           * Main PWM loop: toggle pin & schedule next invocation
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          static void timerCallback(PwmConfig *state) {
   \                     _Z13timerCallbackP9PwmConfig:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    153          	state->dbgNestingLevel++;
   \   00000004   0x69F0             LDR      R0,[R6, #+28]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x61F0             STR      R0,[R6, #+28]
    154          	efiAssertVoid(state->dbgNestingLevel < 25, "PWM nesting issue");
   \   0000000A   0x69F0             LDR      R0,[R6, #+28]
   \   0000000C   0x2819             CMP      R0,#+25
   \   0000000E   0xDB03             BLT.N    ??timerCallback_0
   \   00000010   0x....             LDR.N    R0,??DataTable5_5
   \   00000012   0x.... 0x....      BL       firmwareError
   \   00000016   0xE011             B.N      ??timerCallback_1
    155          
    156          	efitimeus_t switchTimeUs = togglePwmState(state);
   \                     ??timerCallback_0:
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       _Z14togglePwmStateP9PwmConfig
   \   0000001E   0x0004             MOVS     R4,R0
   \   00000020   0x000D             MOVS     R5,R1
    157          	scheduleByTime("pwm", &state->scheduling, switchTimeUs, (schfunc_t) timerCallback, state);
   \   00000022   0x9601             STR      R6,[SP, #+4]
   \   00000024   0x....             LDR.N    R0,??DataTable5_6
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x0022             MOVS     R2,R4
   \   0000002A   0x002B             MOVS     R3,R5
   \   0000002C   0xF116 0x0120      ADDS     R1,R6,#+32
   \   00000030   0x....             ADR.N    R0,??DataTable5  ;; "pwm"
   \   00000032   0x.... 0x....      BL       _Z14scheduleByTimePKcP12scheduling_sxPFvPvES3_
    158          	state->dbgNestingLevel--;
   \   00000036   0x69F0             LDR      R0,[R6, #+28]
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x61F0             STR      R0,[R6, #+28]
    159          }
   \                     ??timerCallback_1:
   \   0000003C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    160          
    161          /**
    162           * Incoming parameters are potentially just values on current stack, so we have to copy
    163           * into our own permanent storage, right?
    164           */

   \                                 In section .text, align 2, keep-with-next
    165          void copyPwmParameters(PwmConfig *state, int phaseCount, float *switchTimes, int waveCount, pin_state_t **pinStates) {
   \                     _Z17copyPwmParametersP9PwmConfigiPfiPPa:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    166          	state->phaseCount = phaseCount;
   \   00000010   0x6525             STR      R5,[R4, #+80]
    167          
    168          	for (int phaseIndex = 0; phaseIndex < phaseCount; phaseIndex++) {
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??copyPwmParameters_0:
   \   00000016   0x45A9             CMP      R9,R5
   \   00000018   0xDA19             BGE.N    ??copyPwmParameters_1
    169          		state->multiWave.setSwitchTime(phaseIndex, switchTimes[phaseIndex]);
   \   0000001A   0xEB16 0x0089      ADDS     R0,R6,R9, LSL #+2
   \   0000001E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000022   0x4649             MOV      R1,R9
   \   00000024   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000028   0x.... 0x....      BL       _ZN12multi_wave_s13setSwitchTimeEif
    170          
    171          		for (int waveIndex = 0; waveIndex < waveCount; waveIndex++) {
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??copyPwmParameters_2:
   \   0000002E   0x42B8             CMP      R0,R7
   \   00000030   0xDA0A             BGE.N    ??copyPwmParameters_3
    172          //			print("output switch time index (%d/%d) at %f to %d\r\n", phaseIndex,waveIndex,
    173          //					switchTimes[phaseIndex], pinStates[waveIndex][phaseIndex]);
    174          			state->multiWave.waves[waveIndex].pinStates[phaseIndex] = pinStates[waveIndex][phaseIndex];
   \   00000032   0x6921             LDR      R1,[R4, #+16]
   \   00000034   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   00000038   0xF858 0x2020      LDR      R2,[R8, R0, LSL #+2]
   \   0000003C   0xF819 0x2002      LDRB     R2,[R9, R2]
   \   00000040   0xF809 0x2001      STRB     R2,[R9, R1]
    175          		}
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0xE7F2             B.N      ??copyPwmParameters_2
    176          	}
   \                     ??copyPwmParameters_3:
   \   00000048   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000004C   0xE7E3             B.N      ??copyPwmParameters_0
    177          }
   \                     ??copyPwmParameters_1:
   \   0000004E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    178          

   \                                 In section .text, align 2, keep-with-next
    179          void PwmConfig::weComplexInit(const char *msg, int phaseCount, float *switchTimes, int waveCount,
    180          		pin_state_t **pinStates, pwm_cycle_callback *cycleCallback, pwm_gen_callback *stateChangeCallback) {
   \                     _ZN9PwmConfig13weComplexInitEPKciPfiPPaPFvPS_EPFvS5_iE:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000010   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \   00000014   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   \   00000018   0xF8DD 0xB034      LDR      R11,[SP, #+52]
    181          
    182          	efiAssertVoid(periodNt != 0, "period is not initialized");
   \   0000001C   0xED94 0x0A06      VLDR     S0,[R4, #+24]
   \   00000020   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000024   0xEEF1 0xFA10      FMSTAT   
   \   00000028   0xD103             BNE.N    ??weComplexInit_0
   \   0000002A   0x....             LDR.N    R0,??DataTable5_7
   \   0000002C   0x.... 0x....      BL       firmwareError
   \   00000030   0xE02E             B.N      ??weComplexInit_1
    183          	if (phaseCount == 0) {
   \                     ??weComplexInit_0:
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD103             BNE.N    ??weComplexInit_2
    184          		firmwareError("signal length cannot be zero");
   \   00000036   0x....             LDR.N    R0,??DataTable5_8
   \   00000038   0x.... 0x....      BL       firmwareError
    185          		return;
   \   0000003C   0xE028             B.N      ??weComplexInit_1
    186          	}
    187          	if (phaseCount > PWM_PHASE_MAX_COUNT) {
   \                     ??weComplexInit_2:
   \   0000003E   0x2EFD             CMP      R6,#+253
   \   00000040   0xDB03             BLT.N    ??weComplexInit_3
    188          		firmwareError("too many phases in PWM");
   \   00000042   0x....             LDR.N    R0,??DataTable5_9
   \   00000044   0x.... 0x....      BL       firmwareError
    189          		return;
   \   00000048   0xE022             B.N      ??weComplexInit_1
    190          	}
    191          	efiAssertVoid(waveCount > 0, "waveCount should be positive");
   \                     ??weComplexInit_3:
   \   0000004A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000004E   0xDA03             BGE.N    ??weComplexInit_4
   \   00000050   0x....             LDR.N    R0,??DataTable5_10
   \   00000052   0x.... 0x....      BL       firmwareError
   \   00000056   0xE01B             B.N      ??weComplexInit_1
    192          	checkSwitchTimes2(phaseCount, switchTimes);
   \                     ??weComplexInit_4:
   \   00000058   0x0039             MOVS     R1,R7
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x.... 0x....      BL       _Z17checkSwitchTimes2iPf
    193          
    194          	this->cycleCallback = cycleCallback;
   \   00000060   0xF8C4 0xA054      STR      R10,[R4, #+84]
    195          	this->stateChangeCallback = stateChangeCallback;
   \   00000064   0xF8C4 0xB058      STR      R11,[R4, #+88]
    196          
    197          	multiWave.waveCount = waveCount;
   \   00000068   0xF8C4 0x800C      STR      R8,[R4, #+12]
    198          
    199          	copyPwmParameters(this, phaseCount, switchTimes, waveCount, pinStates);
   \   0000006C   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000070   0x4643             MOV      R3,R8
   \   00000072   0x003A             MOVS     R2,R7
   \   00000074   0x0031             MOVS     R1,R6
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       _Z17copyPwmParametersP9PwmConfigiPfiPPa
    200          
    201          	safe.phaseIndex = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x64A0             STR      R0,[R4, #+72]
    202          	safe.periodNt = -1;
   \   00000080   0x....             LDR.N    R0,??DataTable5_11  ;; 0xbf800000
   \   00000082   0x63A0             STR      R0,[R4, #+56]
    203          	safe.iteration = -1;
   \   00000084   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000088   0x63E0             STR      R0,[R4, #+60]
    204          
    205          	// let's start the indefinite callback loop of PWM generation
    206          	timerCallback(this);
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       _Z13timerCallbackP9PwmConfig
    207          }
   \                     ??weComplexInit_1:
   \   00000090   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x70 0x77          DC8      "pwm"
   \              0x6D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     _ZN13single_wave_sC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     `?<Constant "phaseIndex range">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     `?<Constant "period not initialized">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     `?<Constant "PWM nesting issue">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     _Z13timerCallbackP9PwmConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     `?<Constant "period is not initial...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     `?<Constant "signal length cannot ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     `?<Constant "too many phases in PWM">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     `?<Constant "waveCount should be p...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .rodata, align 4
   \                     `?<Constant "phaseIndex range">`:
   \   00000000   0x70 0x68          DC8 "phaseIndex range"
   \              0x61 0x73    
   \              0x65 0x49    
   \              0x6E 0x64    
   \              0x65 0x78    
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "PWM nesting issue">`:
   \   00000000   0x50 0x57          DC8 "PWM nesting issue"
   \              0x4D 0x20    
   \              0x6E 0x65    
   \              0x73 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x70 0x77          DC8 "pwm"
   \              0x6D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "period is not initial...">`:
   \   00000000   0x70 0x65          DC8 "period is not initialized"
   \              0x72 0x69    
   \              0x6F 0x64    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x65    
   \              0x64 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "signal length cannot ...">`:
   \   00000000   0x73 0x69          DC8 "signal length cannot be zero"
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x20 0x6C    
   \              0x65 0x6E    
   \              0x67 0x74    
   \              0x68 0x20    
   \              0x63 0x61    
   \              0x6E 0x6E    
   \              0x6F 0x74    
   \              0x20 0x62    
   \              0x65 0x20    
   \              0x7A 0x65    
   \              0x72 0x6F    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "too many phases in PWM">`:
   \   00000000   0x74 0x6F          DC8 "too many phases in PWM"
   \              0x6F 0x20    
   \              0x6D 0x61    
   \              0x6E 0x79    
   \              0x20 0x70    
   \              0x68 0x61    
   \              0x73 0x65    
   \              0x73 0x20    
   \              0x69 0x6E    
   \              0x20 0x50    
   \              0x57 0x4D    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "waveCount should be p...">`:
   \   00000000   0x77 0x61          DC8 "waveCount should be positive"
   \              0x76 0x65    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x20    
   \              0x73 0x68    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x62    
   \              0x65 0x20    
   \              0x70 0x6F    
   \              0x73 0x69    
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "period not initialized">`:
   \   00000000   0x70 0x65          DC8 "period not initialized"
   \              0x72 0x69    
   \              0x6F 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x00         
   \   00000017   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   PwmConfig::PwmConfig()
         8   -> PwmConfig::baseConstructor()
         8   -> multi_wave_s::multi_wave_s()
         8   -> scheduling_s::scheduling_s()
      16   PwmConfig::PwmConfig(float *, single_wave_s *)
        16   -> PwmConfig::baseConstructor()
        16   -> multi_wave_s::init(float *, single_wave_s *)
        16   -> multi_wave_s::multi_wave_s()
        16   -> scheduling_s::scheduling_s()
       8   PwmConfig::baseConstructor()
         8   -> memset
       8   PwmConfig::handleCycleStart()
         8   -- Indirect call
         8   -> firmwareError
         8   -> getTimeNowNt
      16   PwmConfig::init(float *, single_wave_s *)
        16   -> multi_wave_s::init(float *, single_wave_s *)
       8   PwmConfig::subobject PwmConfig()
         8   -> PwmConfig::PwmConfig()
       8   PwmConfig::subobject PwmConfig(float *, single_wave_s *)
         8   -> PwmConfig::PwmConfig(float *, single_wave_s *)
      40   PwmConfig::weComplexInit(char const *, int, float *, int, int8_t **, pwm_cycle_callback *, pwm_gen_callback *)
        40   -> checkSwitchTimes2(int, float *)
        40   -> copyPwmParameters(PwmConfig *, int, float *, int, int8_t **)
        40   -> firmwareError
        40   -> timerCallback(PwmConfig *)
       8   SimplePwm::SimplePwm()
         8   -> PwmConfig::init(float *, single_wave_s *)
         8   -> PwmConfig::subobject PwmConfig()
         8   -> __aeabi_vec_ctor_nocookie_nodtor
         8   -> single_wave_s::init(int8_t *)
         8   -> single_wave_s::single_wave_s()
      16   SimplePwm::setSimplePwmDutyCycle(float)
        16   -> multi_wave_s::setSwitchTime(int, float)
       8   SimplePwm::subobject SimplePwm()
         8   -> SimplePwm::SimplePwm()
      32   copyPwmParameters(PwmConfig *, int, float *, int, int8_t **)
        32   -> multi_wave_s::setSwitchTime(int, float)
      24   getNextSwitchTimeUs(PwmConfig *)
        24   -> __aeabi_f2lz
        24   -> __aeabi_ldivmod
        24   -> firmwareError
        24   -> multi_wave_s::getSwitchTime(int) const
      16   memset
        16   -> __aeabi_memset
      24   timerCallback(PwmConfig *)
        24   -> firmwareError
        24   -> scheduleByTime(char const *, scheduling_s *, int64_t, schfunc_t, void *)
        24   -> togglePwmState(PwmConfig *)
      16   togglePwmState(PwmConfig *)
        16   -- Indirect call
        16   -> PwmConfig::handleCycleStart()
        16   -> __iar_FDtest
        16   -> getNextSwitchTimeUs(PwmConfig *)
        16   -> getTimeNowUs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "PWM nesting issue">
      28  ?<Constant "period is not initial...">
      24  ?<Constant "period not initialized">
      20  ?<Constant "phaseIndex range">
       4  ?<Constant "pwm">
      32  ?<Constant "signal length cannot ...">
      24  ?<Constant "too many phases in PWM">
      32  ?<Constant "waveCount should be p...">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      30  PwmConfig::PwmConfig()
      46  PwmConfig::PwmConfig(float *, single_wave_s *)
      62  PwmConfig::baseConstructor()
      88  PwmConfig::handleCycleStart()
      22  PwmConfig::init(float *, single_wave_s *)
      12  PwmConfig::subobject PwmConfig()
      12  PwmConfig::subobject PwmConfig(float *, single_wave_s *)
     148  PwmConfig::weComplexInit(char const *, int, float *, int, int8_t **, pwm_cycle_callback *, pwm_gen_callback *)
      66  SimplePwm::SimplePwm()
      32  SimplePwm::setSimplePwmDutyCycle(float)
      12  SimplePwm::subobject SimplePwm()
      82  copyPwmParameters(PwmConfig *, int, float *, int, int8_t **)
      90  getNextSwitchTimeUs(PwmConfig *)
      22  memset
      62  timerCallback(PwmConfig *)
      92  togglePwmState(PwmConfig *)

 
 184 bytes in section .rodata
 926 bytes in section .text
 
 904 bytes of CODE  memory (+ 22 bytes shared)
 184 bytes of CONST memory

Errors: none
Warnings: 1
