###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:44 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\util\efilib.cpp  #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\util\efilib.cpp  #
#                       -lCN F:\stuff\rusefi_sourceforge\firmware\iar\Debug\L #
#                       ist\ -lA F:\stuff\rusefi_sourceforge\firmware\iar\Deb #
#                       ug\List\ -o F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       Debug\Obj\ --no_cse --no_unroll --no_inline           #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\e #
#                       filib.lst                                             #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ef #
#                       ilib.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\util\efilib.cpp
      1          /**
      2           * @file	efilib.cpp
      3           *
      4           * We cannot use stdlib because we do not have malloc - so, we have to implement these functions
      5           *
      6           * @date Feb 21, 2014
      7           * @author Andrey Belomutskiy, (c) 2012-2015
      8           */
      9          
     10          #include <string.h>
     11          #include <math.h>
     12          #include "efilib.h"
     13          #include "datalogging.h"
     14          #include "histogram.h"
     15          
     16          #define _MAX_FILLER 11
     17          

   \                                 In section .text, align 2, keep-with-next
     18          const char * boolToString(bool value) {
     19          	return value ? "Yes" : "No";
   \                     _Z12boolToStringb:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??boolToString_0
   \   00000006   0x....             ADR.N    R0,??DataTable3  ;; "Yes"
   \   00000008   0xE000             B.N      ??boolToString_1
   \                     ??boolToString_0:
   \   0000000A   0x....             ADR.N    R0,??DataTable3_1  ;; 0x4E, 0x6F, 0x00, 0x00
   \                     ??boolToString_1:
   \   0000000C   0x4770             BX       LR               ;; return
     20          }
     21          

   \                                 In section .text, align 2, keep-with-next
     22          int minI(int i1, int i2) {
     23          	return i1 < i2 ? i1 : i2;
   \                     minI:
   \   00000000   0x4288             CMP      R0,R1
   \   00000002   0xDB00             BLT.N    ??minI_0
   \                     ??minI_1:
   \   00000004   0x0008             MOVS     R0,R1
   \                     ??minI_0:
   \   00000006   0x4770             BX       LR               ;; return
     24          }
     25          

   \                                 In section .text, align 2, keep-with-next
     26          float efiRound(float value, float precision) {
   \                     efiRound:
   \   00000000   0xEEB0 0x1A40      VMOV.F32 S2,S0
     27          	int a = (int) (value / precision);
   \   00000004   0xEE81 0x0A20      VDIV.F32 S0,S2,S1
   \   00000008   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
     28          	return a * precision;
   \   0000000C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000010   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000014   0x4770             BX       LR               ;; return
     29          }
     30          

   \                                 In section .text, align 2, keep-with-next
     31          float absF(float value) {
     32          	return value > 0 ? value : -value;
   \                     absF:
   \   00000000   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000004   0xEEF1 0xFA10      FMSTAT   
   \   00000008   0xDC01             BGT.N    ??absF_0
   \                     ??absF_1:
   \   0000000A   0xEEB1 0x0A40      VNEG.F32 S0,S0
   \                     ??absF_0:
   \   0000000E   0x4770             BX       LR               ;; return
     33          }
     34          

   \                                 In section .text, align 2, keep-with-next
     35          int absI(int32_t value) {
     36          	return value >= 0 ? value : -value;
   \                     absI:
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD500             BPL.N    ??absI_0
   \                     ??absI_1:
   \   00000004   0x4240             RSBS     R0,R0,#+0
   \                     ??absI_0:
   \   00000006   0x4770             BX       LR               ;; return
     37          }
     38          

   \                                 In section .text, align 2, keep-with-next
     39          int maxI(int i1, int i2) {
     40          	return i1 > i2 ? i1 : i2;
   \                     maxI:
   \   00000000   0x4281             CMP      R1,R0
   \   00000002   0xDB00             BLT.N    ??maxI_0
   \                     ??maxI_1:
   \   00000004   0x0008             MOVS     R0,R1
   \                     ??maxI_0:
   \   00000006   0x4770             BX       LR               ;; return
     41          }
     42          

   \                                 In section .text, align 2, keep-with-next
     43          float maxF(float i1, float i2) {
     44          	return i1 > i2 ? i1 : i2;
   \                     maxF:
   \   00000000   0xEEF4 0x0A40      VCMP.F32 S1,S0
   \   00000004   0xEEF1 0xFA10      FMSTAT   
   \   00000008   0xD401             BMI.N    ??maxF_0
   \                     ??maxF_1:
   \   0000000A   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \                     ??maxF_0:
   \   0000000E   0x4770             BX       LR               ;; return
     45          }
     46          

   \                                 In section .text, align 2, keep-with-next
     47          float minF(float i1, float i2) {
     48          	return i1 < i2 ? i1 : i2;
   \                     minF:
   \   00000000   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000004   0xEEF1 0xFA10      FMSTAT   
   \   00000008   0xD401             BMI.N    ??minF_0
   \                     ??minF_1:
   \   0000000A   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \                     ??minF_0:
   \   0000000E   0x4770             BX       LR               ;; return
     49          }
     50          

   \                                 In section .text, align 2, keep-with-next
     51          uint32_t efiStrlen(const char *param) {
     52          	register const char *s;
     53          	for (s = param; *s; ++s)
   \                     efiStrlen:
   \   00000000   0x0001             MOVS     R1,R0
   \                     ??efiStrlen_0:
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD001             BEQ.N    ??efiStrlen_1
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0xE7FA             B.N      ??efiStrlen_0
     54          		;
     55          	return (s - param);
   \                     ??efiStrlen_1:
   \   0000000C   0x1A08             SUBS     R0,R1,R0
   \   0000000E   0x4770             BX       LR               ;; return
     56          }
     57          

   \                                 In section .text, align 2, keep-with-next
     58          char * efiTrim(char *param) {
   \                     efiTrim:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     59          	while (param[0] == ' ') {
   \                     ??efiTrim_0:
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2820             CMP      R0,#+32
   \   00000008   0xD101             BNE.N    ??efiTrim_1
     60          		param++; // that would skip leading spaces
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \   0000000C   0xE7FA             B.N      ??efiTrim_0
     61          	}
     62          	int len = efiStrlen(param);
   \                     ??efiTrim_1:
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       efiStrlen
   \   00000014   0x0001             MOVS     R1,R0
     63          	while (len > 0 && param[len - 1] == ' ') {
   \                     ??efiTrim_2:
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xDB0A             BLT.N    ??efiTrim_3
   \   0000001A   0x1908             ADDS     R0,R1,R4
   \   0000001C   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \   00000020   0x2820             CMP      R0,#+32
   \   00000022   0xD105             BNE.N    ??efiTrim_3
     64          		param[len - 1] = 0;
   \   00000024   0x1908             ADDS     R0,R1,R4
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0xF800 0x2C01      STRB     R2,[R0, #-1]
     65          		len--;
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
   \   0000002E   0xE7F2             B.N      ??efiTrim_2
     66          	}
     67          	return param;
   \                     ??efiTrim_3:
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
     68          }
     69          

   \                                 In section .text, align 2, keep-with-next
     70          bool startsWith(const char *line, const char *prefix) {
   \                     startsWith:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     71          	uint32_t len = efiStrlen(prefix);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       efiStrlen
   \   0000000C   0x0006             MOVS     R6,R0
     72          	if (efiStrlen(line) < len) {
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       efiStrlen
   \   00000014   0x42B0             CMP      R0,R6
   \   00000016   0xD201             BCS.N    ??startsWith_0
     73          		return false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE00B             B.N      ??startsWith_1
     74          	}
     75          	for (uint32_t i = 0; i < len; i++) {
   \                     ??startsWith_0:
   \   0000001C   0x2100             MOVS     R1,#+0
   \                     ??startsWith_2:
   \   0000001E   0x42B1             CMP      R1,R6
   \   00000020   0xD207             BCS.N    ??startsWith_3
     76          		if (line[i] != prefix[i]) {
   \   00000022   0x5D08             LDRB     R0,[R1, R4]
   \   00000024   0x5D4A             LDRB     R2,[R1, R5]
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xD001             BEQ.N    ??startsWith_4
     77          			return false;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE002             B.N      ??startsWith_1
     78          		}
     79          	}
   \                     ??startsWith_4:
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0xE7F5             B.N      ??startsWith_2
     80          	return true;
   \                     ??startsWith_3:
   \   00000032   0x2001             MOVS     R0,#+1
   \                     ??startsWith_1:
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
     81          }
     82          

   \                                 In section .text, align 2, keep-with-next
     83          int indexOf(const char *string, char ch) {
   \                     indexOf:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     84          	// todo: there should be a standard function for this
     85          	// todo: on the other hand MISRA wants us not to use standard headers
     86          	int len = efiStrlen(string);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       efiStrlen
   \   0000000C   0x0001             MOVS     R1,R0
     87          	for (int i = 0; i < len; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??indexOf_0:
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xDA05             BGE.N    ??indexOf_1
     88          		if (string[i] == ch) {
   \   00000014   0x5D02             LDRB     R2,[R0, R4]
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x42AA             CMP      R2,R5
   \   0000001A   0xD003             BEQ.N    ??indexOf_2
     89          			return i;
     90          		}
     91          	}
   \                     ??indexOf_3:
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xE7F7             B.N      ??indexOf_0
     92          	return -1;
   \                     ??indexOf_1:
   \   00000020   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??indexOf_2:
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     93          }
     94          
     95          // string to integer

   \                                 In section .text, align 2, keep-with-next
     96          int atoi(const char *string) {
   \                     atoi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     97          	// todo: use stdlib '#include <stdlib.h> '
     98          	int len = strlen(string);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       strlen
   \   0000000A   0x0005             MOVS     R5,R0
     99          	if (len == 0) {
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD101             BNE.N    ??atoi_0
    100          		return -ERROR_CODE;
   \   00000010   0x....             LDR.N    R0,??DataTable4_2  ;; 0xed731bd0
   \   00000012   0xE01C             B.N      ??atoi_1
    101          	}
    102          	if (string[0] == '-') {
   \                     ??atoi_0:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x282D             CMP      R0,#+45
   \   00000018   0xD104             BNE.N    ??atoi_2
    103          		return -atoi(string + 1);
   \   0000001A   0x1C60             ADDS     R0,R4,#+1
   \   0000001C   0xF7FF 0xFFF0      BL       atoi
   \   00000020   0x4240             RSBS     R0,R0,#+0
   \   00000022   0xE014             B.N      ??atoi_1
    104          	}
    105          	int result = 0;
   \                     ??atoi_2:
   \   00000024   0x2000             MOVS     R0,#+0
    106          
    107          	for (int i = 0; i < len; i++) {
   \   00000026   0x2100             MOVS     R1,#+0
   \                     ??atoi_3:
   \   00000028   0x42A9             CMP      R1,R5
   \   0000002A   0xDA10             BGE.N    ??atoi_4
    108          		char ch = string[i];
   \   0000002C   0x5D0A             LDRB     R2,[R1, R4]
    109          		if (ch < '0' || ch > '9') {
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0x2A30             CMP      R2,#+48
   \   00000032   0xDB02             BLT.N    ??atoi_5
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x2A3A             CMP      R2,#+58
   \   00000038   0xDB01             BLT.N    ??atoi_6
    110          			return ERROR_CODE;
   \                     ??atoi_5:
   \   0000003A   0x....             LDR.N    R0,??DataTable4_3  ;; 0x128ce430
   \   0000003C   0xE007             B.N      ??atoi_1
    111          		}
    112          		int c = ch - '0';
   \                     ??atoi_6:
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0xF1B2 0x0330      SUBS     R3,R2,#+48
    113          		result = result * 10 + c;
   \   00000044   0x260A             MOVS     R6,#+10
   \   00000046   0xFB06 0x3000      MLA      R0,R6,R0,R3
    114          	}
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0xE7EC             B.N      ??atoi_3
    115          
    116          	return result;
   \                     ??atoi_4:
   \                     ??atoi_1:
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    117          }
    118          

   \                                 In section .bss, align 4
    119          static char todofixthismesswithcopy[100];
   \                     todofixthismesswithcopy:
   \   00000000                      DS8 100
    120          

   \                                 In section .text, align 2, keep-with-next
    121          static char *ltoa_internal(char *p, long num, unsigned radix) {
   \                     _Z13ltoa_internalPclj:
   \   00000000   0xB430             PUSH     {R4,R5}
    122          	int i;
    123          	char *q;
    124          
    125          	q = p + _MAX_FILLER;
   \   00000002   0xF200 0x050B      ADDW     R5,R0,#+11
   \   00000006   0x002C             MOVS     R4,R5
    126          	do {
    127          		i = (int) (num % radix);
   \                     ??ltoa_internal_0:
   \   00000008   0xFBB1 0xF5F2      UDIV     R5,R1,R2
   \   0000000C   0xFB02 0x1515      MLS      R5,R2,R5,R1
   \   00000010   0x002B             MOVS     R3,R5
    128          		i += '0';
   \   00000012   0x3330             ADDS     R3,R3,#+48
    129          		if (i > '9')
   \   00000014   0x2B3A             CMP      R3,#+58
   \   00000016   0xDB00             BLT.N    ??ltoa_internal_1
    130          			i += 'A' - '0' - 10;
   \   00000018   0x1DDB             ADDS     R3,R3,#+7
    131          		*--q = i;
   \                     ??ltoa_internal_1:
   \   0000001A   0x1E64             SUBS     R4,R4,#+1
   \   0000001C   0x7023             STRB     R3,[R4, #+0]
    132          	} while ((num /= radix) != 0);
   \   0000001E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD1F0             BNE.N    ??ltoa_internal_0
    133          
    134          	i = (int) (p + _MAX_FILLER - q);
   \   00000026   0xF110 0x050B      ADDS     R5,R0,#+11
   \   0000002A   0x1B2D             SUBS     R5,R5,R4
   \   0000002C   0x002B             MOVS     R3,R5
    135          	do {
    136          		*p++ = *q++;
   \                     ??ltoa_internal_2:
   \   0000002E   0x7825             LDRB     R5,[R4, #+0]
   \   00000030   0x7005             STRB     R5,[R0, #+0]
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \   00000034   0x1C40             ADDS     R0,R0,#+1
    137          	} while (--i);
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD1F8             BNE.N    ??ltoa_internal_2
    138          
    139          	return p;
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    140          }
    141          

   \                                 In section .text, align 2, keep-with-next
    142          static char* itoa_signed(char *p, int num, unsigned radix) {
   \                     _Z11itoa_signedPcij:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    143          	if (num < 0) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD50A             BPL.N    ??itoa_signed_0
    144          		*p++ = '-';
   \   0000000C   0x202D             MOVS     R0,#+45
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
   \   00000010   0x1C64             ADDS     R4,R4,#+1
    145          		char *end = ltoa_internal(p, -num, radix);
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x4269             RSBS     R1,R5,#+0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _Z13ltoa_internalPclj
    146          		*end = 0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    147          		return end;
   \   00000020   0xE006             B.N      ??itoa_signed_1
    148          	}
    149          	char *end = ltoa_internal(p, num, radix);
   \                     ??itoa_signed_0:
   \   00000022   0x0032             MOVS     R2,R6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       _Z13ltoa_internalPclj
    150          	*end = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    151          	return end;
   \                     ??itoa_signed_1:
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    152          }
    153          
    154          /**
    155           * Integer to string
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          char* itoa10(char *p, int num) {
   \                     itoa10:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    158          // todo: unit test
    159          	return itoa_signed(p, num, 10);
   \   00000006   0x220A             MOVS     R2,#+10
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _Z11itoa_signedPcij
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    160          }
    161          
    162          #define EPS 0.0001
    163          

   \                                 In section .text, align 4, keep-with-next
    164          bool isSameF(float v1, float v2) {
   \                     isSameF:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   0000000A   0xEEB0 0x8A60      VMOV.F32 S16,S1
    165          	return absF(v1 - v2) < EPS;
   \   0000000E   0xEE38 0x0AC8      VSUB.F32 S0,S17,S16
   \   00000012   0x.... 0x....      BL       absF
   \   00000016   0xEDDF 0x....      VLDR.W   S1,??DataTable4  ;; 0x38d1b718
   \   0000001A   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   0000001E   0xEEF1 0xFA10      FMSTAT   
   \   00000022   0xD501             BPL.N    ??isSameF_0
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B.N      ??isSameF_1
   \                     ??isSameF_0:
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??isSameF_1:
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xECBD 0x8B02      VPOP     {D8}
   \   00000030   0xBD02             POP      {R1,PC}          ;; return
    166          }
    167          

   \                                 In section .text, align 2, keep-with-next
    168          int efiPow10(int param) {
   \                     efiPow10:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    169          	switch (param) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00C             BEQ.N    ??efiPow10_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD00E             BEQ.N    ??efiPow10_1
   \   0000000C   0xD30B             BCC.N    ??efiPow10_2
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD010             BEQ.N    ??efiPow10_3
   \   00000012   0xD30C             BCC.N    ??efiPow10_4
   \   00000014   0x2C06             CMP      R4,#+6
   \   00000016   0xD012             BEQ.N    ??efiPow10_5
   \   00000018   0xD30F             BCC.N    ??efiPow10_6
   \   0000001A   0x2C08             CMP      R4,#+8
   \   0000001C   0xD013             BEQ.N    ??efiPow10_7
   \   0000001E   0xD310             BCC.N    ??efiPow10_8
   \   00000020   0xE013             B.N      ??efiPow10_9
    170          	case 0:
    171          		return 1;
   \                     ??efiPow10_0:
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE016             B.N      ??efiPow10_10
    172          	case 1:
    173          		return 10;
   \                     ??efiPow10_2:
   \   00000026   0x200A             MOVS     R0,#+10
   \   00000028   0xE014             B.N      ??efiPow10_10
    174          	case 2:
    175          		return 100;
   \                     ??efiPow10_1:
   \   0000002A   0x2064             MOVS     R0,#+100
   \   0000002C   0xE012             B.N      ??efiPow10_10
    176          	case 3:
    177          		return 1000;
   \                     ??efiPow10_4:
   \   0000002E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000032   0xE00F             B.N      ??efiPow10_10
    178          	case 4:
    179          		return 10000;
   \                     ??efiPow10_3:
   \   00000034   0xF242 0x7010      MOVW     R0,#+10000
   \   00000038   0xE00C             B.N      ??efiPow10_10
    180          	case 5:
    181          		return 100000;
   \                     ??efiPow10_6:
   \   0000003A   0x....             LDR.N    R0,??DataTable4_4  ;; 0x186a0
   \   0000003C   0xE00A             B.N      ??efiPow10_10
    182          	case 6:
    183          		return 1000000;
   \                     ??efiPow10_5:
   \   0000003E   0x....             LDR.N    R0,??DataTable4_5  ;; 0xf4240
   \   00000040   0xE008             B.N      ??efiPow10_10
    184          	case 7:
    185          		return 10000000;
   \                     ??efiPow10_8:
   \   00000042   0x....             LDR.N    R0,??DataTable4_6  ;; 0x989680
   \   00000044   0xE006             B.N      ??efiPow10_10
    186          	case 8:
    187          		return 100000000;
   \                     ??efiPow10_7:
   \   00000046   0x....             LDR.N    R0,??DataTable4_7  ;; 0x5f5e100
   \   00000048   0xE004             B.N      ??efiPow10_10
    188          	}
    189          	return 10 * efiPow10(10 - 1);
   \                     ??efiPow10_9:
   \   0000004A   0x2009             MOVS     R0,#+9
   \   0000004C   0xF7FF 0xFFD8      BL       efiPow10
   \   00000050   0x210A             MOVS     R1,#+10
   \   00000052   0x4348             MULS     R0,R1,R0
   \                     ??efiPow10_10:
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    190          }
    191          
    192          /**
    193           * string to float
    194           * @return NAN in case of invalid string
    195           * todo: explicit value for error code?
    196           */

   \                                 In section .text, align 4, keep-with-next
    197          float atoff(const char *param) {
   \                     atoff:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x4681             MOV      R9,R0
    198          	uint32_t totallen = strlen(param);
   \   0000000A   0x4648             MOV      R0,R9
   \   0000000C   0x.... 0x....      BL       strlen
   \   00000010   0x4680             MOV      R8,R0
    199          	if (totallen > sizeof(todofixthismesswithcopy) - 1)
   \   00000012   0xF1B8 0x0F64      CMP      R8,#+100
   \   00000016   0xD302             BCC.N    ??atoff_0
    200          		return (float) NAN;
   \   00000018   0xED9F 0x....      VLDR.W   S0,??DataTable4_1  ;; 0x7fffffff
   \   0000001C   0xE05F             B.N      ??atoff_1
    201          	strcpy(todofixthismesswithcopy, param);
   \                     ??atoff_0:
   \   0000001E   0x4649             MOV      R1,R9
   \   00000020   0x....             LDR.N    R0,??DataTable4_8
   \   00000022   0x.... 0x....      BL       strcpy
    202          	char *string = todofixthismesswithcopy;
   \   00000026   0x....             LDR.N    R5,??DataTable4_8
    203          
    204          	// todo: is there a standard function?
    205          	// todo: create a unit test
    206          	int dotIndex = indexOf(string, '.');
   \   00000028   0x212E             MOVS     R1,#+46
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       indexOf
   \   00000030   0x0004             MOVS     R4,R0
    207          	if (dotIndex == -1) {
   \   00000032   0xF114 0x0F01      CMN      R4,#+1
   \   00000036   0xD111             BNE.N    ??atoff_2
    208          		// just an integer
    209          		int result = atoi(string);
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       atoi
   \   0000003E   0xEE08 0x0A10      VMOV     S16,R0
    210          		if (absI(result) == ERROR_CODE)
   \   00000042   0xEE18 0x0A10      VMOV     R0,S16
   \   00000046   0x.... 0x....      BL       absI
   \   0000004A   0x....             LDR.N    R1,??DataTable4_3  ;; 0x128ce430
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD102             BNE.N    ??atoff_3
    211          			return (float) NAN;
   \   00000050   0xED9F 0x....      VLDR.W   S0,??DataTable4_1  ;; 0x7fffffff
   \   00000054   0xE043             B.N      ??atoff_1
    212          		return (float) result;
   \                     ??atoff_3:
   \   00000056   0xEEB8 0x0AC8      VCVT.F32.S32 S0,S16
   \   0000005A   0xE040             B.N      ??atoff_1
    213          	}
    214          	// todo: this needs to be fixed
    215          	string[dotIndex] = 0;
   \                     ??atoff_2:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x5560             STRB     R0,[R4, R5]
    216          	int integerPart = atoi(string);
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0x.... 0x....      BL       atoi
   \   00000066   0xEE08 0x0A10      VMOV     S16,R0
    217          	if (absI(integerPart) == ERROR_CODE)
   \   0000006A   0xEE18 0x0A10      VMOV     R0,S16
   \   0000006E   0x.... 0x....      BL       absI
   \   00000072   0x....             LDR.N    R1,??DataTable4_3  ;; 0x128ce430
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD102             BNE.N    ??atoff_4
    218          		return (float) NAN;
   \   00000078   0xED9F 0x....      VLDR.W   S0,??DataTable4_1  ;; 0x7fffffff
   \   0000007C   0xE02F             B.N      ??atoff_1
    219          	string += (dotIndex + 1);
   \                     ??atoff_4:
   \   0000007E   0x1960             ADDS     R0,R4,R5
   \   00000080   0x1C45             ADDS     R5,R0,#+1
    220          	int decimalLen = strlen(string);
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       strlen
   \   00000088   0x0006             MOVS     R6,R0
    221          	int decimal = atoi(string);
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0x.... 0x....      BL       atoi
   \   00000090   0xEE08 0x0A90      VMOV     S17,R0
    222          	if (absI(decimal) == ERROR_CODE)
   \   00000094   0xEE18 0x0A90      VMOV     R0,S17
   \   00000098   0x.... 0x....      BL       absI
   \   0000009C   0x....             LDR.N    R1,??DataTable4_3  ;; 0x128ce430
   \   0000009E   0x4288             CMP      R0,R1
   \   000000A0   0xD102             BNE.N    ??atoff_5
    223          		return (float) NAN;
   \   000000A2   0xED9F 0x....      VLDR.W   S0,??DataTable4_1  ;; 0x7fffffff
   \   000000A6   0xE01A             B.N      ??atoff_1
    224          	float divider = 1.0;
   \                     ??atoff_5:
   \   000000A8   0xEEB7 0x0A00      VMOV.F32 S0,#1.0
    225          	// todo: reuse 'pow10' function which we have anyway
    226          	for (int i = 0; i < decimalLen; i++) {
   \   000000AC   0x2700             MOVS     R7,#+0
   \                     ??atoff_6:
   \   000000AE   0x42B7             CMP      R7,R6
   \   000000B0   0xDA0D             BGE.N    ??atoff_7
    227          		divider = divider * 10.0;
   \   000000B2   0xEE10 0x0A10      VMOV     R0,S0
   \   000000B6   0x.... 0x....      BL       __aeabi_f2d
   \   000000BA   0x2200             MOVS     R2,#+0
   \   000000BC   0x....             LDR.N    R3,??DataTable4_9  ;; 0x40240000
   \   000000BE   0x.... 0x....      BL       __aeabi_dmul
   \   000000C2   0x.... 0x....      BL       __aeabi_d2f
   \   000000C6   0xEE00 0x0A10      VMOV     S0,R0
    228          	}
   \   000000CA   0x1C7F             ADDS     R7,R7,#+1
   \   000000CC   0xE7EF             B.N      ??atoff_6
    229          	return integerPart + decimal / divider;
   \                     ??atoff_7:
   \   000000CE   0xEEF8 0x0AC8      VCVT.F32.S32 S1,S16
   \   000000D2   0xEEB8 0x1AE8      VCVT.F32.S32 S2,S17
   \   000000D6   0xEE81 0x0A00      VDIV.F32 S0,S2,S0
   \   000000DA   0xEE30 0x0A80      VADD.F32 S0,S1,S0
   \                     ??atoff_1:
   \   000000DE   0xECBD 0x8B02      VPOP     {D8}
   \   000000E2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    230          }
    231          
    232          #define TO_LOWER(x) (((x)>='A' && (x)<='Z') ? (x) - 'A' + 'a' : (x))
    233          

   \                                 In section .text, align 2, keep-with-next
    234          bool strEqualCaseInsensitive(const char *str1, const char *str2) {
   \                     strEqualCaseInsensitive:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    235          	int len1 = strlen(str1);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0006             MOVS     R6,R0
    236          	int len2 = strlen(str2);
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       strlen
   \   00000014   0x0001             MOVS     R1,R0
    237          	if (len1 != len2) {
   \   00000016   0x428E             CMP      R6,R1
   \   00000018   0xD001             BEQ.N    ??strEqualCaseInsensitive_0
    238          		return false;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE01D             B.N      ??strEqualCaseInsensitive_1
    239          	}
    240          	for (int i = 0; i < len1; i++)
   \                     ??strEqualCaseInsensitive_0:
   \   0000001E   0x2200             MOVS     R2,#+0
   \                     ??strEqualCaseInsensitive_2:
   \   00000020   0x42B2             CMP      R2,R6
   \   00000022   0xDA19             BGE.N    ??strEqualCaseInsensitive_3
    241          		if (TO_LOWER(str1[i]) != TO_LOWER(str2[i]))
   \   00000024   0x5D10             LDRB     R0,[R2, R4]
   \   00000026   0x2841             CMP      R0,#+65
   \   00000028   0xDB05             BLT.N    ??strEqualCaseInsensitive_4
   \   0000002A   0x5D10             LDRB     R0,[R2, R4]
   \   0000002C   0x285B             CMP      R0,#+91
   \   0000002E   0xDA02             BGE.N    ??strEqualCaseInsensitive_4
   \   00000030   0x5D10             LDRB     R0,[R2, R4]
   \   00000032   0x3020             ADDS     R0,R0,#+32
   \   00000034   0xE000             B.N      ??strEqualCaseInsensitive_5
   \                     ??strEqualCaseInsensitive_4:
   \   00000036   0x5D10             LDRB     R0,[R2, R4]
   \                     ??strEqualCaseInsensitive_5:
   \   00000038   0x5D53             LDRB     R3,[R2, R5]
   \   0000003A   0x2B41             CMP      R3,#+65
   \   0000003C   0xDB05             BLT.N    ??strEqualCaseInsensitive_6
   \   0000003E   0x5D53             LDRB     R3,[R2, R5]
   \   00000040   0x2B5B             CMP      R3,#+91
   \   00000042   0xDA02             BGE.N    ??strEqualCaseInsensitive_6
   \   00000044   0x5D53             LDRB     R3,[R2, R5]
   \   00000046   0x3320             ADDS     R3,R3,#+32
   \   00000048   0xE000             B.N      ??strEqualCaseInsensitive_7
   \                     ??strEqualCaseInsensitive_6:
   \   0000004A   0x5D53             LDRB     R3,[R2, R5]
   \                     ??strEqualCaseInsensitive_7:
   \   0000004C   0x4298             CMP      R0,R3
   \   0000004E   0xD001             BEQ.N    ??strEqualCaseInsensitive_8
    242          			return false;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE002             B.N      ??strEqualCaseInsensitive_1
   \                     ??strEqualCaseInsensitive_8:
   \   00000054   0x1C52             ADDS     R2,R2,#+1
   \   00000056   0xE7E3             B.N      ??strEqualCaseInsensitive_2
    243          	return true;
   \                     ??strEqualCaseInsensitive_3:
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??strEqualCaseInsensitive_1:
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
    244          }
    245          

   \                                 In section .text, align 2, keep-with-next
    246          bool strEqual(const char *str1, const char *str2) {
   \                     strEqual:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    247          	// todo: there must be a standard function?!
    248          	int len1 = strlen(str1);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0006             MOVS     R6,R0
    249          	int len2 = strlen(str2);
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x.... 0x....      BL       strlen
   \   00000014   0x0001             MOVS     R1,R0
    250          	if (len1 != len2) {
   \   00000016   0x428E             CMP      R6,R1
   \   00000018   0xD001             BEQ.N    ??strEqual_0
    251          		return false;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE00B             B.N      ??strEqual_1
    252          	}
    253          	for (int i = 0; i < len1; i++)
   \                     ??strEqual_0:
   \   0000001E   0x2200             MOVS     R2,#+0
   \                     ??strEqual_2:
   \   00000020   0x42B2             CMP      R2,R6
   \   00000022   0xDA07             BGE.N    ??strEqual_3
    254          		if (str1[i] != str2[i])
   \   00000024   0x5D10             LDRB     R0,[R2, R4]
   \   00000026   0x5D53             LDRB     R3,[R2, R5]
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xD001             BEQ.N    ??strEqual_4
    255          			return false;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE002             B.N      ??strEqual_1
   \                     ??strEqual_4:
   \   00000030   0x1C52             ADDS     R2,R2,#+1
   \   00000032   0xE7F5             B.N      ??strEqual_2
    256          	return true;
   \                     ??strEqual_3:
   \   00000034   0x2001             MOVS     R0,#+1
   \                     ??strEqual_1:
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    257          }
    258          
    259          /**
    260           * @brief This function knows how to print a histogram_s summary
    261           */

   \                                 In section .text, align 2, keep-with-next
    262          void printHistogram(Logging *logging, histogram_s *histogram) {
    263          #if EFI_HISTOGRAMS && ! EFI_UNIT_TEST
    264          	int report[5];
    265          	int len = hsReport(histogram, report);
    266          
    267          	resetLogging(logging);
    268          	appendMsgPrefix(logging);
    269          	appendPrintf(logging, "histogram %s *", histogram->name);
    270          	for (int i = 0; i < len; i++)
    271          	appendPrintf(logging, "%d ", report[i]);
    272          	appendPrintf(logging, "*");
    273          	appendMsgPostfix(logging);
    274          	scheduleLogging(logging);
    275          #else
    276          	UNUSED(logging);
    277          	UNUSED(histogram);
    278          	
    279          #endif /* EFI_HISTOGRAMS */
    280          }
   \                     _Z14printHistogramP7LoggingP11histogram_s:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x59 0x65          DC8      "Yes"
   \              0x73 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x4E 0x6F          DC8      0x4E, 0x6F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x38D1B718         DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xED731BD0         DC32     0xed731bd0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x128CE430         DC32     0x128ce430

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x00989680         DC32     0x989680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     todofixthismesswithcopy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40240000         DC32     0x40240000

   \                                 In section .rodata, align 4
   \   00000000   0x59 0x65          DC8 "Yes"
   \              0x73 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x4E 0x6F          DC8 "No"
   \              0x00         
   \   00000003   0x00               DC8 0
    281          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   absF
       0   absI
      40   atoff
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> absI
        40   -> atoi
        40   -> indexOf
        40   -> strcpy
        40   -> strlen
      16   atoi
        16   -> atoi
        16   -> strlen
       0   boolToString(bool)
       8   efiPow10
         8   -> efiPow10
       0   efiRound
       0   efiStrlen
       8   efiTrim
         8   -> efiStrlen
      16   indexOf
        16   -> efiStrlen
      16   isSameF
        16   -> absF
      16   itoa10
        16   -> itoa_signed(char *, int, unsigned int)
      16   itoa_signed(char *, int, unsigned int)
        16   -> ltoa_internal(char *, long, unsigned int)
       8   ltoa_internal(char *, long, unsigned int)
       0   maxF
       0   maxI
       0   minF
       0   minI
       0   printHistogram(Logging *, histogram_s *)
      16   startsWith
        16   -> efiStrlen
      16   strEqual
        16   -> strlen
      16   strEqualCaseInsensitive
        16   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "No">
       4  ?<Constant "Yes">
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      16  absF
       8  absI
     230  atoff
      80  atoi
      14  boolToString(bool)
      86  efiPow10
      22  efiRound
      16  efiStrlen
      52  efiTrim
      38  indexOf
      50  isSameF
      18  itoa10
      50  itoa_signed(char *, int, unsigned int)
      64  ltoa_internal(char *, long, unsigned int)
      16  maxF
       8  maxI
      16  minF
       8  minI
       2  printHistogram(Logging *, histogram_s *)
      54  startsWith
      56  strEqual
      92  strEqualCaseInsensitive
     100  todofixthismesswithcopy

 
   100 bytes in section .bss
     8 bytes in section .rodata
 1 044 bytes in section .text
 
 1 044 bytes of CODE  memory
     8 bytes of CONST memory
   100 bytes of DATA  memory

Errors: none
Warnings: none
