###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:59 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\trig #
#                       ger\rpm_calculator.cpp                                #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\trig #
#                       ger\rpm_calculator.cpp -lCN                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\r #
#                       pm_calculator.lst                                     #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\rp #
#                       m_calculator.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\trigger\rpm_calculator.cpp
      1          /**
      2           * @file    rpm_calculator.cpp
      3           * @brief   RPM calculator
      4           *
      5           * Here we listen to position sensor events in order to figure our if engine is currently running or not.
      6           * Actual getRpm() is calculated once per crankshaft revolution, based on the amount of time passed
      7           * since the start of previous shaft revolution.
      8           *
      9           * @date Jan 1, 2013
     10           * @author Andrey Belomutskiy, (c) 2012-2015
     11           */
     12          
     13          #include "main.h"
     14          #include "rpm_calculator.h"
     15          
     16          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
     17          
     18          #include "trigger_central.h"
     19          #include "engine_configuration.h"
     20          #include "engine_math.h"
     21          
     22          #if EFI_PROD_CODE
     23          #include "rfiutil.h"
     24          #include "engine.h"
     25          #endif
     26          
     27          #if ! EFI_UNIT_TEST
     28          #include <sensor_chart.h>
     29          #endif
     30          
     31          #include "efilib2.h"
     32          
     33          #if EFI_WAVE_CHART
     34          #include "wave_chart.h"
     35          extern WaveChart waveChart;
     36          #endif /* EFI_WAVE_CHART */
     37          
     38          EXTERN_ENGINE
     39          ;
     40          

   \                                 In section .bss, align 8
     41          efitime_t notRunnintNow;
   \                     notRunnintNow:
   \   00000000                      DS8 8

   \                                 In section .bss, align 8
     42          efitime_t notRunningPrev;
   \                     notRunningPrev:
   \   00000000                      DS8 8
     43          

   \                                 In section .bss, align 4
     44          static Logging * logger;
   \                     logger:
   \   00000000                      DS8 4
     45          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp RpmCalculator::subobject RpmCalculator()
   \                     _ZN13RpmCalculatorC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13RpmCalculatorC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     46          RpmCalculator::RpmCalculator() {
   \                     _ZN13RpmCalculatorC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     47          #if !EFI_PROD_CODE
     48          	mockRpm = MOCK_UNDEFINED;
     49          #endif
     50          	rpmValue = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
     51          	setRpmValue(0);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN13RpmCalculator11setRpmValueEi
     52          
     53          	// we need this initial to have not_running at first invocation
     54          	lastRpmEventTimeNt = (efitime_t) -10 * US2NT(US_PER_SECOND_LL);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_5  ;; 0x9bdd3c00
   \   00000014   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000018   0xE9C4 0x0104      STRD     R0,R1,[R4, #+16]
     55          	revolutionCounterSinceStart = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61E0             STR      R0,[R4, #+28]
     56          	revolutionCounterSinceBoot = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x61A0             STR      R0,[R4, #+24]
     57          
     58          	lastRpmEventTimeNt = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xE9C4 0x0104      STRD     R0,R1,[R4, #+16]
     59          	oneDegreeUs = NAN;
   \   0000002C   0xF07F 0x4000      MVNS     R0,#-2147483648
   \   00000030   0x60A0             STR      R0,[R4, #+8]
     60          }
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
     61          
     62          /**
     63           * @return true if there was a full shaft revolution within the last second
     64           */

   \                                 In section .text, align 2, keep-with-next
     65          bool RpmCalculator::isRunning(DECLARE_ENGINE_PARAMETER_F) {
   \                     _ZN13RpmCalculator9isRunningEv:
   \   00000000   0xB5D0             PUSH     {R4,R6,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
     66          	efitick_t nowNt = getTimeNowNt();
   \   00000004   0x.... 0x....      BL       getTimeNowNt
   \   00000008   0x0002             MOVS     R2,R0
   \   0000000A   0x000B             MOVS     R3,R1
     67          	if (engine->stopEngineRequestTimeNt != 0) {
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xE9D0 0x670C      LDRD     R6,R7,[R0, #+48]
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD101             BNE.N    ??isRunning_0
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD011             BEQ.N    ??isRunning_1
     68          		if (nowNt
     69          				- engine->stopEngineRequestTimeNt< 3 * US2NT(US_PER_SECOND_LL)) {
   \                     ??isRunning_0:
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_6
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xE9D0 0x670C      LDRD     R6,R7,[R0, #+48]
   \   00000028   0x1B90             SUBS     R0,R2,R6
   \   0000002A   0xEB73 0x0107      SBCS     R1,R3,R7
   \   0000002E   0x.... 0x....      LDR.W    R6,??DataTable14_7  ;; 0x1e0a6e00
   \   00000032   0x2700             MOVS     R7,#+0
   \   00000034   0x42B9             CMP      R1,R7
   \   00000036   0xDC04             BGT.N    ??isRunning_1
   \   00000038   0xDB01             BLT.N    ??isRunning_2
   \   0000003A   0x42B0             CMP      R0,R6
   \   0000003C   0xD201             BCS.N    ??isRunning_1
     70          			return false;
   \                     ??isRunning_2:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE01D             B.N      ??isRunning_3
     71          		}
     72          	}
     73          	/**
     74          	 * note that the result of this subtraction could be negative, that would happen if
     75          	 * we have a trigger event between the time we've invoked 'getTimeNow' and here
     76          	 */
     77          	bool_t result = nowNt - lastRpmEventTimeNt < US2NT(US_PER_SECOND_LL);
   \                     ??isRunning_1:
   \   00000042   0xE9D4 0x0104      LDRD     R0,R1,[R4, #+16]
   \   00000046   0x1A10             SUBS     R0,R2,R0
   \   00000048   0xEB73 0x0101      SBCS     R1,R3,R1
   \   0000004C   0x.... 0x....      LDR.W    R6,??DataTable14_8  ;; 0xa037a00
   \   00000050   0x2700             MOVS     R7,#+0
   \   00000052   0x42B9             CMP      R1,R7
   \   00000054   0xDC04             BGT.N    ??isRunning_4
   \   00000056   0xDB01             BLT.N    ??isRunning_5
   \   00000058   0x42B0             CMP      R0,R6
   \   0000005A   0xD201             BCS.N    ??isRunning_4
   \                     ??isRunning_5:
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE000             B.N      ??isRunning_6
   \                     ??isRunning_4:
   \   00000060   0x2000             MOVS     R0,#+0
     78          	if (!result) {
   \                     ??isRunning_6:
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD109             BNE.N    ??isRunning_7
     79          		notRunnintNow = nowNt;
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   0000006C   0xE9C1 0x2300      STRD     R2,R3,[R1, #+0]
     80          		notRunningPrev = lastRpmEventTimeNt;
   \   00000070   0xE9D4 0x6704      LDRD     R6,R7,[R4, #+16]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \   00000078   0xE9C1 0x6700      STRD     R6,R7,[R1, #+0]
     81          	}
     82          	return result;
   \                     ??isRunning_7:
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??isRunning_3:
   \   0000007E   0xBDD0             POP      {R4,R6,R7,PC}    ;; return
     83          }
     84          

   \                                 In section .text, align 4, keep-with-next
     85          void RpmCalculator::setRpmValue(int value) {
     86          	previousRpmValue = rpmValue;
   \                     _ZN13RpmCalculator11setRpmValueEi:
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x6042             STR      R2,[R0, #+4]
     87          	rpmValue = value;
   \   00000004   0x6001             STR      R1,[R0, #+0]
     88          	if (rpmValue <= 0) {
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xDA03             BGE.N    ??setRpmValue_0
     89          		oneDegreeUs = NAN;
   \   0000000C   0xF07F 0x4200      MVNS     R2,#-2147483648
   \   00000010   0x6082             STR      R2,[R0, #+8]
   \   00000012   0xE009             B.N      ??setRpmValue_1
     90          	} else {
     91          		oneDegreeUs = getOneDegreeTimeUs(rpmValue);
   \                     ??setRpmValue_0:
   \   00000014   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000018   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001C   0xEDDF 0x....      VLDR.W   S1,??DataTable12  ;; 0x4822c2ab
   \   00000020   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   00000024   0xED80 0x0A02      VSTR     S0,[R0, #+8]
     92          	}
     93          }
   \                     ??setRpmValue_1:
   \   00000028   0x4770             BX       LR               ;; return
     94          

   \                                 In section .text, align 2, keep-with-next
     95          void RpmCalculator::onNewEngineCycle() {
     96          	revolutionCounterSinceBoot++;
   \                     _ZN13RpmCalculator16onNewEngineCycleEv:
   \   00000000   0x6981             LDR      R1,[R0, #+24]
   \   00000002   0x1C49             ADDS     R1,R1,#+1
   \   00000004   0x6181             STR      R1,[R0, #+24]
     97          	revolutionCounterSinceStart++;
   \   00000006   0x69C1             LDR      R1,[R0, #+28]
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0x61C1             STR      R1,[R0, #+28]
     98          }
   \   0000000C   0x4770             BX       LR               ;; return
     99          

   \                                 In section .text, align 2, keep-with-next
    100          uint32_t RpmCalculator::getRevolutionCounter(void) {
    101          	return revolutionCounterSinceBoot;
   \                     _ZN13RpmCalculator20getRevolutionCounterEv:
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x4770             BX       LR               ;; return
    102          }
    103          

   \                                 In section .text, align 2, keep-with-next
    104          uint32_t RpmCalculator::getRevolutionCounterSinceStart(void) {
    105          	return revolutionCounterSinceStart;
   \                     _ZN13RpmCalculator30getRevolutionCounterSinceStartEv:
   \   00000000   0x69C0             LDR      R0,[R0, #+28]
   \   00000002   0x4770             BX       LR               ;; return
    106          }
    107          

   \                                 In section .text, align 2, keep-with-next
    108          float RpmCalculator::getRpmAcceleration() {
   \                     _ZN13RpmCalculator18getRpmAccelerationEv:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    109          	return 1.0 * previousRpmValue / rpmValue;
   \   00000004   0x6870             LDR      R0,[R6, #+4]
   \   00000006   0x.... 0x....      BL       __aeabi_i2d
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable14_11  ;; 0x3ff00000
   \   00000010   0x.... 0x....      BL       __aeabi_dmul
   \   00000014   0x0004             MOVS     R4,R0
   \   00000016   0x000D             MOVS     R5,R1
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_i2d
   \   0000001E   0x0002             MOVS     R2,R0
   \   00000020   0x000B             MOVS     R3,R1
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x.... 0x....      BL       __aeabi_ddiv
   \   0000002A   0x.... 0x....      BL       __aeabi_d2f
   \   0000002E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    110          }
    111          
    112          /**
    113           * WARNING: this is a heavy method because 'getRpm()' is relatively heavy
    114           *
    115           * @return -1 in case of isNoisySignal(), current RPM otherwise
    116           */
    117          // todo: migrate to float return result or add a float version? this would have with calculations
    118          // todo: add a version which does not check time & saves time? need to profile

   \                                 In section .text, align 2, keep-with-next
    119          int RpmCalculator::rpm(DECLARE_ENGINE_PARAMETER_F) {
   \                     _ZN13RpmCalculator3rpmEv:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    120          #if !EFI_PROD_CODE
    121          	if (mockRpm != MOCK_UNDEFINED)
    122          	return mockRpm;
    123          #endif
    124          	if (!isRunning(PASS_ENGINE_PARAMETER_F)) {
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13RpmCalculator9isRunningEv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11B             BNE.N    ??rpm_0
    125          		revolutionCounterSinceStart = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x61E0             STR      R0,[R4, #+28]
    126          		if (rpmValue != 0) {
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD016             BEQ.N    ??rpm_0
    127          			rpmValue = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    128          			scheduleMsg(logger,
    129          					"templog rpm=0 since not running [%x][%x] [%x][%x]",
    130          					(int) (notRunnintNow >> 32), (int) notRunnintNow,
    131          					(int) (notRunningPrev >> 32), (int) notRunningPrev);
   \   0000001C   0x....             LDR.N    R2,??DataTable14_10
   \   0000001E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x....             LDR.N    R2,??DataTable14_10
   \   00000026   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   0000002A   0x9100             STR      R1,[SP, #+0]
   \   0000002C   0x....             LDR.N    R2,??DataTable14_9
   \   0000002E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   00000032   0x0003             MOVS     R3,R0
   \   00000034   0x....             LDR.N    R2,??DataTable14_9
   \   00000036   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   0000003A   0x000A             MOVS     R2,R1
   \   0000003C   0x....             LDR.N    R1,??DataTable14_12
   \   0000003E   0x....             LDR.N    R0,??DataTable14_13
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x.... 0x....      BL       scheduleMsg
    132          		}
    133          	}
    134          	return rpmValue;
   \                     ??rpm_0:
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    135          }
    136          
    137          #if (EFI_PROD_CODE || EFI_SIMULATOR) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    138          bool isCrankingE(Engine *engine) {
   \                     _Z11isCrankingEP6Engine:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    139          	int rpm = getRpmE(engine);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
    140          	return isCrankingR(rpm);
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xDB06             BLT.N    ??isCrankingE_0
   \   0000000E   0x....             LDR.N    R1,??DataTable14_14
   \   00000010   0xF9B1 0x1068      LDRSH    R1,[R1, #+104]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xDA01             BGE.N    ??isCrankingE_0
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B.N      ??isCrankingE_1
   \                     ??isCrankingE_0:
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??isCrankingE_1:
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    141          }
    142          
    143          /**
    144           * WARNING: this is a heavy method because 'getRpm()' is relatively heavy
    145           */

   \                                 In section .text, align 2, keep-with-next
    146          bool isCranking(void) {
   \                     _Z10isCrankingv:
   \   00000000   0xB580             PUSH     {R7,LR}
    147          	return isCrankingE(engine);
   \   00000002   0x....             LDR.N    R0,??DataTable14_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       _Z11isCrankingEP6Engine
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    148          }
    149          #endif
    150          
    151          /**
    152           * @brief Shaft position callback used by RPM calculation logic.
    153           *
    154           * This callback should always be the first of trigger callbacks because other callbacks depend of values
    155           * updated here.
    156           * This callback is invoked on interrupt thread.
    157           */

   \                                 In section .text, align 2, keep-with-next
    158          void rpmShaftPositionCallback(trigger_event_e ckpSignalType,
    159          		uint32_t index DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z24rpmShaftPositionCallback15trigger_event_ej:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4683             MOV      R11,R0
   \   00000008   0x468A             MOV      R10,R1
    160          	RpmCalculator *rpmState = &engine->rpmCalculator;
   \   0000000A   0x....             LDR.N    R0,??DataTable14_6
   \   0000000C   0x6806             LDR      R6,[R0, #+0]
    161          	efitick_t nowNt = getTimeNowNt();
   \   0000000E   0x.... 0x....      BL       getTimeNowNt
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x000D             MOVS     R5,R1
    162          	engine->m.beforeRpmCb = GET_TIMESTAMP();
   \   00000016   0xF242 0x4008      MOVW     R0,#+9224
   \   0000001A   0x....             LDR.N    R1,??DataTable14_6
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x....             LDR.N    R2,??DataTable14_15  ;; 0xe0001004
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x5042             STR      R2,[R0, R1]
    163          #if EFI_PROD_CODE
    164          	efiAssertVoid(getRemainingStack(chThdSelf()) > 256, "lowstck#2z");
   \   00000024   0x....             LDR.N    R0,??DataTable14_16
   \   00000026   0x6980             LDR      R0,[R0, #+24]
   \   00000028   0x.... 0x....      BL       getRemainingStack
   \   0000002C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000030   0xDC03             BGT.N    ??rpmShaftPositionCallback_0
   \   00000032   0x....             LDR.N    R0,??DataTable14_17
   \   00000034   0x.... 0x....      BL       firmwareError
   \   00000038   0xE077             B.N      ??rpmShaftPositionCallback_1
    165          #endif
    166          
    167          	if (index != 0) {
   \                     ??rpmShaftPositionCallback_0:
   \   0000003A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003E   0xD016             BEQ.N    ??rpmShaftPositionCallback_2
    168          #if EFI_ANALOG_CHART || defined(__DOXYGEN__)
    169          		if (boardConfiguration->sensorChartMode == SC_TRIGGER)
   \   00000040   0x....             LDR.N    R0,??DataTable14_18
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF8D0 0x0310      LDR      R0,[R0, #+784]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD10F             BNE.N    ??rpmShaftPositionCallback_3
    170          			scAddData(getCrankshaftAngleNt(nowNt PASS_ENGINE_PARAMETER),
    171          					1000 * ckpSignalType + index);
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x.... 0x....      BL       _Z20getCrankshaftAngleNtx
   \   00000054   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000058   0xF44F 0x707A      MOV      R0,#+1000
   \   0000005C   0xFB00 0xA00B      MLA      R0,R0,R11,R10
   \   00000060   0xEE00 0x0A90      VMOV     S1,R0
   \   00000064   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   00000068   0x.... 0x....      BL       _Z9scAddDataff
    172          #endif
    173          		return;
   \                     ??rpmShaftPositionCallback_3:
   \   0000006C   0xE05D             B.N      ??rpmShaftPositionCallback_1
    174          	}
    175          
    176          	bool hadRpmRecently = rpmState->isRunning(PASS_ENGINE_PARAMETER_F);
   \                     ??rpmShaftPositionCallback_2:
   \   0000006E   0x0030             MOVS     R0,R6
   \   00000070   0x.... 0x....      BL       _ZN13RpmCalculator9isRunningEv
   \   00000074   0x0007             MOVS     R7,R0
    177          
    178          	if (hadRpmRecently) {
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD034             BEQ.N    ??rpmShaftPositionCallback_4
    179          		efitime_t diffNt = nowNt - rpmState->lastRpmEventTimeNt;
   \   0000007C   0xE9D6 0x0104      LDRD     R0,R1,[R6, #+16]
   \   00000080   0x1A20             SUBS     R0,R4,R0
   \   00000082   0xEB75 0x0101      SBCS     R1,R5,R1
   \   00000086   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
    180          		/**
    181          		 * Four stroke cycle is two crankshaft revolutions
    182          		 *
    183          		 * We always do '* 2' because the event signal is already adjusted to 'per engine cycle'
    184          		 * and each revolution of crankshaft consists of two engine cycles revolutions
    185          		 *
    186          		 */
    187          		if (diffNt == 0) {
   \   0000008A   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD107             BNE.N    ??rpmShaftPositionCallback_5
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD105             BNE.N    ??rpmShaftPositionCallback_5
    188          			rpmState->setRpmValue(NOISY_RPM);
   \   00000096   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000009A   0x0030             MOVS     R0,R6
   \   0000009C   0x.... 0x....      BL       _ZN13RpmCalculator11setRpmValueEi
   \   000000A0   0xE021             B.N      ??rpmShaftPositionCallback_4
    189          		} else {
    190          			int mult = engineConfiguration->engineCycle / 360;
   \                     ??rpmShaftPositionCallback_5:
   \   000000A2   0x....             LDR.N    R0,??DataTable14_19
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   000000AA   0xF44F 0x71B4      MOV      R1,#+360
   \   000000AE   0xFB90 0xF8F1      SDIV     R8,R0,R1
    191          			int rpm = (int) (60 * US2NT(US_PER_SECOND_LL) * mult / diffNt);
   \   000000B2   0xEA5F 0x79E8      ASRS     R9,R8,#+31
   \   000000B6   0x....             LDR.N    R2,??DataTable14_20  ;; 0x58d09800
   \   000000B8   0x2302             MOVS     R3,#+2
   \   000000BA   0xFBA2 0x0108      UMULL    R0,R1,R2,R8
   \   000000BE   0xFB02 0x1109      MLA      R1,R2,R9,R1
   \   000000C2   0xFB03 0x1108      MLA      R1,R3,R8,R1
   \   000000C6   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   000000CA   0x.... 0x....      BL       __aeabi_ldivmod
   \   000000CE   0x4681             MOV      R9,R0
    192          			rpmState->setRpmValue(rpm > UNREALISTIC_RPM ? NOISY_RPM : rpm);
   \   000000D0   0xF247 0x5031      MOVW     R0,#+30001
   \   000000D4   0x4581             CMP      R9,R0
   \   000000D6   0xDB02             BLT.N    ??rpmShaftPositionCallback_6
   \   000000D8   0xF05F 0x31FF      MOVS     R1,#-1
   \   000000DC   0xE000             B.N      ??rpmShaftPositionCallback_7
   \                     ??rpmShaftPositionCallback_6:
   \   000000DE   0x4649             MOV      R1,R9
   \                     ??rpmShaftPositionCallback_7:
   \   000000E0   0x0030             MOVS     R0,R6
   \   000000E2   0x.... 0x....      BL       _ZN13RpmCalculator11setRpmValueEi
    193          		}
    194          	}
    195          	rpmState->onNewEngineCycle();
   \                     ??rpmShaftPositionCallback_4:
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0x.... 0x....      BL       _ZN13RpmCalculator16onNewEngineCycleEv
    196          	rpmState->lastRpmEventTimeNt = nowNt;
   \   000000EC   0xE9C6 0x4504      STRD     R4,R5,[R6, #+16]
    197          #if EFI_ANALOG_CHART || defined(__DOXYGEN__)
    198          	if (boardConfiguration->sensorChartMode == SC_TRIGGER)
   \   000000F0   0x....             LDR.N    R0,??DataTable14_18
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF8D0 0x0310      LDR      R0,[R0, #+784]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD109             BNE.N    ??rpmShaftPositionCallback_8
    199          		scAddData(getCrankshaftAngleNt(nowNt PASS_ENGINE_PARAMETER), index);
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x0029             MOVS     R1,R5
   \   00000100   0x.... 0x....      BL       _Z20getCrankshaftAngleNtx
   \   00000104   0xEE00 0xAA90      VMOV     S1,R10
   \   00000108   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   0000010C   0x.... 0x....      BL       _Z9scAddDataff
    200          #endif
    201          	engine->m.rpmCbTime = GET_TIMESTAMP() - engine->m.beforeRpmCb;
   \                     ??rpmShaftPositionCallback_8:
   \   00000110   0x....             LDR.N    R0,??DataTable14_15  ;; 0xe0001004
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0xF242 0x4108      MOVW     R1,#+9224
   \   00000118   0x....             LDR.N    R2,??DataTable14_6
   \   0000011A   0x6812             LDR      R2,[R2, #+0]
   \   0000011C   0x5889             LDR      R1,[R1, R2]
   \   0000011E   0x1A40             SUBS     R0,R0,R1
   \   00000120   0xF242 0x410C      MOVW     R1,#+9228
   \   00000124   0x....             LDR.N    R2,??DataTable14_6
   \   00000126   0x6812             LDR      R2,[R2, #+0]
   \   00000128   0x5088             STR      R0,[R1, R2]
    202          }
   \                     ??rpmShaftPositionCallback_1:
   \   0000012A   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    203          

   \                                 In section .bss, align 8
    204          static scheduling_s tdcScheduler[2];
   \                     tdcScheduler:
   \   00000000                      DS8 48
    205          

   \                                 In section .bss, align 4
    206          static char rpmBuffer[10];
   \                     rpmBuffer:
   \   00000000                      DS8 12
    207          
    208          #if (EFI_PROD_CODE || EFI_SIMULATOR) || defined(__DOXYGEN__)
    209          /**
    210           * This callback has nothing to do with actual engine control, it just sends a Top Dead Center mark to the dev console
    211           * digital sniffer.
    212           */

   \                                 In section .text, align 2, keep-with-next
    213          static void onTdcCallback(void) {
   \                     _Z13onTdcCallbackv:
   \   00000000   0xB580             PUSH     {R7,LR}
    214          	itoa10(rpmBuffer, getRpm());
   \   00000002   0x....             LDR.N    R0,??DataTable14_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0x....             LDR.N    R0,??DataTable14_21
   \   0000000E   0x.... 0x....      BL       itoa10
    215          	addWaveChartEvent(TOP_DEAD_CENTER_MESSAGE, (char* ) rpmBuffer);
   \   00000012   0x....             LDR.N    R2,??DataTable14_21
   \   00000014   0x....             ADR.N    R1,??DataTable14  ;; "r"
   \   00000016   0x....             LDR.N    R0,??DataTable14_22
   \   00000018   0x.... 0x....      BL       _ZN9WaveChart18addWaveChartEvent3EPKcS1_
    216          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    217          
    218          /**
    219           * This trigger callback schedules the actual physical TDC callback in relation to trigger synchronization point.
    220           */

   \                                 In section .text, align 2, keep-with-next
    221          static void tdcMarkCallback(trigger_event_e ckpSignalType,
    222          		uint32_t index0 DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z15tdcMarkCallback15trigger_event_ej:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    223          	(void) ckpSignalType;
    224          	bool isTriggerSynchronizationPoint = index0 == 0;
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD101             BNE.N    ??tdcMarkCallback_0
   \   0000000E   0x2601             MOVS     R6,#+1
   \   00000010   0xE000             B.N      ??tdcMarkCallback_1
   \                     ??tdcMarkCallback_0:
   \   00000012   0x2600             MOVS     R6,#+0
    225          	if (isTriggerSynchronizationPoint
    226          			&& engineConfiguration->isEngineChartEnabled) {
   \                     ??tdcMarkCallback_1:
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD02F             BEQ.N    ??tdcMarkCallback_2
   \   0000001A   0x....             LDR.N    R0,??DataTable14_19
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF890 0x05D8      LDRB     R0,[R0, #+1496]
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x0940             LSRS     R0,R0,#+5
   \   00000026   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD025             BEQ.N    ??tdcMarkCallback_2
    227          		int revIndex2 = engine->rpmCalculator.getRevolutionCounter() % 2;
   \   0000002E   0x....             LDR.N    R0,??DataTable14_6
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       _ZN13RpmCalculator20getRevolutionCounterEv
   \   00000036   0xF010 0x0701      ANDS     R7,R0,#0x1
    228          		int rpm = getRpm();
   \   0000003A   0x....             LDR.N    R0,??DataTable14_6
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
   \   00000042   0x4680             MOV      R8,R0
    229          		// todo: use event-based scheduling, not just time-based scheduling
    230          		if (isValidRpm(rpm)) {
   \   00000044   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000048   0xDB17             BLT.N    ??tdcMarkCallback_2
   \   0000004A   0xF247 0x5030      MOVW     R0,#+30000
   \   0000004E   0x4580             CMP      R8,R0
   \   00000050   0xDA13             BGE.N    ??tdcMarkCallback_2
    231          			scheduleByAngle(rpm, &tdcScheduler[revIndex2], tdcPosition(),
    232          					(schfunc_t) onTdcCallback, NULL, &engine->rpmCalculator);
   \   00000052   0x....             LDR.N    R0,??DataTable14_6
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x2300             MOVS     R3,#+0
   \   0000005A   0x....             LDR.N    R2,??DataTable14_23
   \   0000005C   0x....             LDR.N    R0,??DataTable14_24
   \   0000005E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000062   0x....             LDR.N    R0,??DataTable14_14
   \   00000064   0xEDD0 0x0A75      VLDR     S1,[R0, #+468]
   \   00000068   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000006C   0x2018             MOVS     R0,#+24
   \   0000006E   0x....             LDR.N    R1,??DataTable14_4
   \   00000070   0xFB00 0x1107      MLA      R1,R0,R7,R1
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0x.... 0x....      BL       _Z15scheduleByAngleiP12scheduling_sfPFvPvES1_P13RpmCalculator
    233          		}
    234          	}
    235          }
   \                     ??tdcMarkCallback_2:
   \   0000007A   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    236          #endif
    237          
    238          #if EFI_PROD_CODE || EFI_SIMULATOR

   \                                 In section .text, align 2, keep-with-next
    239          int getRevolutionCounter() {
   \                     _Z20getRevolutionCounterv:
   \   00000000   0xB580             PUSH     {R7,LR}
    240          	return engine->rpmCalculator.getRevolutionCounter();
   \   00000002   0x....             LDR.N    R0,??DataTable14_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       _ZN13RpmCalculator20getRevolutionCounterEv
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    241          }
    242          #endif
    243          
    244          /**
    245           * @return Current crankshaft angle, 0 to 720 for four-stroke
    246           */

   \                                 In section .text, align 4, keep-with-next
    247          float getCrankshaftAngleNt(efitime_t timeNt DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z20getCrankshaftAngleNtx:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
    248          	efitime_t timeSinceZeroAngleNt = timeNt
    249          			- engine->rpmCalculator.lastRpmEventTimeNt;
   \   00000008   0x....             LDR.N    R0,??DataTable14_6
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xE9D0 0x2304      LDRD     R2,R3,[R0, #+16]
   \   00000010   0x1AB4             SUBS     R4,R6,R2
   \   00000012   0xEB77 0x0503      SBCS     R5,R7,R3
    250          
    251          	/**
    252          	 * even if we use 'getOneDegreeTimeUs' macros here, it looks like the
    253          	 * compiler is not smart enough to figure out that "A / ( B / C)" could be optimized into
    254          	 * "A * C / B" in order to replace a slower division with a faster multiplication.
    255          	 */
    256          	int rpm = engine->rpmCalculator.rpm(PASS_ENGINE_PARAMETER_F);
   \   00000016   0x....             LDR.N    R0,??DataTable14_6
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
   \   0000001E   0x4680             MOV      R8,R0
    257          	return rpm == 0 ? NAN : timeSinceZeroAngleNt / getOneDegreeTimeNt(rpm);
   \   00000020   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000024   0xD102             BNE.N    ??getCrankshaftAngleNt_0
   \   00000026   0xED9F 0x....      VLDR.W   S0,??DataTable14_1  ;; 0x7fffffff
   \   0000002A   0xE00F             B.N      ??getCrankshaftAngleNt_1
   \                     ??getCrankshaftAngleNt_0:
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0x.... 0x....      BL       __aeabi_l2f
   \   00000034   0xEE00 0x0A10      VMOV     S0,R0
   \   00000038   0xEE00 0x8A90      VMOV     S1,R8
   \   0000003C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000040   0xED9F 0x....      VLDR.W   S2,??DataTable14_2  ;; 0x4bd59f80
   \   00000044   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \   00000048   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \                     ??getCrankshaftAngleNt_1:
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    258          }
    259          

   \                                 In section .text, align 2, keep-with-next
    260          void initRpmCalculator(Logging *sharedLogger, Engine *engine) {
   \                     _Z17initRpmCalculatorP7LoggingP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    261          	logger = sharedLogger;
   \   00000006   0x....             LDR.N    R0,??DataTable14_13
   \   00000008   0x6004             STR      R4,[R0, #+0]
    262          #if (EFI_PROD_CODE || EFI_SIMULATOR) || defined(__DOXYGEN__)
    263          
    264          //	tdcScheduler[0].name = "tdc0";
    265          //	tdcScheduler[1].name = "tdc1";
    266          	addTriggerEventListener(tdcMarkCallback, "chart TDC mark", engine);
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x....             LDR.N    R1,??DataTable14_25
   \   0000000E   0x....             LDR.N    R0,??DataTable14_26
   \   00000010   0x.... 0x....      BL       _Z23addTriggerEventListenerPFv15trigger_event_ejEPKcP6Engine
    267          #endif
    268          
    269          	addTriggerEventListener(rpmShaftPositionCallback, "rpm reporter", engine);
   \   00000014   0x002A             MOVS     R2,R5
   \   00000016   0x....             LDR.N    R1,??DataTable14_27
   \   00000018   0x....             LDR.N    R0,??DataTable14_28
   \   0000001A   0x.... 0x....      BL       _Z23addTriggerEventListenerPFv15trigger_event_ejEPKcP6Engine
    270          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    271          
    272          #if (EFI_PROD_CODE || EFI_SIMULATOR) || defined(__DOXYGEN__)
    273          /**
    274           * Schedules a callback 'angle' degree of crankshaft from now.
    275           * The callback would be executed once after the duration of time which
    276           * it takes the crankshaft to rotate to the specified angle.
    277           */

   \                                 In section .text, align 2, keep-with-next
    278          void scheduleByAngle(int rpm, scheduling_s *timer, angle_t angle,
    279          		schfunc_t callback, void *param, RpmCalculator *calc) {
   \                     _Z15scheduleByAngleiP12scheduling_sfPFvPvES1_P13RpmCalculator:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000D             MOVS     R5,R1
   \   0000000E   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000012   0x0016             MOVS     R6,R2
   \   00000014   0x001F             MOVS     R7,R3
   \   00000016   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    280          	efiAssertVoid(isValidRpm(rpm), "RPM check expected");
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xDB03             BLT.N    ??scheduleByAngle_0
   \   0000001E   0xF247 0x5030      MOVW     R0,#+30000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xDB03             BLT.N    ??scheduleByAngle_1
   \                     ??scheduleByAngle_0:
   \   00000026   0x....             LDR.N    R0,??DataTable14_29
   \   00000028   0x.... 0x....      BL       firmwareError
   \   0000002C   0xE017             B.N      ??scheduleByAngle_2
    281          	float delayUs = calc->oneDegreeUs * angle;
   \                     ??scheduleByAngle_1:
   \   0000002E   0xED98 0x0A02      VLDR     S0,[R8, #+8]
   \   00000032   0xEE60 0x8A08      VMUL.F32 S17,S0,S16
    282          	efiAssertVoid(!cisnan(delayUs), "NaN delay?");
   \   00000036   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000003A   0x.... 0x....      BL       __iar_FDtest
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xD103             BNE.N    ??scheduleByAngle_3
   \   00000042   0x....             LDR.N    R0,??DataTable14_30
   \   00000044   0x.... 0x....      BL       firmwareError
   \   00000048   0xE009             B.N      ??scheduleByAngle_2
    283          	scheduleTask("by angle", timer, (int) delayUs, callback, param);
   \                     ??scheduleByAngle_3:
   \   0000004A   0x9700             STR      R7,[SP, #+0]
   \   0000004C   0x0033             MOVS     R3,R6
   \   0000004E   0xEEBD 0x0AE8      VCVT.S32.F32 S0,S17
   \   00000052   0xEE10 0x2A10      VMOV     R2,S0
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x....             LDR.N    R0,??DataTable14_31
   \   0000005A   0x.... 0x....      BL       _Z12scheduleTaskPKcP12scheduling_siPFvPvES3_
    284          }
   \                     ??scheduleByAngle_2:
   \   0000005E   0xB002             ADD      SP,SP,#+8
   \   00000060   0xECBD 0x8B02      VPOP     {D8}
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .init_array, align 4, keep-with-next, root
   \   00000000   0x........         DC32    RELOC_ARM_TARGET1 __sti__routine

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#2z">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#2z"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x32 0x7A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x72 0x00          DC8 "r"

   \                                 In section .rodata, align 4
   \                     `?<Constant "chart TDC mark">`:
   \   00000000   0x63 0x68          DC8 "chart TDC mark"
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x54 0x44    
   \              0x43 0x20    
   \              0x6D 0x61    
   \              0x72 0x6B    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "rpm reporter">`:
   \   00000000   0x72 0x70          DC8 "rpm reporter"
   \              0x6D 0x20    
   \              0x72 0x65    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x65 0x72    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "RPM check expected">`:
   \   00000000   0x52 0x50          DC8 "RPM check expected"
   \              0x4D 0x20    
   \              0x63 0x68    
   \              0x65 0x63    
   \              0x6B 0x20    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "NaN delay?">`:
   \   00000000   0x4E 0x61          DC8 "NaN delay?"
   \              0x4E 0x20    
   \              0x64 0x65    
   \              0x6C 0x61    
   \              0x79 0x3F    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "by angle">`:
   \   00000000   0x62 0x79          DC8 "by angle"
   \              0x20 0x61    
   \              0x6E 0x67    
   \              0x6C 0x65    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "templog rpm=0 since n...">`:
   \   00000000   0x74 0x65          DC8 "templog rpm=0 since not running [%x][%x] [%x][%x]"
   \              0x6D 0x70    
   \              0x6C 0x6F    
   \              0x67 0x20    
   \              0x72 0x70    
   \              0x6D 0x3D    
   \              0x30 0x20    
   \              0x73 0x69    
   \              0x6E 0x63    
   \              0x65 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x72 0x75    
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x20 0x5B    
   \              0x25 0x78    
   \              0x5D 0x5B    
   \              0x25 0x78    
   \              0x5D 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x2302             MOVS     R3,#+2
   \   00000004   0x2218             MOVS     R2,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   0000000E   0x.... 0x....      BL       __aeabi_vec_ctor_nocookie_nodtor
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x4822C2AB         DC32     0x4822c2ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x72 0x00          DC8      "r",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x4BD59F80         DC32     0x4bd59f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     _ZN12scheduling_sC1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     tdcScheduler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x9BDD3C00         DC32     0x9bdd3c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x1E0A6E00         DC32     0x1e0a6e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x0A037A00         DC32     0xa037a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     notRunnintNow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     notRunningPrev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     `?<Constant "templog rpm=0 since n...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     logger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x........         DC32     persistentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     `?<Constant "lowstck#2z">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \   00000000   0x........         DC32     boardConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \   00000000   0x58D09800         DC32     0x58d09800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \   00000000   0x........         DC32     rpmBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_22:
   \   00000000   0x........         DC32     waveChart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_23:
   \   00000000   0x........         DC32     _Z13onTdcCallbackv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_24:
   \   00000000   0x........         DC32     _engine+0xDE4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_25:
   \   00000000   0x........         DC32     `?<Constant "chart TDC mark">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_26:
   \   00000000   0x........         DC32     _Z15tdcMarkCallback15trigger_event_ej

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_27:
   \   00000000   0x........         DC32     `?<Constant "rpm reporter">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_28:
   \   00000000   0x........         DC32     _Z24rpmShaftPositionCallback15trigger_event_ej

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_29:
   \   00000000   0x........         DC32     `?<Constant "RPM check expected">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_30:
   \   00000000   0x........         DC32     `?<Constant "NaN delay?">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_31:
   \   00000000   0x........         DC32     `?<Constant "by angle">`
    285          #endif
    286          
    287          #else
    288          RpmCalculator::RpmCalculator() {
    289          
    290          }
    291          
    292          #endif /* EFI_SHAFT_POSITION_INPUT */
    293          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RpmCalculator::RpmCalculator()
         8   -> RpmCalculator::setRpmValue(int)
       0   RpmCalculator::getRevolutionCounter()
       0   RpmCalculator::getRevolutionCounterSinceStart()
      16   RpmCalculator::getRpmAcceleration()
        16   -> __aeabi_d2f
        16   -> __aeabi_ddiv
        16   -> __aeabi_dmul
        16   -> __aeabi_i2d
      16   RpmCalculator::isRunning()
        16   -> getTimeNowNt
       0   RpmCalculator::onNewEngineCycle()
      16   RpmCalculator::rpm()
        16   -> RpmCalculator::isRunning()
        16   -> scheduleMsg
       0   RpmCalculator::setRpmValue(int)
       8   RpmCalculator::subobject RpmCalculator()
         8   -> RpmCalculator::RpmCalculator()
       8   __sti__routine()
         8   -> __aeabi_vec_ctor_nocookie_nodtor
      24   getCrankshaftAngleNt(int64_t)
        24   -> RpmCalculator::rpm()
        24   -> __aeabi_l2f
       8   getRevolutionCounter()
         8   -> RpmCalculator::getRevolutionCounter()
      16   initRpmCalculator(Logging *, Engine *)
        16   -> addTriggerEventListener(ShaftPositionListener, char const *, Engine *)
       8   isCranking()
         8   -> isCrankingE(Engine *)
       8   isCrankingE(Engine *)
         8   -> RpmCalculator::rpm()
       8   onTdcCallback()
         8   -> RpmCalculator::rpm()
         8   -> WaveChart::addWaveChartEvent3(char const *, char const *)
         8   -> itoa10
      48   rpmShaftPositionCallback(trigger_event_e, uint32_t)
        48   -> RpmCalculator::isRunning()
        48   -> RpmCalculator::onNewEngineCycle()
        48   -> RpmCalculator::setRpmValue(int)
        48   -> __aeabi_ldivmod
        48   -> firmwareError
        48   -> getCrankshaftAngleNt(int64_t)
        48   -> getRemainingStack
        48   -> getTimeNowNt
        48   -> scAddData(float, float)
      40   scheduleByAngle(int, scheduling_s *, float, schfunc_t, void *, RpmCalculator *)
        40   -> __iar_FDtest
        40   -> firmwareError
        40   -> scheduleTask(char const *, scheduling_s *, int, schfunc_t, void *)
      32   tdcMarkCallback(trigger_event_e, uint32_t)
        32   -> RpmCalculator::getRevolutionCounter()
        32   -> RpmCalculator::rpm()
        32   -> scheduleByAngle(int, scheduling_s *, float, schfunc_t, void *, RpmCalculator *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "NaN delay?">
      20  ?<Constant "RPM check expected">
      12  ?<Constant "by angle">
      16  ?<Constant "chart TDC mark">
      12  ?<Constant "lowstck#2z">
       2  ?<Constant "r">
      16  ?<Constant "rpm reporter">
      52  ?<Constant "templog rpm=0 since n...">
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_26
       4  ??DataTable14_27
       4  ??DataTable14_28
       4  ??DataTable14_29
       4  ??DataTable14_3
       4  ??DataTable14_30
       4  ??DataTable14_31
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      54  RpmCalculator::RpmCalculator()
       4  RpmCalculator::getRevolutionCounter()
       4  RpmCalculator::getRevolutionCounterSinceStart()
      52  RpmCalculator::getRpmAcceleration()
     128  RpmCalculator::isRunning()
      14  RpmCalculator::onNewEngineCycle()
      74  RpmCalculator::rpm()
      42  RpmCalculator::setRpmValue(int)
      12  RpmCalculator::subobject RpmCalculator()
      20  __sti__routine()
      80  getCrankshaftAngleNt(int64_t)
      12  getRevolutionCounter()
      32  initRpmCalculator(Logging *, Engine *)
      12  isCranking()
      34  isCrankingE(Engine *)
       4  logger
       8  notRunningPrev
       8  notRunnintNow
      30  onTdcCallback()
      12  rpmBuffer
     302  rpmShaftPositionCallback(trigger_event_e, uint32_t)
     104  scheduleByAngle(int, scheduling_s *, float, schfunc_t, void *, RpmCalculator *)
     126  tdcMarkCallback(trigger_event_e, uint32_t)
      48  tdcScheduler
       4  -- Other

 
    80 bytes in section .bss
     4 bytes in section .init_array
   142 bytes in section .rodata
 1 268 bytes in section .text
 
 1 272 bytes of CODE  memory
   142 bytes of CONST memory
    80 bytes of DATA  memory

Errors: none
Warnings: 1
