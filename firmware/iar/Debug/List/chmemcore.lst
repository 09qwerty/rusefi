###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:42 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chmemcore.c                                     #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chmemcore.c -lCN F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -lA                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hmemcore.lst                                          #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       memcore.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chmemcore.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chmemcore.c
     30           * @brief   Core memory manager code.
     31           *
     32           * @addtogroup memcore
     33           * @details Core Memory Manager related APIs and services.
     34           *          <h2>Operation mode</h2>
     35           *          The core memory manager is a simplified allocator that only
     36           *          allows to allocate memory blocks without the possibility to
     37           *          free them.<br>
     38           *          This allocator is meant as a memory blocks provider for the
     39           *          other allocators such as:
     40           *          - C-Runtime allocator (through a compiler specific adapter module).
     41           *          - Heap allocator (see @ref heaps).
     42           *          - Memory pools allocator (see @ref pools).
     43           *          .
     44           *          By having a centralized memory provider the various allocators
     45           *          can coexist and share the main memory.<br>
     46           *          This allocator, alone, is also useful for very simple
     47           *          applications that just require a simple way to get memory
     48           *          blocks.
     49           * @pre     In order to use the core memory manager APIs the @p CH_USE_MEMCORE
     50           *          option must be enabled in @p chconf.h.
     51           * @{
     52           */
     53          
     54          #include "ch.h"
     55          
     56          #if CH_USE_MEMCORE || defined(__DOXYGEN__)
     57          

   \                                 In section .bss, align 4
     58          static uint8_t *nextmem;
   \                     nextmem:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     59          static uint8_t *endmem;
   \                     endmem:
   \   00000000                      DS8 4
     60          
     61          /**
     62           * @brief   Low level memory manager initialization.
     63           *
     64           * @notapi
     65           */

   \                                 In section .text, align 2, keep-with-next
     66          void _core_init(void) {
     67          #if CH_MEMCORE_SIZE == 0
     68            extern uint8_t __heap_base__[];
     69            extern uint8_t __heap_end__[];
     70            nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
     71            endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
     72          #else
     73            static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
     74            nextmem = (uint8_t *)&buffer[0];
   \                     _core_init:
   \   00000000   0x....             LDR.N    R0,??DataTable2
   \   00000002   0x....             LDR.N    R1,??DataTable2_1
   \   00000004   0x6001             STR      R1,[R0, #+0]
     75            endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
   \   00000006   0x....             LDR.N    R0,??DataTable2_2
   \   00000008   0x....             LDR.N    R1,??DataTable2_3
   \   0000000A   0x6001             STR      R1,[R0, #+0]
     76          #endif
     77          }
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .bss, align 8
   \                     ??buffer:
   \   00000000                      DS8 2048
     78          
     79          /**
     80           * @brief   Allocates a memory block.
     81           * @details The size of the returned block is aligned to the alignment
     82           *          type so it is not possible to allocate less
     83           *          than <code>MEM_ALIGN_SIZE</code>.
     84           *
     85           * @param[in] size      the size of the block to be allocated
     86           * @return              A pointer to the allocated memory block.
     87           * @retval NULL         allocation failed, core memory exhausted.
     88           *
     89           * @api
     90           */

   \                                 In section .text, align 2, keep-with-next
     91          void *chCoreAlloc(size_t size) {
   \                     chCoreAlloc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     92            void *p;
     93          
     94            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
     95            p = chCoreAllocI(size);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       chCoreAllocI
   \   00000014   0x0005             MOVS     R5,R0
     96            chSysUnlock();
   \   00000016   0x.... 0x....      BL       dbg_check_unlock
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF380 0x8811      MSR      BASEPRI,R0
     97            return p;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     98          }
     99          
    100          /**
    101           * @brief   Allocates a memory block.
    102           * @details The size of the returned block is aligned to the alignment
    103           *          type so it is not possible to allocate less than
    104           *          <code>MEM_ALIGN_SIZE</code>.
    105           *
    106           * @param[in] size      the size of the block to be allocated.
    107           * @return              A pointer to the allocated memory block.
    108           * @retval NULL         allocation failed, core memory exhausted.
    109           *
    110           * @iclass
    111           */

   \                                 In section .text, align 2, keep-with-next
    112          void *chCoreAllocI(size_t size) {
   \                     chCoreAllocI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    113            void *p;
    114          
    115            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    116          
    117            size = MEM_ALIGN_NEXT(size);
   \   00000008   0x1DE8             ADDS     R0,R5,#+7
   \   0000000A   0x08C5             LSRS     R5,R0,#+3
   \   0000000C   0x00ED             LSLS     R5,R5,#+3
    118            if ((size_t)(endmem - nextmem) < size)
   \   0000000E   0x....             LDR.N    R0,??DataTable2_2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x....             LDR.N    R1,??DataTable2
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x1A40             SUBS     R0,R0,R1
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xD201             BCS.N    ??chCoreAllocI_0
    119              return NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE008             B.N      ??chCoreAllocI_1
    120            p = nextmem;
   \                     ??chCoreAllocI_0:
   \   00000020   0x....             LDR.N    R0,??DataTable2
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0004             MOVS     R4,R0
    121            nextmem += size;
   \   00000026   0x....             LDR.N    R0,??DataTable2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x1828             ADDS     R0,R5,R0
   \   0000002C   0x....             LDR.N    R1,??DataTable2
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    122            return p;
   \   00000030   0x0020             MOVS     R0,R4
   \                     ??chCoreAllocI_1:
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    123          }
    124          
    125          /**
    126           * @brief   Core memory status.
    127           *
    128           * @return              The size, in bytes, of the free core memory.
    129           *
    130           * @api
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          size_t chCoreStatus(void) {
    133          
    134            return (size_t)(endmem - nextmem);
   \                     chCoreStatus:
   \   00000000   0x....             LDR.N    R0,??DataTable2_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable2
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x1A40             SUBS     R0,R0,R1
   \   0000000A   0x4770             BX       LR               ;; return
    135          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     nextmem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     ??buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     endmem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     ??buffer+0x800
    136          #endif /* CH_USE_MEMCORE */
    137          
    138          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _core_init
      16   chCoreAlloc
        16   -> chCoreAllocI
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chCoreAllocI
        16   -> chDbgCheckClassI
       0   chCoreStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
      14  _core_init
    2048  buffer
      36  chCoreAlloc
      52  chCoreAllocI
      12  chCoreStatus
       4  endmem
       4  nextmem

 
 2 056 bytes in section .bss
   130 bytes in section .text
 
   130 bytes of CODE memory
 2 056 bytes of DATA memory

Errors: none
Warnings: none
