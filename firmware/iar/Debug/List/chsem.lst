###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:43 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chsem.c                                         #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chsem.c -lCN F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -o                             #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hsem.lst                                              #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       sem.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chsem.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chsem.c
     30           * @brief   Semaphores code.
     31           *
     32           * @addtogroup semaphores
     33           * @details Semaphores related APIs and services.
     34           *
     35           *          <h2>Operation mode</h2>
     36           *          Semaphores are a flexible synchronization primitive, ChibiOS/RT
     37           *          implements semaphores in their "counting semaphores" variant as
     38           *          defined by Edsger Dijkstra plus several enhancements like:
     39           *          - Wait operation with timeout.
     40           *          - Reset operation.
     41           *          - Atomic wait+signal operation.
     42           *          - Return message from the wait operation (OK, RESET, TIMEOUT).
     43           *          .
     44           *          The binary semaphores variant can be easily implemented using
     45           *          counting semaphores.<br>
     46           *          Operations defined for semaphores:
     47           *          - <b>Signal</b>: The semaphore counter is increased and if the
     48           *            result is non-positive then a waiting thread is removed from
     49           *            the semaphore queue and made ready for execution.
     50           *          - <b>Wait</b>: The semaphore counter is decreased and if the result
     51           *            becomes negative the thread is queued in the semaphore and
     52           *            suspended.
     53           *          - <b>Reset</b>: The semaphore counter is reset to a non-negative
     54           *            value and all the threads in the queue are released.
     55           *          .
     56           *          Semaphores can be used as guards for mutual exclusion zones
     57           *          (note that mutexes are recommended for this kind of use) but
     58           *          also have other uses, queues guards and counters for example.<br>
     59           *          Semaphores usually use a FIFO queuing strategy but it is possible
     60           *          to make them order threads by priority by enabling
     61           *          @p CH_USE_SEMAPHORES_PRIORITY in @p chconf.h.
     62           * @pre     In order to use the semaphore APIs the @p CH_USE_SEMAPHORES
     63           *          option must be enabled in @p chconf.h.
     64           * @{
     65           */
     66          
     67          #include "ch.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void queue_insert(struct Thread *, ThreadsQueue *)
   \                     queue_insert:
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x6042             STR      R2,[R0, #+4]
   \   00000006   0x6048             STR      R0,[R1, #+4]
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *fifo_remove(ThreadsQueue *)
   \                     fifo_remove:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   \   00000008   0x6051             STR      R1,[R2, #+4]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *lifo_remove(ThreadsQueue *)
   \                     lifo_remove:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x6848             LDR      R0,[R1, #+4]
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0x604A             STR      R2,[R1, #+4]
   \   00000008   0x6011             STR      R1,[R2, #+0]
   \   0000000A   0x4770             BX       LR               ;; return
     68          
     69          #if CH_USE_SEMAPHORES || defined(__DOXYGEN__)
     70          
     71          #if CH_USE_SEMAPHORES_PRIORITY
     72          #define sem_insert(tp, qp) prio_insert(tp, qp)
     73          #else
     74          #define sem_insert(tp, qp) queue_insert(tp, qp)
     75          #endif
     76          
     77          /**
     78           * @brief   Initializes a semaphore with the specified counter value.
     79           *
     80           * @param[out] sp       pointer to a @p Semaphore structure
     81           * @param[in] n         initial value of the semaphore counter. Must be
     82           *                      non-negative.
     83           *
     84           * @init
     85           */

   \                                 In section .text, align 2, keep-with-next
     86          void chSemInit(Semaphore *sp, cnt_t n) {
   \                     chSemInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     87          
     88            chDbgCheck((sp != NULL) && (n >= 0), "chSemInit");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??chSemInit_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD504             BPL.N    ??chSemInit_1
   \                     ??chSemInit_0:
   \   0000000E   0x2258             MOVS     R2,#+88
   \   00000010   0x....             LDR.N    R1,??DataTable6
   \   00000012   0x....             LDR.N    R0,??DataTable6_1
   \   00000014   0x.... 0x....      BL       chDbgPanic3
     89          
     90            queue_init(&sp->s_queue);
   \                     ??chSemInit_1:
   \   00000018   0x6064             STR      R4,[R4, #+4]
   \   0000001A   0x6024             STR      R4,[R4, #+0]
     91            sp->s_cnt = n;
   \   0000001C   0x60A5             STR      R5,[R4, #+8]
     92          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     93          
     94          /**
     95           * @brief   Performs a reset operation on the semaphore.
     96           * @post    After invoking this function all the threads waiting on the
     97           *          semaphore, if any, are released and the semaphore counter is set
     98           *          to the specified, non negative, value.
     99           * @note    The released threads can recognize they were waked up by a reset
    100           *          rather than a signal because the @p chSemWait() will return
    101           *          @p RDY_RESET instead of @p RDY_OK.
    102           *
    103           * @param[in] sp        pointer to a @p Semaphore structure
    104           * @param[in] n         the new value of the semaphore counter. The value must
    105           *                      be non-negative.
    106           *
    107           * @api
    108           */

   \                                 In section .text, align 2, keep-with-next
    109          void chSemReset(Semaphore *sp, cnt_t n) {
   \                     chSemReset:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    110          
    111            chSysLock();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock
    112            chSemResetI(sp, n);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       chSemResetI
    113            chSchRescheduleS();
   \   00000018   0x.... 0x....      BL       chSchRescheduleS
    114            chSysUnlock();
   \   0000001C   0x.... 0x....      BL       dbg_check_unlock
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF380 0x8811      MSR      BASEPRI,R0
    115          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    116          
    117          /**
    118           * @brief   Performs a reset operation on the semaphore.
    119           * @post    After invoking this function all the threads waiting on the
    120           *          semaphore, if any, are released and the semaphore counter is set
    121           *          to the specified, non negative, value.
    122           * @post    This function does not reschedule so a call to a rescheduling
    123           *          function must be performed before unlocking the kernel. Note that
    124           *          interrupt handlers always reschedule on exit so an explicit
    125           *          reschedule must not be performed in ISRs.
    126           * @note    The released threads can recognize they were waked up by a reset
    127           *          rather than a signal because the @p chSemWait() will return
    128           *          @p RDY_RESET instead of @p RDY_OK.
    129           *
    130           * @param[in] sp        pointer to a @p Semaphore structure
    131           * @param[in] n         the new value of the semaphore counter. The value must
    132           *                      be non-negative.
    133           *
    134           * @iclass
    135           */

   \                                 In section .text, align 2, keep-with-next
    136          void chSemResetI(Semaphore *sp, cnt_t n) {
   \                     chSemResetI:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    137            cnt_t cnt;
    138          
    139            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    140            chDbgCheck((sp != NULL) && (n >= 0), "chSemResetI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD001             BEQ.N    ??chSemResetI_0
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD504             BPL.N    ??chSemResetI_1
   \                     ??chSemResetI_0:
   \   00000012   0x228C             MOVS     R2,#+140
   \   00000014   0x....             LDR.N    R1,??DataTable6
   \   00000016   0x....             LDR.N    R0,??DataTable6_2
   \   00000018   0x.... 0x....      BL       chDbgPanic3
    141            chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
    142                        ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
    143                        "chSemResetI(), #1",
    144                        "inconsistent semaphore");
   \                     ??chSemResetI_1:
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD402             BMI.N    ??chSemResetI_2
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD008             BEQ.N    ??chSemResetI_3
   \                     ??chSemResetI_2:
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD502             BPL.N    ??chSemResetI_4
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x42A0             CMP      R0,R4
   \   00000032   0xD102             BNE.N    ??chSemResetI_3
   \                     ??chSemResetI_4:
   \   00000034   0x....             LDR.N    R0,??DataTable6_3
   \   00000036   0x.... 0x....      BL       chDbgPanic
    145          
    146            cnt = sp->s_cnt;
   \                     ??chSemResetI_3:
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x0006             MOVS     R6,R0
    147            sp->s_cnt = n;
   \   0000003E   0x60A5             STR      R5,[R4, #+8]
    148            while (++cnt <= 0)
   \                     ??chSemResetI_5:
   \   00000040   0x1C76             ADDS     R6,R6,#+1
   \   00000042   0x2E01             CMP      R6,#+1
   \   00000044   0xDA08             BGE.N    ??chSemResetI_6
    149              chSchReadyI(lifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_RESET;
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       lifo_remove
   \   0000004C   0x.... 0x....      BL       chSchReadyI
   \   00000050   0xF07F 0x0101      MVNS     R1,#+1
   \   00000054   0x6281             STR      R1,[R0, #+40]
   \   00000056   0xE7F3             B.N      ??chSemResetI_5
    150          }
   \                     ??chSemResetI_6:
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    151          
    152          /**
    153           * @brief   Performs a wait operation on a semaphore.
    154           *
    155           * @param[in] sp        pointer to a @p Semaphore structure
    156           * @return              A message specifying how the invoking thread has been
    157           *                      released from the semaphore.
    158           * @retval RDY_OK       if the thread has not stopped on the semaphore or the
    159           *                      semaphore has been signaled.
    160           * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
    161           *
    162           * @api
    163           */

   \                                 In section .text, align 2, keep-with-next
    164          msg_t chSemWait(Semaphore *sp) {
   \                     chSemWait:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    165            msg_t msg;
    166          
    167            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    168            msg = chSemWaitS(sp);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       chSemWaitS
   \   00000014   0x0005             MOVS     R5,R0
    169            chSysUnlock();
   \   00000016   0x.... 0x....      BL       dbg_check_unlock
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF380 0x8811      MSR      BASEPRI,R0
    170            return msg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    171          }
    172          
    173          /**
    174           * @brief   Performs a wait operation on a semaphore.
    175           *
    176           * @param[in] sp        pointer to a @p Semaphore structure
    177           * @return              A message specifying how the invoking thread has been
    178           *                      released from the semaphore.
    179           * @retval RDY_OK       if the thread has not stopped on the semaphore or the
    180           *                      semaphore has been signaled.
    181           * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
    182           *
    183           * @sclass
    184           */

   \                                 In section .text, align 2, keep-with-next
    185          msg_t chSemWaitS(Semaphore *sp) {
   \                     chSemWaitS:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    186          
    187            chDbgCheckClassS();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassS
    188            chDbgCheck(sp != NULL, "chSemWaitS");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??chSemWaitS_0
   \   0000000C   0x22BC             MOVS     R2,#+188
   \   0000000E   0x....             LDR.N    R1,??DataTable6
   \   00000010   0x....             LDR.N    R0,??DataTable6_4
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    189            chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
    190                        ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
    191                        "chSemWaitS(), #1",
    192                        "inconsistent semaphore");
   \                     ??chSemWaitS_0:
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD402             BMI.N    ??chSemWaitS_1
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x42A0             CMP      R0,R4
   \   00000020   0xD008             BEQ.N    ??chSemWaitS_2
   \                     ??chSemWaitS_1:
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD502             BPL.N    ??chSemWaitS_3
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x42A0             CMP      R0,R4
   \   0000002C   0xD102             BNE.N    ??chSemWaitS_2
   \                     ??chSemWaitS_3:
   \   0000002E   0x....             LDR.N    R0,??DataTable6_5
   \   00000030   0x.... 0x....      BL       chDbgPanic
    193          
    194            if (--sp->s_cnt < 0) {
   \                     ??chSemWaitS_2:
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x1E40             SUBS     R0,R0,#+1
   \   00000038   0x60A0             STR      R0,[R4, #+8]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD50E             BPL.N    ??chSemWaitS_4
    195              currp->p_u.wtobjp = sp;
   \   0000003E   0x....             LDR.N    R0,??DataTable6_6
   \   00000040   0x6980             LDR      R0,[R0, #+24]
   \   00000042   0x6284             STR      R4,[R0, #+40]
    196              sem_insert(currp, &sp->s_queue);
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0x....             LDR.N    R0,??DataTable6_6
   \   00000048   0x6980             LDR      R0,[R0, #+24]
   \   0000004A   0x.... 0x....      BL       queue_insert
    197              chSchGoSleepS(THD_STATE_WTSEM);
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      BL       chSchGoSleepS
    198              return currp->p_u.rdymsg;
   \   00000054   0x....             LDR.N    R0,??DataTable6_6
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0x6A80             LDR      R0,[R0, #+40]
   \   0000005A   0xE000             B.N      ??chSemWaitS_5
    199            }
    200            return RDY_OK;
   \                     ??chSemWaitS_4:
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??chSemWaitS_5:
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
    201          }
    202          
    203          /**
    204           * @brief   Performs a wait operation on a semaphore with timeout specification.
    205           *
    206           * @param[in] sp        pointer to a @p Semaphore structure
    207           * @param[in] time      the number of ticks before the operation timeouts,
    208           *                      the following special values are allowed:
    209           *                      - @a TIME_IMMEDIATE immediate timeout.
    210           *                      - @a TIME_INFINITE no timeout.
    211           *                      .
    212           * @return              A message specifying how the invoking thread has been
    213           *                      released from the semaphore.
    214           * @retval RDY_OK       if the thread has not stopped on the semaphore or the
    215           *                      semaphore has been signaled.
    216           * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
    217           * @retval RDY_TIMEOUT  if the semaphore has not been signaled or reset within
    218           *                      the specified timeout.
    219           *
    220           * @api
    221           */

   \                                 In section .text, align 2, keep-with-next
    222          msg_t chSemWaitTimeout(Semaphore *sp, systime_t time) {
   \                     chSemWaitTimeout:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    223            msg_t msg;
    224          
    225            chSysLock();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock
    226            msg = chSemWaitTimeoutS(sp, time);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       chSemWaitTimeoutS
   \   00000018   0x0006             MOVS     R6,R0
    227            chSysUnlock();
   \   0000001A   0x.... 0x....      BL       dbg_check_unlock
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF380 0x8811      MSR      BASEPRI,R0
    228            return msg;
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    229          }
    230          
    231          /**
    232           * @brief   Performs a wait operation on a semaphore with timeout specification.
    233           *
    234           * @param[in] sp        pointer to a @p Semaphore structure
    235           * @param[in] time      the number of ticks before the operation timeouts,
    236           *                      the following special values are allowed:
    237           *                      - @a TIME_IMMEDIATE immediate timeout.
    238           *                      - @a TIME_INFINITE no timeout.
    239           *                      .
    240           * @return              A message specifying how the invoking thread has been
    241           *                      released from the semaphore.
    242           * @retval RDY_OK       if the thread has not stopped on the semaphore or the
    243           *                      semaphore has been signaled.
    244           * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
    245           * @retval RDY_TIMEOUT  if the semaphore has not been signaled or reset within
    246           *                      the specified timeout.
    247           *
    248           * @sclass
    249           */

   \                                 In section .text, align 2, keep-with-next
    250          msg_t chSemWaitTimeoutS(Semaphore *sp, systime_t time) {
   \                     chSemWaitTimeoutS:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    251          
    252            chDbgCheckClassS();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassS
    253            chDbgCheck(sp != NULL, "chSemWaitTimeoutS");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??chSemWaitTimeoutS_0
   \   0000000E   0x22FD             MOVS     R2,#+253
   \   00000010   0x....             LDR.N    R1,??DataTable6
   \   00000012   0x....             LDR.N    R0,??DataTable6_7
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    254            chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
    255                        ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
    256                        "chSemWaitTimeoutS(), #1",
    257                        "inconsistent semaphore");
   \                     ??chSemWaitTimeoutS_0:
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD402             BMI.N    ??chSemWaitTimeoutS_1
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x42A0             CMP      R0,R4
   \   00000022   0xD008             BEQ.N    ??chSemWaitTimeoutS_2
   \                     ??chSemWaitTimeoutS_1:
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD502             BPL.N    ??chSemWaitTimeoutS_3
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x42A0             CMP      R0,R4
   \   0000002E   0xD102             BNE.N    ??chSemWaitTimeoutS_2
   \                     ??chSemWaitTimeoutS_3:
   \   00000030   0x....             LDR.N    R0,??DataTable6_8
   \   00000032   0x.... 0x....      BL       chDbgPanic
    258          
    259            if (--sp->s_cnt < 0) {
   \                     ??chSemWaitTimeoutS_2:
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x60A0             STR      R0,[R4, #+8]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD514             BPL.N    ??chSemWaitTimeoutS_4
    260              if (TIME_IMMEDIATE == time) {
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD105             BNE.N    ??chSemWaitTimeoutS_5
    261                sp->s_cnt++;
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x60A0             STR      R0,[R4, #+8]
    262                return RDY_TIMEOUT;
   \   0000004A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004E   0xE00D             B.N      ??chSemWaitTimeoutS_6
    263              }
    264              currp->p_u.wtobjp = sp;
   \                     ??chSemWaitTimeoutS_5:
   \   00000050   0x....             LDR.N    R0,??DataTable6_6
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0x6284             STR      R4,[R0, #+40]
    265              sem_insert(currp, &sp->s_queue);
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0x....             LDR.N    R0,??DataTable6_6
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0x.... 0x....      BL       queue_insert
    266              return chSchGoSleepTimeoutS(THD_STATE_WTSEM, time);
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \   00000068   0xE000             B.N      ??chSemWaitTimeoutS_6
    267            }
    268            return RDY_OK;
   \                     ??chSemWaitTimeoutS_4:
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??chSemWaitTimeoutS_6:
   \   0000006C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    269          }
    270          
    271          /**
    272           * @brief   Performs a signal operation on a semaphore.
    273           *
    274           * @param[in] sp        pointer to a @p Semaphore structure
    275           *
    276           * @api
    277           */

   \                                 In section .text, align 2, keep-with-next
    278          void chSemSignal(Semaphore *sp) {
   \                     chSemSignal:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    279          
    280            chDbgCheck(sp != NULL, "chSemSignal");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??chSemSignal_0
   \   00000008   0xF44F 0x728C      MOV      R2,#+280
   \   0000000C   0x....             LDR.N    R1,??DataTable6
   \   0000000E   0x....             LDR.N    R0,??DataTable6_9
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    281            chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
    282                        ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
    283                        "chSemSignal(), #1",
    284                        "inconsistent semaphore");
   \                     ??chSemSignal_0:
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD402             BMI.N    ??chSemSignal_1
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x42A0             CMP      R0,R4
   \   0000001E   0xD008             BEQ.N    ??chSemSignal_2
   \                     ??chSemSignal_1:
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD502             BPL.N    ??chSemSignal_3
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x42A0             CMP      R0,R4
   \   0000002A   0xD102             BNE.N    ??chSemSignal_2
   \                     ??chSemSignal_3:
   \   0000002C   0x....             LDR.N    R0,??DataTable6_10
   \   0000002E   0x.... 0x....      BL       chDbgPanic
    285          
    286            chSysLock();
   \                     ??chSemSignal_2:
   \   00000032   0x2020             MOVS     R0,#+32
   \   00000034   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000038   0x.... 0x....      BL       dbg_check_lock
    287            if (++sp->s_cnt <= 0)
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xDA05             BGE.N    ??chSemSignal_4
    288              chSchWakeupS(fifo_remove(&sp->s_queue), RDY_OK);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       fifo_remove
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x.... 0x....      BL       chSchWakeupS
    289            chSysUnlock();
   \                     ??chSemSignal_4:
   \   00000052   0x.... 0x....      BL       dbg_check_unlock
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF380 0x8811      MSR      BASEPRI,R0
    290          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    291          
    292          /**
    293           * @brief   Performs a signal operation on a semaphore.
    294           * @post    This function does not reschedule so a call to a rescheduling
    295           *          function must be performed before unlocking the kernel. Note that
    296           *          interrupt handlers always reschedule on exit so an explicit
    297           *          reschedule must not be performed in ISRs.
    298           *
    299           * @param[in] sp    pointer to a @p Semaphore structure
    300           *
    301           * @iclass
    302           */

   \                                 In section .text, align 2, keep-with-next
    303          void chSemSignalI(Semaphore *sp) {
   \                     chSemSignalI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    304          
    305            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    306            chDbgCheck(sp != NULL, "chSemSignalI");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD105             BNE.N    ??chSemSignalI_0
   \   0000000C   0xF44F 0x7299      MOV      R2,#+306
   \   00000010   0x....             LDR.N    R1,??DataTable6
   \   00000012   0x....             LDR.N    R0,??DataTable6_11
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    307            chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
    308                        ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
    309                        "chSemSignalI(), #1",
    310                        "inconsistent semaphore");
   \                     ??chSemSignalI_0:
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD402             BMI.N    ??chSemSignalI_1
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x42A0             CMP      R0,R4
   \   00000022   0xD008             BEQ.N    ??chSemSignalI_2
   \                     ??chSemSignalI_1:
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD502             BPL.N    ??chSemSignalI_3
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x42A0             CMP      R0,R4
   \   0000002E   0xD102             BNE.N    ??chSemSignalI_2
   \                     ??chSemSignalI_3:
   \   00000030   0x....             LDR.N    R0,??DataTable6_12
   \   00000032   0x.... 0x....      BL       chDbgPanic
    311          
    312            if (++sp->s_cnt <= 0) {
   \                     ??chSemSignalI_2:
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x60A0             STR      R0,[R4, #+8]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xDA08             BGE.N    ??chSemSignalI_4
    313              /* Note, it is done this way in order to allow a tail call on
    314                       chSchReadyI().*/
    315              Thread *tp = fifo_remove(&sp->s_queue);
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       fifo_remove
   \   00000046   0x0005             MOVS     R5,R0
    316              tp->p_u.rdymsg = RDY_OK;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x62A8             STR      R0,[R5, #+40]
    317              chSchReadyI(tp);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       chSchReadyI
    318            }
    319          }
   \                     ??chSemSignalI_4:
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    320          
    321          /**
    322           * @brief   Adds the specified value to the semaphore counter.
    323           * @post    This function does not reschedule so a call to a rescheduling
    324           *          function must be performed before unlocking the kernel. Note that
    325           *          interrupt handlers always reschedule on exit so an explicit
    326           *          reschedule must not be performed in ISRs.
    327           *
    328           * @param[in] sp        pointer to a @p Semaphore structure
    329           * @param[in] n         value to be added to the semaphore counter. The value
    330           *                      must be positive.
    331           *
    332           * @iclass
    333           */

   \                                 In section .text, align 2, keep-with-next
    334          void chSemAddCounterI(Semaphore *sp, cnt_t n) {
   \                     chSemAddCounterI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    335          
    336            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    337            chDbgCheck((sp != NULL) && (n > 0), "chSemAddCounterI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD001             BEQ.N    ??chSemAddCounterI_0
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xDA05             BGE.N    ??chSemAddCounterI_1
   \                     ??chSemAddCounterI_0:
   \   00000012   0xF240 0x1251      MOVW     R2,#+337
   \   00000016   0x....             LDR.N    R1,??DataTable6
   \   00000018   0x....             LDR.N    R0,??DataTable6_13
   \   0000001A   0x.... 0x....      BL       chDbgPanic3
    338            chDbgAssert(((sp->s_cnt >= 0) && isempty(&sp->s_queue)) ||
    339                        ((sp->s_cnt < 0) && notempty(&sp->s_queue)),
    340                        "chSemAddCounterI(), #1",
    341                        "inconsistent semaphore");
   \                     ??chSemAddCounterI_1:
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD402             BMI.N    ??chSemAddCounterI_2
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x42A0             CMP      R0,R4
   \   00000028   0xD008             BEQ.N    ??chSemAddCounterI_3
   \                     ??chSemAddCounterI_2:
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD502             BPL.N    ??chSemAddCounterI_4
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x42A0             CMP      R0,R4
   \   00000034   0xD102             BNE.N    ??chSemAddCounterI_3
   \                     ??chSemAddCounterI_4:
   \   00000036   0x....             LDR.N    R0,??DataTable6_14
   \   00000038   0x.... 0x....      BL       chDbgPanic
    342          
    343            while (n > 0) {
   \                     ??chSemAddCounterI_3:
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xDB0D             BLT.N    ??chSemAddCounterI_5
    344              if (++sp->s_cnt <= 0)
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xDA06             BGE.N    ??chSemAddCounterI_6
    345                chSchReadyI(fifo_remove(&sp->s_queue))->p_u.rdymsg = RDY_OK;
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       fifo_remove
   \   00000050   0x.... 0x....      BL       chSchReadyI
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6281             STR      R1,[R0, #+40]
    346              n--;
   \                     ??chSemAddCounterI_6:
   \   00000058   0x1E6D             SUBS     R5,R5,#+1
   \   0000005A   0xE7EF             B.N      ??chSemAddCounterI_3
    347            }
    348          }
   \                     ??chSemAddCounterI_5:
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemInit\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemResetI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     `?<Constant "chSemResetI(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemWaitS\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     `?<Constant "chSemWaitS(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemWaitTimeoutS\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     `?<Constant "chSemWaitTimeoutS(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemSignal\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     `?<Constant "chSemSignal(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemSignalI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     `?<Constant "chSemSignalI(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     `?<Constant "\\"chSemAddCounterI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     `?<Constant "chSemAddCounterI(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemInit\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemInit\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x22 0x28    
   \              0x29 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x6B 0x65          DC8 6BH, 65H, 72H, 6EH, 65H, 6CH, 5CH, 73H
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x5C 0x73    
   \   00000038   0x72 0x63          DC8 72H, 63H, 5CH, 63H, 68H, 73H, 65H, 6DH
   \              0x5C 0x63    
   \              0x68 0x73    
   \              0x65 0x6D    
   \   00000040   0x2E 0x63          DC8 2EH, 63H, 0
   \              0x00         
   \   00000043   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemResetI\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemResetI\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x52 0x65    
   \              0x73 0x65    
   \              0x74 0x49    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSemResetI(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSemResetI(), #1"
   \              0x53 0x65    
   \              0x6D 0x52    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x49 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemWaitS\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemWaitS\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x57 0x61    
   \              0x69 0x74    
   \              0x53 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSemWaitS(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSemWaitS(), #1"
   \              0x53 0x65    
   \              0x6D 0x57    
   \              0x61 0x69    
   \              0x74 0x53    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemWaitTimeoutS\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemWaitTimeoutS\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x57 0x61    
   \              0x69 0x74    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x6F 0x75    
   \              0x74 0x53    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSemWaitTimeoutS(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSemWaitTimeoutS(), #1"
   \              0x53 0x65    
   \              0x6D 0x57    
   \              0x61 0x69    
   \              0x74 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x53 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemSignal\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemSignal\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSemSignal(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSemSignal(), #1"
   \              0x53 0x65    
   \              0x6D 0x53    
   \              0x69 0x67    
   \              0x6E 0x61    
   \              0x6C 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemSignalI\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemSignalI\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSemSignalI(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSemSignalI(), #1"
   \              0x53 0x65    
   \              0x6D 0x53    
   \              0x69 0x67    
   \              0x6E 0x61    
   \              0x6C 0x49    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chSemAddCounterI\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chSemAddCounterI\"()"
   \              0x68 0x53    
   \              0x65 0x6D    
   \              0x41 0x64    
   \              0x64 0x43    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSemAddCounterI(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSemAddCounterI(), #1"
   \              0x53 0x65    
   \              0x6D 0x41    
   \              0x64 0x64    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x65    
   \              0x72 0x49    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000017   0x00               DC8 0
    349          
    350          #if CH_USE_SEMSW || defined(__DOXYGEN__)
    351          /**
    352           * @brief   Performs atomic signal and wait operations on two semaphores.
    353           * @pre     The configuration option @p CH_USE_SEMSW must be enabled in order
    354           *          to use this function.
    355           *
    356           * @param[in] sps       pointer to a @p Semaphore structure to be signaled
    357           * @param[in] spw       pointer to a @p Semaphore structure to wait on
    358           * @return              A message specifying how the invoking thread has been
    359           *                      released from the semaphore.
    360           * @retval RDY_OK       if the thread has not stopped on the semaphore or the
    361           *                      semaphore has been signaled.
    362           * @retval RDY_RESET    if the semaphore has been reset using @p chSemReset().
    363           *
    364           * @api
    365           */
    366          msg_t chSemSignalWait(Semaphore *sps, Semaphore *spw) {
    367            msg_t msg;
    368          
    369            chDbgCheck((sps != NULL) && (spw != NULL), "chSemSignalWait");
    370            chDbgAssert(((sps->s_cnt >= 0) && isempty(&sps->s_queue)) ||
    371                        ((sps->s_cnt < 0) && notempty(&sps->s_queue)),
    372                        "chSemSignalWait(), #1",
    373                        "inconsistent semaphore");
    374            chDbgAssert(((spw->s_cnt >= 0) && isempty(&spw->s_queue)) ||
    375                        ((spw->s_cnt < 0) && notempty(&spw->s_queue)),
    376                        "chSemSignalWait(), #2",
    377                        "inconsistent semaphore");
    378          
    379            chSysLock();
    380            if (++sps->s_cnt <= 0)
    381              chSchReadyI(fifo_remove(&sps->s_queue))->p_u.rdymsg = RDY_OK;
    382            if (--spw->s_cnt < 0) {
    383              Thread *ctp = currp;
    384              sem_insert(ctp, &spw->s_queue);
    385              ctp->p_u.wtobjp = spw;
    386              chSchGoSleepS(THD_STATE_WTSEM);
    387              msg = ctp->p_u.rdymsg;
    388            }
    389            else {
    390              chSchRescheduleS();
    391              msg = RDY_OK;
    392            }
    393            chSysUnlock();
    394            return msg;
    395          }
    396          #endif /* CH_USE_SEMSW */
    397          
    398          #endif /* CH_USE_SEMAPHORES */
    399          
    400          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   chSemAddCounterI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchReadyI
        16   -> fifo_remove
      16   chSemInit
        16   -> chDbgPanic3
      16   chSemReset
        16   -> chSchRescheduleS
        16   -> chSemResetI
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chSemResetI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchReadyI
        16   -> lifo_remove
       8   chSemSignal
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> chSchWakeupS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
         8   -> fifo_remove
      16   chSemSignalI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchReadyI
        16   -> fifo_remove
      16   chSemWait
        16   -> chSemWaitS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
       8   chSemWaitS
         8   -> chDbgCheckClassS
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> chSchGoSleepS
         8   -> queue_insert
      16   chSemWaitTimeout
        16   -> chSemWaitTimeoutS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chSemWaitTimeoutS
        16   -> chDbgCheckClassS
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchGoSleepTimeoutS
        16   -> queue_insert
       0   fifo_remove
       0   lifo_remove
       0   queue_insert


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "F:\\stuff\\rusefi_sourc...">
      24  ?<Constant "\"chSemAddCounterI\"()">
      16  ?<Constant "\"chSemInit\"()">
      16  ?<Constant "\"chSemResetI\"()">
      20  ?<Constant "\"chSemSignalI\"()">
      16  ?<Constant "\"chSemSignal\"()">
      16  ?<Constant "\"chSemWaitS\"()">
      24  ?<Constant "\"chSemWaitTimeoutS\"()">
      24  ?<Constant "chSemAddCounterI(), #1">
      20  ?<Constant "chSemResetI(), #1">
      20  ?<Constant "chSemSignal(), #1">
      20  ?<Constant "chSemSignalI(), #1">
      20  ?<Constant "chSemWaitS(), #1">
      24  ?<Constant "chSemWaitTimeoutS(), #1">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      94  chSemAddCounterI
      32  chSemInit
      40  chSemReset
      90  chSemResetI
      94  chSemSignal
      84  chSemSignalI
      36  chSemWait
      96  chSemWaitS
      40  chSemWaitTimeout
     110  chSemWaitTimeoutS
      12  fifo_remove
      12  lifo_remove
      14  queue_insert

 
 328 bytes in section .rodata
 814 bytes in section .text
 
 814 bytes of CODE  memory
 328 bytes of CONST memory

Errors: none
Warnings: none
