###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:24 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\flash.c #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\flash.c #
#                        -lCN F:\stuff\rusefi_sourceforge\firmware\iar\Debug\ #
#                       List\ -lA F:\stuff\rusefi_sourceforge\firmware\iar\De #
#                       bug\List\ -o F:\stuff\rusefi_sourceforge\firmware\iar #
#                       \Debug\Obj\ --no_cse --no_unroll --no_inline          #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\f #
#                       lash.lst                                              #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\fl #
#                       ash.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\hw_layer\flash.c
      1          /**
      2           * @file    flash_main.c
      3           * @brief	Lower-level code related to internal flash memory
      4           */
      5          
      6          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
      7          
      8          #if EFI_INTERNAL_FLASH || defined(__DOXYGEN__)
      9          
     10          #include "flash.h"
     11          #include <string.h>
     12          

   \                                 In section .text, align 2, keep-with-next
     13          size_t flashSectorSize(flashsector_t sector) {
   \                     flashSectorSize:
   \   00000000   0x0001             MOVS     R1,R0
     14          	if (sector <= 3)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDA02             BGE.N    ??flashSectorSize_0
     15          		return 16 * 1024;
   \   00000008   0xF44F 0x4080      MOV      R0,#+16384
   \   0000000C   0xE00F             B.N      ??flashSectorSize_1
     16          	else if (sector == 4)
   \                     ??flashSectorSize_0:
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD102             BNE.N    ??flashSectorSize_2
     17          		return 64 * 1024;
   \   00000014   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000018   0xE009             B.N      ??flashSectorSize_1
     18          	else if (sector >= 5 && sector <= 11)
   \                     ??flashSectorSize_2:
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2905             CMP      R1,#+5
   \   0000001E   0xDB05             BLT.N    ??flashSectorSize_3
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x290C             CMP      R1,#+12
   \   00000024   0xDA02             BGE.N    ??flashSectorSize_3
     19          		return 128 * 1024;
   \   00000026   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000002A   0xE000             B.N      ??flashSectorSize_1
     20          	return 0;
   \                     ??flashSectorSize_3:
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??flashSectorSize_1:
   \   0000002E   0x4770             BX       LR               ;; return
     21          }
     22          

   \                                 In section .text, align 2, keep-with-next
     23          flashaddr_t flashSectorBegin(flashsector_t sector) {
   \                     flashSectorBegin:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     24          	flashaddr_t address = FLASH_BASE;
   \   00000004   0xF05F 0x6500      MOVS     R5,#+134217728
     25          	while (sector > 0) {
   \                     ??flashSectorBegin_0:
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD007             BEQ.N    ??flashSectorBegin_1
     26          		--sector;
   \   0000000E   0x1E64             SUBS     R4,R4,#+1
     27          		address += flashSectorSize(sector);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       flashSectorSize
   \   00000018   0x1940             ADDS     R0,R0,R5
   \   0000001A   0x0005             MOVS     R5,R0
   \   0000001C   0xE7F4             B.N      ??flashSectorBegin_0
     28          	}
     29          	return address;
   \                     ??flashSectorBegin_1:
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     30          }
     31          

   \                                 In section .text, align 2, keep-with-next
     32          flashaddr_t flashSectorEnd(flashsector_t sector) {
   \                     flashSectorEnd:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     33          	return flashSectorBegin(sector + 1);
   \   00000004   0x1C60             ADDS     R0,R4,#+1
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       flashSectorBegin
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     34          }
     35          

   \                                 In section .text, align 2, keep-with-next
     36          flashsector_t flashSectorAt(flashaddr_t address) {
   \                     flashSectorAt:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     37          	flashsector_t sector = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     38          	while (address >= flashSectorEnd(sector))
   \                     ??flashSectorAt_0:
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       flashSectorEnd
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD301             BCC.N    ??flashSectorAt_1
     39          		++sector;
   \   00000012   0x1C6D             ADDS     R5,R5,#+1
   \   00000014   0xE7F7             B.N      ??flashSectorAt_0
     40          	return sector;
   \                     ??flashSectorAt_1:
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     41          }
     42          
     43          /**
     44           * @brief Wait for the flash operation to finish.
     45           */
     46          #define flashWaitWhileBusy() { while (FLASH->SR & FLASH_SR_BSY) {} }
     47          
     48          /**
     49           * @brief Unlock the flash memory for write access.
     50           * @return CH_SUCCESS  Unlock was successful.
     51           * @return CH_FAILED    Unlock failed.
     52           */

   \                                 In section .text, align 2, keep-with-next
     53          static bool flashUnlock(void) {
     54          	/* Check if unlock is really needed */
     55          	if (!(FLASH->CR & FLASH_CR_LOCK))
   \                     flashUnlock:
   \   00000000   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD401             BMI.N    ??flashUnlock_0
     56          		return CH_SUCCESS;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE00C             B.N      ??flashUnlock_1
     57          
     58          	/* Write magic unlock sequence */
     59          	FLASH->KEYR = 0x45670123;
   \                     ??flashUnlock_0:
   \   0000000C   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40023c04
   \   0000000E   0x....             LDR.N    R1,??DataTable3_2  ;; 0x45670123
   \   00000010   0x6001             STR      R1,[R0, #+0]
     60          	FLASH->KEYR = 0xCDEF89AB;
   \   00000012   0x....             LDR.N    R0,??DataTable3_1  ;; 0x40023c04
   \   00000014   0x....             LDR.N    R1,??DataTable3_3  ;; 0xcdef89ab
   \   00000016   0x6001             STR      R1,[R0, #+0]
     61          
     62          	/* Check if unlock was successful */
     63          	if (FLASH->CR & FLASH_CR_LOCK)
   \   00000018   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD501             BPL.N    ??flashUnlock_2
     64          		return CH_FAILED;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??flashUnlock_1
     65          	return CH_SUCCESS;
   \                     ??flashUnlock_2:
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??flashUnlock_1:
   \   00000026   0x4770             BX       LR               ;; return
     66          }
     67          
     68          /**
     69           * @brief Lock the flash memory for write access.
     70           */
     71          #define flashLock() { FLASH->CR |= FLASH_CR_LOCK; }
     72          

   \                                 In section .text, align 2, keep-with-next
     73          int flashSectorErase(flashsector_t sector) {
   \                     flashSectorErase:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     74          	/* Unlock flash for write access */
     75          	if (flashUnlock() == CH_FAILED)
   \   00000004   0x.... 0x....      BL       flashUnlock
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??flashSectorErase_0
     76          		return FLASH_RETURN_NO_PERMISSION;
   \   0000000C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000010   0xE063             B.N      ??flashSectorErase_1
     77          
     78          	/* Wait for any busy flags. */
     79          	flashWaitWhileBusy();
   \                     ??flashSectorErase_0:
   \   00000012   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40023c0c
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x03C0             LSLS     R0,R0,#+15
   \   00000018   0xD4FB             BMI.N    ??flashSectorErase_0
     80          
     81          	/* Setup parallelism before any program/erase */
     82          	FLASH->CR &= ~FLASH_CR_PSIZE_MASK;
   \   0000001A   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000022   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   00000024   0x6008             STR      R0,[R1, #+0]
     83          	FLASH->CR |= FLASH_CR_PSIZE_VALUE;
   \   00000026   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000002E   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   00000030   0x6008             STR      R0,[R1, #+0]
     84          
     85          	/* Start deletion of sector.
     86          	 * SNB(3:1) is defined as:
     87          	 * 0000 sector 0
     88          	 * 0001 sector 1
     89          	 * ...
     90          	 * 1011 sector 11
     91          	 * others not allowed */
     92          	FLASH->CR &= ~(FLASH_CR_SNB_0 | FLASH_CR_SNB_1 | FLASH_CR_SNB_2 | FLASH_CR_SNB_3);
   \   00000032   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF030 0x0078      BICS     R0,R0,#0x78
   \   0000003A   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   0000003C   0x6008             STR      R0,[R1, #+0]
     93          	if (sector & 0x1)
   \   0000003E   0x07E0             LSLS     R0,R4,#+31
   \   00000040   0xD505             BPL.N    ??flashSectorErase_2
     94          		FLASH->CR |= FLASH_CR_SNB_0;
   \   00000042   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000004A   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   0000004C   0x6008             STR      R0,[R1, #+0]
     95          	if (sector & 0x2)
   \                     ??flashSectorErase_2:
   \   0000004E   0x07A0             LSLS     R0,R4,#+30
   \   00000050   0xD505             BPL.N    ??flashSectorErase_3
     96          		FLASH->CR |= FLASH_CR_SNB_1;
   \   00000052   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005A   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   0000005C   0x6008             STR      R0,[R1, #+0]
     97          	if (sector & 0x4)
   \                     ??flashSectorErase_3:
   \   0000005E   0x0760             LSLS     R0,R4,#+29
   \   00000060   0xD505             BPL.N    ??flashSectorErase_4
     98          		FLASH->CR |= FLASH_CR_SNB_2;
   \   00000062   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000006A   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   0000006C   0x6008             STR      R0,[R1, #+0]
     99          	if (sector & 0x8)
   \                     ??flashSectorErase_4:
   \   0000006E   0x0720             LSLS     R0,R4,#+28
   \   00000070   0xD505             BPL.N    ??flashSectorErase_5
    100          		FLASH->CR |= FLASH_CR_SNB_3;
   \   00000072   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000007A   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    101          	FLASH->CR |= FLASH_CR_SER;
   \                     ??flashSectorErase_5:
   \   0000007E   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000086   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   00000088   0x6008             STR      R0,[R1, #+0]
    102          	FLASH->CR |= FLASH_CR_STRT;
   \   0000008A   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000092   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   00000094   0x6008             STR      R0,[R1, #+0]
    103          
    104          	/* Wait until it's finished. */
    105          	flashWaitWhileBusy();
   \                     ??flashSectorErase_6:
   \   00000096   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40023c0c
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x03C0             LSLS     R0,R0,#+15
   \   0000009C   0xD4FB             BMI.N    ??flashSectorErase_6
    106          
    107          	/* Sector erase flag does not clear automatically. */
    108          	FLASH->CR &= ~FLASH_CR_SER;
   \   0000009E   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000000A6   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    109          
    110          	/* Lock flash again */
    111          	flashLock()
   \   000000AA   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000000B2   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    112          	;
    113          
    114          	/* Check deleted sector for errors */
    115          	if (flashIsErased(flashSectorBegin(sector), flashSectorSize(sector)) == FALSE)
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x.... 0x....      BL       flashSectorSize
   \   000000BE   0x0005             MOVS     R5,R0
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x.... 0x....      BL       flashSectorBegin
   \   000000C8   0x0029             MOVS     R1,R5
   \   000000CA   0x.... 0x....      BL       flashIsErased
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD102             BNE.N    ??flashSectorErase_7
    116          		return FLASH_RETURN_BAD_FLASH; /* Sector is not empty despite the erase cycle! */
   \   000000D2   0xF07F 0x000A      MVNS     R0,#+10
   \   000000D6   0xE000             B.N      ??flashSectorErase_1
    117          
    118          	/* Successfully deleted sector */
    119          	return FLASH_RETURN_SUCCESS;
   \                     ??flashSectorErase_7:
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??flashSectorErase_1:
   \   000000DA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    120          }
    121          

   \                                 In section .text, align 2, keep-with-next
    122          int flashErase(flashaddr_t address, size_t size) {
   \                     flashErase:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    123          	while (size > 0) {
   \                     ??flashErase_0:
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD019             BEQ.N    ??flashErase_1
    124          		flashsector_t sector = flashSectorAt(address);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       flashSectorAt
   \   00000010   0x0006             MOVS     R6,R0
    125          		int err = flashSectorErase(sector);
   \   00000012   0x0030             MOVS     R0,R6
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       flashSectorErase
   \   0000001A   0x0007             MOVS     R7,R0
    126          		if (err != FLASH_RETURN_SUCCESS)
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD001             BEQ.N    ??flashErase_2
    127          			return err;
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0xE00D             B.N      ??flashErase_3
    128          		address = flashSectorEnd(sector);
   \                     ??flashErase_2:
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       flashSectorEnd
   \   0000002C   0x0004             MOVS     R4,R0
    129          		size_t sector_size = flashSectorSize(sector);
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       flashSectorSize
    130          		if (sector_size >= size)
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD201             BCS.N    ??flashErase_1
    131          			break;
    132          		size -= sector_size;
   \                     ??flashErase_4:
   \   0000003A   0x1A2D             SUBS     R5,R5,R0
   \   0000003C   0xE7E3             B.N      ??flashErase_0
    133          	}
    134          
    135          	return FLASH_RETURN_SUCCESS;
   \                     ??flashErase_1:
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??flashErase_3:
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          bool flashIsErased(flashaddr_t address, size_t size) {
   \                     flashIsErased:
   \   00000000   0x0002             MOVS     R2,R0
    139          	/* Check for default set bits in the flash memory
    140          	 * For efficiency, compare flashdata_t values as much as possible,
    141          	 * then, fallback to byte per byte comparison. */
    142          	while (size >= sizeof(flashdata_t)) {
   \                     ??flashIsErased_0:
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD308             BCC.N    ??flashIsErased_1
    143          		if (*(volatile flashdata_t*) address != (flashdata_t) (-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0xF110 0x0F01      CMN      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??flashIsErased_2
    144          			return false;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE00D             B.N      ??flashIsErased_3
    145          		address += sizeof(flashdata_t);
   \                     ??flashIsErased_2:
   \   00000012   0x1D12             ADDS     R2,R2,#+4
    146          		size -= sizeof(flashdata_t);
   \   00000014   0x1F09             SUBS     R1,R1,#+4
   \   00000016   0xE7F4             B.N      ??flashIsErased_0
    147          	}
    148          	while (size > 0) {
   \                     ??flashIsErased_1:
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD007             BEQ.N    ??flashIsErased_4
    149          		if (*(char*) address != 0xFF)
   \   0000001C   0x7810             LDRB     R0,[R2, #+0]
   \   0000001E   0x28FF             CMP      R0,#+255
   \   00000020   0xD001             BEQ.N    ??flashIsErased_5
    150          			return false;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE003             B.N      ??flashIsErased_3
    151          		++address;
   \                     ??flashIsErased_5:
   \   00000026   0x1C52             ADDS     R2,R2,#+1
    152          		--size;
   \   00000028   0x1E49             SUBS     R1,R1,#+1
   \   0000002A   0xE7F5             B.N      ??flashIsErased_1
    153          	}
    154          
    155          	return TRUE;
   \                     ??flashIsErased_4:
   \   0000002C   0x2001             MOVS     R0,#+1
   \                     ??flashIsErased_3:
   \   0000002E   0x4770             BX       LR               ;; return
    156          }
    157          

   \                                 In section .text, align 2, keep-with-next
    158          bool flashCompare(flashaddr_t address, const char* buffer, size_t size) {
   \                     flashCompare:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0003             MOVS     R3,R0
    159          	/* For efficiency, compare flashdata_t values as much as possible,
    160          	 * then, fallback to byte per byte comparison. */
    161          	while (size >= sizeof(flashdata_t)) {
   \                     ??flashCompare_0:
   \   00000004   0x2A04             CMP      R2,#+4
   \   00000006   0xD309             BCC.N    ??flashCompare_1
    162          		if (*(volatile flashdata_t*) address != *(flashdata_t*) buffer)
   \   00000008   0x6818             LDR      R0,[R3, #+0]
   \   0000000A   0x680C             LDR      R4,[R1, #+0]
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD001             BEQ.N    ??flashCompare_2
    163          			return FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE010             B.N      ??flashCompare_3
    164          		address += sizeof(flashdata_t);
   \                     ??flashCompare_2:
   \   00000014   0x1D1B             ADDS     R3,R3,#+4
    165          		buffer += sizeof(flashdata_t);
   \   00000016   0x1D09             ADDS     R1,R1,#+4
    166          		size -= sizeof(flashdata_t);
   \   00000018   0x1F12             SUBS     R2,R2,#+4
   \   0000001A   0xE7F3             B.N      ??flashCompare_0
    167          	}
    168          	while (size > 0) {
   \                     ??flashCompare_1:
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD009             BEQ.N    ??flashCompare_4
    169          		if (*(volatile char*) address != *buffer)
   \   00000020   0x7818             LDRB     R0,[R3, #+0]
   \   00000022   0x780C             LDRB     R4,[R1, #+0]
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD001             BEQ.N    ??flashCompare_5
    170          			return FALSE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE004             B.N      ??flashCompare_3
    171          		++address;
   \                     ??flashCompare_5:
   \   0000002C   0x1C5B             ADDS     R3,R3,#+1
    172          		++buffer;
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
    173          		--size;
   \   00000030   0x1E52             SUBS     R2,R2,#+1
   \   00000032   0xE7F3             B.N      ??flashCompare_1
    174          	}
    175          
    176          	return TRUE;
   \                     ??flashCompare_4:
   \   00000034   0x2001             MOVS     R0,#+1
   \                     ??flashCompare_3:
   \   00000036   0xBC10             POP      {R4}
   \   00000038   0x4770             BX       LR               ;; return
    177          }
    178          

   \                                 In section .text, align 2, keep-with-next
    179          int flashRead(flashaddr_t address, char* buffer, size_t size) {
   \                     flashRead:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    180          	memcpy(buffer, (char*) address, size);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0021             MOVS     R1,R4
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       memcpy
    181          	return FLASH_RETURN_SUCCESS;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
    182          }
    183          

   \                                 In section .text, align 2, keep-with-next
    184          static void flashWriteData(flashaddr_t address, const flashdata_t data) {
    185          	/* Enter flash programming mode */
    186          	FLASH->CR |= FLASH_CR_PG;
   \                     flashWriteData:
   \   00000000   0x....             LDR.N    R2,??DataTable3  ;; 0x40023c10
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000008   0x....             LDR.N    R3,??DataTable3  ;; 0x40023c10
   \   0000000A   0x601A             STR      R2,[R3, #+0]
    187          
    188          	/* Write the data */
    189          	*(flashdata_t*) address = data;
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    190          
    191          	/* Wait for completion */
    192          	flashWaitWhileBusy();
   \                     ??flashWriteData_0:
   \   0000000E   0x....             LDR.N    R2,??DataTable3_4  ;; 0x40023c0c
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x03D2             LSLS     R2,R2,#+15
   \   00000014   0xD4FB             BMI.N    ??flashWriteData_0
    193          
    194          	/* Exit flash programming mode */
    195          	FLASH->CR &= ~FLASH_CR_PG;
   \   00000016   0x....             LDR.N    R2,??DataTable3  ;; 0x40023c10
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x0852             LSRS     R2,R2,#+1
   \   0000001C   0x0052             LSLS     R2,R2,#+1
   \   0000001E   0x....             LDR.N    R3,??DataTable3  ;; 0x40023c10
   \   00000020   0x601A             STR      R2,[R3, #+0]
    196          }
   \   00000022   0x4770             BX       LR               ;; return
    197          

   \                                 In section .text, align 2, keep-with-next
    198          int flashWrite(flashaddr_t address, const char* buffer, size_t size) {
   \                     flashWrite:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    199          	/* Unlock flash for write access */
    200          	if (flashUnlock() == CH_FAILED)
   \   0000000C   0x.... 0x....      BL       flashUnlock
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??flashWrite_0
    201          		return FLASH_RETURN_NO_PERMISSION;
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0xE04E             B.N      ??flashWrite_1
    202          
    203          	/* Wait for any busy flags */
    204          	flashWaitWhileBusy();
   \                     ??flashWrite_0:
   \   0000001A   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40023c0c
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x03C0             LSLS     R0,R0,#+15
   \   00000020   0xD4FB             BMI.N    ??flashWrite_0
    205          
    206          	/* Setup parallelism before any program/erase */
    207          	FLASH->CR &= ~FLASH_CR_PSIZE_MASK;
   \   00000022   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000002A   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    208          	FLASH->CR |= FLASH_CR_PSIZE_VALUE;
   \   0000002E   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000036   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   00000038   0x6008             STR      R0,[R1, #+0]
    209          
    210          	/* Check if the flash address is correctly aligned */
    211          	size_t alignOffset = address % sizeof(flashdata_t);
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0xFBB4 0xF7F0      UDIV     R7,R4,R0
   \   00000040   0xFB07 0x4710      MLS      R7,R7,R0,R4
    212          //	print("flash alignOffset=%d\r\n", alignOffset);
    213          	if (alignOffset != 0) {
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD019             BEQ.N    ??flashWrite_2
    214          		/* Not aligned, thus we have to read the data in flash already present
    215          		 * and update them with buffer's data */
    216          
    217          		/* Align the flash address correctly */
    218          		flashaddr_t alignedFlashAddress = address - alignOffset;
   \   00000048   0xEBB4 0x0807      SUBS     R8,R4,R7
    219          
    220          		/* Read already present data */
    221          		flashdata_t tmp = *(volatile flashdata_t*) alignedFlashAddress;
   \   0000004C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000050   0x9001             STR      R0,[SP, #+4]
    222          
    223          		/* Compute how much bytes one must update in the data read */
    224          		size_t chunkSize = sizeof(flashdata_t) - alignOffset;
   \   00000052   0xF1D7 0x0904      RSBS     R9,R7,#+4
    225          		if (chunkSize > size)
   \   00000056   0x454E             CMP      R6,R9
   \   00000058   0xD200             BCS.N    ??flashWrite_3
    226          			chunkSize = size; // this happens when both address and address + size are not aligned
   \   0000005A   0x46B1             MOV      R9,R6
    227          
    228          		/* Update the read data with buffer's data */
    229          		memcpy((char*) &tmp + alignOffset, buffer, chunkSize);
   \                     ??flashWrite_3:
   \   0000005C   0x464A             MOV      R2,R9
   \   0000005E   0x0029             MOVS     R1,R5
   \   00000060   0xA801             ADD      R0,SP,#+4
   \   00000062   0x1838             ADDS     R0,R7,R0
   \   00000064   0x.... 0x....      BL       memcpy
    230          
    231          		/* Write the new data in flash */
    232          		flashWriteData(alignedFlashAddress, tmp);
   \   00000068   0x9901             LDR      R1,[SP, #+4]
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       flashWriteData
    233          
    234          		/* Advance */
    235          		address += chunkSize;
   \   00000070   0xEB19 0x0404      ADDS     R4,R9,R4
    236          		buffer += chunkSize;
   \   00000074   0xEB19 0x0505      ADDS     R5,R9,R5
    237          		size -= chunkSize;
   \   00000078   0xEBB6 0x0609      SUBS     R6,R6,R9
    238          	}
    239          
    240          	/* Now, address is correctly aligned. One can copy data directly from
    241          	 * buffer's data to flash memory until the size of the data remaining to be
    242          	 * copied requires special treatment. */
    243          	while (size >= sizeof(flashdata_t)) {
   \                     ??flashWrite_2:
   \   0000007C   0x2E04             CMP      R6,#+4
   \   0000007E   0xD307             BCC.N    ??flashWrite_4
    244          //		print("flash write size=%d\r\n", size);
    245          		flashWriteData(address, *(const flashdata_t*) buffer);
   \   00000080   0x6829             LDR      R1,[R5, #+0]
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       flashWriteData
    246          		address += sizeof(flashdata_t);
   \   00000088   0x1D24             ADDS     R4,R4,#+4
    247          		buffer += sizeof(flashdata_t);
   \   0000008A   0x1D2D             ADDS     R5,R5,#+4
    248          		size -= sizeof(flashdata_t);
   \   0000008C   0x1F36             SUBS     R6,R6,#+4
   \   0000008E   0xE7F5             B.N      ??flashWrite_2
    249          	}
    250          
    251          	/* Now, address is correctly aligned, but the remaining data are to
    252          	 * small to fill a entier flashdata_t. Thus, one must read data already
    253          	 * in flash and update them with buffer's data before writing an entire
    254          	 * flashdata_t to flash memory. */
    255          	if (size > 0) {
   \                     ??flashWrite_4:
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD00A             BEQ.N    ??flashWrite_5
    256          		flashdata_t tmp = *(volatile flashdata_t*) address;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x9000             STR      R0,[SP, #+0]
    257          		memcpy(&tmp, buffer, size);
   \   00000098   0x0032             MOVS     R2,R6
   \   0000009A   0x0029             MOVS     R1,R5
   \   0000009C   0xA800             ADD      R0,SP,#+0
   \   0000009E   0x.... 0x....      BL       memcpy
    258          		flashWriteData(address, tmp);
   \   000000A2   0x9900             LDR      R1,[SP, #+0]
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       flashWriteData
    259          	}
    260          
    261          	/* Lock flash again */
    262          	flashLock()
   \                     ??flashWrite_5:
   \   000000AA   0x....             LDR.N    R0,??DataTable3  ;; 0x40023c10
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000000B2   0x....             LDR.N    R1,??DataTable3  ;; 0x40023c10
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    263          	;
    264          
    265          	return FLASH_RETURN_SUCCESS;
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??flashWrite_1:
   \   000000B8   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    266          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40023C0C         DC32     0x40023c0c
    267          
    268          #endif /* EFI_INTERNAL_FLASH */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   flashCompare
      24   flashErase
        24   -> flashSectorAt
        24   -> flashSectorEnd
        24   -> flashSectorErase
        24   -> flashSectorSize
       0   flashIsErased
      16   flashRead
        16   -> memcpy
      16   flashSectorAt
        16   -> flashSectorEnd
      16   flashSectorBegin
        16   -> flashSectorSize
       8   flashSectorEnd
         8   -> flashSectorBegin
      16   flashSectorErase
        16   -> flashIsErased
        16   -> flashSectorBegin
        16   -> flashSectorSize
        16   -> flashUnlock
       0   flashSectorSize
       0   flashUnlock
      40   flashWrite
        40   -> flashUnlock
        40   -> flashWriteData
        40   -> memcpy
       0   flashWriteData
      16   memcpy
        16   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
      58  flashCompare
      66  flashErase
      48  flashIsErased
      22  flashRead
      28  flashSectorAt
      34  flashSectorBegin
      14  flashSectorEnd
     220  flashSectorErase
      48  flashSectorSize
      40  flashUnlock
     188  flashWrite
      36  flashWriteData
      22  memcpy

 
 844 bytes in section .text
 
 822 bytes of CODE memory (+ 22 bytes shared)

Errors: none
Warnings: 1
