###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:43 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chschd.c                                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chschd.c -lCN F:\stuff\rusefi_sourceforge\firmw #
#                       are\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\List\ -o                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hschd.lst                                             #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       schd.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chschd.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chschd.c
     30           * @brief   Scheduler code.
     31           *
     32           * @addtogroup scheduler
     33           * @details This module provides the default portable scheduler code,
     34           *          scheduler functions can be individually captured by the port
     35           *          layer in order to provide architecture optimized equivalents.
     36           *          When a function is captured its default code is not built into
     37           *          the OS image, the optimized version is included instead.
     38           * @{
     39           */
     40          
     41          #include "ch.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *fifo_remove(ThreadsQueue *)
   \                     fifo_remove:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   \   00000008   0x6051             STR      R1,[R2, #+4]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *dequeue(struct Thread *)
   \                     dequeue:
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x600A             STR      R2,[R1, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   \   0000000C   0x4770             BX       LR               ;; return
     42          
     43          /**
     44           * @brief   Ready list header.
     45           */
     46          #if !defined(PORT_OPTIMIZED_RLIST_VAR) || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     47          ReadyList rlist;
   \                     rlist:
   \   00000000                      DS8 28
     48          #endif /* !defined(PORT_OPTIMIZED_RLIST_VAR) */
     49          
     50          /**
     51           * @brief   Scheduler initialization.
     52           *
     53           * @notapi
     54           */

   \                                 In section .text, align 2, keep-with-next
     55          void _scheduler_init(void) {
     56          
     57            queue_init(&rlist.r_queue);
   \                     _scheduler_init:
   \   00000000   0x....             LDR.N    R0,??DataTable8
   \   00000002   0x....             LDR.N    R1,??DataTable8
   \   00000004   0x6048             STR      R0,[R1, #+4]
   \   00000006   0x....             LDR.N    R1,??DataTable8
   \   00000008   0x6008             STR      R0,[R1, #+0]
     58            rlist.r_prio = NOPRIO;
   \   0000000A   0x....             LDR.N    R0,??DataTable8
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
     59          #if CH_USE_REGISTRY
     60            rlist.r_newer = rlist.r_older = (Thread *)&rlist;
   \   00000010   0x....             LDR.N    R0,??DataTable8
   \   00000012   0x....             LDR.N    R1,??DataTable8
   \   00000014   0x6148             STR      R0,[R1, #+20]
   \   00000016   0x....             LDR.N    R1,??DataTable8
   \   00000018   0x6108             STR      R0,[R1, #+16]
     61          #endif
     62          }
   \   0000001A   0x4770             BX       LR               ;; return
     63          
     64          /**
     65           * @brief   Inserts a thread in the Ready List.
     66           * @details The thread is positioned behind all threads with higher or equal
     67           *          priority.
     68           * @pre     The thread must not be already inserted in any list through its
     69           *          @p p_next and @p p_prev or list corruption would occur.
     70           * @post    This function does not reschedule so a call to a rescheduling
     71           *          function must be performed before unlocking the kernel. Note that
     72           *          interrupt handlers always reschedule on exit so an explicit
     73           *          reschedule must not be performed in ISRs.
     74           *
     75           * @param[in] tp        the thread to be made ready
     76           * @return              The thread pointer.
     77           *
     78           * @iclass
     79           */
     80          #if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
     81          Thread *chSchReadyI(Thread *tp) {
   \                     chSchReadyI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     82            Thread *cp;
     83          
     84            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
     85          
     86            /* Integrity checks.*/
     87            chDbgAssert((tp->p_state != THD_STATE_READY) &&
     88                        (tp->p_state != THD_STATE_FINAL),
     89                        "chSchReadyI(), #1",
     90                        "invalid state");
   \   00000008   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??chSchReadyI_0
   \   00000010   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000014   0x280E             CMP      R0,#+14
   \   00000016   0xD102             BNE.N    ??chSchReadyI_1
   \                     ??chSchReadyI_0:
   \   00000018   0x....             LDR.N    R0,??DataTable8_1
   \   0000001A   0x.... 0x....      BL       chDbgPanic
     91          
     92            tp->p_state = THD_STATE_READY;
   \                     ??chSchReadyI_1:
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x0020      STRB     R0,[R4, #+32]
     93            cp = (Thread *)&rlist.r_queue;
   \   00000024   0x....             LDR.N    R0,??DataTable8
   \   00000026   0x0005             MOVS     R5,R0
     94            do {
     95              cp = cp->p_next;
   \                     ??chSchReadyI_2:
   \   00000028   0x682D             LDR      R5,[R5, #+0]
     96            } while (cp->p_prio >= tp->p_prio);
   \   0000002A   0x68A8             LDR      R0,[R5, #+8]
   \   0000002C   0x68A1             LDR      R1,[R4, #+8]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD2FA             BCS.N    ??chSchReadyI_2
     97            /* Insertion on p_prev.*/
     98            tp->p_next = cp;
   \   00000032   0x6025             STR      R5,[R4, #+0]
     99            tp->p_prev = cp->p_prev;
   \   00000034   0x6868             LDR      R0,[R5, #+4]
   \   00000036   0x6060             STR      R0,[R4, #+4]
    100            tp->p_prev->p_next = cp->p_prev = tp;
   \   00000038   0x606C             STR      R4,[R5, #+4]
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x6004             STR      R4,[R0, #+0]
    101            return tp;
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    102          }
    103          #endif /* !defined(PORT_OPTIMIZED_READYI) */
    104          
    105          /**
    106           * @brief   Puts the current thread to sleep into the specified state.
    107           * @details The thread goes into a sleeping state. The possible
    108           *          @ref thread_states are defined into @p threads.h.
    109           *
    110           * @param[in] newstate  the new thread state
    111           *
    112           * @sclass
    113           */
    114          #if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    115          void chSchGoSleepS(tstate_t newstate) {
   \                     chSchGoSleepS:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    116            Thread *otp;
    117          
    118            chDbgCheckClassS();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassS
    119          
    120            (otp = currp)->p_state = newstate;
   \   00000008   0x....             LDR.N    R0,??DataTable8
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0x0005             MOVS     R5,R0
   \   0000000E   0xF880 0x4020      STRB     R4,[R0, #+32]
    121          #if CH_TIME_QUANTUM > 0
    122            /* The thread is renouncing its remaining time slices so it will have a new
    123               time quantum when it will wakeup.*/
    124            otp->p_preempt = CH_TIME_QUANTUM;
   \   00000012   0x2014             MOVS     R0,#+20
   \   00000014   0xF885 0x0022      STRB     R0,[R5, #+34]
    125          #endif
    126            setcurrp(fifo_remove(&rlist.r_queue));
   \   00000018   0x....             LDR.N    R0,??DataTable8
   \   0000001A   0x.... 0x....      BL       fifo_remove
   \   0000001E   0x....             LDR.N    R1,??DataTable8
   \   00000020   0x6188             STR      R0,[R1, #+24]
    127            currp->p_state = THD_STATE_CURRENT;
   \   00000022   0x....             LDR.N    R0,??DataTable8
   \   00000024   0x6980             LDR      R0,[R0, #+24]
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF880 0x1020      STRB     R1,[R0, #+32]
    128            chSysSwitch(currp, otp);
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       dbg_trace
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       getRemainingStack
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD502             BPL.N    ??chSchGoSleepS_0
   \   0000003C   0x....             LDR.N    R0,??DataTable8_2
   \   0000003E   0x.... 0x....      BL       chDbgPanic
   \                     ??chSchGoSleepS_0:
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0x....             LDR.N    R0,??DataTable8
   \   00000046   0x6980             LDR      R0,[R0, #+24]
   \   00000048   0x.... 0x....      BL       _port_switch
    129          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    130          #endif /* !defined(PORT_OPTIMIZED_GOSLEEPS) */
    131          
    132          #if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
    133          /*
    134           * Timeout wakeup callback.
    135           */

   \                                 In section .text, align 2, keep-with-next
    136          static void wakeup(void *p) {
   \                     wakeup:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    137            Thread *tp = (Thread *)p;
   \   00000004   0x0025             MOVS     R5,R4
    138          
    139            chSysLockFromIsr();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock_from_isr
    140            switch (tp->p_state) {
   \   00000010   0xF895 0x0020      LDRB     R0,[R5, #+32]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??wakeup_0
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD008             BEQ.N    ??wakeup_1
   \   0000001C   0x280D             CMP      R0,#+13
   \   0000001E   0xD00B             BEQ.N    ??wakeup_2
   \   00000020   0xE00D             B.N      ??wakeup_3
    141            case THD_STATE_READY:
    142              /* Handling the special case where the thread has been made ready by
    143                 another thread with higher priority.*/
    144              chSysUnlockFromIsr();
   \                     ??wakeup_0:
   \   00000022   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF380 0x8811      MSR      BASEPRI,R0
    145              return;
   \   0000002C   0xE012             B.N      ??wakeup_4
    146          #if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    147              (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
    148          #if CH_USE_SEMAPHORES
    149            case THD_STATE_WTSEM:
    150              chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
   \                     ??wakeup_1:
   \   0000002E   0x6AA8             LDR      R0,[R5, #+40]
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x6AA9             LDR      R1,[R5, #+40]
   \   00000036   0x6088             STR      R0,[R1, #+8]
    151              /* Falls into, intentional. */
    152          #endif
    153          #if CH_USE_QUEUES
    154            case THD_STATE_WTQUEUE:
    155          #endif
    156          #if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
    157            case THD_STATE_WTCOND:
    158          #endif
    159              /* States requiring dequeuing.*/
    160              dequeue(tp);
   \                     ??wakeup_2:
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       dequeue
    161          #endif
    162            }
    163            tp->p_u.rdymsg = RDY_TIMEOUT;
   \                     ??wakeup_3:
   \   0000003E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000042   0x62A8             STR      R0,[R5, #+40]
    164            chSchReadyI(tp);
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       chSchReadyI
    165            chSysUnlockFromIsr();
   \   0000004A   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF380 0x8811      MSR      BASEPRI,R0
    166          }
   \                     ??wakeup_4:
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    167          
    168          /**
    169           * @brief   Puts the current thread to sleep into the specified state with
    170           *          timeout specification.
    171           * @details The thread goes into a sleeping state, if it is not awakened
    172           *          explicitly within the specified timeout then it is forcibly
    173           *          awakened with a @p RDY_TIMEOUT low level message. The possible
    174           *          @ref thread_states are defined into @p threads.h.
    175           *
    176           * @param[in] newstate  the new thread state
    177           * @param[in] time      the number of ticks before the operation timeouts, the
    178           *                      special values are handled as follow:
    179           *                      - @a TIME_INFINITE the thread enters an infinite sleep
    180           *                        state, this is equivalent to invoking
    181           *                        @p chSchGoSleepS() but, of course, less efficient.
    182           *                      - @a TIME_IMMEDIATE this value is not allowed.
    183           *                      .
    184           * @return              The wakeup message.
    185           * @retval RDY_TIMEOUT if a timeout occurs.
    186           *
    187           * @sclass
    188           */

   \                                 In section .text, align 2, keep-with-next
    189          msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
   \                     chSchGoSleepTimeoutS:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    190          
    191            chDbgCheckClassS();
   \   00000008   0x.... 0x....      BL       chDbgCheckClassS
    192          
    193            if (TIME_INFINITE != time) {
   \   0000000C   0xF115 0x0F01      CMN      R5,#+1
   \   00000010   0xD011             BEQ.N    ??chSchGoSleepTimeoutS_0
    194              VirtualTimer vt;
    195          
    196              chVTSetI(&vt, time, wakeup, currp);
   \   00000012   0x....             LDR.N    R0,??DataTable8
   \   00000014   0x6983             LDR      R3,[R0, #+24]
   \   00000016   0x....             LDR.N    R2,??DataTable8_3
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       chVTSetI
    197              chSchGoSleepS(newstate);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x.... 0x....      BL       chSchGoSleepS
    198              if (chVTIsArmedI(&vt))
   \   00000028   0x9803             LDR      R0,[SP, #+12]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD007             BEQ.N    ??chSchGoSleepTimeoutS_1
    199                chVTResetI(&vt);
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       chVTResetI
   \   00000034   0xE003             B.N      ??chSchGoSleepTimeoutS_1
    200            }
    201            else
    202              chSchGoSleepS(newstate);
   \                     ??chSchGoSleepTimeoutS_0:
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       chSchGoSleepS
    203            return currp->p_u.rdymsg;
   \                     ??chSchGoSleepTimeoutS_1:
   \   0000003E   0x....             LDR.N    R0,??DataTable8
   \   00000040   0x6980             LDR      R0,[R0, #+24]
   \   00000042   0x6A80             LDR      R0,[R0, #+40]
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xBD30             POP      {R4,R5,PC}       ;; return
    204          }
    205          #endif /* !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) */
    206          
    207          /**
    208           * @brief   Wakes up a thread.
    209           * @details The thread is inserted into the ready list or immediately made
    210           *          running depending on its relative priority compared to the current
    211           *          thread.
    212           * @pre     The thread must not be already inserted in any list through its
    213           *          @p p_next and @p p_prev or list corruption would occur.
    214           * @note    It is equivalent to a @p chSchReadyI() followed by a
    215           *          @p chSchRescheduleS() but much more efficient.
    216           * @note    The function assumes that the current thread has the highest
    217           *          priority.
    218           *
    219           * @param[in] ntp       the Thread to be made ready
    220           * @param[in] msg       message to the awakened thread
    221           *
    222           * @sclass
    223           */
    224          #if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    225          void chSchWakeupS(Thread *ntp, msg_t msg) {
   \                     chSchWakeupS:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    226          
    227            chDbgCheckClassS();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassS
    228          
    229            ntp->p_u.rdymsg = msg;
   \   0000000A   0x62A5             STR      R5,[R4, #+40]
    230            /* If the waken thread has a not-greater priority than the current
    231               one then it is just inserted in the ready list else it made
    232               running immediately and the invoking thread goes in the ready
    233               list instead.*/
    234            if (ntp->p_prio <= currp->p_prio)
   \   0000000C   0x....             LDR.N    R0,??DataTable8
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x68A1             LDR      R1,[R4, #+8]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD303             BCC.N    ??chSchWakeupS_0
    235              chSchReadyI(ntp);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       chSchReadyI
   \   0000001E   0xE018             B.N      ??chSchWakeupS_1
    236            else {
    237              Thread *otp = chSchReadyI(currp);
   \                     ??chSchWakeupS_0:
   \   00000020   0x....             LDR.N    R0,??DataTable8
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x.... 0x....      BL       chSchReadyI
   \   00000028   0x0006             MOVS     R6,R0
    238              setcurrp(ntp);
   \   0000002A   0x....             LDR.N    R0,??DataTable8
   \   0000002C   0x6184             STR      R4,[R0, #+24]
    239              ntp->p_state = THD_STATE_CURRENT;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0020      STRB     R0,[R4, #+32]
    240              chSysSwitch(ntp, otp);
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       dbg_trace
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       getRemainingStack
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD502             BPL.N    ??chSchWakeupS_2
   \   00000044   0x....             LDR.N    R0,??DataTable8_2
   \   00000046   0x.... 0x....      BL       chDbgPanic
   \                     ??chSchWakeupS_2:
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       _port_switch
    241            }
    242          }
   \                     ??chSchWakeupS_1:
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    243          #endif /* !defined(PORT_OPTIMIZED_WAKEUPS) */
    244          
    245          /**
    246           * @brief   Performs a reschedule if a higher priority thread is runnable.
    247           * @details If a thread with a higher priority than the current thread is in
    248           *          the ready list then make the higher priority thread running.
    249           *
    250           * @sclass
    251           */
    252          #if !defined(PORT_OPTIMIZED_RESCHEDULES) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    253          void chSchRescheduleS(void) {
   \                     chSchRescheduleS:
   \   00000000   0xB580             PUSH     {R7,LR}
    254          
    255            chDbgCheckClassS();
   \   00000002   0x.... 0x....      BL       chDbgCheckClassS
    256          
    257            if (chSchIsRescRequiredI())
   \   00000006   0x....             LDR.N    R0,??DataTable8
   \   00000008   0x6980             LDR      R0,[R0, #+24]
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x....             LDR.N    R1,??DataTable8
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD201             BCS.N    ??chSchRescheduleS_0
    258              chSchDoRescheduleAhead();
   \   00000016   0x.... 0x....      BL       chSchDoRescheduleAhead
    259          }
   \                     ??chSchRescheduleS_0:
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    260          #endif /* !defined(PORT_OPTIMIZED_RESCHEDULES) */
    261          
    262          /**
    263           * @brief   Evaluates if preemption is required.
    264           * @details The decision is taken by comparing the relative priorities and
    265           *          depending on the state of the round robin timeout counter.
    266           * @note    Not a user function, it is meant to be invoked by the scheduler
    267           *          itself or from within the port layer.
    268           *
    269           * @retval TRUE         if there is a thread that must go in running state
    270           *                      immediately.
    271           * @retval FALSE        if preemption is not required.
    272           *
    273           * @special
    274           */
    275          #if !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) || defined(__DOXYGEN__)
    276          bool_t chSchIsPreemptionRequired(void) {
    277            tprio_t p1 = firstprio(&rlist.r_queue);
    278            tprio_t p2 = currp->p_prio;
    279          #if CH_TIME_QUANTUM > 0
    280            /* If the running thread has not reached its time quantum, reschedule only
    281               if the first thread on the ready queue has a higher priority.
    282               Otherwise, if the running thread has used up its time quantum, reschedule
    283               if the first thread on the ready queue has equal or higher priority.*/
    284            return currp->p_preempt ? p1 > p2 : p1 >= p2;
    285          #else
    286            /* If the round robin preemption feature is not enabled then performs a
    287               simpler comparison.*/
    288            return p1 > p2;
    289          #endif
    290          }
    291          #endif /* !defined(PORT_OPTIMIZED_ISPREEMPTIONREQUIRED) */
    292          
    293          /**
    294           * @brief   Switches to the first thread on the runnable queue.
    295           * @details The current thread is positioned in the ready list behind all
    296           *          threads having the same priority. The thread regains its time
    297           *          quantum.
    298           * @note    Not a user function, it is meant to be invoked by the scheduler
    299           *          itself or from within the port layer.
    300           *
    301           * @special
    302           */
    303          #if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    304          void chSchDoRescheduleBehind(void) {
   \                     chSchDoRescheduleBehind:
   \   00000000   0xB510             PUSH     {R4,LR}
    305            Thread *otp;
    306          
    307            otp = currp;
   \   00000002   0x....             LDR.N    R0,??DataTable8
   \   00000004   0x6980             LDR      R0,[R0, #+24]
   \   00000006   0x0004             MOVS     R4,R0
    308            /* Picks the first thread from the ready queue and makes it current.*/
    309            setcurrp(fifo_remove(&rlist.r_queue));
   \   00000008   0x....             LDR.N    R0,??DataTable8
   \   0000000A   0x.... 0x....      BL       fifo_remove
   \   0000000E   0x....             LDR.N    R1,??DataTable8
   \   00000010   0x6188             STR      R0,[R1, #+24]
    310            currp->p_state = THD_STATE_CURRENT;
   \   00000012   0x....             LDR.N    R0,??DataTable8
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x1020      STRB     R1,[R0, #+32]
    311          #if CH_TIME_QUANTUM > 0
    312            otp->p_preempt = CH_TIME_QUANTUM;
   \   0000001C   0x2014             MOVS     R0,#+20
   \   0000001E   0xF884 0x0022      STRB     R0,[R4, #+34]
    313          #endif
    314            chSchReadyI(otp);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       chSchReadyI
    315            chSysSwitch(currp, otp);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       dbg_trace
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       getRemainingStack
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD502             BPL.N    ??chSchDoRescheduleBehind_0
   \   00000038   0x....             LDR.N    R0,??DataTable8_2
   \   0000003A   0x.... 0x....      BL       chDbgPanic
   \                     ??chSchDoRescheduleBehind_0:
   \   0000003E   0x0021             MOVS     R1,R4
   \   00000040   0x....             LDR.N    R0,??DataTable8
   \   00000042   0x6980             LDR      R0,[R0, #+24]
   \   00000044   0x.... 0x....      BL       _port_switch
    316          }
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    317          #endif /* !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) */
    318          
    319          /**
    320           * @brief   Switches to the first thread on the runnable queue.
    321           * @details The current thread is positioned in the ready list ahead of all
    322           *          threads having the same priority.
    323           * @note    Not a user function, it is meant to be invoked by the scheduler
    324           *          itself or from within the port layer.
    325           *
    326           * @special
    327           */
    328          #if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    329          void chSchDoRescheduleAhead(void) {
   \                     chSchDoRescheduleAhead:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    330            Thread *otp, *cp;
    331          
    332            otp = currp;
   \   00000002   0x....             LDR.N    R0,??DataTable8
   \   00000004   0x6980             LDR      R0,[R0, #+24]
   \   00000006   0x0004             MOVS     R4,R0
    333            /* Picks the first thread from the ready queue and makes it current.*/
    334            setcurrp(fifo_remove(&rlist.r_queue));
   \   00000008   0x....             LDR.N    R0,??DataTable8
   \   0000000A   0x.... 0x....      BL       fifo_remove
   \   0000000E   0x....             LDR.N    R1,??DataTable8
   \   00000010   0x6188             STR      R0,[R1, #+24]
    335            currp->p_state = THD_STATE_CURRENT;
   \   00000012   0x....             LDR.N    R0,??DataTable8
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF880 0x1020      STRB     R1,[R0, #+32]
    336          
    337            otp->p_state = THD_STATE_READY;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0020      STRB     R0,[R4, #+32]
    338            cp = (Thread *)&rlist.r_queue;
   \   00000022   0x....             LDR.N    R0,??DataTable8
   \   00000024   0x0005             MOVS     R5,R0
    339            do {
    340              cp = cp->p_next;
   \                     ??chSchDoRescheduleAhead_0:
   \   00000026   0x682D             LDR      R5,[R5, #+0]
    341            } while (cp->p_prio > otp->p_prio);
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x68A9             LDR      R1,[R5, #+8]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD3FA             BCC.N    ??chSchDoRescheduleAhead_0
    342            /* Insertion on p_prev.*/
    343            otp->p_next = cp;
   \   00000030   0x6025             STR      R5,[R4, #+0]
    344            otp->p_prev = cp->p_prev;
   \   00000032   0x6868             LDR      R0,[R5, #+4]
   \   00000034   0x6060             STR      R0,[R4, #+4]
    345            otp->p_prev->p_next = cp->p_prev = otp;
   \   00000036   0x606C             STR      R4,[R5, #+4]
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x6004             STR      R4,[R0, #+0]
    346          
    347            chSysSwitch(currp, otp);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       dbg_trace
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       getRemainingStack
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD502             BPL.N    ??chSchDoRescheduleAhead_1
   \   0000004C   0x....             LDR.N    R0,??DataTable8_2
   \   0000004E   0x.... 0x....      BL       chDbgPanic
   \                     ??chSchDoRescheduleAhead_1:
   \   00000052   0x0021             MOVS     R1,R4
   \   00000054   0x....             LDR.N    R0,??DataTable8
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0x.... 0x....      BL       _port_switch
    348          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    349          #endif /* !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) */
    350          
    351          /**
    352           * @brief   Switches to the first thread on the runnable queue.
    353           * @details The current thread is positioned in the ready list behind or
    354           *          ahead of all threads having the same priority depending on
    355           *          if it used its whole time slice.
    356           * @note    Not a user function, it is meant to be invoked by the scheduler
    357           *          itself or from within the port layer.
    358           *
    359           * @special
    360           */
    361          #if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    362          void chSchDoReschedule(void) {
   \                     chSchDoReschedule:
   \   00000000   0xB580             PUSH     {R7,LR}
    363          
    364          #if CH_TIME_QUANTUM > 0
    365            /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
    366               handle on preemption: time quantum elapsed or not.*/
    367            if (currp->p_preempt == 0) {
   \   00000002   0x....             LDR.N    R0,??DataTable8
   \   00000004   0x6980             LDR      R0,[R0, #+24]
   \   00000006   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??chSchDoReschedule_0
    368              /* The thread consumed its time quantum so it is enqueued behind threads
    369                 with same priority level, however, it acquires a new time quantum.*/
    370              chSchDoRescheduleBehind();
   \   0000000E   0x.... 0x....      BL       chSchDoRescheduleBehind
   \   00000012   0xE001             B.N      ??chSchDoReschedule_1
    371            }
    372            else {
    373              /* The thread didn't consume all its time quantum so it is put ahead of
    374                 threads with equal priority and does not acquire a new time quantum.*/
    375              chSchDoRescheduleAhead();
   \                     ??chSchDoReschedule_0:
   \   00000014   0x.... 0x....      BL       chSchDoRescheduleAhead
    376            }
    377          #else /* !(CH_TIME_QUANTUM > 0) */
    378            /* If the round-robin mechanism is disabled then the thread goes always
    379               ahead of its peers.*/
    380            chSchDoRescheduleAhead();
    381          #endif /* !(CH_TIME_QUANTUM > 0) */
    382          }
   \                     ??chSchDoReschedule_1:
   \   00000018   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     `?<Constant "chSchReadyI(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     `?<Constant "stack overflow">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     wakeup

   \                                 In section .rodata, align 4
   \                     `?<Constant "chSchReadyI(), #1">`:
   \   00000000   0x63 0x68          DC8 "chSchReadyI(), #1"
   \              0x53 0x63    
   \              0x68 0x52    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x49 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "stack overflow">`:
   \   00000000   0x73 0x74          DC8 "stack overflow"
   \              0x61 0x63    
   \              0x6B 0x20    
   \              0x6F 0x76    
   \              0x65 0x72    
   \              0x66 0x6C    
   \              0x6F 0x77    
   \              0x00         
   \   0000000F   0x00               DC8 0
    383          #endif /* !defined(PORT_OPTIMIZED_DORESCHEDULE) */
    384          
    385          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   _scheduler_init
       8   chSchDoReschedule
         8   -> chSchDoRescheduleAhead
         8   -> chSchDoRescheduleBehind
      16   chSchDoRescheduleAhead
        16   -> _port_switch
        16   -> chDbgPanic
        16   -> dbg_trace
        16   -> fifo_remove
        16   -> getRemainingStack
       8   chSchDoRescheduleBehind
         8   -> _port_switch
         8   -> chDbgPanic
         8   -> chSchReadyI
         8   -> dbg_trace
         8   -> fifo_remove
         8   -> getRemainingStack
      16   chSchGoSleepS
        16   -> _port_switch
        16   -> chDbgCheckClassS
        16   -> chDbgPanic
        16   -> dbg_trace
        16   -> fifo_remove
        16   -> getRemainingStack
      32   chSchGoSleepTimeoutS
        32   -> chDbgCheckClassS
        32   -> chSchGoSleepS
        32   -> chVTResetI
        32   -> chVTSetI
      16   chSchReadyI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
       8   chSchRescheduleS
         8   -> chDbgCheckClassS
         8   -> chSchDoRescheduleAhead
      16   chSchWakeupS
        16   -> _port_switch
        16   -> chDbgCheckClassS
        16   -> chDbgPanic
        16   -> chSchReadyI
        16   -> dbg_trace
        16   -> getRemainingStack
       0   dequeue
       0   fifo_remove
      16   wakeup
        16   -> chSchReadyI
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
        16   -> dequeue


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "chSchReadyI(), #1">
      16  ?<Constant "stack overflow">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
      28  _scheduler_init
      26  chSchDoReschedule
      94  chSchDoRescheduleAhead
      74  chSchDoRescheduleBehind
      78  chSchGoSleepS
      72  chSchGoSleepTimeoutS
      66  chSchReadyI
      28  chSchRescheduleS
      84  chSchWakeupS
      14  dequeue
      12  fifo_remove
      28  rlist
      86  wakeup

 
  28 bytes in section .bss
  36 bytes in section .rodata
 678 bytes in section .text
 
 678 bytes of CODE  memory
  36 bytes of CONST memory
  28 bytes of DATA  memory

Errors: none
Warnings: none
