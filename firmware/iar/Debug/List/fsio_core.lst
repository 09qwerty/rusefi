###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:27 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\core #
#                       \fsio_core.cpp                                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\core #
#                       \fsio_core.cpp -lCN F:\stuff\rusefi_sourceforge\firmw #
#                       are\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\List\ -o                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\f #
#                       sio_core.lst                                          #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\fs #
#                       io_core.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\core\fsio_core.cpp
      1          /**
      2           * @file fsio_core.cpp
      3           * @brief core FSUI handling logic
      4           *
      5           * Here we parse and evaluate logical expressions in
      6           * http://en.wikipedia.org/wiki/Reverse_Polish_notation
      7           *
      8           * Once the expressions are parsed on startup (that's a heavy operation),
      9           * evaluating those is relatively efficient.
     10           *
     11           *
     12           * @date Oct 3, 2014
     13           * @author Andrey Belomutskiy, (c) 2012-2015
     14           */
     15          
     16          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     17          
     18          #if EFI_FSIO || defined(__DOXYGEN__)
     19          
     20          #include "fsio_core.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp FLStack<float, 32>::FLStack()
   \                     _ZN7FLStackIfLi32EEC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN7FLStackIfLi32EE5resetEv
   \   0000000A   0x2280             MOVS     R2,#+128
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x1D20             ADDS     R0,R4,#+4
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void FLStack<float, 32>::reset()
   \                     _ZN7FLStackIfLi32EE5resetEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __vfp void FLStack<float, 32>::push(float)
   \                     _ZN7FLStackIfLi32EE4pushEf:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xDB03             BLT.N    ??push_1
   \   00000012   0x4807             LDR.N    R0,??push_2
   \   00000014   0x.... 0x....      BL       firmwareError
   \   00000018   0xE006             B.N      ??push_3
   \                     ??push_1:
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x1C41             ADDS     R1,R0,#+1
   \   0000001E   0x6021             STR      R1,[R4, #+0]
   \   00000020   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000024   0xED80 0x8A01      VSTR     S16,[R0, #+4]
   \                     ??push_3:
   \   00000028   0xECBD 0x8B02      VPOP     {D8}
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   \   0000002E   0xBF00             Nop      
   \                     ??push_2:
   \   00000030   0x........         DC32     _ZZN7FLStackIfLi32EE4pushEfEs

   \                                 In section .text, align 4
   \   __interwork __vfp float FLStack<float, 32>::pop()
   \                     _ZN7FLStackIfLi32EE3popEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD102             BNE.N    ??pop_2
   \   0000000A   0x4805             LDR.N    R0,??pop_3
   \   0000000C   0x.... 0x....      BL       firmwareError
   \                     ??pop_2:
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x6020             STR      R0,[R4, #+0]
   \   00000016   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   0000001A   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??pop_3:
   \   00000020   0x........         DC32     _ZZN7FLStackIfLi32EE3popEvEs

   \                                 In section .text, align 2
   \   __interwork __softfp int FLStack<float, 32>::size()
   \                     _ZN7FLStackIfLi32EE4sizeEv:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
     21          #include "fsio_impl.h"
     22          

   \                                 In section .bss, align 4
     23          LENameOrdinalPair * LE_FIRST = NULL;
   \                     LE_FIRST:
   \   00000000                      DS8 4
     24          
     25          /**
     26           * the main point of these static fields is that their constructor would register
     27           * them in the magic list of operator name/ordinal pairs
     28           */

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine:
   \   00000000   0xB580             PUSH     {R7,LR}
     29          static LENameOrdinalPair leAnd(LE_OPERATOR_AND, "and");
   \   00000002   0x....             ADR.N    R2,??DataTable2  ;; "and"
   \   00000004   0x2106             MOVS     R1,#+6
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000A   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     30          static LENameOrdinalPair leAnd2(LE_OPERATOR_AND, "&");
   \   0000000E   0x....             ADR.N    R2,??DataTable2_1  ;; "&"
   \   00000010   0x2106             MOVS     R1,#+6
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000016   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     31          static LENameOrdinalPair leOr(LE_OPERATOR_OR, "or");
   \   0000001A   0x....             ADR.N    R2,??DataTable2_2  ;; 0x6F, 0x72, 0x00, 0x00
   \   0000001C   0x2107             MOVS     R1,#+7
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   00000022   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     32          static LENameOrdinalPair leOr2(LE_OPERATOR_OR, "|");
   \   00000026   0x....             ADR.N    R2,??DataTable2_3  ;; "|"
   \   00000028   0x2107             MOVS     R1,#+7
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   0000002E   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     33          static LENameOrdinalPair leNot(LE_OPERATOR_NOT, "not");
   \   00000032   0x....             ADR.N    R2,??DataTable2_4  ;; "not"
   \   00000034   0x2108             MOVS     R1,#+8
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   0000003A   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     34          
     35          static LENameOrdinalPair leAdd(LE_OPERATOR_ADDITION, "+");
   \   0000003E   0x....             ADR.N    R2,??DataTable2_5  ;; "+"
   \   00000040   0x2109             MOVS     R1,#+9
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable8_6
   \   00000046   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     36          static LENameOrdinalPair leSub(LE_OPERATOR_SUBTRACTION, "-");
   \   0000004A   0x....             ADR.N    R2,??DataTable2_6  ;; "-"
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable8_7
   \   00000052   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     37          static LENameOrdinalPair leMul(LE_OPERATOR_MULTIPLICATION, "*");
   \   00000056   0x....             ADR.N    R2,??DataTable2_7  ;; "*"
   \   00000058   0x210B             MOVS     R1,#+11
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \   0000005E   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     38          static LENameOrdinalPair leDiv(LE_OPERATOR_DIVISION, "/");
   \   00000062   0x....             ADR.N    R2,??DataTable2_8  ;; "/"
   \   00000064   0x210C             MOVS     R1,#+12
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable8_9
   \   0000006A   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     39          
     40          static LENameOrdinalPair leMore(LE_OPERATOR_MORE, ">");
   \   0000006E   0x....             ADR.N    R2,??DataTable2_9  ;; ">"
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable8_10
   \   00000076   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     41          static LENameOrdinalPair leMoreOrEqual(LE_OPERATOR_MORE_OR_EQUAL, ">=");
   \   0000007A   0x....             ADR.N    R2,??DataTable2_10  ;; 0x3E, 0x3D, 0x00, 0x00
   \   0000007C   0x2105             MOVS     R1,#+5
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable8_11
   \   00000082   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     42          
     43          static LENameOrdinalPair leLess(LE_OPERATOR_LESS, "<");
   \   00000086   0x....             ADR.N    R2,??DataTable2_11  ;; "<"
   \   00000088   0x2102             MOVS     R1,#+2
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable8_12
   \   0000008E   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     44          static LENameOrdinalPair leLessOrEquals(LE_OPERATOR_LESS_OR_EQUAL, "<=");
   \   00000092   0x....             ADR.N    R2,??DataTable2_12  ;; 0x3C, 0x3D, 0x00, 0x00
   \   00000094   0x2104             MOVS     R1,#+4
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable8_13
   \   0000009A   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     45          
     46          static LENameOrdinalPair leMax(LE_METHOD_MAX, "max");
   \   0000009E   0x....             ADR.N    R2,??DataTable2_13  ;; "max"
   \   000000A0   0x210D             MOVS     R1,#+13
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable8_14
   \   000000A6   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     47          static LENameOrdinalPair leMin(LE_METHOD_MIN, "min");
   \   000000AA   0x....             ADR.N    R2,??DataTable2_14  ;; "min"
   \   000000AC   0x210E             MOVS     R1,#+14
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable8_15
   \   000000B2   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
     48          static LENameOrdinalPair leIf(LE_METHOD_IF, "if");
   \   000000B6   0x....             ADR.N    R2,??DataTable2_15  ;; 0x69, 0x66, 0x00, 0x00
   \   000000B8   0x210F             MOVS     R1,#+15
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   000000BE   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
   \   000000C2   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     leAnd:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leAnd2:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leOr:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leOr2:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leNot:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leAdd:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leSub:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leMul:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leDiv:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leMore:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leMoreOrEqual:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leLess:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leLessOrEquals:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leMax:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leMin:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     leIf:
   \   00000000                      DS8 12
     49          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp LENameOrdinalPair::subobject LENameOrdinalPair(le_action_e, char const *)
   \                     _ZN17LENameOrdinalPairC2E11le_action_ePKc:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN17LENameOrdinalPairC1E11le_action_ePKc
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     50          LENameOrdinalPair::LENameOrdinalPair(le_action_e action, const char *name) {
     51          	this->action = action;
   \                     _ZN17LENameOrdinalPairC1E11le_action_ePKc:
   \   00000000   0x6041             STR      R1,[R0, #+4]
     52          	this->name = name;
   \   00000002   0x6082             STR      R2,[R0, #+8]
     53          	this->next = LE_FIRST;
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable8_17
   \   00000008   0x681B             LDR      R3,[R3, #+0]
   \   0000000A   0x6003             STR      R3,[R0, #+0]
     54          	LE_FIRST = this;
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable8_17
   \   00000010   0x6018             STR      R0,[R3, #+0]
     55          }
   \   00000012   0x4770             BX       LR               ;; return
     56          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp LEElement::subobject LEElement()
   \                     _ZN9LEElementC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9LEElementC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     57          LEElement::LEElement() {
     58          	action = LE_UNDEFINED;
   \                     _ZN9LEElementC1Ev:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
     59          	next = NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x60C1             STR      R1,[R0, #+12]
     60          	fValue = NAN;
   \   00000008   0xF07F 0x4100      MVNS     R1,#-2147483648
   \   0000000C   0x6041             STR      R1,[R0, #+4]
     61          	iValue = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6081             STR      R1,[R0, #+8]
     62          }
   \   00000012   0x4770             BX       LR               ;; return
     63          
     64          //void LEElement::init(le_action_e action, int iValue) {
     65          //	this->action = action;
     66          //	this->iValue = iValue;
     67          //}
     68          

   \                                 In section .text, align 2, keep-with-next
     69          void LEElement::init(le_action_e action) {
     70          	this->action = action;
   \                     _ZN9LEElement4initE11le_action_e:
   \   00000000   0x6001             STR      R1,[R0, #+0]
     71          }
   \   00000002   0x4770             BX       LR               ;; return
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void LEElement::init(le_action_e action, float fValue) {
     74          	this->action = action;
   \                     _ZN9LEElement4initE11le_action_ef:
   \   00000000   0x6001             STR      R1,[R0, #+0]
     75          	this->fValue = fValue;
   \   00000002   0xED80 0x0A01      VSTR     S0,[R0, #+4]
     76          }
   \   00000006   0x4770             BX       LR               ;; return
     77          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp LECalculator::subobject LECalculator()
   \                     _ZN12LECalculatorC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN12LECalculatorC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     78          LECalculator::LECalculator() {
   \                     _ZN12LECalculatorC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xF514 0x7002      ADDS     R0,R4,#+520
   \   00000008   0x.... 0x....      BL       _ZN7FLStackIfLi32EEC1Ev
     79          	reset();
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       _ZN12LECalculator5resetEv
     80          }
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
     81          

   \                                 In section .text, align 2, keep-with-next
     82          void LECalculator::reset() {
   \                     _ZN12LECalculator5resetEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     83          	first = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8C4 0x0204      STR      R0,[R4, #+516]
     84          	stack.reset();
   \   0000000A   0xF514 0x7002      ADDS     R0,R4,#+520
   \   0000000E   0x.... 0x....      BL       _ZN7FLStackIfLi32EE5resetEv
     85          	currentCalculationLogPosition = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8C4 0x0200      STR      R0,[R4, #+512]
     86          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     87          

   \                                 In section .text, align 2, keep-with-next
     88          void LECalculator::reset(LEElement *element) {
   \                     _ZN12LECalculator5resetEP9LEElement:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     89          	reset();
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       _ZN12LECalculator5resetEv
     90          	add(element);
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZN12LECalculator3addEP9LEElement
     91          }
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     92          

   \                                 In section .text, align 2, keep-with-next
     93          void LECalculator::add(LEElement *element) {
     94          	if (first == NULL) {
   \                     _ZN12LECalculator3addEP9LEElement:
   \   00000000   0xF8D0 0x2204      LDR      R2,[R0, #+516]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD102             BNE.N    ??add_0
     95          		first = element;
   \   00000008   0xF8C0 0x1204      STR      R1,[R0, #+516]
   \   0000000C   0xE007             B.N      ??add_1
     96          	} else {
     97          		LEElement *last = first;
   \                     ??add_0:
   \   0000000E   0xF8D0 0x2204      LDR      R2,[R0, #+516]
     98          		while (last->next != NULL) {
   \                     ??add_2:
   \   00000012   0x68D3             LDR      R3,[R2, #+12]
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD001             BEQ.N    ??add_3
     99          			last = last->next;
   \   00000018   0x68D2             LDR      R2,[R2, #+12]
   \   0000001A   0xE7FA             B.N      ??add_2
    100          		}
    101          		last->next = element;
   \                     ??add_3:
   \   0000001C   0x60D1             STR      R1,[R2, #+12]
    102          	}
    103          }
   \                     ??add_1:
   \   0000001E   0x4770             BX       LR               ;; return
    104          

   \                                 In section .text, align 2, keep-with-next
    105          static bool float2bool(float v) {
    106          	return v != 0;
   \                     _Z10float2boolf:
   \   00000000   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000004   0xEEF1 0xFA10      FMSTAT   
   \   00000008   0xD001             BEQ.N    ??float2bool_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??float2bool_1
   \                     ??float2bool_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??float2bool_1:
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
    107          }
    108          

   \                                 In section .text, align 4, keep-with-next
    109          float LECalculator::pop(le_action_e action) {
   \                     _ZN12LECalculator3popE11le_action_e:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    110          	if (stack.size() == 0) {
   \   00000006   0xF514 0x7002      ADDS     R0,R4,#+520
   \   0000000A   0x.... 0x....      BL       _ZN7FLStackIfLi32EE4sizeEv
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD109             BNE.N    ??pop_0
    111          		warning(OBD_PCM_Processor_Fault, "empty stack for %d", action);
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable8_18
   \   00000018   0xF240 0x205E      MOVW     R0,#+606
   \   0000001C   0x.... 0x....      BL       warning
    112          		return NAN;
   \   00000020   0xED9F 0x....      VLDR.W   S0,??DataTable2_16  ;; 0x7fffffff
   \   00000024   0xE003             B.N      ??pop_1
    113          	}
    114          	return stack.pop();
   \                     ??pop_0:
   \   00000026   0xF514 0x7002      ADDS     R0,R4,#+520
   \   0000002A   0x.... 0x....      BL       _ZN7FLStackIfLi32EE3popEv
   \                     ??pop_1:
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          void LECalculator::push(le_action_e action, float value) {
   \                     _ZN12LECalculator4pushE11le_action_ef:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
    118          	stack.push(value);
   \   0000000E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000012   0xF514 0x7002      ADDS     R0,R4,#+520
   \   00000016   0x.... 0x....      BL       _ZN7FLStackIfLi32EE4pushEf
    119          	if (currentCalculationLogPosition < MAX_CALC_LOG) {
   \   0000001A   0xF8D4 0x0200      LDR      R0,[R4, #+512]
   \   0000001E   0x2840             CMP      R0,#+64
   \   00000020   0xDA0E             BGE.N    ??push_0
    120          		calcLogAction[currentCalculationLogPosition] = action;
   \   00000022   0xF8D4 0x0200      LDR      R0,[R4, #+512]
   \   00000026   0xF844 0x5020      STR      R5,[R4, R0, LSL #+2]
    121          		calcLogValue[currentCalculationLogPosition] = value;
   \   0000002A   0xF8D4 0x0200      LDR      R0,[R4, #+512]
   \   0000002E   0xEB14 0x0080      ADDS     R0,R4,R0, LSL #+2
   \   00000032   0xED80 0x8A40      VSTR     S16,[R0, #+256]
    122          		currentCalculationLogPosition++;
   \   00000036   0xF8D4 0x0200      LDR      R0,[R4, #+512]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xF8C4 0x0200      STR      R0,[R4, #+512]
    123          	}
    124          }
   \                     ??push_0:
   \   00000040   0xECBD 0x8B02      VPOP     {D8}
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    125          
    126          /**
    127           * @return true in case of error, false otherwise
    128           */

   \                                 In section .text, align 4, keep-with-next
    129          bool_t LECalculator::doJob(Engine *engine, LEElement *element) {
   \                     _ZN12LECalculator5doJobEP6EngineP9LEElement:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    130          #if EFI_PROD_CODE || defined(__DOXYGEN__)
    131          	efiAssert(getRemainingStack(chThdSelf()) > 64, "FSIO logic", false);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable8_19
   \   00000010   0x6980             LDR      R0,[R0, #+24]
   \   00000012   0x.... 0x....      BL       getRemainingStack
   \   00000016   0x2841             CMP      R0,#+65
   \   00000018   0xDA05             BGE.N    ??doJob_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8_20
   \   0000001E   0x.... 0x....      BL       firmwareError
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE1E3             B.N      ??doJob_1
    132          #endif
    133          	switch (element->action) {
   \                     ??doJob_0:
   \   00000026   0x6830             LDR      R0,[R6, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xF000 0x81CE      BEQ.W    ??doJob_2
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD02D             BEQ.N    ??doJob_3
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD076             BEQ.N    ??doJob_4
   \   00000036   0x2803             CMP      R0,#+3
   \   00000038   0xF000 0x80A8      BEQ.W    ??doJob_5
   \   0000003C   0x2804             CMP      R0,#+4
   \   0000003E   0xF000 0x810F      BEQ.W    ??doJob_6
   \   00000042   0x2805             CMP      R0,#+5
   \   00000044   0xF000 0x812A      BEQ.W    ??doJob_7
   \   00000048   0x2806             CMP      R0,#+6
   \   0000004A   0xD027             BEQ.N    ??doJob_8
   \   0000004C   0x2807             CMP      R0,#+7
   \   0000004E   0xD047             BEQ.N    ??doJob_9
   \   00000050   0x2808             CMP      R0,#+8
   \   00000052   0xF000 0x8085      BEQ.W    ??doJob_10
   \   00000056   0x2809             CMP      R0,#+9
   \   00000058   0xF000 0x80B6      BEQ.W    ??doJob_11
   \   0000005C   0x280A             CMP      R0,#+10
   \   0000005E   0xF000 0x80C6      BEQ.W    ??doJob_12
   \   00000062   0x280B             CMP      R0,#+11
   \   00000064   0xF000 0x80D6      BEQ.W    ??doJob_13
   \   00000068   0x280C             CMP      R0,#+12
   \   0000006A   0xF000 0x80E6      BEQ.W    ??doJob_14
   \   0000006E   0x280D             CMP      R0,#+13
   \   00000070   0xF000 0x8153      BEQ.W    ??doJob_15
   \   00000074   0x280E             CMP      R0,#+14
   \   00000076   0xF000 0x8167      BEQ.W    ??doJob_16
   \   0000007A   0x280F             CMP      R0,#+15
   \   0000007C   0xF000 0x812C      BEQ.W    ??doJob_17
   \   00000080   0x286F             CMP      R0,#+111
   \   00000082   0xF000 0x8178      BEQ.W    ??doJob_18
   \   00000086   0x2870             CMP      R0,#+112
   \   00000088   0xF000 0x8196      BEQ.W    ??doJob_19
   \   0000008C   0xE1A4             B.N      ??doJob_20
    134          
    135          	case LE_NUMERIC_VALUE:
    136          		push(element->action, element->fValue);
   \                     ??doJob_3:
   \   0000008E   0xED96 0x0A01      VLDR     S0,[R6, #+4]
   \   00000092   0x6831             LDR      R1,[R6, #+0]
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    137          		break;
   \   0000009A   0xE1A7             B.N      ??doJob_21
    138          	case LE_OPERATOR_AND: {
    139          		float v1 = pop(LE_OPERATOR_AND);
   \                     ??doJob_8:
   \   0000009C   0x2106             MOVS     R1,#+6
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000000A4   0xEEB0 0x8A40      VMOV.F32 S16,S0
    140          		float v2 = pop(LE_OPERATOR_AND);
   \   000000A8   0x2106             MOVS     R1,#+6
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000000B0   0xEEF0 0x8A40      VMOV.F32 S17,S0
    141          
    142          		push(element->action, float2bool(v1) && float2bool(v2));
   \   000000B4   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000B8   0x.... 0x....      BL       _Z10float2boolf
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD004             BEQ.N    ??doJob_22
   \   000000C0   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000000C4   0x.... 0x....      BL       _Z10float2boolf
   \   000000C8   0xE000             B.N      ??doJob_23
   \                     ??doJob_22:
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??doJob_23:
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0xEE00 0x0A10      VMOV     S0,R0
   \   000000D2   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000000D6   0x6831             LDR      R1,[R6, #+0]
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    143          	}
    144          		break;
   \   000000DE   0xE185             B.N      ??doJob_21
    145          	case LE_OPERATOR_OR: {
    146          		float v1 = pop(LE_OPERATOR_OR);
   \                     ??doJob_9:
   \   000000E0   0x2107             MOVS     R1,#+7
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000000E8   0xEEB0 0x8A40      VMOV.F32 S16,S0
    147          		float v2 = pop(LE_OPERATOR_OR);
   \   000000EC   0x2107             MOVS     R1,#+7
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000000F4   0xEEF0 0x8A40      VMOV.F32 S17,S0
    148          
    149          		push(element->action, float2bool(v1) || float2bool(v2));
   \   000000F8   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   000000FC   0x.... 0x....      BL       _Z10float2boolf
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD104             BNE.N    ??doJob_24
   \   00000104   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000108   0x.... 0x....      BL       _Z10float2boolf
   \   0000010C   0xE000             B.N      ??doJob_25
   \                     ??doJob_24:
   \   0000010E   0x2001             MOVS     R0,#+1
   \                     ??doJob_25:
   \   00000110   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000112   0xEE00 0x0A10      VMOV     S0,R0
   \   00000116   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000011A   0x6831             LDR      R1,[R6, #+0]
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    150          	}
    151          		break;
   \   00000122   0xE163             B.N      ??doJob_21
    152          	case LE_OPERATOR_LESS: {
    153          		// elements on stack are in reverse order
    154          		float v2 = pop(LE_OPERATOR_LESS);
   \                     ??doJob_4:
   \   00000124   0x2102             MOVS     R1,#+2
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   0000012C   0xEEB0 0x8A40      VMOV.F32 S16,S0
    155          		float v1 = pop(LE_OPERATOR_LESS);
   \   00000130   0x2102             MOVS     R1,#+2
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000138   0xEEF0 0x8A40      VMOV.F32 S17,S0
    156          
    157          		push(element->action, v1 < v2);
   \   0000013C   0xEEF4 0x8A48      VCMP.F32 S17,S16
   \   00000140   0xEEF1 0xFA10      FMSTAT   
   \   00000144   0xD501             BPL.N    ??doJob_26
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0xE000             B.N      ??doJob_27
   \                     ??doJob_26:
   \   0000014A   0x2000             MOVS     R0,#+0
   \                     ??doJob_27:
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0xEE00 0x0A10      VMOV     S0,R0
   \   00000152   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000156   0x6831             LDR      R1,[R6, #+0]
   \   00000158   0x0020             MOVS     R0,R4
   \   0000015A   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    158          	}
    159          		break;
   \   0000015E   0xE145             B.N      ??doJob_21
    160          	case LE_OPERATOR_NOT: {
    161          		float v = pop(LE_OPERATOR_NOT);
   \                     ??doJob_10:
   \   00000160   0x2108             MOVS     R1,#+8
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000168   0xEEB0 0x8A40      VMOV.F32 S16,S0
    162          		push(element->action, !float2bool(v));
   \   0000016C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000170   0x.... 0x....      BL       _Z10float2boolf
   \   00000174   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000178   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000017E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000182   0x6831             LDR      R1,[R6, #+0]
   \   00000184   0x0020             MOVS     R0,R4
   \   00000186   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    163          	}
    164          		break;
   \   0000018A   0xE12F             B.N      ??doJob_21
    165          	case LE_OPERATOR_MORE: {
    166          		// elements on stack are in reverse order
    167          		float v2 = pop(LE_OPERATOR_MORE);
   \                     ??doJob_5:
   \   0000018C   0x2103             MOVS     R1,#+3
   \   0000018E   0x0020             MOVS     R0,R4
   \   00000190   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000194   0xEEB0 0x8A40      VMOV.F32 S16,S0
    168          		float v1 = pop(LE_OPERATOR_MORE);
   \   00000198   0x2103             MOVS     R1,#+3
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000001A0   0xEEF0 0x8A40      VMOV.F32 S17,S0
    169          
    170          		push(element->action, v1 > v2);
   \   000001A4   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   000001A8   0xEEF1 0xFA10      FMSTAT   
   \   000001AC   0xD501             BPL.N    ??doJob_28
   \   000001AE   0x2001             MOVS     R0,#+1
   \   000001B0   0xE000             B.N      ??doJob_29
   \                     ??doJob_28:
   \   000001B2   0x2000             MOVS     R0,#+0
   \                     ??doJob_29:
   \   000001B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B6   0xEE00 0x0A10      VMOV     S0,R0
   \   000001BA   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000001BE   0x6831             LDR      R1,[R6, #+0]
   \   000001C0   0x0020             MOVS     R0,R4
   \   000001C2   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    171          	}
    172          		break;
   \   000001C6   0xE111             B.N      ??doJob_21
    173          	case LE_OPERATOR_ADDITION: {
    174          		// elements on stack are in reverse order
    175          		float v2 = pop(LE_OPERATOR_MORE);
   \                     ??doJob_11:
   \   000001C8   0x2103             MOVS     R1,#+3
   \   000001CA   0x0020             MOVS     R0,R4
   \   000001CC   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000001D0   0xEEB0 0x8A40      VMOV.F32 S16,S0
    176          		float v1 = pop(LE_OPERATOR_MORE);
   \   000001D4   0x2103             MOVS     R1,#+3
   \   000001D6   0x0020             MOVS     R0,R4
   \   000001D8   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000001DC   0xEEF0 0x8A40      VMOV.F32 S17,S0
    177          
    178          		push(element->action, v1 + v2);
   \   000001E0   0xEE38 0x0A88      VADD.F32 S0,S17,S16
   \   000001E4   0x6831             LDR      R1,[R6, #+0]
   \   000001E6   0x0020             MOVS     R0,R4
   \   000001E8   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    179          	}
    180          		break;
   \   000001EC   0xE0FE             B.N      ??doJob_21
    181          	case LE_OPERATOR_SUBTRACTION: {
    182          		// elements on stack are in reverse order
    183          		float v2 = pop(LE_OPERATOR_MORE);
   \                     ??doJob_12:
   \   000001EE   0x2103             MOVS     R1,#+3
   \   000001F0   0x0020             MOVS     R0,R4
   \   000001F2   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000001F6   0xEEB0 0x8A40      VMOV.F32 S16,S0
    184          		float v1 = pop(LE_OPERATOR_MORE);
   \   000001FA   0x2103             MOVS     R1,#+3
   \   000001FC   0x0020             MOVS     R0,R4
   \   000001FE   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000202   0xEEF0 0x8A40      VMOV.F32 S17,S0
    185          
    186          		push(element->action, v1 - v2);
   \   00000206   0xEE38 0x0AC8      VSUB.F32 S0,S17,S16
   \   0000020A   0x6831             LDR      R1,[R6, #+0]
   \   0000020C   0x0020             MOVS     R0,R4
   \   0000020E   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    187          	}
    188          		break;
   \   00000212   0xE0EB             B.N      ??doJob_21
    189          	case LE_OPERATOR_MULTIPLICATION: {
    190          		// elements on stack are in reverse order
    191          		float v2 = pop(LE_OPERATOR_MORE);
   \                     ??doJob_13:
   \   00000214   0x2103             MOVS     R1,#+3
   \   00000216   0x0020             MOVS     R0,R4
   \   00000218   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   0000021C   0xEEB0 0x8A40      VMOV.F32 S16,S0
    192          		float v1 = pop(LE_OPERATOR_MORE);
   \   00000220   0x2103             MOVS     R1,#+3
   \   00000222   0x0020             MOVS     R0,R4
   \   00000224   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000228   0xEEF0 0x8A40      VMOV.F32 S17,S0
    193          
    194          		push(element->action, v1 * v2);
   \   0000022C   0xEE28 0x0A88      VMUL.F32 S0,S17,S16
   \   00000230   0x6831             LDR      R1,[R6, #+0]
   \   00000232   0x0020             MOVS     R0,R4
   \   00000234   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    195          	}
    196          		break;
   \   00000238   0xE0D8             B.N      ??doJob_21
    197          	case LE_OPERATOR_DIVISION: {
    198          		// elements on stack are in reverse order
    199          		float v2 = pop(LE_OPERATOR_MORE);
   \                     ??doJob_14:
   \   0000023A   0x2103             MOVS     R1,#+3
   \   0000023C   0x0020             MOVS     R0,R4
   \   0000023E   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000242   0xEEB0 0x8A40      VMOV.F32 S16,S0
    200          		float v1 = pop(LE_OPERATOR_MORE);
   \   00000246   0x2103             MOVS     R1,#+3
   \   00000248   0x0020             MOVS     R0,R4
   \   0000024A   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   0000024E   0xEEF0 0x8A40      VMOV.F32 S17,S0
    201          
    202          		push(element->action, v1 / v2);
   \   00000252   0xEE88 0x0A88      VDIV.F32 S0,S17,S16
   \   00000256   0x6831             LDR      R1,[R6, #+0]
   \   00000258   0x0020             MOVS     R0,R4
   \   0000025A   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    203          	}
    204          		break;
   \   0000025E   0xE0C5             B.N      ??doJob_21
    205          	case LE_OPERATOR_LESS_OR_EQUAL: {
    206          		// elements on stack are in reverse order
    207          		float v2 = pop(LE_OPERATOR_LESS_OR_EQUAL);
   \                     ??doJob_6:
   \   00000260   0x2104             MOVS     R1,#+4
   \   00000262   0x0020             MOVS     R0,R4
   \   00000264   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000268   0xEEB0 0x8A40      VMOV.F32 S16,S0
    208          		float v1 = pop(LE_OPERATOR_LESS_OR_EQUAL);
   \   0000026C   0x2104             MOVS     R1,#+4
   \   0000026E   0x0020             MOVS     R0,R4
   \   00000270   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000274   0xEEF0 0x8A40      VMOV.F32 S17,S0
    209          
    210          		push(element->action, v1 <= v2);
   \   00000278   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   0000027C   0xEEF1 0xFA10      FMSTAT   
   \   00000280   0xDB01             BLT.N    ??doJob_30
   \   00000282   0x2001             MOVS     R0,#+1
   \   00000284   0xE000             B.N      ??doJob_31
   \                     ??doJob_30:
   \   00000286   0x2000             MOVS     R0,#+0
   \                     ??doJob_31:
   \   00000288   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000028E   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000292   0x6831             LDR      R1,[R6, #+0]
   \   00000294   0x0020             MOVS     R0,R4
   \   00000296   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    211          	}
    212          		break;
   \   0000029A   0xE0A7             B.N      ??doJob_21
    213          	case LE_OPERATOR_MORE_OR_EQUAL: {
    214          		// elements on stack are in reverse order
    215          		float v2 = pop(LE_OPERATOR_MORE_OR_EQUAL);
   \                     ??doJob_7:
   \   0000029C   0x2105             MOVS     R1,#+5
   \   0000029E   0x0020             MOVS     R0,R4
   \   000002A0   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000002A4   0xEEB0 0x8A40      VMOV.F32 S16,S0
    216          		float v1 = pop(LE_OPERATOR_MORE_OR_EQUAL);
   \   000002A8   0x2105             MOVS     R1,#+5
   \   000002AA   0x0020             MOVS     R0,R4
   \   000002AC   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000002B0   0xEEF0 0x8A40      VMOV.F32 S17,S0
    217          
    218          		push(element->action, v1 >= v2);
   \   000002B4   0xEEF4 0x8A48      VCMP.F32 S17,S16
   \   000002B8   0xEEF1 0xFA10      FMSTAT   
   \   000002BC   0xDB01             BLT.N    ??doJob_32
   \   000002BE   0x2001             MOVS     R0,#+1
   \   000002C0   0xE000             B.N      ??doJob_33
   \                     ??doJob_32:
   \   000002C2   0x2000             MOVS     R0,#+0
   \                     ??doJob_33:
   \   000002C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C6   0xEE00 0x0A10      VMOV     S0,R0
   \   000002CA   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000002CE   0x6831             LDR      R1,[R6, #+0]
   \   000002D0   0x0020             MOVS     R0,R4
   \   000002D2   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    219          	}
    220          		break;
   \   000002D6   0xE089             B.N      ??doJob_21
    221          	case LE_METHOD_IF: {
    222          		// elements on stack are in reverse order
    223          		float vFalse = pop(LE_METHOD_IF);
   \                     ??doJob_17:
   \   000002D8   0x210F             MOVS     R1,#+15
   \   000002DA   0x0020             MOVS     R0,R4
   \   000002DC   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000002E0   0xEEB0 0x8A40      VMOV.F32 S16,S0
    224          		float vTrue = pop(LE_METHOD_IF);
   \   000002E4   0x210F             MOVS     R1,#+15
   \   000002E6   0x0020             MOVS     R0,R4
   \   000002E8   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000002EC   0xEEF0 0x8A40      VMOV.F32 S17,S0
    225          		float vCond = pop(LE_METHOD_IF);
   \   000002F0   0x210F             MOVS     R1,#+15
   \   000002F2   0x0020             MOVS     R0,R4
   \   000002F4   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   000002F8   0xEEB0 0x9A40      VMOV.F32 S18,S0
    226          		push(element->action, vCond != 0 ? vTrue : vFalse);
   \   000002FC   0xEEB5 0x9A40      VCMP.F32 S18,#0.0
   \   00000300   0xEEF1 0xFA10      FMSTAT   
   \   00000304   0xD002             BEQ.N    ??doJob_34
   \   00000306   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000030A   0xE001             B.N      ??doJob_35
   \                     ??doJob_34:
   \   0000030C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \                     ??doJob_35:
   \   00000310   0x6831             LDR      R1,[R6, #+0]
   \   00000312   0x0020             MOVS     R0,R4
   \   00000314   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    227          	}
    228          		break;
   \   00000318   0xE068             B.N      ??doJob_21
    229          	case LE_METHOD_MAX: {
    230          		float v2 = pop(LE_METHOD_MAX);
   \                     ??doJob_15:
   \   0000031A   0x210D             MOVS     R1,#+13
   \   0000031C   0x0020             MOVS     R0,R4
   \   0000031E   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000322   0xEEB0 0x8A40      VMOV.F32 S16,S0
    231          		float v1 = pop(LE_METHOD_MAX);
   \   00000326   0x210D             MOVS     R1,#+13
   \   00000328   0x0020             MOVS     R0,R4
   \   0000032A   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   0000032E   0xEEF0 0x8A40      VMOV.F32 S17,S0
    232          		push(element->action, maxF(v1, v2));
   \   00000332   0xEEF0 0x0A48      VMOV.F32 S1,S16
   \   00000336   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000033A   0x.... 0x....      BL       maxF
   \   0000033E   0x6831             LDR      R1,[R6, #+0]
   \   00000340   0x0020             MOVS     R0,R4
   \   00000342   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    233          	}
    234          		break;
   \   00000346   0xE051             B.N      ??doJob_21
    235          	case LE_METHOD_MIN: {
    236          		float v2 = pop(LE_METHOD_MIN);
   \                     ??doJob_16:
   \   00000348   0x210E             MOVS     R1,#+14
   \   0000034A   0x0020             MOVS     R0,R4
   \   0000034C   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   00000350   0xEEB0 0x8A40      VMOV.F32 S16,S0
    237          		float v1 = pop(LE_METHOD_MIN);
   \   00000354   0x210E             MOVS     R1,#+14
   \   00000356   0x0020             MOVS     R0,R4
   \   00000358   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   0000035C   0xEEF0 0x8A40      VMOV.F32 S17,S0
    238          		push(element->action, minF(v1, v2));
   \   00000360   0xEEF0 0x0A48      VMOV.F32 S1,S16
   \   00000364   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000368   0x.... 0x....      BL       minF
   \   0000036C   0x6831             LDR      R1,[R6, #+0]
   \   0000036E   0x0020             MOVS     R0,R4
   \   00000370   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    239          	}
    240          		break;
   \   00000374   0xE03A             B.N      ??doJob_21
    241          	case LE_METHOD_FSIO_SETTING: {
    242          		float i = pop(LE_METHOD_FSIO_SETTING);
   \                     ??doJob_18:
   \   00000376   0x216F             MOVS     R1,#+111
   \   00000378   0x0020             MOVS     R0,R4
   \   0000037A   0x.... 0x....      BL       _ZN12LECalculator3popE11le_action_e
   \   0000037E   0xEEB0 0x8A40      VMOV.F32 S16,S0
    243          		int index = (int) i;
   \   00000382   0xEEBD 0x0AC8      VCVT.S32.F32 S0,S16
   \   00000386   0xEE10 0x7A10      VMOV     R7,S0
    244          		if (index >= 0 && index < LE_COMMAND_COUNT) {
   \   0000038A   0x2F00             CMP      R7,#+0
   \   0000038C   0xD40D             BMI.N    ??doJob_36
   \   0000038E   0x2F10             CMP      R7,#+16
   \   00000390   0xDA0B             BGE.N    ??doJob_36
    245          			push(element->action, engine->engineConfiguration->bc.fsio_setting[index]);
   \   00000392   0x6A68             LDR      R0,[R5, #+36]
   \   00000394   0xEB10 0x0087      ADDS     R0,R0,R7, LSL #+2
   \   00000398   0xF8D0 0x0504      LDR      R0,[R0, #+1284]
   \   0000039C   0xEE00 0x0A10      VMOV     S0,R0
   \   000003A0   0x6831             LDR      R1,[R6, #+0]
   \   000003A2   0x0020             MOVS     R0,R4
   \   000003A4   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
   \   000003A8   0xE005             B.N      ??doJob_37
    246          		} else {
    247          			push(element->action, NAN);
   \                     ??doJob_36:
   \   000003AA   0xED9F 0x....      VLDR.W   S0,??DataTable8  ;; 0x7fffffff
   \   000003AE   0x6831             LDR      R1,[R6, #+0]
   \   000003B0   0x0020             MOVS     R0,R4
   \   000003B2   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    248          		}
    249          	}
    250          		break;
   \                     ??doJob_37:
   \   000003B6   0xE019             B.N      ??doJob_21
    251          	case LE_METHOD_KNOCK:
    252          		push(element->action, engine->knockCount);
   \                     ??doJob_19:
   \   000003B8   0xED95 0x0A9B      VLDR     S0,[R5, #+620]
   \   000003BC   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000003C0   0x6831             LDR      R1,[R6, #+0]
   \   000003C2   0x0020             MOVS     R0,R4
   \   000003C4   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    253          		break;
   \   000003C8   0xE010             B.N      ??doJob_21
    254          	case LE_UNDEFINED:
    255          		warning(OBD_PCM_Processor_Fault, "FSIO undefined action");
   \                     ??doJob_2:
   \   000003CA   0x....             LDR.N    R1,??DataTable8_21
   \   000003CC   0xF240 0x205E      MOVW     R0,#+606
   \   000003D0   0x.... 0x....      BL       warning
    256          		return true;
   \   000003D4   0x2001             MOVS     R0,#+1
   \   000003D6   0xE00A             B.N      ??doJob_1
    257          	default:
    258          		push(element->action, getLEValue(engine, &stack, element->action));
   \                     ??doJob_20:
   \   000003D8   0x6832             LDR      R2,[R6, #+0]
   \   000003DA   0xF514 0x7102      ADDS     R1,R4,#+520
   \   000003DE   0x0028             MOVS     R0,R5
   \   000003E0   0x.... 0x....      BL       _Z10getLEValueP6EngineP7FLStackIfLi32EE11le_action_e
   \   000003E4   0x6831             LDR      R1,[R6, #+0]
   \   000003E6   0x0020             MOVS     R0,R4
   \   000003E8   0x.... 0x....      BL       _ZN12LECalculator4pushE11le_action_ef
    259          	}
    260          	return false;
   \                     ??doJob_21:
   \   000003EC   0x2000             MOVS     R0,#+0
   \                     ??doJob_1:
   \   000003EE   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000003F2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    261          }
    262          

   \                                 In section .text, align 2, keep-with-next
    263          float LECalculator::getValue2(LEElement *element, Engine *engine) {
   \                     _ZN12LECalculator9getValue2EP9LEElementP6Engine:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    264          	reset(element);
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN12LECalculator5resetEP9LEElement
    265          	return getValue(engine);
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       _ZN12LECalculator8getValueEP6Engine
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    266          }
    267          

   \                                 In section .text, align 4, keep-with-next
    268          float LECalculator::getValue(Engine *engine) {
   \                     _ZN12LECalculator8getValueEP6Engine:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    269          	if (first == NULL) {
   \   00000006   0xF8D4 0x0204      LDR      R0,[R4, #+516]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??getValue_0
    270          		warning(OBD_PCM_Processor_Fault, "no FSIO code");
   \   0000000E   0x....             LDR.N    R1,??DataTable8_22
   \   00000010   0xF240 0x205E      MOVW     R0,#+606
   \   00000014   0x.... 0x....      BL       warning
    271          		return NAN;
   \   00000018   0xED9F 0x....      VLDR.W   S0,??DataTable8  ;; 0x7fffffff
   \   0000001C   0xE035             B.N      ??getValue_1
    272          	}
    273          	LEElement *element = first;
   \                     ??getValue_0:
   \   0000001E   0xF8D4 0x6204      LDR      R6,[R4, #+516]
    274          
    275          	stack.reset();
   \   00000022   0xF514 0x7002      ADDS     R0,R4,#+520
   \   00000026   0x.... 0x....      BL       _ZN7FLStackIfLi32EE5resetEv
    276          
    277          	int counter = 0;
   \   0000002A   0x2700             MOVS     R7,#+0
    278          	while (element != NULL) {
   \                     ??getValue_2:
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xD015             BEQ.N    ??getValue_3
    279          		efiAssert(counter < 200, "FSIOcount", NAN); // just in case
   \   00000030   0x2FC8             CMP      R7,#+200
   \   00000032   0xDB05             BLT.N    ??getValue_4
   \   00000034   0x....             LDR.N    R0,??DataTable8_23
   \   00000036   0x.... 0x....      BL       firmwareError
   \   0000003A   0xED9F 0x....      VLDR.W   S0,??DataTable8  ;; 0x7fffffff
   \   0000003E   0xE024             B.N      ??getValue_1
    280          
    281          		bool_t isError = doJob(engine, element);
   \                     ??getValue_4:
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       _ZN12LECalculator5doJobEP6EngineP9LEElement
    282          		if (isError) {
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??getValue_5
    283          			// error already reported
    284          			return NAN;
   \   00000050   0xED9F 0x....      VLDR.W   S0,??DataTable8  ;; 0x7fffffff
   \   00000054   0xE019             B.N      ??getValue_1
    285          		}
    286          		element = element->next;
   \                     ??getValue_5:
   \   00000056   0x68F6             LDR      R6,[R6, #+12]
    287          		counter++;
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \   0000005A   0xE7E7             B.N      ??getValue_2
    288          	}
    289          	if (stack.size() != 1) {
   \                     ??getValue_3:
   \   0000005C   0xF514 0x7002      ADDS     R0,R4,#+520
   \   00000060   0x.... 0x....      BL       _ZN7FLStackIfLi32EE4sizeEv
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD00C             BEQ.N    ??getValue_6
    290          		warning(OBD_PCM_Processor_Fault, "unexpected FSIO stack size: %d", stack.size());
   \   00000068   0xF514 0x7002      ADDS     R0,R4,#+520
   \   0000006C   0x.... 0x....      BL       _ZN7FLStackIfLi32EE4sizeEv
   \   00000070   0x0002             MOVS     R2,R0
   \   00000072   0x....             LDR.N    R1,??DataTable8_24
   \   00000074   0xF240 0x205E      MOVW     R0,#+606
   \   00000078   0x.... 0x....      BL       warning
    291          		return NAN;
   \   0000007C   0xED9F 0x....      VLDR.W   S0,??DataTable8  ;; 0x7fffffff
   \   00000080   0xE003             B.N      ??getValue_1
    292          	}
    293          	return stack.pop();
   \                     ??getValue_6:
   \   00000082   0xF514 0x7002      ADDS     R0,R4,#+520
   \   00000086   0x.... 0x....      BL       _ZN7FLStackIfLi32EE3popEv
   \                     ??getValue_1:
   \   0000008A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    294          }
    295          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp LEElementPool::subobject LEElementPool(LEElement *, int)
   \                     _ZN13LEElementPoolC2EP9LEElementi:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13LEElementPoolC1EP9LEElementi
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    296          LEElementPool::LEElementPool(LEElement *pool, int size) {
   \                     _ZN13LEElementPoolC1EP9LEElementi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    297          	this->pool = pool;
   \   00000008   0x6025             STR      R5,[R4, #+0]
    298          	this->size = size;
   \   0000000A   0x60A6             STR      R6,[R4, #+8]
    299          	reset();
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       _ZN13LEElementPool5resetEv
    300          }
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
    301          

   \                                 In section .text, align 2, keep-with-next
    302          void LEElementPool::reset() {
    303          	index = 0;
   \                     _ZN13LEElementPool5resetEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6041             STR      R1,[R0, #+4]
    304          }
   \   00000004   0x4770             BX       LR               ;; return
    305          

   \                                 In section .text, align 2, keep-with-next
    306          int LEElementPool::getSize() {
    307          	return index;
   \                     _ZN13LEElementPool7getSizeEv:
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x4770             BX       LR               ;; return
    308          }
    309          

   \                                 In section .text, align 2, keep-with-next
    310          LEElement *LEElementPool::next() {
   \                     _ZN13LEElementPool4nextEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    311          	if (index >= size) {
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xDB04             BLT.N    ??next_0
    312          		// todo: this should not be a fatal error, just an error
    313          		firmwareError("LE_ELEMENT_POOL_SIZE overflow");
   \   0000000C   0x....             LDR.N    R0,??DataTable8_25
   \   0000000E   0x.... 0x....      BL       firmwareError
    314          		return NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE005             B.N      ??next_1
    315          	}
    316          	return &pool[index++];
   \                     ??next_0:
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x1C41             ADDS     R1,R0,#+1
   \   0000001A   0x6061             STR      R1,[R4, #+4]
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0xEB11 0x1000      ADDS     R0,R1,R0, LSL #+4
   \                     ??next_1:
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    317          }
    318          

   \                                 In section .text, align 2, keep-with-next
    319          bool isNumeric(const char* line) {
    320          	return line[0] >= '0' && line[0] <= '9';
   \                     _Z9isNumericPKc:
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x2930             CMP      R1,#+48
   \   00000004   0xDB04             BLT.N    ??isNumeric_0
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x283A             CMP      R0,#+58
   \   0000000A   0xDA01             BGE.N    ??isNumeric_0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??isNumeric_1
   \                     ??isNumeric_0:
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??isNumeric_1:
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /**
    324           * @return pointer at the position after the consumed token, null if no token consumed
    325           */

   \                                 In section .text, align 2, keep-with-next
    326          const char *getNextToken(const char *line, char *buffer, const int bufferSize) {
   \                     _Z12getNextTokenPKcPci:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    327          	while (line[0] != 0 && line[0] == ' ') {
   \                     ??getNextToken_0:
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??getNextToken_1
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xD101             BNE.N    ??getNextToken_1
    328          		line++;
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \   00000016   0xE7F7             B.N      ??getNextToken_0
    329          	}
    330          	if (line[0] == 0) {
   \                     ??getNextToken_1:
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??getNextToken_2
    331          		return NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE01B             B.N      ??getNextToken_3
    332          	}
    333          	int tokenLen = indexOf(line, ' ');
   \                     ??getNextToken_2:
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       indexOf
   \   0000002A   0x0007             MOVS     R7,R0
    334          	if (tokenLen == -1) {
   \   0000002C   0xF117 0x0F01      CMN      R7,#+1
   \   00000030   0xD103             BNE.N    ??getNextToken_4
    335          		// no space - the whole remaining line is the token
    336          		tokenLen = strlen(line);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       strlen
   \   00000038   0x0007             MOVS     R7,R0
    337          	}
    338          	efiAssert(tokenLen < bufferSize, "token overflow", NULL);
   \                     ??getNextToken_4:
   \   0000003A   0x42B7             CMP      R7,R6
   \   0000003C   0xDB04             BLT.N    ??getNextToken_5
   \   0000003E   0x....             LDR.N    R0,??DataTable8_26
   \   00000040   0x.... 0x....      BL       firmwareError
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE008             B.N      ??getNextToken_3
    339          	strncpy(buffer, line, tokenLen);
   \                     ??getNextToken_5:
   \   00000048   0x003A             MOVS     R2,R7
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       strncpy
    340          	buffer[tokenLen] = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x5578             STRB     R0,[R7, R5]
    341          	line += tokenLen;
   \   00000056   0x193C             ADDS     R4,R7,R4
    342          	return line;
   \   00000058   0x0020             MOVS     R0,R4
   \                     ??getNextToken_3:
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    343          }
    344          

   \                                 In section .text, align 2, keep-with-next
    345          le_action_e parseAction(const char * line) {
   \                     _Z11parseActionPKc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    346          	LENameOrdinalPair *pair = LE_FIRST;
   \   00000004   0x....             LDR.N    R0,??DataTable8_17
   \   00000006   0x6805             LDR      R5,[R0, #+0]
    347          	while (pair != NULL) {
   \                     ??parseAction_0:
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD009             BEQ.N    ??parseAction_1
    348          		if (strEqualCaseInsensitive(pair->name, line)) {
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x68A8             LDR      R0,[R5, #+8]
   \   00000010   0x.... 0x....      BL       strEqualCaseInsensitive
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??parseAction_2
    349          			return pair->action;
   \   00000018   0x6868             LDR      R0,[R5, #+4]
   \   0000001A   0xE002             B.N      ??parseAction_3
    350          		}
    351          		pair = pair->next;
   \                     ??parseAction_2:
   \   0000001C   0x682D             LDR      R5,[R5, #+0]
   \   0000001E   0xE7F3             B.N      ??parseAction_0
    352          	}
    353          	return LE_UNDEFINED;
   \                     ??parseAction_1:
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??parseAction_3:
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    354          }
    355          

   \                                 In section .bss, align 4
    356          static char parsingBuffer[64];
   \                     parsingBuffer:
   \   00000000                      DS8 64
    357          

   \                                 In section .text, align 2, keep-with-next
    358          LEElement *LEElementPool::parseExpression(const char * line) {
   \                     _ZN13LEElementPool15parseExpressionEPKc:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    359          
    360          	LEElement *first = NULL;
   \   00000008   0x2600             MOVS     R6,#+0
    361          	LEElement *last = NULL;
   \   0000000A   0x2700             MOVS     R7,#+0
    362          
    363          	while (true) {
    364          		line = getNextToken(line, parsingBuffer, sizeof(parsingBuffer));
   \                     ??parseExpression_0:
   \   0000000C   0x2240             MOVS     R2,#+64
   \   0000000E   0x....             LDR.N    R1,??DataTable8_27
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       _Z12getNextTokenPKcPci
   \   00000016   0x0005             MOVS     R5,R0
    365          
    366          		if (line == NULL) {
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD101             BNE.N    ??parseExpression_1
    367          			/**
    368          			 * No more tokens in this line
    369          			 */
    370          			return first;
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0xE030             B.N      ??parseExpression_2
    371          		}
    372          
    373          		LEElement *n = next();
   \                     ??parseExpression_1:
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       _ZN13LEElementPool4nextEv
   \   00000026   0x4680             MOV      R8,R0
    374          		if (n == NULL) {
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD101             BNE.N    ??parseExpression_3
    375          			return first;
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xE027             B.N      ??parseExpression_2
    376          		}
    377          
    378          		if (isNumeric(parsingBuffer)) {
   \                     ??parseExpression_3:
   \   00000032   0x....             LDR.N    R0,??DataTable8_27
   \   00000034   0x.... 0x....      BL       _Z9isNumericPKc
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD007             BEQ.N    ??parseExpression_4
    379          			n->init(LE_NUMERIC_VALUE, atoff(parsingBuffer));
   \   0000003C   0x....             LDR.N    R0,??DataTable8_27
   \   0000003E   0x.... 0x....      BL       atoff
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x.... 0x....      BL       _ZN9LEElement4initE11le_action_ef
   \   0000004A   0xE011             B.N      ??parseExpression_5
    380          		} else {
    381          			le_action_e action = parseAction(parsingBuffer);
   \                     ??parseExpression_4:
   \   0000004C   0x....             LDR.N    R0,??DataTable8_27
   \   0000004E   0x.... 0x....      BL       _Z11parseActionPKc
   \   00000052   0x4681             MOV      R9,R0
    382          			if (action == LE_UNDEFINED) {
   \   00000054   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000058   0xD106             BNE.N    ??parseExpression_6
    383          				/**
    384          				 * Cannot recognize token
    385          				 */
    386          				warning((obd_code_e) 0, "unrecognized [%s]", parsingBuffer);
   \   0000005A   0x....             LDR.N    R2,??DataTable8_27
   \   0000005C   0x....             LDR.N    R1,??DataTable8_28
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       warning
    387          				return NULL;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE00C             B.N      ??parseExpression_2
    388          			}
    389          			n->init(action);
   \                     ??parseExpression_6:
   \   00000068   0x4649             MOV      R1,R9
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       _ZN9LEElement4initE11le_action_e
    390          		}
    391          
    392          		if (first == NULL) {
   \                     ??parseExpression_5:
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD102             BNE.N    ??parseExpression_7
    393          			first = n;
   \   00000074   0x4646             MOV      R6,R8
    394          			last = n;
   \   00000076   0x4647             MOV      R7,R8
   \   00000078   0xE7C8             B.N      ??parseExpression_0
    395          		} else {
    396          			last->next = n;
   \                     ??parseExpression_7:
   \   0000007A   0xF8C7 0x800C      STR      R8,[R7, #+12]
    397          			last = last->next;
   \   0000007E   0x68FF             LDR      R7,[R7, #+12]
   \   00000080   0xE7C4             B.N      ??parseExpression_0
    398          		}
    399          	}
   \                     ??parseExpression_2:
   \   00000082   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    400          	return first;
    401          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x61 0x6E          DC8      "and"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x26 0x00          DC8      "&",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x6F 0x72          DC8      0x6F, 0x72, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x7C 0x00          DC8      "|",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x6E 0x6F          DC8      "not"
   \              0x74 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x2B 0x00          DC8      "+",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x2D 0x00          DC8      "-",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x2A 0x00          DC8      "*",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x3E 0x00          DC8      ">",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x3E 0x3D          DC8      0x3E, 0x3D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x3C 0x00          DC8      "<",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x3C 0x3D          DC8      0x3C, 0x3D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x6D 0x61          DC8      "max"
   \              0x78 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x6D 0x69          DC8      "min"
   \              0x6E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x69 0x66          DC8      0x69, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     leAnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     leAnd2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     leOr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     leOr2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     leNot

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     leAdd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     leSub

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     leMul

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     leDiv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     leMore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     leMoreOrEqual

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     leLess

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     leLessOrEquals

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     leMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x........         DC32     leMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     leIf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x........         DC32     LE_FIRST

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x........         DC32     `?<Constant "empty stack for %d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x........         DC32     `?<Constant "FSIO logic">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x........         DC32     `?<Constant "FSIO undefined action">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x........         DC32     `?<Constant "no FSIO code">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   0x........         DC32     `?<Constant "FSIOcount">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \   00000000   0x........         DC32     `?<Constant "unexpected FSIO stack...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \   00000000   0x........         DC32     `?<Constant "LE_ELEMENT_POOL_SIZE ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_26:
   \   00000000   0x........         DC32     `?<Constant "token overflow">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_27:
   \   00000000   0x........         DC32     parsingBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_28:
   \   00000000   0x........         DC32     `?<Constant "unrecognized [%s]">`

   \                                 In section .init_array, align 4, keep-with-next, root
   \   00000000   0x........         DC32    RELOC_ARM_TARGET1 __sti__routine

   \                                 In section .rodata, align 4
   \                     `?<Constant "token overflow">`:
   \   00000000   0x74 0x6F          DC8 "token overflow"
   \              0x6B 0x65    
   \              0x6E 0x20    
   \              0x6F 0x76    
   \              0x65 0x72    
   \              0x66 0x6C    
   \              0x6F 0x77    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "LE_ELEMENT_POOL_SIZE ...">`:
   \   00000000   0x4C 0x45          DC8 "LE_ELEMENT_POOL_SIZE overflow"
   \              0x5F 0x45    
   \              0x4C 0x45    
   \              0x4D 0x45    
   \              0x4E 0x54    
   \              0x5F 0x50    
   \              0x4F 0x4F    
   \              0x4C 0x5F    
   \              0x53 0x49    
   \              0x5A 0x45    
   \              0x20 0x6F    
   \              0x76 0x65    
   \              0x72 0x66    
   \              0x6C 0x6F    
   \              0x77 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "unrecognized [%s]">`:
   \   00000000   0x75 0x6E          DC8 "unrecognized [%s]"
   \              0x72 0x65    
   \              0x63 0x6F    
   \              0x67 0x6E    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "no FSIO code">`:
   \   00000000   0x6E 0x6F          DC8 "no FSIO code"
   \              0x20 0x46    
   \              0x53 0x49    
   \              0x4F 0x20    
   \              0x63 0x6F    
   \              0x64 0x65    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "FSIOcount">`:
   \   00000000   0x46 0x53          DC8 "FSIOcount"
   \              0x49 0x4F    
   \              0x63 0x6F    
   \              0x75 0x6E    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "unexpected FSIO stack...">`:
   \   00000000   0x75 0x6E          DC8 "unexpected FSIO stack size: %d"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x46    
   \              0x53 0x49    
   \              0x4F 0x20    
   \              0x73 0x74    
   \              0x61 0x63    
   \              0x6B 0x20    
   \              0x73 0x69    
   \              0x7A 0x65    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "FSIO logic">`:
   \   00000000   0x46 0x53          DC8 "FSIO logic"
   \              0x49 0x4F    
   \              0x20 0x6C    
   \              0x6F 0x67    
   \              0x69 0x63    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "FSIO undefined action">`:
   \   00000000   0x46 0x53          DC8 "FSIO undefined action"
   \              0x49 0x4F    
   \              0x20 0x75    
   \              0x6E 0x64    
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "empty stack for %d">`:
   \   00000000   0x65 0x6D          DC8 "empty stack for %d"
   \              0x70 0x74    
   \              0x79 0x20    
   \              0x73 0x74    
   \              0x61 0x63    
   \              0x6B 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x61 0x6E          DC8 "and"
   \              0x64 0x00    

   \                                 In section .rodata, align 2
   \   00000000   0x26 0x00          DC8 "&"

   \                                 In section .rodata, align 4
   \   00000000   0x6F 0x72          DC8 "or"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x7C 0x00          DC8 "|"

   \                                 In section .rodata, align 4
   \   00000000   0x6E 0x6F          DC8 "not"
   \              0x74 0x00    

   \                                 In section .rodata, align 2
   \   00000000   0x2B 0x00          DC8 "+"

   \                                 In section .rodata, align 2
   \   00000000   0x2D 0x00          DC8 "-"

   \                                 In section .rodata, align 2
   \   00000000   0x2A 0x00          DC8 "*"

   \                                 In section .rodata, align 2
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 2
   \   00000000   0x3E 0x00          DC8 ">"

   \                                 In section .rodata, align 4
   \   00000000   0x3E 0x3D          DC8 ">="
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x3C 0x00          DC8 "<"

   \                                 In section .rodata, align 4
   \   00000000   0x3C 0x3D          DC8 "<="
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x6D 0x61          DC8 "max"
   \              0x78 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x6D 0x69          DC8 "min"
   \              0x6E 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x69 0x66          DC8 "if"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 2
   \   __code __interwork __softfp FLStack<float, 32>::subobject FLStack()
   \                     _ZN7FLStackIfLi32EEC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN7FLStackIfLi32EEC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    402          
    403          #endif /* EFI_FSIO */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FLStack<float, 32>::FLStack()
         8   -> FLStack<float, 32>::reset()
         8   -> memset
       8   FLStack<float, 32>::pop()
         8   -> firmwareError
      16   FLStack<float, 32>::push(float)
        16   -> firmwareError
       0   FLStack<float, 32>::reset()
       0   FLStack<float, 32>::size()
       8   FLStack<float, 32>::subobject FLStack()
         8   -> FLStack<float, 32>::FLStack()
       8   LECalculator::LECalculator()
         8   -> FLStack<float, 32>::FLStack()
         8   -> LECalculator::reset()
       0   LECalculator::add(LEElement *)
      40   LECalculator::doJob(Engine *, LEElement *)
        40   -> LECalculator::pop(le_action_e)
        40   -> LECalculator::push(le_action_e, float)
        40   -> firmwareError
        40   -> float2bool(float)
        40   -> getLEValue(Engine *, calc_stack_t *, le_action_e)
        40   -> getRemainingStack
        40   -> maxF
        40   -> minF
        40   -> warning
      24   LECalculator::getValue(Engine *)
        24   -> FLStack<float, 32>::pop()
        24   -> FLStack<float, 32>::reset()
        24   -> FLStack<float, 32>::size()
        24   -> LECalculator::doJob(Engine *, LEElement *)
        24   -> firmwareError
        24   -> warning
      16   LECalculator::getValue2(LEElement *, Engine *)
        16   -> LECalculator::getValue(Engine *)
        16   -> LECalculator::reset(LEElement *)
      16   LECalculator::pop(le_action_e)
        16   -> FLStack<float, 32>::pop()
        16   -> FLStack<float, 32>::size()
        16   -> warning
      24   LECalculator::push(le_action_e, float)
        24   -> FLStack<float, 32>::push(float)
       8   LECalculator::reset()
         8   -> FLStack<float, 32>::reset()
      16   LECalculator::reset(LEElement *)
        16   -> LECalculator::add(LEElement *)
        16   -> LECalculator::reset()
       8   LECalculator::subobject LECalculator()
         8   -> LECalculator::LECalculator()
       0   LEElement::LEElement()
       0   LEElement::init(le_action_e)
       0   LEElement::init(le_action_e, float)
       8   LEElement::subobject LEElement()
         8   -> LEElement::LEElement()
      16   LEElementPool::LEElementPool(LEElement *, int)
        16   -> LEElementPool::reset()
       0   LEElementPool::getSize()
       8   LEElementPool::next()
         8   -> firmwareError
      32   LEElementPool::parseExpression(char const *)
        32   -> LEElement::init(le_action_e)
        32   -> LEElement::init(le_action_e, float)
        32   -> LEElementPool::next()
        32   -> atoff
        32   -> getNextToken(char const *, char *, int)
        32   -> isNumeric(char const *)
        32   -> parseAction(char const *)
        32   -> warning
       0   LEElementPool::reset()
       8   LEElementPool::subobject LEElementPool(LEElement *, int)
         8   -> LEElementPool::LEElementPool(LEElement *, int)
       0   LENameOrdinalPair::LENameOrdinalPair(le_action_e, char const *)
       8   LENameOrdinalPair::subobject LENameOrdinalPair(le_action_e, char const *)
         8   -> LENameOrdinalPair::LENameOrdinalPair(le_action_e, char const *)
       8   __sti__routine()
         8   -> LENameOrdinalPair::LENameOrdinalPair(le_action_e, char const *)
       0   float2bool(float)
      24   getNextToken(char const *, char *, int)
        24   -> firmwareError
        24   -> indexOf
        24   -> strlen
        24   -> strncpy
       0   isNumeric(char const *)
      16   memset
        16   -> __aeabi_memset
      16   parseAction(char const *)
        16   -> strEqualCaseInsensitive


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "&">
       2  ?<Constant "*">
       2  ?<Constant "+">
       2  ?<Constant "-">
       2  ?<Constant "/">
       2  ?<Constant "<">
       4  ?<Constant "<=">
       2  ?<Constant ">">
       4  ?<Constant ">=">
      12  ?<Constant "FSIO logic">
      24  ?<Constant "FSIO undefined action">
      12  ?<Constant "FSIOcount">
      32  ?<Constant "LE_ELEMENT_POOL_SIZE ...">
       4  ?<Constant "and">
      20  ?<Constant "empty stack for %d">
       4  ?<Constant "if">
       4  ?<Constant "max">
       4  ?<Constant "min">
      16  ?<Constant "no FSIO code">
       4  ?<Constant "not">
       4  ?<Constant "or">
      16  ?<Constant "token overflow">
      32  ?<Constant "unexpected FSIO stack...">
      20  ?<Constant "unrecognized [%s]">
       2  ?<Constant "|">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_24
       4  ??DataTable8_25
       4  ??DataTable8_26
       4  ??DataTable8_27
       4  ??DataTable8_28
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      24  FLStack<float, 32>::FLStack()
      36  FLStack<float, 32>::pop()
      52  FLStack<float, 32>::push(float)
       6  FLStack<float, 32>::reset()
       4  FLStack<float, 32>::size()
      12  FLStack<float, 32>::subobject FLStack()
      22  LECalculator::LECalculator()
      32  LECalculator::add(LEElement *)
    1012  LECalculator::doJob(Engine *, LEElement *)
     140  LECalculator::getValue(Engine *)
      26  LECalculator::getValue2(LEElement *, Engine *)
      48  LECalculator::pop(le_action_e)
      70  LECalculator::push(le_action_e, float)
      26  LECalculator::reset()
      22  LECalculator::reset(LEElement *)
      12  LECalculator::subobject LECalculator()
      20  LEElement::LEElement()
       4  LEElement::init(le_action_e)
       8  LEElement::init(le_action_e, float)
      12  LEElement::subobject LEElement()
      22  LEElementPool::LEElementPool(LEElement *, int)
       4  LEElementPool::getSize()
      36  LEElementPool::next()
     134  LEElementPool::parseExpression(char const *)
       6  LEElementPool::reset()
      12  LEElementPool::subobject LEElementPool(LEElement *, int)
      20  LENameOrdinalPair::LENameOrdinalPair(le_action_e, char const *)
      12  LENameOrdinalPair::subobject LENameOrdinalPair(le_action_e, char const *)
       4  LE_FIRST
     196  __sti__routine()
      20  float2bool(float)
      92  getNextToken(char const *, char *, int)
      22  isNumeric(char const *)
      12  leAdd
      12  leAnd
      12  leAnd2
      12  leDiv
      12  leIf
      12  leLess
      12  leLessOrEquals
      12  leMax
      12  leMin
      12  leMore
      12  leMoreOrEqual
      12  leMul
      12  leNot
      12  leOr
      12  leOr2
      12  leSub
      22  memset
      36  parseAction(char const *)
      64  parsingBuffer
      44  -- Other

 
   260 bytes in section .bss
     4 bytes in section .init_array
   272 bytes in section .rodata
 2 406 bytes in section .text
 
 2 254 bytes of CODE  memory (+ 156 bytes shared)
   232 bytes of CONST memory (+  40 bytes shared)
   260 bytes of DATA  memory

Errors: none
Warnings: 2
