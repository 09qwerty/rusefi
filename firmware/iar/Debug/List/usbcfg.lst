###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:06 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\serial_ #
#                       over_usb\usbcfg.c                                     #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\serial_ #
#                       over_usb\usbcfg.c -lCN F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -lA                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\u #
#                       sbcfg.lst                                             #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\us #
#                       bcfg.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\hw_layer\serial_over_usb\usbcfg.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          #include "main.h"
     18          
     19          #if HAL_USE_SERIAL_USB || defined(__DOXYGEN__)
     20          
     21          /*
     22           * Endpoints to be used for USBD1.
     23           */
     24          #define USBD1_DATA_REQUEST_EP           1
     25          #define USBD1_DATA_AVAILABLE_EP         1
     26          #define USBD1_INTERRUPT_REQUEST_EP      2
     27          
     28          /*
     29           * USB Device Descriptor.
     30           */

   \                                 In section .rodata, align 4
     31          static const uint8_t vcom_device_descriptor_data[18] = {
   \                     vcom_device_descriptor_data:
   \   00000000   0x12 0x01          DC8 18, 1, 16, 1, 2, 0, 0, 64, 131, 4, 64, 87, 0, 2, 1, 2, 3, 1, 0, 0
   \              0x10 0x01    
   \              0x02 0x00    
   \              0x00 0x40    
   \              0x83 0x04    
   \              0x40 0x57    
   \              0x00 0x02    
   \              0x01 0x02    
   \              0x03 0x01    
   \              0x00 0x00    
     32            USB_DESC_DEVICE       (0x0110,        /* bcdUSB (1.1).                    */
     33                                   0x02,          /* bDeviceClass (CDC).              */
     34                                   0x00,          /* bDeviceSubClass.                 */
     35                                   0x00,          /* bDeviceProtocol.                 */
     36                                   0x40,          /* bMaxPacketSize.                  */
     37                                   0x0483,        /* idVendor (ST).                   */
     38                                   0x5740,        /* idProduct.                       */
     39                                   0x0200,        /* bcdDevice.                       */
     40                                   1,             /* iManufacturer.                   */
     41                                   2,             /* iProduct.                        */
     42                                   3,             /* iSerialNumber.                   */
     43                                   1)             /* bNumConfigurations.              */
     44          };
     45          
     46          /*
     47           * Device Descriptor wrapper.
     48           */

   \                                 In section .rodata, align 4
     49          static const USBDescriptor vcom_device_descriptor = {
   \                     vcom_device_descriptor:
   \   00000000   0x00000012         DC32 18, vcom_device_descriptor_data
   \              0x........   
     50            sizeof vcom_device_descriptor_data,
     51            vcom_device_descriptor_data
     52          };
     53          
     54          /* Configuration Descriptor tree for a CDC.*/

   \                                 In section .rodata, align 4
     55          static const uint8_t vcom_configuration_descriptor_data[67] = {
   \                     vcom_configuration_descriptor_data:
   \   00000000   0x09 0x02          DC8 9, 2, 67, 0, 2, 1, 0, 192, 50, 9, 4, 0, 0, 1, 2, 2, 1, 0, 5, 36, 0
   \              0x43 0x00    
   \              0x02 0x01    
   \              0x00 0xC0    
   \              0x32 0x09    
   \              0x04 0x00    
   \              0x00 0x01    
   \              0x02 0x02    
   \              0x01 0x00    
   \              0x05 0x24    
   \              0x00         
   \   00000015   0x10 0x01          DC8 16, 1, 5, 36, 1, 0, 1, 4, 36, 2, 2, 5, 36, 6, 0, 1, 7, 5, 130, 3, 8
   \              0x05 0x24    
   \              0x01 0x00    
   \              0x01 0x04    
   \              0x24 0x02    
   \              0x02 0x05    
   \              0x24 0x06    
   \              0x00 0x01    
   \              0x07 0x05    
   \              0x82 0x03    
   \              0x08         
   \   0000002A   0x00 0xFF          DC8 0, 255, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 1, 2, 64, 0, 0, 7, 5, 129
   \              0x09 0x04    
   \              0x01 0x00    
   \              0x02 0x0A    
   \              0x00 0x00    
   \              0x00 0x07    
   \              0x05 0x01    
   \              0x02 0x40    
   \              0x00 0x00    
   \              0x07 0x05    
   \              0x81         
   \   0000003F   0x02 0x40          DC8 2, 64, 0, 0, 0
   \              0x00 0x00    
   \              0x00         
     56            /* Configuration Descriptor.*/
     57            USB_DESC_CONFIGURATION(67,            /* wTotalLength.                    */
     58                                   0x02,          /* bNumInterfaces.                  */
     59                                   0x01,          /* bConfigurationValue.             */
     60                                   0,             /* iConfiguration.                  */
     61                                   0xC0,          /* bmAttributes (self powered).     */
     62                                   50),           /* bMaxPower (100mA).               */
     63            /* Interface Descriptor.*/
     64            USB_DESC_INTERFACE    (0x00,          /* bInterfaceNumber.                */
     65                                   0x00,          /* bAlternateSetting.               */
     66                                   0x01,          /* bNumEndpoints.                   */
     67                                   0x02,          /* bInterfaceClass (Communications
     68                                                     Interface Class, CDC section
     69                                                     4.2).                            */
     70                                   0x02,          /* bInterfaceSubClass (Abstract
     71                                                   Control Model, CDC section 4.3).   */
     72                                   0x01,          /* bInterfaceProtocol (AT commands,
     73                                                     CDC section 4.4).                */
     74                                   0),            /* iInterface.                      */
     75            /* Header Functional Descriptor (CDC section 5.2.3).*/
     76            USB_DESC_BYTE         (5),            /* bLength.                         */
     77            USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
     78            USB_DESC_BYTE         (0x00),         /* bDescriptorSubtype (Header
     79                                                     Functional Descriptor.           */
     80            USB_DESC_BCD          (0x0110),       /* bcdCDC.                          */
     81            /* Call Management Functional Descriptor. */
     82            USB_DESC_BYTE         (5),            /* bFunctionLength.                 */
     83            USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
     84            USB_DESC_BYTE         (0x01),         /* bDescriptorSubtype (Call Management
     85                                                     Functional Descriptor).          */
     86            USB_DESC_BYTE         (0x00),         /* bmCapabilities (D0+D1).          */
     87            USB_DESC_BYTE         (0x01),         /* bDataInterface.                  */
     88            /* ACM Functional Descriptor.*/
     89            USB_DESC_BYTE         (4),            /* bFunctionLength.                 */
     90            USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
     91            USB_DESC_BYTE         (0x02),         /* bDescriptorSubtype (Abstract
     92                                                     Control Management Descriptor).  */
     93            USB_DESC_BYTE         (0x02),         /* bmCapabilities.                  */
     94            /* Union Functional Descriptor.*/
     95            USB_DESC_BYTE         (5),            /* bFunctionLength.                 */
     96            USB_DESC_BYTE         (0x24),         /* bDescriptorType (CS_INTERFACE).  */
     97            USB_DESC_BYTE         (0x06),         /* bDescriptorSubtype (Union
     98                                                     Functional Descriptor).          */
     99            USB_DESC_BYTE         (0x00),         /* bMasterInterface (Communication
    100                                                     Class Interface).                */
    101            USB_DESC_BYTE         (0x01),         /* bSlaveInterface0 (Data Class
    102                                                     Interface).                      */
    103            /* Endpoint 2 Descriptor.*/
    104            USB_DESC_ENDPOINT     (USBD1_INTERRUPT_REQUEST_EP|0x80,
    105                                   0x03,          /* bmAttributes (Interrupt).        */
    106                                   0x0008,        /* wMaxPacketSize.                  */
    107                                   0xFF),         /* bInterval.                       */
    108            /* Interface Descriptor.*/
    109            USB_DESC_INTERFACE    (0x01,          /* bInterfaceNumber.                */
    110                                   0x00,          /* bAlternateSetting.               */
    111                                   0x02,          /* bNumEndpoints.                   */
    112                                   0x0A,          /* bInterfaceClass (Data Class
    113                                                     Interface, CDC section 4.5).     */
    114                                   0x00,          /* bInterfaceSubClass (CDC section
    115                                                     4.6).                            */
    116                                   0x00,          /* bInterfaceProtocol (CDC section
    117                                                     4.7).                            */
    118                                   0x00),         /* iInterface.                      */
    119            /* Endpoint 3 Descriptor.*/
    120            USB_DESC_ENDPOINT     (USBD1_DATA_AVAILABLE_EP,       /* bEndpointAddress.*/
    121                                   0x02,          /* bmAttributes (Bulk).             */
    122                                   0x0040,        /* wMaxPacketSize.                  */
    123                                   0x00),         /* bInterval.                       */
    124            /* Endpoint 1 Descriptor.*/
    125            USB_DESC_ENDPOINT     (USBD1_DATA_REQUEST_EP|0x80,    /* bEndpointAddress.*/
    126                                   0x02,          /* bmAttributes (Bulk).             */
    127                                   0x0040,        /* wMaxPacketSize.                  */
    128                                   0x00)          /* bInterval.                       */
    129          };
    130          
    131          /*
    132           * Configuration Descriptor wrapper.
    133           */

   \                                 In section .rodata, align 4
    134          static const USBDescriptor vcom_configuration_descriptor = {
   \                     vcom_configuration_descriptor:
   \   00000000   0x00000043         DC32 67, vcom_configuration_descriptor_data
   \              0x........   
    135            sizeof vcom_configuration_descriptor_data,
    136            vcom_configuration_descriptor_data
    137          };
    138          
    139          /*
    140           * U.S. English language identifier.
    141           */

   \                                 In section .rodata, align 4
    142          static const uint8_t vcom_string0[] = {
   \                     vcom_string0:
   \   00000000   0x04 0x03          DC8 4, 3, 9, 4
   \              0x09 0x04    
    143            USB_DESC_BYTE(4),                     /* bLength.                         */
    144            USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */
    145            USB_DESC_WORD(0x0409)                 /* wLANGID (U.S. English).          */
    146          };
    147          
    148          /*
    149           * Vendor string.
    150           */

   \                                 In section .rodata, align 4
    151          static const uint8_t vcom_string1[] = {
   \                     vcom_string1:
   \   00000000   0x26 0x03          DC8 38, 3, 83, 0, 84, 0, 77, 0, 105, 0, 99, 0, 114, 0, 111, 0, 101, 0
   \              0x53 0x00    
   \              0x54 0x00    
   \              0x4D 0x00    
   \              0x69 0x00    
   \              0x63 0x00    
   \              0x72 0x00    
   \              0x6F 0x00    
   \              0x65 0x00    
   \   00000012   0x6C 0x00          DC8 108, 0, 101, 0, 99, 0, 116, 0, 114, 0, 111, 0, 110, 0, 105, 0, 99
   \              0x65 0x00    
   \              0x63 0x00    
   \              0x74 0x00    
   \              0x72 0x00    
   \              0x6F 0x00    
   \              0x6E 0x00    
   \              0x69 0x00    
   \              0x63         
   \   00000023   0x00 0x73          DC8 0, 115, 0, 0, 0
   \              0x00 0x00    
   \              0x00         
    152            USB_DESC_BYTE(38),                    /* bLength.                         */
    153            USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */
    154            'S', 0, 'T', 0, 'M', 0, 'i', 0, 'c', 0, 'r', 0, 'o', 0, 'e', 0,
    155            'l', 0, 'e', 0, 'c', 0, 't', 0, 'r', 0, 'o', 0, 'n', 0, 'i', 0,
    156            'c', 0, 's', 0
    157          };
    158          
    159          /*
    160           * Device Description string.
    161           */

   \                                 In section .rodata, align 4
    162          static const uint8_t vcom_string2[] = {
   \                     vcom_string2:
   \   00000000   0x38 0x03          DC8 56, 3, 67, 0, 104, 0, 105, 0, 98, 0, 105, 0, 79, 0, 83, 0, 47, 0
   \              0x43 0x00    
   \              0x68 0x00    
   \              0x69 0x00    
   \              0x62 0x00    
   \              0x69 0x00    
   \              0x4F 0x00    
   \              0x53 0x00    
   \              0x2F 0x00    
   \   00000012   0x52 0x00          DC8 82, 0, 84, 0, 32, 0, 86, 0, 105, 0, 114, 0, 116, 0, 117, 0, 97, 0
   \              0x54 0x00    
   \              0x20 0x00    
   \              0x56 0x00    
   \              0x69 0x00    
   \              0x72 0x00    
   \              0x74 0x00    
   \              0x75 0x00    
   \              0x61 0x00    
   \   00000024   0x6C 0x00          DC8 108, 0, 32, 0, 67, 0, 79, 0, 77, 0, 32, 0, 80, 0, 111, 0, 114, 0
   \              0x20 0x00    
   \              0x43 0x00    
   \              0x4F 0x00    
   \              0x4D 0x00    
   \              0x20 0x00    
   \              0x50 0x00    
   \              0x6F 0x00    
   \              0x72 0x00    
   \   00000036   0x74 0x00          DC8 116, 0
    163            USB_DESC_BYTE(56),                    /* bLength.                         */
    164            USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */
    165            'C', 0, 'h', 0, 'i', 0, 'b', 0, 'i', 0, 'O', 0, 'S', 0, '/', 0,
    166            'R', 0, 'T', 0, ' ', 0, 'V', 0, 'i', 0, 'r', 0, 't', 0, 'u', 0,
    167            'a', 0, 'l', 0, ' ', 0, 'C', 0, 'O', 0, 'M', 0, ' ', 0, 'P', 0,
    168            'o', 0, 'r', 0, 't', 0
    169          };
    170          
    171          /*
    172           * Serial Number string.
    173           */

   \                                 In section .rodata, align 4
    174          static const uint8_t vcom_string3[] = {
   \                     vcom_string3:
   \   00000000   0x08 0x03          DC8 8, 3, 50, 0, 54, 0, 56, 0
   \              0x32 0x00    
   \              0x36 0x00    
   \              0x38 0x00    
    175            USB_DESC_BYTE(8),                     /* bLength.                         */
    176            USB_DESC_BYTE(USB_DESCRIPTOR_STRING), /* bDescriptorType.                 */
    177            '0' + CH_KERNEL_MAJOR, 0,
    178            '0' + CH_KERNEL_MINOR, 0,
    179            '0' + CH_KERNEL_PATCH, 0
    180          };
    181          
    182          /*
    183           * Strings wrappers array.
    184           */

   \                                 In section .rodata, align 4
    185          static const USBDescriptor vcom_strings[] = {
   \                     vcom_strings:
   \   00000000   0x00000004         DC32 4, vcom_string0, 38, vcom_string1, 56, vcom_string2, 8
   \              0x........   
   \              0x00000026   
   \              0x........   
   \              0x00000038   
   \              0x........   
   \              0x00000008   
   \   0000001C   0x........         DC32 vcom_string3
    186            {sizeof vcom_string0, vcom_string0},
    187            {sizeof vcom_string1, vcom_string1},
    188            {sizeof vcom_string2, vcom_string2},
    189            {sizeof vcom_string3, vcom_string3}
    190          };
    191          
    192          /*
    193           * Handles the GET_DESCRIPTOR callback. All required descriptors must be
    194           * handled here.
    195           */

   \                                 In section .text, align 2, keep-with-next
    196          static const USBDescriptor *get_descriptor(USBDriver *usbp,
    197                                                     uint8_t dtype,
    198                                                     uint8_t dindex,
    199                                                     uint16_t lang) {
   \                     get_descriptor:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0004             MOVS     R4,R0
    200          
    201            (void)usbp;
    202            (void)lang;
    203            switch (dtype) {
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD004             BEQ.N    ??get_descriptor_0
   \   0000000A   0xD30F             BCC.N    ??get_descriptor_1
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0xD005             BEQ.N    ??get_descriptor_2
   \   00000010   0xD302             BCC.N    ??get_descriptor_3
   \   00000012   0xE00B             B.N      ??get_descriptor_1
    204            case USB_DESCRIPTOR_DEVICE:
    205              return &vcom_device_descriptor;
   \                     ??get_descriptor_0:
   \   00000014   0x....             LDR.N    R0,??DataTable1
   \   00000016   0xE00A             B.N      ??get_descriptor_4
    206            case USB_DESCRIPTOR_CONFIGURATION:
    207              return &vcom_configuration_descriptor;
   \                     ??get_descriptor_3:
   \   00000018   0x....             LDR.N    R0,??DataTable1_1
   \   0000001A   0xE008             B.N      ??get_descriptor_4
    208            case USB_DESCRIPTOR_STRING:
    209              if (dindex < 4)
   \                     ??get_descriptor_2:
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x2A04             CMP      R2,#+4
   \   00000020   0xDA04             BGE.N    ??get_descriptor_1
    210                return &vcom_strings[dindex];
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x....             LDR.N    R0,??DataTable1_2
   \   00000026   0xEB10 0x00C2      ADDS     R0,R0,R2, LSL #+3
   \   0000002A   0xE000             B.N      ??get_descriptor_4
    211            }
    212            return NULL;
   \                     ??get_descriptor_1:
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??get_descriptor_4:
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    213          }
    214          
    215          /**
    216           * @brief   IN EP1 state.
    217           */

   \                                 In section .bss, align 4
    218          static USBInEndpointState ep1instate;
   \                     ep1instate:
   \   00000000                      DS8 20
    219          
    220          /**
    221           * @brief   OUT EP1 state.
    222           */

   \                                 In section .bss, align 4
    223          static USBOutEndpointState ep1outstate;
   \                     ep1outstate:
   \   00000000                      DS8 20
    224          
    225          /**
    226           * @brief   EP1 initialization structure (both IN and OUT).
    227           */

   \                                 In section .rodata, align 4
    228          static const USBEndpointConfig ep1config = {
   \                     ep1config:
   \   00000000   0x00000002         DC32 2, 0H, sduDataTransmitted, sduDataReceived
   \              0x00000000   
   \              0x........   
   \              0x........   
   \   00000010   0x0040 0x0040      DC16 64, 64
   \   00000014   0x........         DC32 ep1instate, ep1outstate
   \              0x........   
   \   0000001C   0x0002             DC16 2
   \   0000001E   0x00 0x00          DC8 0, 0
   \   00000020   0x00000000         DC32 0H
    229            USB_EP_MODE_TYPE_BULK,
    230            NULL,
    231            sduDataTransmitted,
    232            sduDataReceived,
    233            0x0040,
    234            0x0040,
    235            &ep1instate,
    236            &ep1outstate,
    237            2,
    238            NULL
    239          };
    240          
    241          /**
    242           * @brief   IN EP2 state.
    243           */

   \                                 In section .bss, align 4
    244          static USBInEndpointState ep2instate;
   \                     ep2instate:
   \   00000000                      DS8 20
    245          
    246          /**
    247           * @brief   EP2 initialization structure (IN only).
    248           */

   \                                 In section .rodata, align 4
    249          static const USBEndpointConfig ep2config = {
   \                     ep2config:
   \   00000000   0x00000003         DC32 3, 0H, sduInterruptTransmitted, 0H
   \              0x00000000   
   \              0x........   
   \              0x00000000   
   \   00000010   0x0010 0x0000      DC16 16, 0
   \   00000014   0x........         DC32 ep2instate, 0H
   \              0x00000000   
   \   0000001C   0x0001             DC16 1
   \   0000001E   0x00 0x00          DC8 0, 0
   \   00000020   0x00000000         DC32 0H
    250            USB_EP_MODE_TYPE_INTR,
    251            NULL,
    252            sduInterruptTransmitted,
    253            NULL,
    254            0x0010,
    255            0x0000,
    256            &ep2instate,
    257            NULL,
    258            1,
    259            NULL
    260          };
    261          
    262          /*
    263           * Handles the USB driver global events.
    264           */

   \                                 In section .text, align 2, keep-with-next
    265          static void usb_event(USBDriver *usbp, usbevent_t event) {
   \                     usb_event:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    266            extern SerialUSBDriver SDU1;
    267          
    268            switch (event) {
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD008             BEQ.N    ??usb_event_0
   \   0000000C   0x2D02             CMP      R5,#+2
   \   0000000E   0xD008             BEQ.N    ??usb_event_1
   \   00000010   0xD306             BCC.N    ??usb_event_2
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xD01E             BEQ.N    ??usb_event_3
   \   00000016   0xD31C             BCC.N    ??usb_event_4
   \   00000018   0x2D05             CMP      R5,#+5
   \   0000001A   0xD01C             BEQ.N    ??usb_event_5
   \   0000001C   0xE01C             B.N      ??usb_event_6
    269            case USB_EVENT_RESET:
    270              return;
   \                     ??usb_event_0:
   \   0000001E   0xE01B             B.N      ??usb_event_7
    271            case USB_EVENT_ADDRESS:
    272              return;
   \                     ??usb_event_2:
   \   00000020   0xE01A             B.N      ??usb_event_7
    273            case USB_EVENT_CONFIGURED:
    274              chSysLockFromIsr();
   \                     ??usb_event_1:
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000028   0x.... 0x....      BL       dbg_check_lock_from_isr
    275          
    276              /* Enables the endpoints specified into the configuration.
    277                 Note, this callback is invoked from an ISR so I-Class functions
    278                 must be used.*/
    279              usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
   \   0000002C   0x....             LDR.N    R2,??DataTable1_3
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       usbInitEndpointI
    280              usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
   \   00000036   0x....             LDR.N    R2,??DataTable1_4
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       usbInitEndpointI
    281          
    282              /* Resetting the state of the CDC subsystem.*/
    283              sduConfigureHookI(&SDU1);
   \   00000040   0x....             LDR.N    R0,??DataTable1_5
   \   00000042   0x.... 0x....      BL       sduConfigureHookI
    284          
    285              chSysUnlockFromIsr();
   \   00000046   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF380 0x8811      MSR      BASEPRI,R0
    286              return;
   \   00000050   0xE002             B.N      ??usb_event_7
    287            case USB_EVENT_SUSPEND:
    288              return;
   \                     ??usb_event_4:
   \   00000052   0xE001             B.N      ??usb_event_7
    289            case USB_EVENT_WAKEUP:
    290              return;
   \                     ??usb_event_3:
   \   00000054   0xE000             B.N      ??usb_event_7
    291            case USB_EVENT_STALLED:
    292              return;
   \                     ??usb_event_5:
   \   00000056   0xE7FF             B.N      ??usb_event_7
    293            }
    294            return;
   \                     ??usb_event_6:
   \                     ??usb_event_7:
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    295          }
    296          
    297          /*
    298           * USB driver configuration.
    299           */

   \                                 In section .rodata, align 4
    300          const USBConfig usbcfg = {
   \                     usbcfg:
   \   00000000   0x........         DC32 usb_event, get_descriptor, sduRequestsHook, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
    301            usb_event,
    302            get_descriptor,
    303            sduRequestsHook,
    304            NULL
    305          };
    306          
    307          /*
    308           * Serial over USB driver configuration.
    309           */

   \                                 In section .rodata, align 4
    310          const SerialUSBConfig serusbcfg = {
   \                     serusbcfg:
   \   00000000   0x........         DC32 USBD1
   \   00000004   0x01 0x01          DC8 1, 1, 2, 0
   \              0x02 0x00    
    311            &USBD1,
    312            USBD1_DATA_REQUEST_EP,
    313            USBD1_DATA_AVAILABLE_EP,
    314            USBD1_INTERRUPT_REQUEST_EP
    315          };
    316          
    317          /* Virtual serial port over USB.*/

   \                                 In section .bss, align 4
    318          SerialUSBDriver SDU1;
   \                     SDU1:
   \   00000000                      DS8 600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     vcom_device_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     vcom_configuration_descriptor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     vcom_strings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     ep1config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     ep2config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x........         DC32     SDU1
    319          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   get_descriptor
      16   usb_event
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
        16   -> sduConfigureHookI
        16   -> usbInitEndpointI


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
     600  SDU1
      36  ep1config
      20  ep1instate
      20  ep1outstate
      36  ep2config
      20  ep2instate
      50  get_descriptor
       8  serusbcfg
      90  usb_event
      16  usbcfg
       8  vcom_configuration_descriptor
      68  vcom_configuration_descriptor_data
       8  vcom_device_descriptor
      20  vcom_device_descriptor_data
       4  vcom_string0
      40  vcom_string1
      56  vcom_string2
       8  vcom_string3
      32  vcom_strings

 
 660 bytes in section .bss
 340 bytes in section .rodata
 164 bytes in section .text
 
 164 bytes of CODE  memory
 340 bytes of CONST memory
 660 bytes of DATA  memory

Errors: none
Warnings: none
