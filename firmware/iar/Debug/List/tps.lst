###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:04 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\sens #
#                       ors\tps.cpp                                           #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\sens #
#                       ors\tps.cpp -lCN F:\stuff\rusefi_sourceforge\firmware #
#                       \iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\Obj\ --no_cse --no_unroll           #
#                       --no_inline --no_code_motion --no_tbaa                #
#                       --no_clustering --no_scheduling --debug               #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\t #
#                       ps.lst                                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\tp #
#                       s.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\sensors\tps.cpp
      1          #include "main.h"
      2          #include "tps.h"
      3          #include "engine_configuration.h"
      4          #include "interpolation.h"
      5          #include "adc_inputs.h"
      6          #include "allsensors.h"
      7          
      8          #if !EFI_PROD_CODE
      9          	int mockTps;
     10          #endif
     11          
     12          	EXTERN_ENGINE;
     13          
     14          /**
     15           * We are using one instance for read and another for modification, this is how we get lock-free thread-safety
     16           *
     17           */

   \                                 In section .bss, align 4
     18          static tps_roc_s states[2];
   \                     states:
   \   00000000                      DS8 40
     19          

   \                                 In section .bss, align 4
     20          int tpsFastAdc = 0;
   \                     tpsFastAdc:
   \   00000000                      DS8 4
     21          

   \                                 In section .bss, align 4
     22          static volatile int tpsRocIndex = 0;
   \                     tpsRocIndex:
   \   00000000                      DS8 4
     23          
     24          /**
     25           * this method is lock-free thread-safe if invoked only from one thread
     26           */

   \                                 In section .text, align 2, keep-with-next
     27          void saveTpsState(time_t now, float curValue) {
   \                     _Z12saveTpsStatejf:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xED2D 0x8B02      VPUSH    {D8}
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
     28          	int tpsNextIndex = (tpsRocIndex + 1) % 2;
   \   0000000E   0x....             LDR.N    R0,??DataTable7_8
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0xFB90 0xF5F1      SDIV     R5,R0,R1
   \   0000001A   0xFB05 0x0511      MLS      R5,R5,R1,R0
     29          	tps_roc_s *cur = &states[tpsRocIndex];
   \   0000001E   0x....             LDR.N    R0,??DataTable7_8
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2114             MOVS     R1,#+20
   \   00000024   0x....             LDR.N    R2,??DataTable7_9
   \   00000026   0xFB01 0x2600      MLA      R6,R1,R0,R2
     30          	tps_roc_s *next = &states[tpsNextIndex];
   \   0000002A   0x2014             MOVS     R0,#+20
   \   0000002C   0x....             LDR.N    R1,??DataTable7_9
   \   0000002E   0xFB00 0x1705      MLA      R7,R0,R5,R1
     31          
     32          	next->prevTime = cur->curTime;
   \   00000032   0x68B0             LDR      R0,[R6, #+8]
   \   00000034   0x6038             STR      R0,[R7, #+0]
     33          	next->prevValue = cur->curValue;
   \   00000036   0x68F0             LDR      R0,[R6, #+12]
   \   00000038   0x6078             STR      R0,[R7, #+4]
     34          	next->curTime = now;
   \   0000003A   0x60BC             STR      R4,[R7, #+8]
     35          	next->curValue = curValue;
   \   0000003C   0xED87 0x8A03      VSTR     S16,[R7, #+12]
     36          
     37          	int diffSysticks = overflowDiff(now, cur->curTime);
   \   00000040   0x68B0             LDR      R0,[R6, #+8]
   \   00000042   0xEBB4 0x0800      SUBS     R8,R4,R0
     38          	float diffSeconds = diffSysticks * 1.0 / CH_FREQUENCY;
   \   00000046   0x4640             MOV      R0,R8
   \   00000048   0x.... 0x....      BL       __aeabi_i2d
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x....             LDR.N    R3,??DataTable7_10  ;; 0x3ff00000
   \   00000050   0x.... 0x....      BL       __aeabi_dmul
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x....             LDR.N    R3,??DataTable7_11  ;; 0x408f4000
   \   00000058   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005C   0x.... 0x....      BL       __aeabi_d2f
   \   00000060   0xEE00 0x0A10      VMOV     S0,R0
     39          	next->rateOfChange = (curValue - cur->curValue) / diffSeconds;
   \   00000064   0xEDD6 0x0A03      VLDR     S1,[R6, #+12]
   \   00000068   0xEE78 0x0A60      VSUB.F32 S1,S16,S1
   \   0000006C   0xEEC0 0x0A80      VDIV.F32 S1,S1,S0
   \   00000070   0xEDC7 0x0A04      VSTR     S1,[R7, #+16]
     40          
     41          	// here we update volatile index
     42          	tpsRocIndex = tpsNextIndex;
   \   00000074   0x....             LDR.N    R0,??DataTable7_8
   \   00000076   0x6005             STR      R5,[R0, #+0]
     43          }
   \   00000078   0xECBD 0x8B02      VPOP     {D8}
   \   0000007C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     44          
     45          /**
     46           * this read-only method is lock-free thread-safe
     47           */

   \                                 In section .text, align 2, keep-with-next
     48          float getTpsRateOfChange(void) {
     49          	return states[tpsRocIndex].rateOfChange;
   \                     _Z18getTpsRateOfChangev:
   \   00000000   0x....             LDR.N    R0,??DataTable7_8
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2114             MOVS     R1,#+20
   \   00000006   0x....             LDR.N    R2,??DataTable7_9
   \   00000008   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000000C   0xED90 0x0A04      VLDR     S0,[R0, #+16]
   \   00000010   0x4770             BX       LR               ;; return
     50          }
     51          
     52          /*
     53           * Return current TPS position based on configured ADC levels, and adc
     54           *
     55           * */

   \                                 In section .text, align 4, keep-with-next
     56          percent_t getTpsValue(int adc DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z11getTpsValuei:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEE08 0x0A10      VMOV     S16,R0
     57          	if (engineConfiguration->tpsMin == engineConfiguration->tpsMax) {
   \   0000000A   0x....             LDR.N    R0,??DataTable7_12
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF9B0 0x0052      LDRSH    R0,[R0, #+82]
   \   00000012   0x....             LDR.N    R1,??DataTable7_12
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF9B1 0x1054      LDRSH    R1,[R1, #+84]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD10B             BNE.N    ??getTpsValue_0
     58          		warning(OBD_PCM_Processor_Fault, "Invalid TPS configuration: same value %d", engineConfiguration->tpsMin);
   \   0000001E   0x....             LDR.N    R0,??DataTable7_12
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF9B0 0x2052      LDRSH    R2,[R0, #+82]
   \   00000026   0x....             LDR.N    R1,??DataTable7_13
   \   00000028   0xF240 0x205E      MOVW     R0,#+606
   \   0000002C   0x.... 0x....      BL       warning
     59          		return NAN;
   \   00000030   0xED9F 0x....      VLDR.W   S0,??DataTable7  ;; 0x7fffffff
   \   00000034   0xE025             B.N      ??getTpsValue_1
     60          	}
     61          	float result = interpolate(engineConfiguration->tpsMin, 0, engineConfiguration->tpsMax, 100, adc);
   \                     ??getTpsValue_0:
   \   00000036   0xEEB8 0x2AC8      VCVT.F32.S32 S4,S16
   \   0000003A   0xEDDF 0x....      VLDR.W   S3,??DataTable7_1  ;; 0x42c80000
   \   0000003E   0x....             LDR.N    R0,??DataTable7_12
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF9B0 0x0054      LDRSH    R0,[R0, #+84]
   \   00000046   0xEE00 0x0A10      VMOV     S0,R0
   \   0000004A   0xEEB8 0x1AC0      VCVT.F32.S32 S2,S0
   \   0000004E   0xEDDF 0x....      VLDR.W   S1,??DataTable7_2  ;; 0x0
   \   00000052   0x....             LDR.N    R0,??DataTable7_12
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF9B0 0x0052      LDRSH    R0,[R0, #+82]
   \   0000005A   0xEE00 0x0A10      VMOV     S0,R0
   \   0000005E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000062   0x.... 0x....      BL       _Z11interpolatefffff
   \   00000066   0xEEF0 0x8A40      VMOV.F32 S17,S0
     62          	// this would put the value into the 0-100 range
     63          	return maxF(0, minF(100, result));
   \   0000006A   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   0000006E   0xED9F 0x....      VLDR.W   S0,??DataTable7_1  ;; 0x42c80000
   \   00000072   0x.... 0x....      BL       minF
   \   00000076   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   0000007A   0xED9F 0x....      VLDR.W   S0,??DataTable7_2  ;; 0x0
   \   0000007E   0x.... 0x....      BL       maxF
   \                     ??getTpsValue_1:
   \   00000082   0xECBD 0x8B02      VPOP     {D8}
   \   00000086   0xBD01             POP      {R0,PC}          ;; return
     64          }
     65          
     66          /*
     67           * Return voltage on TPS AND channel
     68           * */

   \                                 In section .text, align 4, keep-with-next
     69          float getTPSVoltage(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z13getTPSVoltagev:
   \   00000000   0xB580             PUSH     {R7,LR}
     70          	return getVoltageDivided("tps", engineConfiguration->tpsAdcChannel);
   \   00000002   0x....             LDR.N    R0,??DataTable7_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF8D0 0x120C      LDR      R1,[R0, #+524]
   \   0000000A   0x....             ADR.N    R0,??DataTable7_3  ;; "tps"
   \   0000000C   0x.... 0x....      BL       _Z19getInternalAdcValuePKc13adc_channel_e
   \   00000010   0xEE00 0x0A10      VMOV     S0,R0
   \   00000014   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000018   0xEDDF 0x....      VLDR.W   S1,??DataTable7_4  ;; 0x3a400c01
   \   0000001C   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000020   0x....             LDR.N    R0,??DataTable7_12
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xEDD0 0x0A74      VLDR     S1,[R0, #+464]
   \   00000028   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
     71          }
     72          
     73          /*
     74           * Return TPS ADC readings.
     75           * We need ADC value because TunerStudio has a nice TPS configuration wizard, and this wizard
     76           * wants a TPS value.
     77           */

   \                                 In section .text, align 2, keep-with-next
     78          int getTPS10bitAdc(DECLARE_ENGINE_PARAMETER_F) {
     79          #if !EFI_PROD_CODE
     80          	if (mockTps != MOCK_UNDEFINED)
     81          		return mockTps;
     82          #endif
     83          	if(engineConfiguration->tpsAdcChannel==EFI_ADC_NONE)
   \                     _Z14getTPS10bitAdcv:
   \   00000000   0x....             LDR.N    R0,??DataTable7_12
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF8D0 0x020C      LDR      R0,[R0, #+524]
   \   00000008   0x2810             CMP      R0,#+16
   \   0000000A   0xD102             BNE.N    ??getTPS10bitAdc_0
     84          		return -1;
   \   0000000C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000010   0xE004             B.N      ??getTPS10bitAdc_1
     85          #if EFI_PROD_CODE
     86          	return tpsFastAdc / 4;
   \                     ??getTPS10bitAdc_0:
   \   00000012   0x....             LDR.N    R0,??DataTable7_14
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \                     ??getTPS10bitAdc_1:
   \   0000001C   0x4770             BX       LR               ;; return
     87          #else
     88          	return 0;
     89          #endif /* EFI_PROD_CODE */
     90          }
     91          
     92          /**
     93           * @brief Position on physical primary TPS
     94           */

   \                                 In section .text, align 2, keep-with-next
     95          static float getPrimatyRawTPS(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z16getPrimatyRawTPSv:
   \   00000000   0xB580             PUSH     {R7,LR}
     96          	float tpsValue = getTpsValue(getTPS10bitAdc(PASS_ENGINE_PARAMETER_F) PASS_ENGINE_PARAMETER);
   \   00000002   0x.... 0x....      BL       _Z14getTPS10bitAdcv
   \   00000006   0x.... 0x....      BL       _Z11getTpsValuei
     97          	return tpsValue;
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
     98          }
     99          
    100          #define NO_TPS_MAGIC_VALUE 66.611
    101          

   \                                 In section .text, align 4, keep-with-next
    102          percent_t getPedalPosition(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z16getPedalPositionv:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
    103          	float voltage = getVoltageDivided("pPS", engineConfiguration->pedalPositionChannel);
   \   00000006   0x....             LDR.N    R0,??DataTable7_12
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF8D0 0x125C      LDR      R1,[R0, #+604]
   \   0000000E   0x....             ADR.N    R0,??DataTable7_5  ;; "pPS"
   \   00000010   0x.... 0x....      BL       _Z19getInternalAdcValuePKc13adc_channel_e
   \   00000014   0xEE00 0x0A10      VMOV     S0,R0
   \   00000018   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001C   0xEDDF 0x....      VLDR.W   S1,??DataTable7_4  ;; 0x3a400c01
   \   00000020   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000024   0x....             LDR.N    R0,??DataTable7_12
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xEDD0 0x0A74      VLDR     S1,[R0, #+464]
   \   0000002C   0xEE20 0x8A20      VMUL.F32 S16,S0,S1
    104          	float result = interpolate(engineConfiguration->pedalPositionMin, 0, engineConfiguration->pedalPositionMax, 100, voltage);
   \   00000030   0xEEB0 0x2A48      VMOV.F32 S4,S16
   \   00000034   0xEDDF 0x....      VLDR.W   S3,??DataTable7_1  ;; 0x42c80000
   \   00000038   0x....             LDR.N    R0,??DataTable7_12
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF9B0 0x023E      LDRSH    R0,[R0, #+574]
   \   00000040   0xEE00 0x0A10      VMOV     S0,R0
   \   00000044   0xEEB8 0x1AC0      VCVT.F32.S32 S2,S0
   \   00000048   0xEDDF 0x....      VLDR.W   S1,??DataTable7_2  ;; 0x0
   \   0000004C   0x....             LDR.N    R0,??DataTable7_12
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF9B0 0x023C      LDRSH    R0,[R0, #+572]
   \   00000054   0xEE00 0x0A10      VMOV     S0,R0
   \   00000058   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000005C   0x.... 0x....      BL       _Z11interpolatefffff
   \   00000060   0xEEF0 0x8A40      VMOV.F32 S17,S0
    105          
    106          	// this would put the value into the 0-100 range
    107          	return maxF(0, minF(100, result));
   \   00000064   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   00000068   0xED9F 0x....      VLDR.W   S0,??DataTable7_1  ;; 0x42c80000
   \   0000006C   0x.... 0x....      BL       minF
   \   00000070   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   00000074   0xED9F 0x....      VLDR.W   S0,??DataTable7_2  ;; 0x0
   \   00000078   0x.... 0x....      BL       maxF
   \   0000007C   0xECBD 0x8B02      VPOP     {D8}
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
    108          }
    109          

   \                                 In section .text, align 4, keep-with-next
    110          percent_t getTPS(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z6getTPSv:
   \   00000000   0xB580             PUSH     {R7,LR}
    111          	if (!engineConfiguration->hasTpsSensor)
   \   00000002   0x....             LDR.N    R0,??DataTable7_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF890 0x05D9      LDRB     R0,[R0, #+1497]
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x09C0             LSRS     R0,R0,#+7
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD102             BNE.N    ??getTPS_0
    112          		return NO_TPS_MAGIC_VALUE;
   \   00000014   0xED9F 0x....      VLDR.W   S0,??DataTable7_6  ;; 0x428538d5
   \   00000018   0xE001             B.N      ??getTPS_1
    113          	// todo: if (config->isDualTps)
    114          	// todo: blah blah
    115          	// todo: if two TPS do not match - show OBD code via malfunction_central.c
    116          
    117          	return getPrimatyRawTPS(PASS_ENGINE_PARAMETER_F);
   \                     ??getTPS_0:
   \   0000001A   0x.... 0x....      BL       _Z16getPrimatyRawTPSv
   \                     ??getTPS_1:
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    118          }
    119          

   \                                 In section .text, align 4, keep-with-next
    120          int convertVoltageTo10bitADC(float voltage) {
   \                     _Z24convertVoltageTo10bitADCf:
   \   00000000   0xB500             PUSH     {LR}
    121          	// divided by 2 because of voltage divider, then converted into 10bit ADC value (TunerStudio format)
    122          	return (int) (voltage / 2 * 1024 / 3.3);
   \   00000002   0xEEF0 0x0A00      VMOV.F32 S1,#2.0
   \   00000006   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000000A   0xEDDF 0x....      VLDR.W   S1,??DataTable7_7  ;; 0x44800000
   \   0000000E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000012   0xEE10 0x0A10      VMOV     R0,S0
   \   00000016   0x.... 0x....      BL       __aeabi_f2d
   \   0000001A   0xF05F 0x3266      MOVS     R2,#+1717986918
   \   0000001E   0x....             LDR.N    R3,??DataTable7_15  ;; 0x400a6666
   \   00000020   0x.... 0x....      BL       __aeabi_ddiv
   \   00000024   0x.... 0x....      BL       __aeabi_d2iz
   \   00000028   0xBD00             POP      {PC}             ;; return
    123          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x74 0x70          DC8      "tps"
   \              0x73 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x3A400C01         DC32     0x3a400c01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x70 0x50          DC8      "pPS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x428538D5         DC32     0x428538d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x44800000         DC32     0x44800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     tpsRocIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     states

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x408F4000         DC32     0x408f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     `?<Constant "Invalid TPS configura...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     tpsFastAdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x400A6666         DC32     0x400a6666

   \                                 In section .rodata, align 4
   \                     `?<Constant "Invalid TPS configura...">`:
   \   00000000   0x49 0x6E          DC8 "Invalid TPS configuration: same value %d"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x54 0x50    
   \              0x53 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x73    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x76 0x61    
   \              0x6C 0x75    
   \              0x65 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x74 0x70          DC8 "tps"
   \              0x73 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x70 0x50          DC8 "pPS"
   \              0x53 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   convertVoltageTo10bitADC(float)
         4   -> __aeabi_d2iz
         4   -> __aeabi_ddiv
         4   -> __aeabi_f2d
      16   getPedalPosition()
        16   -> getInternalAdcValue(char const *, adc_channel_e)
        16   -> interpolate(float, float, float, float, float)
        16   -> maxF
        16   -> minF
       8   getPrimatyRawTPS()
         8   -> getTPS10bitAdc()
         8   -> getTpsValue(int)
       8   getTPS()
         8   -> getPrimatyRawTPS()
       0   getTPS10bitAdc()
       8   getTPSVoltage()
         8   -> getInternalAdcValue(char const *, adc_channel_e)
       0   getTpsRateOfChange()
      16   getTpsValue(int)
        16   -> interpolate(float, float, float, float, float)
        16   -> maxF
        16   -> minF
        16   -> warning
      32   saveTpsState(time_t, float)
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_i2d


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      44  ?<Constant "Invalid TPS configura...">
       4  ?<Constant "pPS">
       4  ?<Constant "tps">
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      42  convertVoltageTo10bitADC(float)
     130  getPedalPosition()
      12  getPrimatyRawTPS()
      32  getTPS()
      30  getTPS10bitAdc()
      46  getTPSVoltage()
      18  getTpsRateOfChange()
     136  getTpsValue(int)
     128  saveTpsState(time_t, float)
      40  states
       4  tpsFastAdc
       4  tpsRocIndex

 
  48 bytes in section .bss
  52 bytes in section .rodata
 638 bytes in section .text
 
 638 bytes of CODE  memory
  52 bytes of CONST memory
  48 bytes of DATA  memory

Errors: none
Warnings: 1
