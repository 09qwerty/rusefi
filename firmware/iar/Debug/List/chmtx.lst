###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:42 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chmtx.c                                         #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chmtx.c -lCN F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -o                             #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hmtx.lst                                              #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       mtx.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chmtx.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    chmtx.c
     30           * @brief   Mutexes code.
     31           *
     32           * @addtogroup mutexes
     33           * @details Mutexes related APIs and services.
     34           *
     35           *          <h2>Operation mode</h2>
     36           *          A mutex is a threads synchronization object that can be in two
     37           *          distinct states:
     38           *          - Not owned (unlocked).
     39           *          - Owned by a thread (locked).
     40           *          .
     41           *          Operations defined for mutexes:
     42           *          - <b>Lock</b>: The mutex is checked, if the mutex is not owned by
     43           *            some other thread then it is associated to the locking thread
     44           *            else the thread is queued on the mutex in a list ordered by
     45           *            priority.
     46           *          - <b>Unlock</b>: The mutex is released by the owner and the highest
     47           *            priority thread waiting in the queue, if any, is resumed and made
     48           *            owner of the mutex.
     49           *          .
     50           *          <h2>Constraints</h2>
     51           *          In ChibiOS/RT the Unlock operations are always performed in
     52           *          lock-reverse order. The unlock API does not even have a parameter,
     53           *          the mutex to unlock is selected from an internal, per-thread, stack
     54           *          of owned mutexes. This both improves the performance and is
     55           *          required for an efficient implementation of the priority
     56           *          inheritance mechanism.
     57           *
     58           *          <h2>The priority inversion problem</h2>
     59           *          The mutexes in ChibiOS/RT implements the <b>full</b> priority
     60           *          inheritance mechanism in order handle the priority inversion
     61           *          problem.<br>
     62           *          When a thread is queued on a mutex, any thread, directly or
     63           *          indirectly, holding the mutex gains the same priority of the
     64           *          waiting thread (if their priority was not already equal or higher).
     65           *          The mechanism works with any number of nested mutexes and any
     66           *          number of involved threads. The algorithm complexity (worst case)
     67           *          is N with N equal to the number of nested mutexes.
     68           * @pre     In order to use the mutex APIs the @p CH_USE_MUTEXES option
     69           *          must be enabled in @p chconf.h.
     70           * @post    Enabling mutexes requires 5-12 (depending on the architecture)
     71           *          extra bytes in the @p Thread structure.
     72           * @{
     73           */
     74          
     75          #include "ch.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void prio_insert(struct Thread *, ThreadsQueue *)
   \                     prio_insert:
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x000A             MOVS     R2,R1
   \                     ??prio_insert_0:
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x428A             CMP      R2,R1
   \   00000008   0xD003             BEQ.N    ??prio_insert_1
   \   0000000A   0x6893             LDR      R3,[R2, #+8]
   \   0000000C   0x6884             LDR      R4,[R0, #+8]
   \   0000000E   0x42A3             CMP      R3,R4
   \   00000010   0xD2F8             BCS.N    ??prio_insert_0
   \                     ??prio_insert_1:
   \   00000012   0x6002             STR      R2,[R0, #+0]
   \   00000014   0x6853             LDR      R3,[R2, #+4]
   \   00000016   0x6043             STR      R3,[R0, #+4]
   \   00000018   0x6050             STR      R0,[R2, #+4]
   \   0000001A   0x6843             LDR      R3,[R0, #+4]
   \   0000001C   0x6018             STR      R0,[R3, #+0]
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *fifo_remove(ThreadsQueue *)
   \                     fifo_remove:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   \   00000008   0x6051             STR      R1,[R2, #+4]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *dequeue(struct Thread *)
   \                     dequeue:
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x600A             STR      R2,[R1, #+0]
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   \   0000000C   0x4770             BX       LR               ;; return
     76          
     77          #if CH_USE_MUTEXES || defined(__DOXYGEN__)
     78          
     79          /**
     80           * @brief   Initializes s @p Mutex structure.
     81           *
     82           * @param[out] mp       pointer to a @p Mutex structure
     83           *
     84           * @init
     85           */

   \                                 In section .text, align 2, keep-with-next
     86          void chMtxInit(Mutex *mp) {
   \                     chMtxInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     87          
     88            chDbgCheck(mp != NULL, "chMtxInit");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??chMtxInit_0
   \   00000008   0x2258             MOVS     R2,#+88
   \   0000000A   0x....             LDR.N    R1,??DataTable5
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
     89          
     90            queue_init(&mp->m_queue);
   \                     ??chMtxInit_0:
   \   00000012   0x6064             STR      R4,[R4, #+4]
   \   00000014   0x6024             STR      R4,[R4, #+0]
     91            mp->m_owner = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x60A0             STR      R0,[R4, #+8]
     92          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
     93          
     94          /**
     95           * @brief   Locks the specified mutex.
     96           * @post    The mutex is locked and inserted in the per-thread stack of owned
     97           *          mutexes.
     98           *
     99           * @param[in] mp        pointer to the @p Mutex structure
    100           *
    101           * @api
    102           */

   \                                 In section .text, align 2, keep-with-next
    103          void chMtxLock(Mutex *mp) {
   \                     chMtxLock:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    104          
    105            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    106          
    107            chMtxLockS(mp);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       chMtxLockS
    108          
    109            chSysUnlock();
   \   00000014   0x.... 0x....      BL       dbg_check_unlock
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF380 0x8811      MSR      BASEPRI,R0
    110          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    111          
    112          /**
    113           * @brief   Locks the specified mutex.
    114           * @post    The mutex is locked and inserted in the per-thread stack of owned
    115           *          mutexes.
    116           *
    117           * @param[in] mp        pointer to the @p Mutex structure
    118           *
    119           * @sclass
    120           */

   \                                 In section .text, align 2, keep-with-next
    121          void chMtxLockS(Mutex *mp) {
   \                     chMtxLockS:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    122            Thread *ctp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable5_2
   \   00000006   0x6985             LDR      R5,[R0, #+24]
    123          
    124            chDbgCheckClassS();
   \   00000008   0x.... 0x....      BL       chDbgCheckClassS
    125            chDbgCheck(mp != NULL, "chMtxLockS");
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??chMtxLockS_0
   \   00000010   0x227D             MOVS     R2,#+125
   \   00000012   0x....             LDR.N    R1,??DataTable5
   \   00000014   0x....             LDR.N    R0,??DataTable5_3
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    126          
    127            /* Is the mutex already locked? */
    128            if (mp->m_owner != NULL) {
   \                     ??chMtxLockS_0:
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD032             BEQ.N    ??chMtxLockS_1
    129              /* Priority inheritance protocol; explores the thread-mutex dependencies
    130                 boosting the priority of all the affected threads to equal the priority
    131                 of the running thread requesting the mutex.*/
    132              Thread *tp = mp->m_owner;
   \   00000020   0x68A6             LDR      R6,[R4, #+8]
    133              /* Does the running thread have higher priority than the mutex
    134                 owning thread? */
    135              while (tp->p_prio < ctp->p_prio) {
   \                     ??chMtxLockS_2:
   \   00000022   0x68B0             LDR      R0,[R6, #+8]
   \   00000024   0x68A9             LDR      R1,[R5, #+8]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD218             BCS.N    ??chMtxLockS_3
    136                /* Make priority of thread tp match the running thread's priority.*/
    137                tp->p_prio = ctp->p_prio;
   \   0000002A   0x68A8             LDR      R0,[R5, #+8]
   \   0000002C   0x60B0             STR      R0,[R6, #+8]
    138                /* The following states need priority queues reordering.*/
    139                switch (tp->p_state) {
   \   0000002E   0xF896 0x0020      LDRB     R0,[R6, #+32]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00A             BEQ.N    ??chMtxLockS_4
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD110             BNE.N    ??chMtxLockS_5
    140                case THD_STATE_WTMTX:
    141                  /* Re-enqueues the mutex owner with its new priority.*/
    142                  prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
   \                     ??chMtxLockS_6:
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       dequeue
   \   00000040   0x6AB1             LDR      R1,[R6, #+40]
   \   00000042   0x.... 0x....      BL       prio_insert
    143                  tp = ((Mutex *)tp->p_u.wtobjp)->m_owner;
   \   00000046   0x6AB0             LDR      R0,[R6, #+40]
   \   00000048   0x6886             LDR      R6,[R0, #+8]
    144                  continue;
   \   0000004A   0xE7EA             B.N      ??chMtxLockS_2
    145          #if CH_USE_CONDVARS ||                                                      \
    146              (CH_USE_SEMAPHORES && CH_USE_SEMAPHORES_PRIORITY) ||                    \
    147              (CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY)
    148          #if CH_USE_CONDVARS
    149                case THD_STATE_WTCOND:
    150          #endif
    151          #if CH_USE_SEMAPHORES && CH_USE_SEMAPHORES_PRIORITY
    152                case THD_STATE_WTSEM:
    153          #endif
    154          #if CH_USE_MESSAGES && CH_USE_MESSAGES_PRIORITY
    155                case THD_STATE_SNDMSGQ:
    156          #endif
    157                  /* Re-enqueues tp with its new priority on the queue.*/
    158                  prio_insert(dequeue(tp), (ThreadsQueue *)tp->p_u.wtobjp);
    159                  break;
    160          #endif
    161                case THD_STATE_READY:
    162          #if CH_DBG_ENABLE_ASSERTS
    163                  /* Prevents an assertion in chSchReadyI().*/
    164                  tp->p_state = THD_STATE_CURRENT;
   \                     ??chMtxLockS_4:
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF886 0x0020      STRB     R0,[R6, #+32]
    165          #endif
    166                  /* Re-enqueues tp with its new priority on the ready list.*/
    167                  chSchReadyI(dequeue(tp));
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0x.... 0x....      BL       dequeue
   \   00000058   0x.... 0x....      BL       chSchReadyI
    168                  break;
    169                }
    170                break;
    171              }
    172              /* Sleep on the mutex.*/
    173              prio_insert(ctp, &mp->m_queue);
   \                     ??chMtxLockS_5:
   \                     ??chMtxLockS_3:
   \   0000005C   0x0021             MOVS     R1,R4
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       prio_insert
    174              ctp->p_u.wtobjp = mp;
   \   00000064   0x62AC             STR      R4,[R5, #+40]
    175              chSchGoSleepS(THD_STATE_WTMTX);
   \   00000066   0x2004             MOVS     R0,#+4
   \   00000068   0x.... 0x....      BL       chSchGoSleepS
    176              /* It is assumed that the thread performing the unlock operation assigns
    177                 the mutex to this thread.*/
    178              chDbgAssert(mp->m_owner == ctp, "chMtxLockS(), #1", "not owner");
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0x42A8             CMP      R0,R5
   \   00000070   0xD002             BEQ.N    ??chMtxLockS_7
   \   00000072   0x....             LDR.N    R0,??DataTable5_4
   \   00000074   0x.... 0x....      BL       chDbgPanic
    179              chDbgAssert(ctp->p_mtxlist == mp, "chMtxLockS(), #2", "not owned");
   \                     ??chMtxLockS_7:
   \   00000078   0x6BE8             LDR      R0,[R5, #+60]
   \   0000007A   0x42A0             CMP      R0,R4
   \   0000007C   0xD007             BEQ.N    ??chMtxLockS_8
   \   0000007E   0x....             LDR.N    R0,??DataTable5_5
   \   00000080   0x.... 0x....      BL       chDbgPanic
   \   00000084   0xE003             B.N      ??chMtxLockS_8
    180            }
    181            else {
    182              /* It was not owned, inserted in the owned mutexes list.*/
    183              mp->m_owner = ctp;
   \                     ??chMtxLockS_1:
   \   00000086   0x60A5             STR      R5,[R4, #+8]
    184              mp->m_next = ctp->p_mtxlist;
   \   00000088   0x6BE8             LDR      R0,[R5, #+60]
   \   0000008A   0x60E0             STR      R0,[R4, #+12]
    185              ctp->p_mtxlist = mp;
   \   0000008C   0x63EC             STR      R4,[R5, #+60]
    186            }
    187          }
   \                     ??chMtxLockS_8:
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
    188          
    189          /**
    190           * @brief   Tries to lock a mutex.
    191           * @details This function attempts to lock a mutex, if the mutex is already
    192           *          locked by another thread then the function exits without waiting.
    193           * @post    The mutex is locked and inserted in the per-thread stack of owned
    194           *          mutexes.
    195           * @note    This function does not have any overhead related to the
    196           *          priority inheritance mechanism because it does not try to
    197           *          enter a sleep state.
    198           *
    199           * @param[in] mp        pointer to the @p Mutex structure
    200           * @return              The operation status.
    201           * @retval TRUE         if the mutex has been successfully acquired
    202           * @retval FALSE        if the lock attempt failed.
    203           *
    204           * @api
    205           */

   \                                 In section .text, align 2, keep-with-next
    206          bool_t chMtxTryLock(Mutex *mp) {
   \                     chMtxTryLock:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    207            bool_t b;
    208          
    209            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    210          
    211            b = chMtxTryLockS(mp);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       chMtxTryLockS
   \   00000014   0x0005             MOVS     R5,R0
    212          
    213            chSysUnlock();
   \   00000016   0x.... 0x....      BL       dbg_check_unlock
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF380 0x8811      MSR      BASEPRI,R0
    214            return b;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    215          }
    216          
    217          /**
    218           * @brief   Tries to lock a mutex.
    219           * @details This function attempts to lock a mutex, if the mutex is already
    220           *          taken by another thread then the function exits without waiting.
    221           * @post    The mutex is locked and inserted in the per-thread stack of owned
    222           *          mutexes.
    223           * @note    This function does not have any overhead related to the
    224           *          priority inheritance mechanism because it does not try to
    225           *          enter a sleep state.
    226           *
    227           * @param[in] mp        pointer to the @p Mutex structure
    228           * @return              The operation status.
    229           * @retval TRUE         if the mutex has been successfully acquired
    230           * @retval FALSE        if the lock attempt failed.
    231           *
    232           * @sclass
    233           */

   \                                 In section .text, align 2, keep-with-next
    234          bool_t chMtxTryLockS(Mutex *mp) {
   \                     chMtxTryLockS:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    235          
    236            chDbgCheckClassS();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassS
    237            chDbgCheck(mp != NULL, "chMtxTryLockS");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??chMtxTryLockS_0
   \   0000000C   0x22ED             MOVS     R2,#+237
   \   0000000E   0x....             LDR.N    R1,??DataTable5
   \   00000010   0x....             LDR.N    R0,??DataTable5_6
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    238          
    239            if (mp->m_owner != NULL)
   \                     ??chMtxTryLockS_0:
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??chMtxTryLockS_1
    240              return FALSE;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00A             B.N      ??chMtxTryLockS_2
    241            mp->m_owner = currp;
   \                     ??chMtxTryLockS_1:
   \   00000020   0x....             LDR.N    R0,??DataTable5_2
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x60A0             STR      R0,[R4, #+8]
    242            mp->m_next = currp->p_mtxlist;
   \   00000026   0x....             LDR.N    R0,??DataTable5_2
   \   00000028   0x6980             LDR      R0,[R0, #+24]
   \   0000002A   0x6BC0             LDR      R0,[R0, #+60]
   \   0000002C   0x60E0             STR      R0,[R4, #+12]
    243            currp->p_mtxlist = mp;
   \   0000002E   0x....             LDR.N    R0,??DataTable5_2
   \   00000030   0x6980             LDR      R0,[R0, #+24]
   \   00000032   0x63C4             STR      R4,[R0, #+60]
    244            return TRUE;
   \   00000034   0x2001             MOVS     R0,#+1
   \                     ??chMtxTryLockS_2:
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    245          }
    246          
    247          /**
    248           * @brief   Unlocks the next owned mutex in reverse lock order.
    249           * @pre     The invoking thread <b>must</b> have at least one owned mutex.
    250           * @post    The mutex is unlocked and removed from the per-thread stack of
    251           *          owned mutexes.
    252           *
    253           * @return              A pointer to the unlocked mutex.
    254           *
    255           * @api
    256           */

   \                                 In section .text, align 2, keep-with-next
    257          Mutex *chMtxUnlock(void) {
   \                     chMtxUnlock:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    258            Thread *ctp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable5_2
   \   00000006   0x6984             LDR      R4,[R0, #+24]
    259            Mutex *ump, *mp;
    260          
    261            chSysLock();
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000E   0x.... 0x....      BL       dbg_check_lock
    262            chDbgAssert(ctp->p_mtxlist != NULL,
    263                        "chMtxUnlock(), #1",
    264                        "owned mutexes list empty");
   \   00000012   0x6BE0             LDR      R0,[R4, #+60]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??chMtxUnlock_0
   \   00000018   0x....             LDR.N    R0,??DataTable5_7
   \   0000001A   0x.... 0x....      BL       chDbgPanic
    265            chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
    266                        "chMtxUnlock(), #2",
    267                        "ownership failure");
   \                     ??chMtxUnlock_0:
   \   0000001E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x42A0             CMP      R0,R4
   \   00000024   0xD002             BEQ.N    ??chMtxUnlock_1
   \   00000026   0x....             LDR.N    R0,??DataTable5_8
   \   00000028   0x.... 0x....      BL       chDbgPanic
    268            /* Removes the top Mutex from the Thread's owned mutexes list and marks it
    269               as not owned.*/
    270            ump = ctp->p_mtxlist;
   \                     ??chMtxUnlock_1:
   \   0000002C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002E   0x0005             MOVS     R5,R0
    271            ctp->p_mtxlist = ump->m_next;
   \   00000030   0x68E8             LDR      R0,[R5, #+12]
   \   00000032   0x63E0             STR      R0,[R4, #+60]
    272            /* If a thread is waiting on the mutex then the fun part begins.*/
    273            if (chMtxQueueNotEmptyS(ump)) {
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD020             BEQ.N    ??chMtxUnlock_2
    274              Thread *tp;
    275          
    276              /* Recalculates the optimal thread priority by scanning the owned
    277                 mutexes list.*/
    278              tprio_t newprio = ctp->p_realprio;
   \   0000003A   0xF8D4 0x8040      LDR      R8,[R4, #+64]
    279              mp = ctp->p_mtxlist;
   \   0000003E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000040   0x0006             MOVS     R6,R0
    280              while (mp != NULL) {
   \                     ??chMtxUnlock_3:
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD00B             BEQ.N    ??chMtxUnlock_4
    281                /* If the highest priority thread waiting in the mutexes list has a
    282                   greater priority than the current thread base priority then the final
    283                   priority will have at least that priority.*/
    284                if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x42B0             CMP      R0,R6
   \   0000004A   0xD006             BEQ.N    ??chMtxUnlock_5
   \   0000004C   0x6830             LDR      R0,[R6, #+0]
   \   0000004E   0x6880             LDR      R0,[R0, #+8]
   \   00000050   0x4580             CMP      R8,R0
   \   00000052   0xD202             BCS.N    ??chMtxUnlock_5
    285                  newprio = mp->m_queue.p_next->p_prio;
   \   00000054   0x6830             LDR      R0,[R6, #+0]
   \   00000056   0x6880             LDR      R0,[R0, #+8]
   \   00000058   0x4680             MOV      R8,R0
    286                mp = mp->m_next;
   \                     ??chMtxUnlock_5:
   \   0000005A   0x68F6             LDR      R6,[R6, #+12]
   \   0000005C   0xE7F1             B.N      ??chMtxUnlock_3
    287              }
    288              /* Assigns to the current thread the highest priority among all the
    289                 waiting threads.*/
    290              ctp->p_prio = newprio;
   \                     ??chMtxUnlock_4:
   \   0000005E   0xF8C4 0x8008      STR      R8,[R4, #+8]
    291              /* Awakens the highest priority thread waiting for the unlocked mutex and
    292                 assigns the mutex to it.*/
    293              tp = fifo_remove(&ump->m_queue);
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       fifo_remove
   \   00000068   0x0007             MOVS     R7,R0
    294              ump->m_owner = tp;
   \   0000006A   0x60AF             STR      R7,[R5, #+8]
    295              ump->m_next = tp->p_mtxlist;
   \   0000006C   0x6BF8             LDR      R0,[R7, #+60]
   \   0000006E   0x60E8             STR      R0,[R5, #+12]
    296              tp->p_mtxlist = ump;
   \   00000070   0x63FD             STR      R5,[R7, #+60]
    297              chSchWakeupS(tp, RDY_OK);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       chSchWakeupS
   \   0000007A   0xE001             B.N      ??chMtxUnlock_6
    298            }
    299            else
    300              ump->m_owner = NULL;
   \                     ??chMtxUnlock_2:
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x60A8             STR      R0,[R5, #+8]
    301            chSysUnlock();
   \                     ??chMtxUnlock_6:
   \   00000080   0x.... 0x....      BL       dbg_check_unlock
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF380 0x8811      MSR      BASEPRI,R0
    302            return ump;
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    303          }
    304          
    305          /**
    306           * @brief   Unlocks the next owned mutex in reverse lock order.
    307           * @pre     The invoking thread <b>must</b> have at least one owned mutex.
    308           * @post    The mutex is unlocked and removed from the per-thread stack of
    309           *          owned mutexes.
    310           * @post    This function does not reschedule so a call to a rescheduling
    311           *          function must be performed before unlocking the kernel.
    312           *
    313           * @return              A pointer to the unlocked mutex.
    314           *
    315           * @sclass
    316           */

   \                                 In section .text, align 2, keep-with-next
    317          Mutex *chMtxUnlockS(void) {
   \                     chMtxUnlockS:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    318            Thread *ctp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable5_2
   \   00000006   0x6984             LDR      R4,[R0, #+24]
    319            Mutex *ump, *mp;
    320          
    321            chDbgCheckClassS();
   \   00000008   0x.... 0x....      BL       chDbgCheckClassS
    322            chDbgAssert(ctp->p_mtxlist != NULL,
    323                        "chMtxUnlockS(), #1",
    324                        "owned mutexes list empty");
   \   0000000C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??chMtxUnlockS_0
   \   00000012   0x....             LDR.N    R0,??DataTable5_9
   \   00000014   0x.... 0x....      BL       chDbgPanic
    325            chDbgAssert(ctp->p_mtxlist->m_owner == ctp,
    326                        "chMtxUnlockS(), #2",
    327                        "ownership failure");
   \                     ??chMtxUnlockS_0:
   \   00000018   0x6BE0             LDR      R0,[R4, #+60]
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x42A0             CMP      R0,R4
   \   0000001E   0xD002             BEQ.N    ??chMtxUnlockS_1
   \   00000020   0x....             LDR.N    R0,??DataTable5_10
   \   00000022   0x.... 0x....      BL       chDbgPanic
    328          
    329            /* Removes the top Mutex from the owned mutexes list and marks it as not
    330               owned.*/
    331            ump = ctp->p_mtxlist;
   \                     ??chMtxUnlockS_1:
   \   00000026   0x6BE0             LDR      R0,[R4, #+60]
   \   00000028   0x0005             MOVS     R5,R0
    332            ctp->p_mtxlist = ump->m_next;
   \   0000002A   0x68E8             LDR      R0,[R5, #+12]
   \   0000002C   0x63E0             STR      R0,[R4, #+60]
    333            /* If a thread is waiting on the mutex then the fun part begins.*/
    334            if (chMtxQueueNotEmptyS(ump)) {
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x42A8             CMP      R0,R5
   \   00000032   0xD01F             BEQ.N    ??chMtxUnlockS_2
    335              Thread *tp;
    336          
    337              /* Recalculates the optimal thread priority by scanning the owned
    338                 mutexes list.*/
    339              tprio_t newprio = ctp->p_realprio;
   \   00000034   0xF8D4 0x8040      LDR      R8,[R4, #+64]
    340              mp = ctp->p_mtxlist;
   \   00000038   0x6BE0             LDR      R0,[R4, #+60]
   \   0000003A   0x0006             MOVS     R6,R0
    341              while (mp != NULL) {
   \                     ??chMtxUnlockS_3:
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD00B             BEQ.N    ??chMtxUnlockS_4
    342                /* If the highest priority thread waiting in the mutexes list has a
    343                   greater priority than the current thread base priority then the final
    344                   priority will have at least that priority.*/
    345                if (chMtxQueueNotEmptyS(mp) && (mp->m_queue.p_next->p_prio > newprio))
   \   00000040   0x6830             LDR      R0,[R6, #+0]
   \   00000042   0x42B0             CMP      R0,R6
   \   00000044   0xD006             BEQ.N    ??chMtxUnlockS_5
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x6880             LDR      R0,[R0, #+8]
   \   0000004A   0x4580             CMP      R8,R0
   \   0000004C   0xD202             BCS.N    ??chMtxUnlockS_5
    346                  newprio = mp->m_queue.p_next->p_prio;
   \   0000004E   0x6830             LDR      R0,[R6, #+0]
   \   00000050   0x6880             LDR      R0,[R0, #+8]
   \   00000052   0x4680             MOV      R8,R0
    347                mp = mp->m_next;
   \                     ??chMtxUnlockS_5:
   \   00000054   0x68F6             LDR      R6,[R6, #+12]
   \   00000056   0xE7F1             B.N      ??chMtxUnlockS_3
    348              }
    349              ctp->p_prio = newprio;
   \                     ??chMtxUnlockS_4:
   \   00000058   0xF8C4 0x8008      STR      R8,[R4, #+8]
    350              /* Awakens the highest priority thread waiting for the unlocked mutex and
    351                 assigns the mutex to it.*/
    352              tp = fifo_remove(&ump->m_queue);
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0x.... 0x....      BL       fifo_remove
   \   00000062   0x0007             MOVS     R7,R0
    353              ump->m_owner = tp;
   \   00000064   0x60AF             STR      R7,[R5, #+8]
    354              ump->m_next = tp->p_mtxlist;
   \   00000066   0x6BF8             LDR      R0,[R7, #+60]
   \   00000068   0x60E8             STR      R0,[R5, #+12]
    355              tp->p_mtxlist = ump;
   \   0000006A   0x63FD             STR      R5,[R7, #+60]
    356              chSchReadyI(tp);
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       chSchReadyI
   \   00000072   0xE001             B.N      ??chMtxUnlockS_6
    357            }
    358            else
    359              ump->m_owner = NULL;
   \                     ??chMtxUnlockS_2:
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x60A8             STR      R0,[R5, #+8]
    360            return ump;
   \                     ??chMtxUnlockS_6:
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    361          }
    362          
    363          /**
    364           * @brief   Unlocks all the mutexes owned by the invoking thread.
    365           * @post    The stack of owned mutexes is emptied and all the found
    366           *          mutexes are unlocked.
    367           * @note    This function is <b>MUCH MORE</b> efficient than releasing the
    368           *          mutexes one by one and not just because the call overhead,
    369           *          this function does not have any overhead related to the priority
    370           *          inheritance mechanism.
    371           *
    372           * @api
    373           */

   \                                 In section .text, align 2, keep-with-next
    374          void chMtxUnlockAll(void) {
   \                     chMtxUnlockAll:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    375            Thread *ctp = currp;
   \   00000002   0x....             LDR.N    R0,??DataTable5_2
   \   00000004   0x6984             LDR      R4,[R0, #+24]
    376          
    377            chSysLock();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock
    378            if (ctp->p_mtxlist != NULL) {
   \   00000010   0x6BE0             LDR      R0,[R4, #+60]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD01A             BEQ.N    ??chMtxUnlockAll_0
    379              do {
    380                Mutex *ump = ctp->p_mtxlist;
   \                     ??chMtxUnlockAll_1:
   \   00000016   0x6BE5             LDR      R5,[R4, #+60]
    381                ctp->p_mtxlist = ump->m_next;
   \   00000018   0x68E8             LDR      R0,[R5, #+12]
   \   0000001A   0x63E0             STR      R0,[R4, #+60]
    382                if (chMtxQueueNotEmptyS(ump)) {
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xD00B             BEQ.N    ??chMtxUnlockAll_2
    383                  Thread *tp = fifo_remove(&ump->m_queue);
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       fifo_remove
   \   00000028   0x0006             MOVS     R6,R0
    384                  ump->m_owner = tp;
   \   0000002A   0x60AE             STR      R6,[R5, #+8]
    385                  ump->m_next = tp->p_mtxlist;
   \   0000002C   0x6BF0             LDR      R0,[R6, #+60]
   \   0000002E   0x60E8             STR      R0,[R5, #+12]
    386                  tp->p_mtxlist = ump;
   \   00000030   0x63F5             STR      R5,[R6, #+60]
    387                  chSchReadyI(tp);
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       chSchReadyI
   \   00000038   0xE001             B.N      ??chMtxUnlockAll_3
    388                }
    389                else
    390                  ump->m_owner = NULL;
   \                     ??chMtxUnlockAll_2:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x60A8             STR      R0,[R5, #+8]
    391              } while (ctp->p_mtxlist != NULL);
   \                     ??chMtxUnlockAll_3:
   \   0000003E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD1E8             BNE.N    ??chMtxUnlockAll_1
    392              ctp->p_prio = ctp->p_realprio;
   \   00000044   0x6C20             LDR      R0,[R4, #+64]
   \   00000046   0x60A0             STR      R0,[R4, #+8]
    393              chSchRescheduleS();
   \   00000048   0x.... 0x....      BL       chSchRescheduleS
    394            }
    395            chSysUnlock();
   \                     ??chMtxUnlockAll_0:
   \   0000004C   0x.... 0x....      BL       dbg_check_unlock
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF380 0x8811      MSR      BASEPRI,R0
    396          }
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     `?<Constant "\\"chMtxInit\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     `?<Constant "\\"chMtxLockS\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     `?<Constant "chMtxLockS(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     `?<Constant "chMtxLockS(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     `?<Constant "\\"chMtxTryLockS\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     `?<Constant "chMtxUnlock(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     `?<Constant "chMtxUnlock(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     `?<Constant "chMtxUnlockS(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     `?<Constant "chMtxUnlockS(), #2">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chMtxInit\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chMtxInit\"()"
   \              0x68 0x4D    
   \              0x74 0x78    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x22 0x28    
   \              0x29 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x6B 0x65          DC8 6BH, 65H, 72H, 6EH, 65H, 6CH, 5CH, 73H
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x5C 0x73    
   \   00000038   0x72 0x63          DC8 72H, 63H, 5CH, 63H, 68H, 6DH, 74H, 78H
   \              0x5C 0x63    
   \              0x68 0x6D    
   \              0x74 0x78    
   \   00000040   0x2E 0x63          DC8 2EH, 63H, 0
   \              0x00         
   \   00000043   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chMtxLockS\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chMtxLockS\"()"
   \              0x68 0x4D    
   \              0x74 0x78    
   \              0x4C 0x6F    
   \              0x63 0x6B    
   \              0x53 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chMtxLockS(), #1">`:
   \   00000000   0x63 0x68          DC8 "chMtxLockS(), #1"
   \              0x4D 0x74    
   \              0x78 0x4C    
   \              0x6F 0x63    
   \              0x6B 0x53    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "chMtxLockS(), #2">`:
   \   00000000   0x63 0x68          DC8 "chMtxLockS(), #2"
   \              0x4D 0x74    
   \              0x78 0x4C    
   \              0x6F 0x63    
   \              0x6B 0x53    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x32    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chMtxTryLockS\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chMtxTryLockS\"()"
   \              0x68 0x4D    
   \              0x74 0x78    
   \              0x54 0x72    
   \              0x79 0x4C    
   \              0x6F 0x63    
   \              0x6B 0x53    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chMtxUnlock(), #1">`:
   \   00000000   0x63 0x68          DC8 "chMtxUnlock(), #1"
   \              0x4D 0x74    
   \              0x78 0x55    
   \              0x6E 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chMtxUnlock(), #2">`:
   \   00000000   0x63 0x68          DC8 "chMtxUnlock(), #2"
   \              0x4D 0x74    
   \              0x78 0x55    
   \              0x6E 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x32 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chMtxUnlockS(), #1">`:
   \   00000000   0x63 0x68          DC8 "chMtxUnlockS(), #1"
   \              0x4D 0x74    
   \              0x78 0x55    
   \              0x6E 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x53    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chMtxUnlockS(), #2">`:
   \   00000000   0x63 0x68          DC8 "chMtxUnlockS(), #2"
   \              0x4D 0x74    
   \              0x78 0x55    
   \              0x6E 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x53    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x32    
   \              0x00         
   \   00000013   0x00               DC8 0
    397          
    398          #endif /* CH_USE_MUTEXES */
    399          
    400          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   chMtxInit
         8   -> chDbgPanic3
       8   chMtxLock
         8   -> chMtxLockS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
      16   chMtxLockS
        16   -> chDbgCheckClassS
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchGoSleepS
        16   -> chSchReadyI
        16   -> dequeue
        16   -> prio_insert
      16   chMtxTryLock
        16   -> chMtxTryLockS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
       8   chMtxTryLockS
         8   -> chDbgCheckClassS
         8   -> chDbgPanic3
      24   chMtxUnlock
        24   -> chDbgPanic
        24   -> chSchWakeupS
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
        24   -> fifo_remove
      16   chMtxUnlockAll
        16   -> chSchReadyI
        16   -> chSchRescheduleS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
        16   -> fifo_remove
      24   chMtxUnlockS
        24   -> chDbgCheckClassS
        24   -> chDbgPanic
        24   -> chSchReadyI
        24   -> fifo_remove
       0   dequeue
       0   fifo_remove
       4   prio_insert


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      68  ?<Constant "F:\\stuff\\rusefi_sourc...">
      16  ?<Constant "\"chMtxInit\"()">
      16  ?<Constant "\"chMtxLockS\"()">
      20  ?<Constant "\"chMtxTryLockS\"()">
      20  ?<Constant "chMtxLockS(), #1">
      20  ?<Constant "chMtxLockS(), #2">
      20  ?<Constant "chMtxUnlock(), #1">
      20  ?<Constant "chMtxUnlock(), #2">
      20  ?<Constant "chMtxUnlockS(), #1">
      20  ?<Constant "chMtxUnlockS(), #2">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      28  chMtxInit
      32  chMtxLock
     144  chMtxLockS
      38  chMtxTryLock
      56  chMtxTryLockS
     144  chMtxUnlock
      88  chMtxUnlockAll
     126  chMtxUnlockS
      14  dequeue
      12  fifo_remove
      34  prio_insert

 
 240 bytes in section .rodata
 760 bytes in section .text
 
 760 bytes of CODE  memory
 240 bytes of CONST memory

Errors: none
Warnings: none
