###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:08:54 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32F4xx\stm32_dma.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32F4xx\stm32_dma.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\s #
#                       tm32_dma.lst                                          #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\st #
#                       m32_dma.o                                             #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32F4xx\stm32_dma.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32F4xx/stm32_dma.c
     19           * @brief   Enhanced DMA helper driver code.
     20           *
     21           * @addtogroup STM32F4xx_DMA
     22           * @details DMA sharing helper driver. In the STM32 the DMA streams are a
     23           *          shared resource, this driver allows to allocate and free DMA
     24           *          streams at runtime in order to allow all the other device
     25           *          drivers to coordinate the access to the resource.
     26           * @note    The DMA ISR handlers are all declared into this module because
     27           *          sharing, the various device drivers can associate a callback to
     28           *          ISRs when allocating streams.
     29           * @{
     30           */
     31          
     32          #include "ch.h"
     33          #include "hal.h"
     34          
     35          /* The following macro is only defined if some driver requiring DMA services
     36             has been enabled.*/
     37          #if defined(STM32_DMA_REQUIRED) || defined(__DOXYGEN__)
     38          
     39          /*===========================================================================*/
     40          /* Driver local definitions.                                                 */
     41          /*===========================================================================*/
     42          
     43          /**
     44           * @brief   Mask of the DMA1 streams in @p dma_streams_mask.
     45           */
     46          #define STM32_DMA1_STREAMS_MASK     0x000000FF
     47          
     48          /**
     49           * @brief   Mask of the DMA2 streams in @p dma_streams_mask.
     50           */
     51          #define STM32_DMA2_STREAMS_MASK     0x0000FF00
     52          
     53          /**
     54           * @brief   Post-reset value of the stream CR register.
     55           */
     56          #define STM32_DMA_CR_RESET_VALUE    0x00000000
     57          
     58          /**
     59           * @brief   Post-reset value of the stream FCR register.
     60           */
     61          #define STM32_DMA_FCR_RESET_VALUE   0x00000021
     62          
     63          /*===========================================================================*/
     64          /* Driver exported variables.                                                */
     65          /*===========================================================================*/
     66          
     67          /**
     68           * @brief   DMA streams descriptors.
     69           * @details This table keeps the association between an unique stream
     70           *          identifier and the involved physical registers.
     71           * @note    Don't use this array directly, use the appropriate wrapper macros
     72           *          instead: @p STM32_DMA1_STREAM0, @p STM32_DMA1_STREAM1 etc.
     73           */

   \                                 In section .rodata, align 4
     74          const stm32_dma_stream_t _stm32_dma_streams[STM32_DMA_STREAMS] = {
   \                     _stm32_dma_streams:
   \   00000000   0x40026010         DC32 40026010H, 40026008H
   \              0x40026008   
   \   00000008   0x00 0x00          DC8 0, 0, 11, 0
   \              0x0B 0x00    
   \   0000000C   0x40026028         DC32 40026028H, 40026008H
   \              0x40026008   
   \   00000014   0x06 0x01          DC8 6, 1, 12, 0
   \              0x0C 0x00    
   \   00000018   0x40026040         DC32 40026040H, 40026008H
   \              0x40026008   
   \   00000020   0x10 0x02          DC8 16, 2, 13, 0
   \              0x0D 0x00    
   \   00000024   0x40026058         DC32 40026058H, 40026008H
   \              0x40026008   
   \   0000002C   0x16 0x03          DC8 22, 3, 14, 0
   \              0x0E 0x00    
   \   00000030   0x40026070         DC32 40026070H, 4002600CH
   \              0x4002600C   
   \   00000038   0x00 0x04          DC8 0, 4, 15, 0
   \              0x0F 0x00    
   \   0000003C   0x40026088         DC32 40026088H, 4002600CH
   \              0x4002600C   
   \   00000044   0x06 0x05          DC8 6, 5, 16, 0
   \              0x10 0x00    
   \   00000048   0x400260A0         DC32 400260A0H, 4002600CH
   \              0x4002600C   
   \   00000050   0x10 0x06          DC8 16, 6, 17, 0
   \              0x11 0x00    
   \   00000054   0x400260B8         DC32 400260B8H, 4002600CH
   \              0x4002600C   
   \   0000005C   0x16 0x07          DC8 22, 7, 47, 0
   \              0x2F 0x00    
   \   00000060   0x40026410         DC32 40026410H, 40026408H
   \              0x40026408   
   \   00000068   0x00 0x08          DC8 0, 8, 56, 0
   \              0x38 0x00    
   \   0000006C   0x40026428         DC32 40026428H, 40026408H
   \              0x40026408   
   \   00000074   0x06 0x09          DC8 6, 9, 57, 0
   \              0x39 0x00    
   \   00000078   0x40026440         DC32 40026440H, 40026408H
   \              0x40026408   
   \   00000080   0x10 0x0A          DC8 16, 10, 58, 0
   \              0x3A 0x00    
   \   00000084   0x40026458         DC32 40026458H, 40026408H
   \              0x40026408   
   \   0000008C   0x16 0x0B          DC8 22, 11, 59, 0
   \              0x3B 0x00    
   \   00000090   0x40026470         DC32 40026470H, 4002640CH
   \              0x4002640C   
   \   00000098   0x00 0x0C          DC8 0, 12, 60, 0
   \              0x3C 0x00    
   \   0000009C   0x40026488         DC32 40026488H, 4002640CH
   \              0x4002640C   
   \   000000A4   0x06 0x0D          DC8 6, 13, 68, 0
   \              0x44 0x00    
   \   000000A8   0x400264A0         DC32 400264A0H, 4002640CH
   \              0x4002640C   
   \   000000B0   0x10 0x0E          DC8 16, 14, 69, 0
   \              0x45 0x00    
   \   000000B4   0x400264B8         DC32 400264B8H, 4002640CH
   \              0x4002640C   
   \   000000BC   0x16 0x0F          DC8 22, 15, 70, 0
   \              0x46 0x00    
     75            {DMA1_Stream0, &DMA1->LIFCR, 0, 0, DMA1_Stream0_IRQn},
     76            {DMA1_Stream1, &DMA1->LIFCR, 6, 1, DMA1_Stream1_IRQn},
     77            {DMA1_Stream2, &DMA1->LIFCR, 16, 2, DMA1_Stream2_IRQn},
     78            {DMA1_Stream3, &DMA1->LIFCR, 22, 3, DMA1_Stream3_IRQn},
     79            {DMA1_Stream4, &DMA1->HIFCR, 0, 4, DMA1_Stream4_IRQn},
     80            {DMA1_Stream5, &DMA1->HIFCR, 6, 5, DMA1_Stream5_IRQn},
     81            {DMA1_Stream6, &DMA1->HIFCR, 16, 6, DMA1_Stream6_IRQn},
     82            {DMA1_Stream7, &DMA1->HIFCR, 22, 7, DMA1_Stream7_IRQn},
     83            {DMA2_Stream0, &DMA2->LIFCR, 0, 8, DMA2_Stream0_IRQn},
     84            {DMA2_Stream1, &DMA2->LIFCR, 6, 9, DMA2_Stream1_IRQn},
     85            {DMA2_Stream2, &DMA2->LIFCR, 16, 10, DMA2_Stream2_IRQn},
     86            {DMA2_Stream3, &DMA2->LIFCR, 22, 11, DMA2_Stream3_IRQn},
     87            {DMA2_Stream4, &DMA2->HIFCR, 0, 12, DMA2_Stream4_IRQn},
     88            {DMA2_Stream5, &DMA2->HIFCR, 6, 13, DMA2_Stream5_IRQn},
     89            {DMA2_Stream6, &DMA2->HIFCR, 16, 14, DMA2_Stream6_IRQn},
     90            {DMA2_Stream7, &DMA2->HIFCR, 22, 15, DMA2_Stream7_IRQn},
     91          };
     92          
     93          /*===========================================================================*/
     94          /* Driver local variables and types.                                         */
     95          /*===========================================================================*/
     96          
     97          /**
     98           * @brief   DMA ISR redirector type.
     99           */
    100          typedef struct {
    101            stm32_dmaisr_t        dma_func;       /**< @brief DMA callback function.  */
    102            void                  *dma_param;     /**< @brief DMA callback parameter. */
    103          } dma_isr_redir_t;
    104          
    105          /**
    106           * @brief   Mask of the allocated streams.
    107           */

   \                                 In section .bss, align 4
    108          static uint32_t dma_streams_mask;
   \                     dma_streams_mask:
   \   00000000                      DS8 4
    109          
    110          /**
    111           * @brief   DMA IRQ redirectors.
    112           */

   \                                 In section .bss, align 4
    113          static dma_isr_redir_t dma_isr_redir[STM32_DMA_STREAMS];
   \                     dma_isr_redir:
   \   00000000                      DS8 128
    114          
    115          /*===========================================================================*/
    116          /* Driver local functions.                                                   */
    117          /*===========================================================================*/
    118          
    119          /*===========================================================================*/
    120          /* Driver interrupt handlers.                                                */
    121          /*===========================================================================*/
    122          
    123          /**
    124           * @brief   DMA1 stream 0 shared interrupt handler.
    125           *
    126           * @isr
    127           */

   \                                 In section .text, align 2, keep-with-next
    128          CH_IRQ_HANDLER(DMA1_Stream0_IRQHandler) {
   \                     Vector6C:
   \   00000000   0xB510             PUSH     {R4,LR}
    129            uint32_t flags;
    130          
    131            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    132          
    133            flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40026000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    134            DMA1->LIFCR = flags << 0;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40026008
   \   00000016   0x6004             STR      R4,[R0, #+0]
    135            if (dma_isr_redir[0].dma_func)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ.N    ??Vector6C_0
    136              dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0x4790             BLX      R2
    137          
    138            CH_IRQ_EPILOGUE();
   \                     ??Vector6C_0:
   \   00000032   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000036   0x.... 0x....      BL       _port_irq_epilogue
    139          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    140          
    141          /**
    142           * @brief   DMA1 stream 1 shared interrupt handler.
    143           *
    144           * @isr
    145           */

   \                                 In section .text, align 2, keep-with-next
    146          CH_IRQ_HANDLER(DMA1_Stream1_IRQHandler) {
   \                     Vector70:
   \   00000000   0xB510             PUSH     {R4,LR}
    147            uint32_t flags;
    148          
    149            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    150          
    151            flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40026000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0980             LSRS     R0,R0,#+6
   \   0000000E   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000012   0x0004             MOVS     R4,R0
    152            DMA1->LIFCR = flags << 6;
   \   00000014   0x01A0             LSLS     R0,R4,#+6
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x40026008
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    153            if (dma_isr_redir[1].dma_func)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??Vector70_0
    154              dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000032   0x6892             LDR      R2,[R2, #+8]
   \   00000034   0x4790             BLX      R2
    155          
    156            CH_IRQ_EPILOGUE();
   \                     ??Vector70_0:
   \   00000036   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000003A   0x.... 0x....      BL       _port_irq_epilogue
    157          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    158          
    159          /**
    160           * @brief   DMA1 stream 2 shared interrupt handler.
    161           *
    162           * @isr
    163           */

   \                                 In section .text, align 2, keep-with-next
    164          CH_IRQ_HANDLER(DMA1_Stream2_IRQHandler) {
   \                     Vector74:
   \   00000000   0xB510             PUSH     {R4,LR}
    165            uint32_t flags;
    166          
    167            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    168          
    169            flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40026000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0C00             LSRS     R0,R0,#+16
   \   0000000E   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000012   0x0004             MOVS     R4,R0
    170            DMA1->LIFCR = flags << 16;
   \   00000014   0x0420             LSLS     R0,R4,#+16
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x40026008
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    171            if (dma_isr_redir[2].dma_func)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x6900             LDR      R0,[R0, #+16]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??Vector74_0
    172              dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x6940             LDR      R0,[R0, #+20]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000032   0x6912             LDR      R2,[R2, #+16]
   \   00000034   0x4790             BLX      R2
    173          
    174            CH_IRQ_EPILOGUE();
   \                     ??Vector74_0:
   \   00000036   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000003A   0x.... 0x....      BL       _port_irq_epilogue
    175          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    176          
    177          /**
    178           * @brief   DMA1 stream 3 shared interrupt handler.
    179           *
    180           * @isr
    181           */

   \                                 In section .text, align 2, keep-with-next
    182          CH_IRQ_HANDLER(DMA1_Stream3_IRQHandler) {
   \                     Vector78:
   \   00000000   0xB510             PUSH     {R4,LR}
    183            uint32_t flags;
    184          
    185            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    186          
    187            flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40026000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0D80             LSRS     R0,R0,#+22
   \   0000000E   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000012   0x0004             MOVS     R4,R0
    188            DMA1->LIFCR = flags << 22;
   \   00000014   0x05A0             LSLS     R0,R4,#+22
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x40026008
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    189            if (dma_isr_redir[3].dma_func)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x6980             LDR      R0,[R0, #+24]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??Vector78_0
    190              dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x69C0             LDR      R0,[R0, #+28]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000032   0x6992             LDR      R2,[R2, #+24]
   \   00000034   0x4790             BLX      R2
    191          
    192            CH_IRQ_EPILOGUE();
   \                     ??Vector78_0:
   \   00000036   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000003A   0x.... 0x....      BL       _port_irq_epilogue
    193          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    194          
    195          /**
    196           * @brief   DMA1 stream 4 shared interrupt handler.
    197           *
    198           * @isr
    199           */

   \                                 In section .text, align 2, keep-with-next
    200          CH_IRQ_HANDLER(DMA1_Stream4_IRQHandler) {
   \                     Vector7C:
   \   00000000   0xB510             PUSH     {R4,LR}
    201            uint32_t flags;
    202          
    203            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    204          
    205            flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x40026004
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    206            DMA1->HIFCR = flags << 0;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x4002600c
   \   00000016   0x6004             STR      R4,[R0, #+0]
    207            if (dma_isr_redir[4].dma_func)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ.N    ??Vector7C_0
    208              dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000028   0x6A40             LDR      R0,[R0, #+36]
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   0000002E   0x6A12             LDR      R2,[R2, #+32]
   \   00000030   0x4790             BLX      R2
    209          
    210            CH_IRQ_EPILOGUE();
   \                     ??Vector7C_0:
   \   00000032   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000036   0x.... 0x....      BL       _port_irq_epilogue
    211          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    212          
    213          /**
    214           * @brief   DMA1 stream 5 shared interrupt handler.
    215           *
    216           * @isr
    217           */

   \                                 In section .text, align 2, keep-with-next
    218          CH_IRQ_HANDLER(DMA1_Stream5_IRQHandler) {
   \                     Vector80:
   \   00000000   0xB510             PUSH     {R4,LR}
    219            uint32_t flags;
    220          
    221            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    222          
    223            flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x40026004
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0980             LSRS     R0,R0,#+6
   \   0000000E   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000012   0x0004             MOVS     R4,R0
    224            DMA1->HIFCR = flags << 6;
   \   00000014   0x01A0             LSLS     R0,R4,#+6
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0x4002600c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    225            if (dma_isr_redir[5].dma_func)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x6A80             LDR      R0,[R0, #+40]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??Vector80_0
    226              dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x6AC0             LDR      R0,[R0, #+44]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000032   0x6A92             LDR      R2,[R2, #+40]
   \   00000034   0x4790             BLX      R2
    227          
    228            CH_IRQ_EPILOGUE();
   \                     ??Vector80_0:
   \   00000036   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000003A   0x.... 0x....      BL       _port_irq_epilogue
    229          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    230          
    231          /**
    232           * @brief   DMA1 stream 6 shared interrupt handler.
    233           *
    234           * @isr
    235           */

   \                                 In section .text, align 2, keep-with-next
    236          CH_IRQ_HANDLER(DMA1_Stream6_IRQHandler) {
   \                     Vector84:
   \   00000000   0xB510             PUSH     {R4,LR}
    237            uint32_t flags;
    238          
    239            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    240          
    241            flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x40026004
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0C00             LSRS     R0,R0,#+16
   \   0000000E   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000012   0x0004             MOVS     R4,R0
    242            DMA1->HIFCR = flags << 16;
   \   00000014   0x0420             LSLS     R0,R4,#+16
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0x4002600c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    243            if (dma_isr_redir[6].dma_func)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x6B00             LDR      R0,[R0, #+48]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??Vector84_0
    244              dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x6B40             LDR      R0,[R0, #+52]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000032   0x6B12             LDR      R2,[R2, #+48]
   \   00000034   0x4790             BLX      R2
    245          
    246            CH_IRQ_EPILOGUE();
   \                     ??Vector84_0:
   \   00000036   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000003A   0x.... 0x....      BL       _port_irq_epilogue
    247          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    248          
    249          /**
    250           * @brief   DMA1 stream 7 shared interrupt handler.
    251           *
    252           * @isr
    253           */

   \                                 In section .text, align 2, keep-with-next
    254          CH_IRQ_HANDLER(DMA1_Stream7_IRQHandler) {
   \                     VectorFC:
   \   00000000   0xB510             PUSH     {R4,LR}
    255            uint32_t flags;
    256          
    257            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    258          
    259            flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x40026004
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0D80             LSRS     R0,R0,#+22
   \   0000000E   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000012   0x0004             MOVS     R4,R0
    260            DMA1->HIFCR = flags << 22;
   \   00000014   0x05A0             LSLS     R0,R4,#+22
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0x4002600c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    261            if (dma_isr_redir[7].dma_func)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000020   0x6B80             LDR      R0,[R0, #+56]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ.N    ??VectorFC_0
    262              dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000002C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000032   0x6B92             LDR      R2,[R2, #+56]
   \   00000034   0x4790             BLX      R2
    263          
    264            CH_IRQ_EPILOGUE();
   \                     ??VectorFC_0:
   \   00000036   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000003A   0x.... 0x....      BL       _port_irq_epilogue
    265          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    266          
    267          /**
    268           * @brief   DMA2 stream 0 shared interrupt handler.
    269           *
    270           * @isr
    271           */

   \                                 In section .text, align 2, keep-with-next
    272          CH_IRQ_HANDLER(DMA2_Stream0_IRQHandler) {
   \                     Vector120:
   \   00000000   0xB510             PUSH     {R4,LR}
    273            uint32_t flags;
    274          
    275            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    276          
    277            flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_5  ;; 0x40026400
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    278            DMA2->LIFCR = flags << 0;
   \   00000012   0x....             LDR.N    R0,??DataTable18_6  ;; 0x40026408
   \   00000014   0x6004             STR      R4,[R0, #+0]
    279            if (dma_isr_redir[8].dma_func)
   \   00000016   0x....             LDR.N    R0,??DataTable18_2
   \   00000018   0x6C00             LDR      R0,[R0, #+64]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??Vector120_0
    280              dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x....             LDR.N    R0,??DataTable18_2
   \   00000022   0x6C40             LDR      R0,[R0, #+68]
   \   00000024   0x....             LDR.N    R2,??DataTable18_2
   \   00000026   0x6C12             LDR      R2,[R2, #+64]
   \   00000028   0x4790             BLX      R2
    281          
    282            CH_IRQ_EPILOGUE();
   \                     ??Vector120_0:
   \   0000002A   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000002E   0x.... 0x....      BL       _port_irq_epilogue
    283          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    284          
    285          /**
    286           * @brief   DMA2 stream 1 shared interrupt handler.
    287           *
    288           * @isr
    289           */

   \                                 In section .text, align 2, keep-with-next
    290          CH_IRQ_HANDLER(DMA2_Stream1_IRQHandler) {
   \                     Vector124:
   \   00000000   0xB510             PUSH     {R4,LR}
    291            uint32_t flags;
    292          
    293            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    294          
    295            flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_5  ;; 0x40026400
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0980             LSRS     R0,R0,#+6
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    296            DMA2->LIFCR = flags << 6;
   \   00000012   0x01A0             LSLS     R0,R4,#+6
   \   00000014   0x....             LDR.N    R1,??DataTable18_6  ;; 0x40026408
   \   00000016   0x6008             STR      R0,[R1, #+0]
    297            if (dma_isr_redir[9].dma_func)
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x6C80             LDR      R0,[R0, #+72]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??Vector124_0
    298              dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable18_2
   \   00000024   0x6CC0             LDR      R0,[R0, #+76]
   \   00000026   0x....             LDR.N    R2,??DataTable18_2
   \   00000028   0x6C92             LDR      R2,[R2, #+72]
   \   0000002A   0x4790             BLX      R2
    299          
    300            CH_IRQ_EPILOGUE();
   \                     ??Vector124_0:
   \   0000002C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000030   0x.... 0x....      BL       _port_irq_epilogue
    301          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    302          
    303          /**
    304           * @brief   DMA2 stream 2 shared interrupt handler.
    305           *
    306           * @isr
    307           */

   \                                 In section .text, align 2, keep-with-next
    308          CH_IRQ_HANDLER(DMA2_Stream2_IRQHandler) {
   \                     Vector128:
   \   00000000   0xB510             PUSH     {R4,LR}
    309            uint32_t flags;
    310          
    311            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    312          
    313            flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_5  ;; 0x40026400
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0C00             LSRS     R0,R0,#+16
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    314            DMA2->LIFCR = flags << 16;
   \   00000012   0x0420             LSLS     R0,R4,#+16
   \   00000014   0x....             LDR.N    R1,??DataTable18_6  ;; 0x40026408
   \   00000016   0x6008             STR      R0,[R1, #+0]
    315            if (dma_isr_redir[10].dma_func)
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x6D00             LDR      R0,[R0, #+80]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??Vector128_0
    316              dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable18_2
   \   00000024   0x6D40             LDR      R0,[R0, #+84]
   \   00000026   0x....             LDR.N    R2,??DataTable18_2
   \   00000028   0x6D12             LDR      R2,[R2, #+80]
   \   0000002A   0x4790             BLX      R2
    317          
    318            CH_IRQ_EPILOGUE();
   \                     ??Vector128_0:
   \   0000002C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000030   0x.... 0x....      BL       _port_irq_epilogue
    319          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    320          
    321          /**
    322           * @brief   DMA2 stream 3 shared interrupt handler.
    323           *
    324           * @isr
    325           */

   \                                 In section .text, align 2, keep-with-next
    326          CH_IRQ_HANDLER(DMA2_Stream3_IRQHandler) {
   \                     Vector12C:
   \   00000000   0xB510             PUSH     {R4,LR}
    327            uint32_t flags;
    328          
    329            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    330          
    331            flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_5  ;; 0x40026400
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0D80             LSRS     R0,R0,#+22
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    332            DMA2->LIFCR = flags << 22;
   \   00000012   0x05A0             LSLS     R0,R4,#+22
   \   00000014   0x....             LDR.N    R1,??DataTable18_6  ;; 0x40026408
   \   00000016   0x6008             STR      R0,[R1, #+0]
    333            if (dma_isr_redir[11].dma_func)
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x6D80             LDR      R0,[R0, #+88]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??Vector12C_0
    334              dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable18_2
   \   00000024   0x6DC0             LDR      R0,[R0, #+92]
   \   00000026   0x....             LDR.N    R2,??DataTable18_2
   \   00000028   0x6D92             LDR      R2,[R2, #+88]
   \   0000002A   0x4790             BLX      R2
    335          
    336            CH_IRQ_EPILOGUE();
   \                     ??Vector12C_0:
   \   0000002C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000030   0x.... 0x....      BL       _port_irq_epilogue
    337          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    338          
    339          /**
    340           * @brief   DMA2 stream 4 shared interrupt handler.
    341           *
    342           * @isr
    343           */

   \                                 In section .text, align 2, keep-with-next
    344          CH_IRQ_HANDLER(DMA2_Stream4_IRQHandler) {
   \                     Vector130:
   \   00000000   0xB510             PUSH     {R4,LR}
    345            uint32_t flags;
    346          
    347            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    348          
    349            flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_7  ;; 0x40026404
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   0000000E   0x0004             MOVS     R4,R0
    350            DMA2->HIFCR = flags << 0;
   \   00000010   0x....             LDR.N    R0,??DataTable18_8  ;; 0x4002640c
   \   00000012   0x6004             STR      R4,[R0, #+0]
    351            if (dma_isr_redir[12].dma_func)
   \   00000014   0x....             LDR.N    R0,??DataTable18_2
   \   00000016   0x6E00             LDR      R0,[R0, #+96]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD005             BEQ.N    ??Vector130_0
    352              dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x....             LDR.N    R0,??DataTable18_2
   \   00000020   0x6E40             LDR      R0,[R0, #+100]
   \   00000022   0x....             LDR.N    R2,??DataTable18_2
   \   00000024   0x6E12             LDR      R2,[R2, #+96]
   \   00000026   0x4790             BLX      R2
    353          
    354            CH_IRQ_EPILOGUE();
   \                     ??Vector130_0:
   \   00000028   0x.... 0x....      BL       dbg_check_leave_isr
   \   0000002C   0x.... 0x....      BL       _port_irq_epilogue
    355          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    356          
    357          /**
    358           * @brief   DMA2 stream 5 shared interrupt handler.
    359           *
    360           * @isr
    361           */

   \                                 In section .text, align 2, keep-with-next
    362          CH_IRQ_HANDLER(DMA2_Stream5_IRQHandler) {
   \                     Vector150:
   \   00000000   0xB510             PUSH     {R4,LR}
    363            uint32_t flags;
    364          
    365            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    366          
    367            flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_7  ;; 0x40026404
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0980             LSRS     R0,R0,#+6
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    368            DMA2->HIFCR = flags << 6;
   \   00000012   0x01A0             LSLS     R0,R4,#+6
   \   00000014   0x....             LDR.N    R1,??DataTable18_8  ;; 0x4002640c
   \   00000016   0x6008             STR      R0,[R1, #+0]
    369            if (dma_isr_redir[13].dma_func)
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x6E80             LDR      R0,[R0, #+104]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??Vector150_0
    370              dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable18_2
   \   00000024   0x6EC0             LDR      R0,[R0, #+108]
   \   00000026   0x....             LDR.N    R2,??DataTable18_2
   \   00000028   0x6E92             LDR      R2,[R2, #+104]
   \   0000002A   0x4790             BLX      R2
    371          
    372            CH_IRQ_EPILOGUE();
   \                     ??Vector150_0:
   \   0000002C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000030   0x.... 0x....      BL       _port_irq_epilogue
    373          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    374          
    375          /**
    376           * @brief   DMA2 stream 6 shared interrupt handler.
    377           *
    378           * @isr
    379           */

   \                                 In section .text, align 2, keep-with-next
    380          CH_IRQ_HANDLER(DMA2_Stream6_IRQHandler) {
   \                     Vector154:
   \   00000000   0xB510             PUSH     {R4,LR}
    381            uint32_t flags;
    382          
    383            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    384          
    385            flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_7  ;; 0x40026404
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0C00             LSRS     R0,R0,#+16
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    386            DMA2->HIFCR = flags << 16;
   \   00000012   0x0420             LSLS     R0,R4,#+16
   \   00000014   0x....             LDR.N    R1,??DataTable18_8  ;; 0x4002640c
   \   00000016   0x6008             STR      R0,[R1, #+0]
    387            if (dma_isr_redir[14].dma_func)
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x6F00             LDR      R0,[R0, #+112]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??Vector154_0
    388              dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable18_2
   \   00000024   0x6F40             LDR      R0,[R0, #+116]
   \   00000026   0x....             LDR.N    R2,??DataTable18_2
   \   00000028   0x6F12             LDR      R2,[R2, #+112]
   \   0000002A   0x4790             BLX      R2
    389          
    390            CH_IRQ_EPILOGUE();
   \                     ??Vector154_0:
   \   0000002C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000030   0x.... 0x....      BL       _port_irq_epilogue
    391          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    392          
    393          /**
    394           * @brief   DMA2 stream 7 shared interrupt handler.
    395           *
    396           * @isr
    397           */

   \                                 In section .text, align 2, keep-with-next
    398          CH_IRQ_HANDLER(DMA2_Stream7_IRQHandler) {
   \                     Vector158:
   \   00000000   0xB510             PUSH     {R4,LR}
    399            uint32_t flags;
    400          
    401            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    402          
    403            flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable18_7  ;; 0x40026404
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0D80             LSRS     R0,R0,#+22
   \   0000000C   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000010   0x0004             MOVS     R4,R0
    404            DMA2->HIFCR = flags << 22;
   \   00000012   0x05A0             LSLS     R0,R4,#+22
   \   00000014   0x....             LDR.N    R1,??DataTable18_8  ;; 0x4002640c
   \   00000016   0x6008             STR      R0,[R1, #+0]
    405            if (dma_isr_redir[15].dma_func)
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x6F80             LDR      R0,[R0, #+120]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??Vector158_0
    406              dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable18_2
   \   00000024   0x6FC0             LDR      R0,[R0, #+124]
   \   00000026   0x....             LDR.N    R2,??DataTable18_2
   \   00000028   0x6F92             LDR      R2,[R2, #+120]
   \   0000002A   0x4790             BLX      R2
    407          
    408            CH_IRQ_EPILOGUE();
   \                     ??Vector158_0:
   \   0000002C   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000030   0x.... 0x....      BL       _port_irq_epilogue
    409          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    410          
    411          /*===========================================================================*/
    412          /* Driver exported functions.                                                */
    413          /*===========================================================================*/
    414          
    415          /**
    416           * @brief   STM32 DMA helper initialization.
    417           *
    418           * @init
    419           */

   \                                 In section .text, align 2, keep-with-next
    420          void dmaInit(void) {
    421            int i;
    422          
    423            dma_streams_mask = 0;
   \                     dmaInit:
   \   00000000   0x....             LDR.N    R1,??DataTable18_9
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x600A             STR      R2,[R1, #+0]
    424            for (i = 0; i < STM32_DMA_STREAMS; i++) {
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0008             MOVS     R0,R1
   \                     ??dmaInit_0:
   \   0000000A   0x2810             CMP      R0,#+16
   \   0000000C   0xDA0C             BGE.N    ??dmaInit_1
    425              _stm32_dma_streams[i].stream->CR = 0;
   \   0000000E   0x210C             MOVS     R1,#+12
   \   00000010   0x....             LDR.N    R2,??DataTable18_10
   \   00000012   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    426              dma_isr_redir[i].dma_func = NULL;
   \   0000001C   0x....             LDR.N    R1,??DataTable18_2
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0xF841 0x2030      STR      R2,[R1, R0, LSL #+3]
    427            }
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0xE7F0             B.N      ??dmaInit_0
    428            DMA1->LIFCR = 0xFFFFFFFF;
   \                     ??dmaInit_1:
   \   00000028   0x....             LDR.N    R1,??DataTable18_1  ;; 0x40026008
   \   0000002A   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000002E   0x600A             STR      R2,[R1, #+0]
    429            DMA1->HIFCR = 0xFFFFFFFF;
   \   00000030   0x....             LDR.N    R1,??DataTable18_4  ;; 0x4002600c
   \   00000032   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000036   0x600A             STR      R2,[R1, #+0]
    430            DMA2->LIFCR = 0xFFFFFFFF;
   \   00000038   0x....             LDR.N    R1,??DataTable18_6  ;; 0x40026408
   \   0000003A   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000003E   0x600A             STR      R2,[R1, #+0]
    431            DMA2->HIFCR = 0xFFFFFFFF;
   \   00000040   0x....             LDR.N    R1,??DataTable18_8  ;; 0x4002640c
   \   00000042   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000046   0x600A             STR      R2,[R1, #+0]
    432          }
   \   00000048   0x4770             BX       LR               ;; return
    433          
    434          /**
    435           * @brief   Allocates a DMA stream.
    436           * @details The stream is allocated and, if required, the DMA clock enabled.
    437           *          The function also enables the IRQ vector associated to the stream
    438           *          and initializes its priority.
    439           * @pre     The stream must not be already in use or an error is returned.
    440           * @post    The stream is allocated and the default ISR handler redirected
    441           *          to the specified function.
    442           * @post    The stream ISR vector is enabled and its priority configured.
    443           * @post    The stream must be freed using @p dmaStreamRelease() before it can
    444           *          be reused with another peripheral.
    445           * @post    The stream is in its post-reset state.
    446           * @note    This function can be invoked in both ISR or thread context.
    447           *
    448           * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
    449           * @param[in] priority  IRQ priority mask for the DMA stream
    450           * @param[in] func      handling function pointer, can be @p NULL
    451           * @param[in] param     a parameter to be passed to the handling function
    452           * @return              The operation status.
    453           * @retval FALSE        no error, stream taken.
    454           * @retval TRUE         error, stream already taken.
    455           *
    456           * @special
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          bool_t dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
    459                                   uint32_t priority,
    460                                   stm32_dmaisr_t func,
    461                                   void *param) {
   \                     dmaStreamAllocate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    462          
    463            chDbgCheck(dmastp != NULL, "dmaStreamAllocate");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??dmaStreamAllocate_0
   \   0000000E   0xF240 0x12CF      MOVW     R2,#+463
   \   00000012   0x....             LDR.N    R1,??DataTable18_11
   \   00000014   0x....             LDR.N    R0,??DataTable18_12
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    464          
    465            /* Checks if the stream is already taken.*/
    466            if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
   \                     ??dmaStreamAllocate_0:
   \   0000001A   0x....             LDR.N    R0,??DataTable18_9
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x7A61             LDRB     R1,[R4, #+9]
   \   00000020   0x40C8             LSRS     R0,R0,R1
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD501             BPL.N    ??dmaStreamAllocate_1
    467              return TRUE;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE044             B.N      ??dmaStreamAllocate_2
    468          
    469            /* Marks the stream as allocated.*/
    470            dma_isr_redir[dmastp->selfindex].dma_func  = func;
   \                     ??dmaStreamAllocate_1:
   \   0000002A   0x7A60             LDRB     R0,[R4, #+9]
   \   0000002C   0x....             LDR.N    R1,??DataTable18_2
   \   0000002E   0xF841 0x6030      STR      R6,[R1, R0, LSL #+3]
    471            dma_isr_redir[dmastp->selfindex].dma_param = param;
   \   00000032   0x7A60             LDRB     R0,[R4, #+9]
   \   00000034   0x....             LDR.N    R1,??DataTable18_2
   \   00000036   0xEB11 0x00C0      ADDS     R0,R1,R0, LSL #+3
   \   0000003A   0x6047             STR      R7,[R0, #+4]
    472            dma_streams_mask |= (1 << dmastp->selfindex);
   \   0000003C   0x....             LDR.N    R0,??DataTable18_9
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF994 0x2009      LDRSB    R2,[R4, #+9]
   \   00000046   0x4091             LSLS     R1,R1,R2
   \   00000048   0x4308             ORRS     R0,R1,R0
   \   0000004A   0x....             LDR.N    R1,??DataTable18_9
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    473          
    474            /* Enabling DMA clocks required by the current streams set.*/
    475            if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
   \   0000004E   0x....             LDR.N    R0,??DataTable18_9
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x0600             LSLS     R0,R0,#+24
   \   00000054   0xD005             BEQ.N    ??dmaStreamAllocate_3
    476              rccEnableDMA1(FALSE);
   \   00000056   0x....             LDR.N    R0,??DataTable18_13  ;; 0x40023830
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000005E   0x....             LDR.N    R1,??DataTable18_13  ;; 0x40023830
   \   00000060   0x6008             STR      R0,[R1, #+0]
    477            if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
   \                     ??dmaStreamAllocate_3:
   \   00000062   0x....             LDR.N    R0,??DataTable18_9
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF410 0x4F7F      TST      R0,#0xFF00
   \   0000006A   0xD005             BEQ.N    ??dmaStreamAllocate_4
    478              rccEnableDMA2(FALSE);
   \   0000006C   0x....             LDR.N    R0,??DataTable18_13  ;; 0x40023830
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000074   0x....             LDR.N    R1,??DataTable18_13  ;; 0x40023830
   \   00000076   0x6008             STR      R0,[R1, #+0]
    479          
    480            /* Putting the stream in a safe state.*/
    481            dmaStreamDisable(dmastp);
   \                     ??dmaStreamAllocate_4:
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x0940             LSRS     R0,R0,#+5
   \   0000007E   0x0140             LSLS     R0,R0,#+5
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x6008             STR      R0,[R1, #+0]
   \                     ??dmaStreamAllocate_5:
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x07C0             LSLS     R0,R0,#+31
   \   0000008A   0xD4FB             BMI.N    ??dmaStreamAllocate_5
   \   0000008C   0x203D             MOVS     R0,#+61
   \   0000008E   0xF994 0x1008      LDRSB    R1,[R4, #+8]
   \   00000092   0x4088             LSLS     R0,R0,R1
   \   00000094   0x6861             LDR      R1,[R4, #+4]
   \   00000096   0x6008             STR      R0,[R1, #+0]
    482            dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    483            dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x2121             MOVS     R1,#+33
   \   000000A2   0x6141             STR      R1,[R0, #+20]
    484          
    485            /* Enables the associated IRQ vector if a callback is defined.*/
    486            if (func != NULL)
   \   000000A4   0x0030             MOVS     R0,R6
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD003             BEQ.N    ??dmaStreamAllocate_6
    487              nvicEnableVector(dmastp->vector, CORTEX_PRIORITY_MASK(priority));
   \   000000AA   0x0129             LSLS     R1,R5,#+4
   \   000000AC   0x7AA0             LDRB     R0,[R4, #+10]
   \   000000AE   0x.... 0x....      BL       nvicEnableVector
    488          
    489            return FALSE;
   \                     ??dmaStreamAllocate_6:
   \   000000B2   0x2000             MOVS     R0,#+0
   \                     ??dmaStreamAllocate_2:
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    490          }
    491          
    492          /**
    493           * @brief   Releases a DMA stream.
    494           * @details The stream is freed and, if required, the DMA clock disabled.
    495           *          Trying to release a unallocated stream is an illegal operation
    496           *          and is trapped if assertions are enabled.
    497           * @pre     The stream must have been allocated using @p dmaStreamAllocate().
    498           * @post    The stream is again available.
    499           * @note    This function can be invoked in both ISR or thread context.
    500           *
    501           * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
    502           *
    503           * @special
    504           */

   \                                 In section .text, align 2, keep-with-next
    505          void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
   \                     dmaStreamRelease:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    506          
    507            chDbgCheck(dmastp != NULL, "dmaStreamRelease");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??dmaStreamRelease_0
   \   00000008   0xF240 0x12FB      MOVW     R2,#+507
   \   0000000C   0x....             LDR.N    R1,??DataTable18_11
   \   0000000E   0x....             LDR.N    R0,??DataTable18_14
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    508          
    509            /* Check if the streams is not taken.*/
    510            chDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0,
    511                        "dmaStreamRelease(), #1", "not allocated");
   \                     ??dmaStreamRelease_0:
   \   00000014   0x....             LDR.N    R0,??DataTable18_9
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7A61             LDRB     R1,[R4, #+9]
   \   0000001A   0x40C8             LSRS     R0,R0,R1
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD402             BMI.N    ??dmaStreamRelease_1
   \   00000020   0x....             LDR.N    R0,??DataTable18_15
   \   00000022   0x.... 0x....      BL       chDbgPanic
    512          
    513            /* Disables the associated IRQ vector.*/
    514            nvicDisableVector(dmastp->vector);
   \                     ??dmaStreamRelease_1:
   \   00000026   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000028   0x.... 0x....      BL       nvicDisableVector
    515          
    516            /* Marks the stream as not allocated.*/
    517            dma_streams_mask &= ~(1 << dmastp->selfindex);
   \   0000002C   0x....             LDR.N    R0,??DataTable18_9
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF994 0x2009      LDRSB    R2,[R4, #+9]
   \   00000036   0x4091             LSLS     R1,R1,R2
   \   00000038   0x4388             BICS     R0,R0,R1
   \   0000003A   0x....             LDR.N    R1,??DataTable18_9
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    518          
    519            /* Shutting down clocks that are no more required, if any.*/
    520            if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0)
   \   0000003E   0x....             LDR.N    R0,??DataTable18_9
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x0600             LSLS     R0,R0,#+24
   \   00000044   0xD105             BNE.N    ??dmaStreamRelease_2
    521              rccDisableDMA1(FALSE);
   \   00000046   0x....             LDR.N    R0,??DataTable18_13  ;; 0x40023830
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   0000004E   0x....             LDR.N    R1,??DataTable18_13  ;; 0x40023830
   \   00000050   0x6008             STR      R0,[R1, #+0]
    522            if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0)
   \                     ??dmaStreamRelease_2:
   \   00000052   0x....             LDR.N    R0,??DataTable18_9
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF410 0x4F7F      TST      R0,#0xFF00
   \   0000005A   0xD105             BNE.N    ??dmaStreamRelease_3
    523              rccDisableDMA2(FALSE);
   \   0000005C   0x....             LDR.N    R0,??DataTable18_13  ;; 0x40023830
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   00000064   0x....             LDR.N    R1,??DataTable18_13  ;; 0x40023830
   \   00000066   0x6008             STR      R0,[R1, #+0]
    524          }
   \                     ??dmaStreamRelease_3:
   \   00000068   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40026000         DC32     0x40026000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x40026008         DC32     0x40026008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     dma_isr_redir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x40026004         DC32     0x40026004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x4002600C         DC32     0x4002600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x40026400         DC32     0x40026400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x40026408         DC32     0x40026408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x40026404         DC32     0x40026404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x4002640C         DC32     0x4002640c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x........         DC32     dma_streams_mask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x........         DC32     _stm32_dma_streams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x........         DC32     `?<Constant "\\"dmaStreamAllocate\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x........         DC32     `?<Constant "\\"dmaStreamRelease\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x........         DC32     `?<Constant "dmaStreamRelease(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"dmaStreamAllocate\\"()">`:
   \   00000000   0x22 0x64          DC8 "\"dmaStreamAllocate\"()"
   \              0x6D 0x61    
   \              0x53 0x74    
   \              0x72 0x65    
   \              0x61 0x6D    
   \              0x41 0x6C    
   \              0x6C 0x6F    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 70H, 6CH, 61H, 74H
   \              0x6C 0x5C    
   \              0x70 0x6C    
   \              0x61 0x74    
   \   00000038   0x66 0x6F          DC8 66H, 6FH, 72H, 6DH, 73H, 5CH, 53H, 54H
   \              0x72 0x6D    
   \              0x73 0x5C    
   \              0x53 0x54    
   \   00000040   0x4D 0x33          DC8 4DH, 33H, 32H, 46H, 34H, 78H, 78H, 5CH
   \              0x32 0x46    
   \              0x34 0x78    
   \              0x78 0x5C    
   \   00000048   0x73 0x74          DC8 73H, 74H, 6DH, 33H, 32H, 5FH, 64H, 6DH
   \              0x6D 0x33    
   \              0x32 0x5F    
   \              0x64 0x6D    
   \   00000050   0x61 0x2E          DC8 61H, 2EH, 63H, 0
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"dmaStreamRelease\\"()">`:
   \   00000000   0x22 0x64          DC8 "\"dmaStreamRelease\"()"
   \              0x6D 0x61    
   \              0x53 0x74    
   \              0x72 0x65    
   \              0x61 0x6D    
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \              0x65 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "dmaStreamRelease(), #1">`:
   \   00000000   0x64 0x6D          DC8 "dmaStreamRelease(), #1"
   \              0x61 0x53    
   \              0x74 0x72    
   \              0x65 0x61    
   \              0x6D 0x52    
   \              0x65 0x6C    
   \              0x65 0x61    
   \              0x73 0x65    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000017   0x00               DC8 0
    525          
    526          #endif /* STM32_DMA_REQUIRED */
    527          
    528          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Vector120
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector124
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector128
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector12C
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector130
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector150
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector154
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector158
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector6C
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector70
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector74
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector78
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector7C
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector80
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   Vector84
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       8   VectorFC
         8   -- Indirect call
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
       0   dmaInit
      24   dmaStreamAllocate
        24   -> chDbgPanic3
        24   -> nvicEnableVector
       8   dmaStreamRelease
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> nvicDisableVector


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      84  ?<Constant "F:\\stuff\\rusefi_sourc...">
      24  ?<Constant "\"dmaStreamAllocate\"()">
      24  ?<Constant "\"dmaStreamRelease\"()">
      24  ?<Constant "dmaStreamRelease(), #1">
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      52  Vector120
      54  Vector124
      54  Vector128
      54  Vector12C
      50  Vector130
      54  Vector150
      54  Vector154
      54  Vector158
      60  Vector6C
      64  Vector70
      64  Vector74
      64  Vector78
      60  Vector7C
      64  Vector80
      64  Vector84
      64  VectorFC
     192  _stm32_dma_streams
      74  dmaInit
     182  dmaStreamAllocate
     106  dmaStreamRelease
     128  dma_isr_redir
       4  dma_streams_mask

 
   132 bytes in section .bss
   348 bytes in section .rodata
 1 356 bytes in section .text
 
 1 356 bytes of CODE  memory
   348 bytes of CONST memory
   132 bytes of DATA  memory

Errors: none
Warnings: none
