###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:01 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\hardwar #
#                       e.cpp                                                 #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\hw_layer\hardwar #
#                       e.cpp -lCN F:\stuff\rusefi_sourceforge\firmware\iar\D #
#                       ebug\List\ -lA F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\Debug\Obj\ --no_cse --no_unroll --no_inline     #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\h #
#                       ardware.lst                                           #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ha #
#                       rdware.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\hw_layer\hardware.cpp
      1          /**
      2           * @file    hardware.cpp
      3           * @brief   Hardware package entry point
      4           *
      5           * @date May 27, 2013
      6           * @author Andrey Belomutskiy, (c) 2012-2015
      7           */
      8          
      9          #include "main.h"
     10          #include "adc_inputs.h"
     11          #include "can_hw.h"
     12          #include "console_io.h"
     13          #include "hardware.h"
     14          #include "io_pins.h"
     15          #include "pin_repository.h"
     16          #include "rtc_helper.h"
     17          #include "rfiutil.h"
     18          #include "injector_central.h"
     19          #include "vehicle_speed.h"
     20          
     21          #include "trigger_input.h"
     22          #include "eficonsole.h"
     23          #include "max31855.h"
     24          
     25          #if EFI_PROD_CODE
     26          #include "AdcConfiguration.h"
     27          #include "board_test.h"
     28          #include "mcp3208.h"
     29          #include "HIP9011.h"
     30          #include "histogram.h"
     31          #include "mmc_card.h"
     32          #include "neo6m.h"
     33          #include "lcd_HD44780.h"
     34          #include "settings.h"
     35          #include "algo.h"
     36          #include "joystick.h"
     37          #include "trigger_central.h"
     38          #include "svnversion.h"
     39          #include "engine_configuration.h"
     40          #include "wbo.h"
     41          #endif
     42          
     43          #if EFI_SPEED_DENSITY
     44          #include "map_averaging.h"
     45          #endif /* EFI_SPEED_DENSITY */
     46          
     47          #if EFI_INTERNAL_FLASH
     48          #include "flash_main.h"
     49          #endif /* EFI_INTERNAL_FLASH */
     50          
     51          EXTERN_ENGINE
     52          ;
     53          extern bool hasFirmwareErrorFlag;
     54          

   \                                 In section .bss, align 4
     55          static Mutex spiMtx;
   \                     spiMtx:
   \   00000000                      DS8 16
     56          

   \                                 In section .bss, align 4
     57          int maxNesting = 0;
   \                     maxNesting:
   \   00000000                      DS8 4
     58          
     59          #if HAL_USE_SPI || defined(__DOXYGEN__)
     60          static bool isSpiInitialized[5] = { false, false, false, false, false };
     61          
     62          /**
     63           * Only one consumer can use SPI bus at a given time
     64           */

   \                                 In section .text, align 2, keep-with-next
     65          void lockSpi(spi_device_e device) {
   \                     _Z7lockSpi12spi_device_e:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     66          	efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lockSpi");
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000008   0x6980             LDR      R0,[R0, #+24]
   \   0000000A   0x.... 0x....      BL       getRemainingStack
   \   0000000E   0x2881             CMP      R0,#+129
   \   00000010   0xDA04             BGE.N    ??lockSpi_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000016   0x.... 0x....      BL       firmwareError
   \   0000001A   0xE003             B.N      ??lockSpi_1
     67          	// todo: different locks for different SPI devices!
     68          	chMtxLock(&spiMtx);
   \                     ??lockSpi_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000020   0x.... 0x....      BL       chMtxLock
     69          }
   \                     ??lockSpi_1:
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
     70          

   \                                 In section .text, align 2, keep-with-next
     71          void unlockSpi(void) {
   \                     _Z9unlockSpiv:
   \   00000000   0xB580             PUSH     {R7,LR}
     72          	chMtxUnlock();
   \   00000002   0x.... 0x....      BL       chMtxUnlock
     73          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
     74          

   \                                 In section .text, align 2, keep-with-next
     75          static void initSpiModules(board_configuration_s *boardConfiguration) {
   \                     _Z14initSpiModulesP21board_configuration_s:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     76          	if (boardConfiguration->is_enabled_spi_2) {
   \   00000004   0xF894 0x0180      LDRB     R0,[R4, #+384]
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??initSpiModules_0
     77          		turnOnSpi(SPI_DEVICE_2);
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       _Z9turnOnSpi12spi_device_e
     78          	}
     79          	if (boardConfiguration->is_enabled_spi_3) {
   \                     ??initSpiModules_0:
   \   0000001A   0xF894 0x0180      LDRB     R0,[R4, #+384]
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x0880             LSRS     R0,R0,#+2
   \   00000022   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??initSpiModules_1
     80          		turnOnSpi(SPI_DEVICE_3);
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x.... 0x....      BL       _Z9turnOnSpi12spi_device_e
     81          	}
     82          }
   \                     ??initSpiModules_1:
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
     83          

   \                                 In section .text, align 2, keep-with-next
     84          SPIDriver * getSpiDevice(spi_device_e spiDevice) {
   \                     _Z12getSpiDevice12spi_device_e:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     85          	if (spiDevice == SPI_NONE) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??getSpiDevice_0
     86          		return NULL;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE010             B.N      ??getSpiDevice_1
     87          	}
     88          #if STM32_SPI_USE_SPI1 || defined(__DOXYGEN__)
     89          	if (spiDevice == SPI_DEVICE_1) {
   \                     ??getSpiDevice_0:
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD101             BNE.N    ??getSpiDevice_2
     90          		return &SPID1;
   \   00000010   0x....             LDR.N    R0,??DataTable5_4
   \   00000012   0xE00C             B.N      ??getSpiDevice_1
     91          	}
     92          #endif
     93          #if STM32_SPI_USE_SPI2 || defined(__DOXYGEN__)
     94          	if (spiDevice == SPI_DEVICE_2) {
   \                     ??getSpiDevice_2:
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xD101             BNE.N    ??getSpiDevice_3
     95          		return &SPID2;
   \   00000018   0x....             LDR.N    R0,??DataTable5_5
   \   0000001A   0xE008             B.N      ??getSpiDevice_1
     96          	}
     97          #endif
     98          #if STM32_SPI_USE_SPI3 || defined(__DOXYGEN__)
     99          	if (spiDevice == SPI_DEVICE_3) {
   \                     ??getSpiDevice_3:
   \   0000001C   0x2C03             CMP      R4,#+3
   \   0000001E   0xD101             BNE.N    ??getSpiDevice_4
    100          		return &SPID3;
   \   00000020   0x....             LDR.N    R0,??DataTable5_6
   \   00000022   0xE004             B.N      ??getSpiDevice_1
    101          	}
    102          #endif
    103          	firmwareError("Unexpected SPI device: %d", spiDevice);
   \                     ??getSpiDevice_4:
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x....             LDR.N    R0,??DataTable5_7
   \   00000028   0x.... 0x....      BL       firmwareError
    104          	return NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??getSpiDevice_1:
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    105          }
    106          #endif
    107          
    108          #if HAL_USE_I2C || defined(__DOXYGEN__)

   \                                 In section .data, align 4
    109          static I2CConfig i2cfg = { OPMODE_I2C, 100000, STD_DUTY_CYCLE, };
   \                     i2cfg:
   \   00000000   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x000186A0         DC32 100000
   \   00000008   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
    110          

   \                                 In section .text, align 2, keep-with-next
    111          void initI2Cmodule(void) {
   \                     _Z13initI2Cmodulev:
   \   00000000   0xB580             PUSH     {R7,LR}
    112          	print("Starting I2C module\r\n");
   \   00000002   0x....             LDR.N    R0,??DataTable5_8
   \   00000004   0x.... 0x....      BL       print
    113          	i2cInit();
   \   00000008   0x.... 0x....      BL       i2cInit
    114          	i2cStart(&I2CD1, &i2cfg);
   \   0000000C   0x....             LDR.N    R1,??DataTable5_9
   \   0000000E   0x....             LDR.N    R0,??DataTable5_10
   \   00000010   0x.... 0x....      BL       i2cStart
    115          
    116          	mySetPadMode("I2C clock", EFI_I2C_SCL_PORT, EFI_I2C_SCL_PIN,
    117          	PAL_MODE_ALTERNATE(EFI_I2C_AF) | PAL_STM32_OTYPE_OPENDRAIN);
   \   00000014   0xF240 0x2306      MOVW     R3,#+518
   \   00000018   0x2206             MOVS     R2,#+6
   \   0000001A   0x....             LDR.N    R1,??DataTable5_11  ;; 0x40020400
   \   0000001C   0x....             LDR.N    R0,??DataTable5_12
   \   0000001E   0x.... 0x....      BL       _Z12mySetPadModePKcP12GPIO_TypeDefjj
    118          	mySetPadMode("I2C data", EFI_I2C_SDA_PORT, EFI_I2C_SDA_PIN,
    119          	PAL_MODE_ALTERNATE(EFI_I2C_AF) | PAL_STM32_OTYPE_OPENDRAIN);
   \   00000022   0xF240 0x2306      MOVW     R3,#+518
   \   00000026   0x2207             MOVS     R2,#+7
   \   00000028   0x....             LDR.N    R1,??DataTable5_11  ;; 0x40020400
   \   0000002A   0x....             LDR.N    R0,??DataTable5_13
   \   0000002C   0x.... 0x....      BL       _Z12mySetPadModePKcP12GPIO_TypeDefjj
    120          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    121          
    122          //static char txbuf[1];
    123          

   \                                 In section .text, align 2, keep-with-next
    124          static void sendI2Cbyte(int addr, int data) {
    125          //	i2cAcquireBus(&I2CD1);
    126          //	txbuf[0] = data;
    127          //	i2cMasterTransmit(&I2CD1, addr, txbuf, 1, NULL, 0);
    128          //	i2cReleaseBus(&I2CD1);
    129          }
   \                     _Z11sendI2Cbyteii:
   \   00000000   0x4770             BX       LR               ;; return
    130          
    131          #endif
    132          

   \                                 In section .bss, align 4
    133          static Logging *sharedLogger;
   \                     sharedLogger:
   \   00000000                      DS8 4
    134          
    135          #if EFI_PROD_CODE
    136          
    137          extern AdcDevice fastAdc;
    138          
    139          #define TPS_IS_SLOW -1
    140          

   \                                 In section .bss, align 4
    141          static int fastMapSampleIndex;
   \                     fastMapSampleIndex:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    142          static int hipSampleIndex;
   \                     hipSampleIndex:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    143          static int tpsSampleIndex;
   \                     tpsSampleIndex:
   \   00000000                      DS8 4
    144          
    145          extern int tpsFastAdc;
    146          
    147          /**
    148           * This method is not in the adc* lower-level file because it is more business logic then hardware.
    149           */

   \                                 In section .text, align 2, keep-with-next
    150          void adc_callback_fast(ADCDriver *adcp, adcsample_t *buffer, size_t n) {
   \                     _Z17adc_callback_fastP9ADCDriverPtj:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    151          	efiAssertVoid(getRemainingStack(chThdSelf()) > 64, "lowstck12a");
   \   00000008   0x....             LDR.N    R0,??DataTable5_1
   \   0000000A   0x6980             LDR      R0,[R0, #+24]
   \   0000000C   0x.... 0x....      BL       getRemainingStack
   \   00000010   0x2841             CMP      R0,#+65
   \   00000012   0xDA03             BGE.N    ??adc_callback_fast_0
   \   00000014   0x....             LDR.N    R0,??DataTable5_14
   \   00000016   0x.... 0x....      BL       firmwareError
   \   0000001A   0xE036             B.N      ??adc_callback_fast_1
    152          
    153          	(void) buffer;
    154          	(void) n;
    155          	/**
    156          	 * Note, only in the ADC_COMPLETE state because the ADC driver fires an
    157          	 * intermediate callback when the buffer is half full.
    158          	 * */
    159          	if (adcp->state == ADC_COMPLETE) {
   \                     ??adc_callback_fast_0:
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xD133             BNE.N    ??adc_callback_fast_2
    160          		/**
    161          		 * this callback is executed 10 000 times a second, it needs to be as fast as possible
    162          		 */
    163          		efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "lowstck#9b");
   \   00000022   0x....             LDR.N    R0,??DataTable5_1
   \   00000024   0x6980             LDR      R0,[R0, #+24]
   \   00000026   0x.... 0x....      BL       getRemainingStack
   \   0000002A   0x2881             CMP      R0,#+129
   \   0000002C   0xDA03             BGE.N    ??adc_callback_fast_3
   \   0000002E   0x....             LDR.N    R0,??DataTable5_15
   \   00000030   0x.... 0x....      BL       firmwareError
   \   00000034   0xE029             B.N      ??adc_callback_fast_1
    164          
    165          #if EFI_MAP_AVERAGING
    166          		mapAveragingCallback(fastAdc.samples[fastMapSampleIndex]);
   \                     ??adc_callback_fast_3:
   \   00000036   0x....             LDR.N    R0,??DataTable5_16
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x....             LDR.N    R1,??DataTable5_17
   \   0000003C   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000040   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000044   0x.... 0x....      BL       _Z20mapAveragingCallbackt
    167          #endif /* EFI_MAP_AVERAGING */
    168          #if EFI_HIP_9011 || defined(__DOXYGEN__)
    169          		if (boardConfiguration->isHip9011Enabled) {
   \   00000048   0x....             LDR.N    R0,??DataTable5_18
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF890 0x0180      LDRB     R0,[R0, #+384]
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x0980             LSRS     R0,R0,#+6
   \   00000054   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD008             BEQ.N    ??adc_callback_fast_4
    170          			hipAdcCallback(fastAdc.samples[hipSampleIndex]);
   \   0000005C   0x....             LDR.N    R0,??DataTable5_19
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x....             LDR.N    R1,??DataTable5_17
   \   00000062   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000066   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   0000006A   0x.... 0x....      BL       _Z14hipAdcCallbackt
    171          		}
    172          #endif
    173          		if(tpsSampleIndex!=TPS_IS_SLOW) {
   \                     ??adc_callback_fast_4:
   \   0000006E   0x....             LDR.N    R0,??DataTable5_20
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF110 0x0F01      CMN      R0,#+1
   \   00000076   0xD008             BEQ.N    ??adc_callback_fast_2
    174          			tpsFastAdc = fastAdc.samples[tpsSampleIndex];
   \   00000078   0x....             LDR.N    R0,??DataTable5_20
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x....             LDR.N    R1,??DataTable5_17
   \   0000007E   0xEB11 0x0040      ADDS     R0,R1,R0, LSL #+1
   \   00000082   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000086   0x....             LDR.N    R1,??DataTable5_21
   \   00000088   0x6008             STR      R0,[R1, #+0]
    175          		}
    176          	}
    177          }
   \                     ??adc_callback_fast_2:
   \                     ??adc_callback_fast_1:
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    178          

   \                                 In section .text, align 2, keep-with-next
    179          static void calcFastAdcIndexes(void) {
    180          	fastMapSampleIndex = fastAdc.internalAdcIndexByHardwareIndex[engineConfiguration->map.sensor.hwChannel];
   \                     _Z18calcFastAdcIndexesv:
   \   00000000   0x....             LDR.N    R0,??DataTable5_22
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF8D0 0x00FC      LDR      R0,[R0, #+252]
   \   00000008   0x....             LDR.N    R1,??DataTable5_17
   \   0000000A   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000000E   0x....             LDR.N    R1,??DataTable5_16
   \   00000010   0x6008             STR      R0,[R1, #+0]
    181          	hipSampleIndex =
    182          			engineConfiguration->hipOutputChannel == EFI_ADC_NONE ?
    183          					-1 : fastAdc.internalAdcIndexByHardwareIndex[engineConfiguration->hipOutputChannel];
   \   00000012   0x....             LDR.N    R0,??DataTable5_22
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF8D0 0x05DC      LDR      R0,[R0, #+1500]
   \   0000001A   0x2810             CMP      R0,#+16
   \   0000001C   0xD104             BNE.N    ??calcFastAdcIndexes_0
   \   0000001E   0x....             LDR.N    R0,??DataTable5_19
   \   00000020   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xE008             B.N      ??calcFastAdcIndexes_1
   \                     ??calcFastAdcIndexes_0:
   \   00000028   0x....             LDR.N    R0,??DataTable5_22
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF8D0 0x05DC      LDR      R0,[R0, #+1500]
   \   00000030   0x....             LDR.N    R1,??DataTable5_17
   \   00000032   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000036   0x....             LDR.N    R1,??DataTable5_19
   \   00000038   0x6008             STR      R0,[R1, #+0]
    184          	if (engineConfiguration->tpsAdcChannel != EFI_ADC_NONE) {
   \                     ??calcFastAdcIndexes_1:
   \   0000003A   0x....             LDR.N    R0,??DataTable5_22
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF8D0 0x020C      LDR      R0,[R0, #+524]
   \   00000042   0x2810             CMP      R0,#+16
   \   00000044   0xD009             BEQ.N    ??calcFastAdcIndexes_2
    185          		tpsSampleIndex = fastAdc.internalAdcIndexByHardwareIndex[engineConfiguration->tpsAdcChannel];
   \   00000046   0x....             LDR.N    R0,??DataTable5_22
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF8D0 0x020C      LDR      R0,[R0, #+524]
   \   0000004E   0x....             LDR.N    R1,??DataTable5_17
   \   00000050   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000054   0x....             LDR.N    R1,??DataTable5_20
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \   00000058   0xE003             B.N      ??calcFastAdcIndexes_3
    186          	} else {
    187          		tpsSampleIndex = TPS_IS_SLOW;
   \                     ??calcFastAdcIndexes_2:
   \   0000005A   0x....             LDR.N    R0,??DataTable5_20
   \   0000005C   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000060   0x6001             STR      R1,[R0, #+0]
    188          	}
    189          }
   \                     ??calcFastAdcIndexes_3:
   \   00000062   0x4770             BX       LR               ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          static void adcConfigListener(Engine *engine) {
   \                     _Z17adcConfigListenerP6Engine:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    192          	calcFastAdcIndexes();
   \   00000004   0x.... 0x....      BL       _Z18calcFastAdcIndexesv
    193          }
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void turnOnHardware(Logging *sharedLogger) {
   \                     _Z14turnOnHardwareP7Logging:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    196          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    197          	turnOnTriggerInputPins(sharedLogger);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _Z22turnOnTriggerInputPinsP7Logging
    198          #endif /* EFI_SHAFT_POSITION_INPUT */
    199          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    200          
    201          extern engine_configuration_s activeConfiguration;
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void applyNewHardwareSettings(void) {
   \                     _Z24applyNewHardwareSettingsv:
   \   00000000   0xB580             PUSH     {R7,LR}
    204          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    205          	applyNewTriggerInputPins();
   \   00000002   0x.... 0x....      BL       _Z24applyNewTriggerInputPinsv
    206          #endif /* EFI_SHAFT_POSITION_INPUT */
    207          	stopInjectionPins();
   \   00000006   0x.... 0x....      BL       _Z17stopInjectionPinsv
    208          	stopIgnitionPins();
   \   0000000A   0x.... 0x....      BL       _Z16stopIgnitionPinsv
    209          
    210          	startInjectionPins();
   \   0000000E   0x.... 0x....      BL       _Z18startInjectionPinsv
    211          	startIgnitionPins();
   \   00000012   0x.... 0x....      BL       _Z17startIgnitionPinsv
    212          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    213          

   \                                 In section .text, align 2, keep-with-next
    214          void initHardware(Logging *l) {
   \                     _Z12initHardwareP7Logging:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    215          	sharedLogger = l;
   \   00000004   0x....             LDR.N    R0,??DataTable5_23
   \   00000006   0x6004             STR      R4,[R0, #+0]
    216          	engine_configuration_s *engineConfiguration = engine->engineConfiguration;
   \   00000008   0x....             LDR.N    R0,??DataTable5_24
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6A45             LDR      R5,[R0, #+36]
    217          	efiAssertVoid(engineConfiguration!=NULL, "engineConfiguration");
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD103             BNE.N    ??initHardware_0
   \   00000012   0x....             LDR.N    R0,??DataTable5_25
   \   00000014   0x.... 0x....      BL       firmwareError
   \   00000018   0xE0A0             B.N      ??initHardware_1
    218          	board_configuration_s *boardConfiguration = &engineConfiguration->bc;
   \                     ??initHardware_0:
   \   0000001A   0xF515 0x761C      ADDS     R6,R5,#+624
    219          
    220          	printMsg(sharedLogger, "initHardware()");
   \   0000001E   0x....             LDR.N    R1,??DataTable5_26
   \   00000020   0x....             LDR.N    R0,??DataTable5_23
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x.... 0x....      BL       printMsg
    221          	// todo: enable protection. it's disabled because it takes
    222          	// 10 extra seconds to re-flash the chip
    223          	//flashProtect();
    224          
    225          	chMtxInit(&spiMtx);
   \   00000028   0x....             LDR.N    R0,??DataTable5_3
   \   0000002A   0x.... 0x....      BL       chMtxInit
    226          
    227          #if EFI_HISTOGRAMS
    228          	/**
    229          	 * histograms is a data structure for CPU monitor, it does not depend on configuration
    230          	 */
    231          	initHistogramsModule();
    232          #endif /* EFI_HISTOGRAMS */
    233          
    234          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    235          	/**
    236          	 * This is so early because we want to init logger
    237          	 * which would be used while finding trigger synch index
    238          	 * while reading configuration
    239          	 */
    240          	initTriggerDecoderLogger(sharedLogger);
   \   0000002E   0x....             LDR.N    R0,??DataTable5_23
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       _Z24initTriggerDecoderLoggerP7Logging
    241          #endif
    242          
    243          	/**
    244          	 * We need the LED_ERROR pin even before we read configuration
    245          	 */
    246          	initPrimaryPins();
   \   00000036   0x.... 0x....      BL       _Z15initPrimaryPinsv
    247          
    248          	if (hasFirmwareError()) {
   \   0000003A   0x....             LDR.N    R0,??DataTable5_27
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xF040 0x808C      BNE.W    ??initHardware_1
    249          		return;
    250          	}
    251          
    252          	initDataStructures(PASS_ENGINE_PARAMETER_F);
   \                     ??initHardware_2:
   \   00000044   0x.... 0x....      BL       _Z18initDataStructuresv
    253          
    254          #if EFI_INTERNAL_FLASH
    255          
    256          	palSetPadMode(CONFIG_RESET_SWITCH_PORT, CONFIG_RESET_SWITCH_PIN, PAL_MODE_INPUT_PULLUP);
   \   00000048   0x2220             MOVS     R2,#+32
   \   0000004A   0x2140             MOVS     R1,#+64
   \   0000004C   0x....             LDR.N    R0,??DataTable5_28  ;; 0x40020c00
   \   0000004E   0x.... 0x....      BL       _pal_lld_setgroupmode
    257          
    258          	initFlash(sharedLogger);
   \   00000052   0x....             LDR.N    R0,??DataTable5_23
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x.... 0x....      BL       _Z9initFlashP7Logging
    259          	/**
    260          	 * this call reads configuration from flash memory or sets default configuration
    261          	 * if flash state does not look right.
    262          	 */
    263          	if (SHOULD_INGORE_FLASH()) {
   \   0000005A   0x....             LDR.N    R0,??DataTable5_29  ;; 0x40020c10
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD109             BNE.N    ??initHardware_3
    264          		engineConfiguration->engineType = DEFAULT_ENGINE_TYPE;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6028             STR      R0,[R5, #+0]
    265          		resetConfigurationExt(sharedLogger, engineConfiguration->engineType PASS_ENGINE_PARAMETER);
   \   0000006A   0x6829             LDR      R1,[R5, #+0]
   \   0000006C   0x....             LDR.N    R0,??DataTable5_23
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x.... 0x....      BL       _Z21resetConfigurationExtP7Logging13engine_type_e
    266          		writeToFlashNow();
   \   00000074   0x.... 0x....      BL       _Z15writeToFlashNowv
   \   00000078   0xE001             B.N      ??initHardware_4
    267          	} else {
    268          		readFromFlash();
   \                     ??initHardware_3:
   \   0000007A   0x.... 0x....      BL       _Z13readFromFlashv
    269          	}
    270          #else
    271          	engineConfiguration->engineType = DEFAULT_ENGINE_TYPE;
    272          	resetConfigurationExt(sharedLogger, engineConfiguration->engineType PASS_ENGINE_PARAMETER);
    273          #endif /* EFI_INTERNAL_FLASH */
    274          
    275          	if (hasFirmwareError()) {
   \                     ??initHardware_4:
   \   0000007E   0x....             LDR.N    R0,??DataTable5_27
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD16A             BNE.N    ??initHardware_1
    276          		return;
    277          	}
    278          
    279          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    280          	initTriggerDecoder();
   \                     ??initHardware_5:
   \   00000086   0x.... 0x....      BL       _Z18initTriggerDecoderv
    281          #endif
    282          
    283          	mySetPadMode2("board test", boardConfiguration->boardTestModeJumperPin,
    284          	PAL_MODE_INPUT_PULLUP);
   \   0000008A   0x2220             MOVS     R2,#+32
   \   0000008C   0xF8D6 0x1150      LDR      R1,[R6, #+336]
   \   00000090   0x....             LDR.N    R0,??DataTable5_30
   \   00000092   0x.... 0x....      BL       _Z13mySetPadMode2PKc11brain_pin_ej
    285          	bool isBoardTestMode_b = GET_BOARD_TEST_MODE_VALUE();
   \   00000096   0xF8D6 0x0150      LDR      R0,[R6, #+336]
   \   0000009A   0x.... 0x....      BL       _Z9getHwPort11brain_pin_e
   \   0000009E   0x6907             LDR      R7,[R0, #+16]
   \   000000A0   0xF8D6 0x0150      LDR      R0,[R6, #+336]
   \   000000A4   0x.... 0x....      BL       _Z8getHwPin11brain_pin_e
   \   000000A8   0xFA37 0xF000      LSRS     R0,R7,R0
   \   000000AC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000B0   0xF090 0x0701      EORS     R7,R0,#0x1
    286          
    287          #if HAL_USE_ADC || defined(__DOXYGEN__)
    288          	initAdcInputs(isBoardTestMode_b);
   \   000000B4   0x0038             MOVS     R0,R7
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       _Z13initAdcInputsb
    289          #endif
    290          
    291          	if (isBoardTestMode_b) {
   \   000000BC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000BE   0x2F00             CMP      R7,#+0
   \   000000C0   0xD001             BEQ.N    ??initHardware_6
    292          		// this method never returns
    293          		initBoardTest();
   \   000000C2   0x.... 0x....      BL       _Z13initBoardTestv
    294          	}
    295          
    296          	initRtc();
   \                     ??initHardware_6:
   \   000000C6   0x.... 0x....      BL       _Z7initRtcv
    297          
    298          	initOutputPins();
   \   000000CA   0x.... 0x....      BL       _Z14initOutputPinsv
    299          
    300          #if EFI_MAX_31855
    301          	initMax31855(sharedLogger, getSpiDevice(boardConfiguration->max31855spiDevice), boardConfiguration->max31855_cs);
   \   000000CE   0xF8D6 0x01C0      LDR      R0,[R6, #+448]
   \   000000D2   0x.... 0x....      BL       _Z12getSpiDevice12spi_device_e
   \   000000D6   0x0001             MOVS     R1,R0
   \   000000D8   0xF516 0x72D0      ADDS     R2,R6,#+416
   \   000000DC   0x....             LDR.N    R0,??DataTable5_23
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x.... 0x....      BL       _Z12initMax31855P7LoggingP9SPIDriverP11brain_pin_e
    302          #endif /* EFI_MAX_31855 */
    303          
    304          #if EFI_CAN_SUPPORT
    305          	initCan();
   \   000000E4   0x.... 0x....      BL       _Z7initCanv
    306          #endif /* EFI_CAN_SUPPORT */
    307          
    308          //	init_adc_mcp3208(&adcState, &SPID2);
    309          //	requestAdcValue(&adcState, 0);
    310          
    311          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    312          	// todo: figure out better startup logic
    313          	initTriggerCentral(sharedLogger, engine);
   \   000000E8   0x....             LDR.N    R0,??DataTable5_24
   \   000000EA   0x6801             LDR      R1,[R0, #+0]
   \   000000EC   0x....             LDR.N    R0,??DataTable5_23
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0x.... 0x....      BL       _Z18initTriggerCentralP7LoggingP6Engine
    314          #endif /* EFI_SHAFT_POSITION_INPUT */
    315          
    316          	turnOnHardware(sharedLogger);
   \   000000F4   0x....             LDR.N    R0,??DataTable5_23
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x.... 0x....      BL       _Z14turnOnHardwareP7Logging
    317          
    318          #if HAL_USE_SPI || defined(__DOXYGEN__)
    319          	initSpiModules(boardConfiguration);
   \   000000FC   0x0030             MOVS     R0,R6
   \   000000FE   0x.... 0x....      BL       _Z14initSpiModulesP21board_configuration_s
    320          #endif
    321          
    322          #if EFI_HIP_9011
    323          	initHip9011(sharedLogger);
   \   00000102   0x....             LDR.N    R0,??DataTable5_23
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x.... 0x....      BL       _Z11initHip9011P7Logging
    324          #endif /* EFI_HIP_9011 */
    325          
    326          #if EFI_FILE_LOGGING
    327          	initMmcCard();
   \   0000010A   0x.... 0x....      BL       initMmcCard
    328          #endif /* EFI_FILE_LOGGING */
    329          
    330          //	initFixedLeds();
    331          
    332          	//	initBooleanInputs();
    333          
    334          #if EFI_UART_GPS
    335          	initGps();
   \   0000010E   0x.... 0x....      BL       initGps
    336          #endif
    337          
    338          #if ADC_SNIFFER
    339          	initAdcDriver();
    340          #endif
    341          
    342          #if EFI_HD44780_LCD
    343          //	initI2Cmodule();
    344          	lcd_HD44780_init(sharedLogger);
   \   00000112   0x....             LDR.N    R0,??DataTable5_23
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x.... 0x....      BL       lcd_HD44780_init
    345          	if (hasFirmwareError())
   \   0000011A   0x....             LDR.N    R0,??DataTable5_27
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD11C             BNE.N    ??initHardware_1
    346          		return;
    347          
    348          	lcd_HD44780_print_string(VCS_VERSION);
   \                     ??initHardware_7:
   \   00000122   0x....             LDR.N    R0,??DataTable5_31
   \   00000124   0x.... 0x....      BL       lcd_HD44780_print_string
    349          
    350          #endif /* EFI_HD44780_LCD */
    351          
    352          #if HAL_USE_I2C || defined(__DOXYGEN__)
    353          	addConsoleActionII("i2c", sendI2Cbyte);
   \   00000128   0x....             LDR.N    R1,??DataTable5_32
   \   0000012A   0x....             ADR.N    R0,??DataTable5  ;; "i2c"
   \   0000012C   0x.... 0x....      BL       addConsoleActionII
    354          #endif
    355          
    356          //	while (true) {
    357          //		for (int addr = 0x20; addr < 0x28; addr++) {
    358          //			sendI2Cbyte(addr, 0);
    359          //			int err = i2cGetErrors(&I2CD1);
    360          //			print("I2C: err=%x from %d\r\n", err, addr);
    361          //			chThdSleepMilliseconds(5);
    362          //			sendI2Cbyte(addr, 255);
    363          //			chThdSleepMilliseconds(5);
    364          //		}
    365          //	}
    366          
    367          #if EFI_VEHICLE_SPEED || defined(__DOXYGEN__)
    368          	initVehicleSpeed(sharedLogger);
   \   00000130   0x....             LDR.N    R0,??DataTable5_23
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x.... 0x....      BL       _Z16initVehicleSpeedP7Logging
    369          #endif
    370          
    371          	initJoystick(sharedLogger);
   \   00000138   0x....             LDR.N    R0,??DataTable5_23
   \   0000013A   0x6800             LDR      R0,[R0, #+0]
   \   0000013C   0x.... 0x....      BL       _Z12initJoystickP7Logging
    372          
    373          	calcFastAdcIndexes();
   \   00000140   0x.... 0x....      BL       _Z18calcFastAdcIndexesv
    374          	engine->addConfigurationListener(adcConfigListener);
   \   00000144   0x....             LDR.N    R1,??DataTable5_33
   \   00000146   0x....             LDR.N    R0,??DataTable5_24
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x.... 0x....      BL       _ZN6Engine24addConfigurationListenerEPFvPS_E
    375          
    376          	initWboController();
   \   0000014E   0x.... 0x....      BL       _Z17initWboControllerv
    377          
    378          	printMsg(sharedLogger, "initHardware() OK!");
   \   00000152   0x....             LDR.N    R1,??DataTable5_34
   \   00000154   0x....             LDR.N    R0,??DataTable5_23
   \   00000156   0x6800             LDR      R0,[R0, #+0]
   \   00000158   0x.... 0x....      BL       printMsg
    379          }
   \                     ??initHardware_1:
   \   0000015C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x69 0x32          DC8      "i2c"
   \              0x63 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     `?<Constant "lockSpi">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     spiMtx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     SPID1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     SPID2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     SPID3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     `?<Constant "Unexpected SPI device...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     `?<Constant "Starting I2C module\\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     i2cfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     I2CD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     `?<Constant "I2C clock">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     `?<Constant "I2C data">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     `?<Constant "lowstck12a">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     `?<Constant "lowstck#9b">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x........         DC32     fastMapSampleIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x........         DC32     fastAdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x........         DC32     boardConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     hipSampleIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x........         DC32     tpsSampleIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x........         DC32     tpsFastAdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x........         DC32     sharedLogger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \   00000000   0x........         DC32     `?<Constant "engineConfiguration">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_26:
   \   00000000   0x........         DC32     `?<Constant "initHardware()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_27:
   \   00000000   0x........         DC32     hasFirmwareErrorFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_28:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_29:
   \   00000000   0x40020C10         DC32     0x40020c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_30:
   \   00000000   0x........         DC32     `?<Constant "board test">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_31:
   \   00000000   0x........         DC32     `?<Constant "8529">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_32:
   \   00000000   0x........         DC32     _Z11sendI2Cbyteii

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_33:
   \   00000000   0x........         DC32     _Z17adcConfigListenerP6Engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_34:
   \   00000000   0x........         DC32     `?<Constant "initHardware() OK!">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "lockSpi">`:
   \   00000000   0x6C 0x6F          DC8 "lockSpi"
   \              0x63 0x6B    
   \              0x53 0x70    
   \              0x69 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Unexpected SPI device...">`:
   \   00000000   0x55 0x6E          DC8 "Unexpected SPI device: %d"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x53    
   \              0x50 0x49    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x3A    
   \              0x20 0x25    
   \              0x64 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Starting I2C module\\r\\n">`:
   \   00000000   0x53 0x74          DC8 "Starting I2C module\015\012"
   \              0x61 0x72    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x49    
   \              0x32 0x43    
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x75 0x6C    
   \              0x65 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "I2C clock">`:
   \   00000000   0x49 0x32          DC8 "I2C clock"
   \              0x43 0x20    
   \              0x63 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "I2C data">`:
   \   00000000   0x49 0x32          DC8 "I2C data"
   \              0x43 0x20    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck12a">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck12a"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x31    
   \              0x32 0x61    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowstck#9b">`:
   \   00000000   0x6C 0x6F          DC8 "lowstck#9b"
   \              0x77 0x73    
   \              0x74 0x63    
   \              0x6B 0x23    
   \              0x39 0x62    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "engineConfiguration">`:
   \   00000000   0x65 0x6E          DC8 "engineConfiguration"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "initHardware()">`:
   \   00000000   0x69 0x6E          DC8 "initHardware()"
   \              0x69 0x74    
   \              0x48 0x61    
   \              0x72 0x64    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "board test">`:
   \   00000000   0x62 0x6F          DC8 "board test"
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x74 0x65    
   \              0x73 0x74    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "8529">`:
   \   00000000   0x38 0x35          DC8 "8529"
   \              0x32 0x39    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x69 0x32          DC8 "i2c"
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "initHardware() OK!">`:
   \   00000000   0x69 0x6E          DC8 "initHardware() OK!"
   \              0x69 0x74    
   \              0x48 0x61    
   \              0x72 0x64    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x28 0x29    
   \              0x20 0x4F    
   \              0x4B 0x21    
   \              0x00         
   \   00000013   0x00               DC8 0
    380          
    381          #endif /* EFI_PROD_CODE */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   adcConfigListener(Engine *)
         8   -> calcFastAdcIndexes()
      16   adc_callback_fast(ADCDriver *, uint16_t *, size_t)
        16   -> firmwareError
        16   -> getRemainingStack
        16   -> hipAdcCallback(uint16_t)
        16   -> mapAveragingCallback(uint16_t)
       8   applyNewHardwareSettings()
         8   -> applyNewTriggerInputPins()
         8   -> startIgnitionPins()
         8   -> startInjectionPins()
         8   -> stopIgnitionPins()
         8   -> stopInjectionPins()
       0   calcFastAdcIndexes()
       8   getSpiDevice(spi_device_e)
         8   -> firmwareError
      24   initHardware(Logging *)
        24   -> Engine::addConfigurationListener(void (*)(Engine *))
        24   -> _pal_lld_setgroupmode
        24   -> addConsoleActionII
        24   -> calcFastAdcIndexes()
        24   -> chMtxInit
        24   -> firmwareError
        24   -> getHwPin(brain_pin_e)
        24   -> getHwPort(brain_pin_e)
        24   -> getSpiDevice(spi_device_e)
        24   -> initAdcInputs(bool)
        24   -> initBoardTest()
        24   -> initCan()
        24   -> initDataStructures()
        24   -> initFlash(Logging *)
        24   -> initGps
        24   -> initHip9011(Logging *)
        24   -> initJoystick(Logging *)
        24   -> initMax31855(Logging *, SPIDriver *, brain_pin_e *)
        24   -> initMmcCard
        24   -> initOutputPins()
        24   -> initPrimaryPins()
        24   -> initRtc()
        24   -> initSpiModules(board_configuration_s *)
        24   -> initTriggerCentral(Logging *, Engine *)
        24   -> initTriggerDecoder()
        24   -> initTriggerDecoderLogger(Logging *)
        24   -> initVehicleSpeed(Logging *)
        24   -> initWboController()
        24   -> lcd_HD44780_init
        24   -> lcd_HD44780_print_string
        24   -> mySetPadMode2(char const *, brain_pin_e, iomode_t)
        24   -> printMsg
        24   -> readFromFlash()
        24   -> resetConfigurationExt(Logging *, engine_type_e)
        24   -> turnOnHardware(Logging *)
        24   -> writeToFlashNow()
       8   initI2Cmodule()
         8   -> i2cInit
         8   -> i2cStart
         8   -> mySetPadMode(char const *, ioportid_t, uint32_t, iomode_t)
         8   -> print
       8   initSpiModules(board_configuration_s *)
         8   -> turnOnSpi(spi_device_e)
       8   lockSpi(spi_device_e)
         8   -> chMtxLock
         8   -> firmwareError
         8   -> getRemainingStack
       0   sendI2Cbyte(int, int)
       8   turnOnHardware(Logging *)
         8   -> turnOnTriggerInputPins(Logging *)
       8   unlockSpi()
         8   -> chMtxUnlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "8529">
      12  ?<Constant "I2C clock">
      12  ?<Constant "I2C data">
      24  ?<Constant "Starting I2C module\r\n">
      28  ?<Constant "Unexpected SPI device...">
      12  ?<Constant "board test">
      20  ?<Constant "engineConfiguration">
       4  ?<Constant "i2c">
      20  ?<Constant "initHardware() OK!">
      16  ?<Constant "initHardware()">
       8  ?<Constant "lockSpi">
      12  ?<Constant "lowstck#9b">
      12  ?<Constant "lowstck12a">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_28
       4  ??DataTable5_29
       4  ??DataTable5_3
       4  ??DataTable5_30
       4  ??DataTable5_31
       4  ??DataTable5_32
       4  ??DataTable5_33
       4  ??DataTable5_34
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      10  adcConfigListener(Engine *)
     140  adc_callback_fast(ADCDriver *, uint16_t *, size_t)
      24  applyNewHardwareSettings()
     100  calcFastAdcIndexes()
       4  fastMapSampleIndex
      48  getSpiDevice(spi_device_e)
       4  hipSampleIndex
      12  i2cfg
     350  initHardware(Logging *)
      50  initI2Cmodule()
      50  initSpiModules(board_configuration_s *)
      38  lockSpi(spi_device_e)
       4  maxNesting
       2  sendI2Cbyte(int, int)
       4  sharedLogger
      16  spiMtx
       4  tpsSampleIndex
      12  turnOnHardware(Logging *)
       8  unlockSpi()

 
  36 bytes in section .bss
  12 bytes in section .data
 188 bytes in section .rodata
 972 bytes in section .text
 
 972 bytes of CODE  memory
 188 bytes of CONST memory
  48 bytes of DATA  memory

Errors: none
Warnings: 2
