###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:47 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\math #
#                       \engine_math.cpp                                      #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\math #
#                       \engine_math.cpp -lCN F:\stuff\rusefi_sourceforge\fir #
#                       mware\iar\Debug\List\ -lA                             #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\e #
#                       ngine_math.lst                                        #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\en #
#                       gine_math.o                                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\math\engine_math.cpp
      1          /**
      2           * @file	engine_math.cpp
      3           * @brief
      4           *
      5           * @date Jul 13, 2013
      6           * @author Andrey Belomutskiy, (c) 2012-2015
      7           *
      8           * This file is part of rusEfi - see http://rusefi.com
      9           *
     10           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     11           * the GNU General Public License as published by the Free Software Foundation; either
     12           * version 3 of the License, or (at your option) any later version.
     13           *
     14           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     15           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License along with this program.
     19           * If not, see <http://www.gnu.org/licenses/>.
     20           */
     21          
     22          #include "main.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     23          #include "engine_math.h"

   \                                 In section .text, align 4
   \   __code __interwork __softfp ArrayList<InjectionEvent, 45>::ArrayList()
   \                     _ZN9ArrayListI14InjectionEventLi45EEC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x232D             MOVS     R3,#+45
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x4908             LDR.N    R1,??ArrayList_0
   \   0000000A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000000E   0x.... 0x....      BL       __aeabi_vec_ctor_nocookie_nodtor
   \   00000012   0xF44F 0x52B4      MOV      R2,#+5760
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000001C   0x.... 0x....      BL       memset
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       _ZN9ArrayListI14InjectionEventLi45EE5resetEv
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   \   0000002A   0xBF00             Nop      
   \                     ??ArrayList_0:
   \   0000002C   0x........         DC32     _ZN14InjectionEventC1Ev

   \                                 In section .text, align 2
   \   __interwork __softfp void ArrayList<InjectionEvent, 45>::reset()
   \                     _ZN9ArrayListI14InjectionEventLi45EE5resetEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void ArrayList<IgnitionEvent, 80>::reset()
   \                     _ZN9ArrayListI13IgnitionEventLi80EE5resetEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp InjectionEvent *ArrayList<InjectionEvent, 45>::add()
   \                     _ZN9ArrayListI14InjectionEventLi45EE3addEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x282D             CMP      R0,#+45
   \   00000008   0xDB04             BLT.N    ??add_0
   \   0000000A   0x4806             LDR.N    R0,??add_1
   \   0000000C   0x.... 0x....      BL       firmwareError
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE006             B.N      ??add_2
   \                     ??add_0:
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x1C41             ADDS     R1,R0,#+1
   \   00000018   0x6021             STR      R1,[R4, #+0]
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000020   0x3008             ADDS     R0,R0,#+8
   \                     ??add_2:
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   \                     ??add_1:
   \   00000024   0x........         DC32     _ZZN9ArrayListI14InjectionEventLi45EE3addEvEs

   \                                 In section .text, align 4
   \   __interwork __softfp IgnitionEvent *ArrayList<IgnitionEvent, 80>::add()
   \                     _ZN9ArrayListI13IgnitionEventLi80EE3addEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2850             CMP      R0,#+80
   \   00000008   0xDB04             BLT.N    ??add_3
   \   0000000A   0x4806             LDR.N    R0,??add_4
   \   0000000C   0x.... 0x....      BL       firmwareError
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE006             B.N      ??add_5
   \                     ??add_3:
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x1C41             ADDS     R1,R0,#+1
   \   00000018   0x6021             STR      R1,[R4, #+0]
   \   0000001A   0x2160             MOVS     R1,#+96
   \   0000001C   0xFB01 0x4000      MLA      R0,R1,R0,R4
   \   00000020   0x3008             ADDS     R0,R0,#+8
   \                     ??add_5:
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   \                     ??add_4:
   \   00000024   0x........         DC32     _ZZN9ArrayListI13IgnitionEventLi80EE3addEvEs
     24          #include "engine_configuration.h"
     25          #include "interpolation.h"
     26          #include "allsensors.h"
     27          #include "io_pins.h"
     28          #include "trigger_decoder.h"
     29          #include "event_registry.h"
     30          #include "efiGpio.h"
     31          #include "fuel_math.h"
     32          
     33          EXTERN_ENGINE
     34          ;
     35          
     36          extern engine_pins_s enginePins;
     37          
     38          /**
     39           * @return number of milliseconds in one crankshaft revolution
     40           */

   \                                 In section .text, align 4, keep-with-next
     41          float getCrankshaftRevolutionTimeMs(int rpm) {
   \                     _Z29getCrankshaftRevolutionTimeMsi:
   \   00000000   0xEE00 0x0A10      VMOV     S0,R0
     42          	return 360 * getOneDegreeTimeMs(rpm);
   \   00000004   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000008   0xEDDF 0x....      VLDR.W   S1,??DataTable4  ;; 0x4326aaab
   \   0000000C   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable4_1  ;; 0x43b40000
   \   00000014   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000018   0x4770             BX       LR               ;; return
     43          }
     44          
     45          /**
     46           * @brief Returns engine load according to selected engine_load_mode
     47           *
     48           */

   \                                 In section .text, align 4, keep-with-next
     49          float getEngineLoadT(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z14getEngineLoadTv:
   \   00000000   0xB580             PUSH     {R7,LR}
     50          	efiAssert(engine!=NULL, "engine 2NULL", NAN);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD106             BNE.N    ??getEngineLoadT_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000010   0x.... 0x....      BL       firmwareError
   \   00000014   0xED9F 0x....      VLDR.W   S0,??DataTable4_2  ;; 0x7fffffff
   \   00000018   0xE054             B.N      ??getEngineLoadT_1
     51          	efiAssert(engineConfiguration!=NULL, "engineConfiguration 2NULL", NAN);
   \                     ??getEngineLoadT_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD106             BNE.N    ??getEngineLoadT_2
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000028   0x.... 0x....      BL       firmwareError
   \   0000002C   0xED9F 0x....      VLDR.W   S0,??DataTable4_2  ;; 0x7fffffff
   \   00000030   0xE048             B.N      ??getEngineLoadT_1
     52          	switch (engineConfiguration->algorithm) {
   \                     ??getEngineLoadT_2:
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF8D0 0x01A8      LDR      R0,[R0, #+424]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD006             BEQ.N    ??getEngineLoadT_3
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xD029             BEQ.N    ??getEngineLoadT_4
   \   00000044   0xD32B             BCC.N    ??getEngineLoadT_5
   \   00000046   0x2804             CMP      R0,#+4
   \   00000048   0xD02C             BEQ.N    ??getEngineLoadT_6
   \   0000004A   0xD325             BCC.N    ??getEngineLoadT_4
   \   0000004C   0xE02D             B.N      ??getEngineLoadT_7
     53          	case LM_PLAIN_MAF:
     54          		if (!hasMafSensor(PASS_ENGINE_PARAMETER_F)) {
   \                     ??getEngineLoadT_3:
   \   0000004E   0x.... 0x....      BL       _Z12hasMafSensorv
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD108             BNE.N    ??getEngineLoadT_8
     55          			warning(OBD_PCM_Processor_Fault, "MAF sensor needed for current fuel algorithm");
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000005A   0xF240 0x205E      MOVW     R0,#+606
   \   0000005E   0x.... 0x....      BL       warning
     56          			return NAN;
   \   00000062   0xED9F 0x....      VLDR.W   S0,??DataTable4_2  ;; 0x7fffffff
   \   00000066   0xE02D             B.N      ??getEngineLoadT_1
     57          		}
     58          		return getMafT(engineConfiguration);
   \                     ??getEngineLoadT_8:
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF8D0 0x1244      LDR      R1,[R0, #+580]
   \   00000072   0x....             ADR.N    R0,??DataTable4_3  ;; "maf"
   \   00000074   0x.... 0x....      BL       _Z19getInternalAdcValuePKc13adc_channel_e
   \   00000078   0xEE00 0x0A10      VMOV     S0,R0
   \   0000007C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000080   0xEDDF 0x....      VLDR.W   S1,??DataTable4_4  ;; 0x3a400c01
   \   00000084   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xEDD0 0x0A74      VLDR     S1,[R0, #+464]
   \   00000092   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000096   0xE015             B.N      ??getEngineLoadT_1
     59          	case LM_SPEED_DENSITY:
     60          		// SD engine load is used for timing lookup but not for fuel calculation
     61          	case LM_MAP:
     62          		return getMap();
   \                     ??getEngineLoadT_4:
   \   00000098   0x.... 0x....      BL       _Z6getMapv
   \   0000009C   0xE012             B.N      ??getEngineLoadT_1
     63          	case LM_ALPHA_N:
     64          		return getTPS(PASS_ENGINE_PARAMETER_F);
   \                     ??getEngineLoadT_5:
   \   0000009E   0x.... 0x....      BL       _Z6getTPSv
   \   000000A2   0xE00F             B.N      ??getEngineLoadT_1
     65          	case LM_REAL_MAF: {
     66          		return getRealMaf(PASS_ENGINE_PARAMETER_F);
   \                     ??getEngineLoadT_6:
   \   000000A4   0x.... 0x....      BL       _Z10getRealMafv
   \   000000A8   0xE00C             B.N      ??getEngineLoadT_1
     67          	}
     68          	default:
     69          		warning(OBD_PCM_Processor_Fault, "Unexpected engine load parameter: %d", engineConfiguration->algorithm);
   \                     ??getEngineLoadT_7:
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF8D0 0x21A8      LDR      R2,[R0, #+424]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   000000B8   0xF240 0x205E      MOVW     R0,#+606
   \   000000BC   0x.... 0x....      BL       warning
     70          		return -1;
   \   000000C0   0xEEBF 0x0A00      VMOV.F32 S0,#-1.0
   \                     ??getEngineLoadT_1:
   \   000000C4   0xBD01             POP      {R0,PC}          ;; return
     71          	}
     72          }
     73          

   \                                 In section .text, align 2, keep-with-next
     74          void setSingleCoilDwell(engine_configuration_s *engineConfiguration) {
     75          	for (int i = 0; i < DWELL_CURVE_SIZE; i++) {
   \                     _Z18setSingleCoilDwellP22engine_configuration_s:
   \   00000000   0x2100             MOVS     R1,#+0
   \                     ??setSingleCoilDwell_0:
   \   00000002   0x2908             CMP      R1,#+8
   \   00000004   0xDA11             BGE.N    ??setSingleCoilDwell_1
     76          		engineConfiguration->sparkDwellBins[i] = -10 + i;
   \   00000006   0xF1B1 0x020A      SUBS     R2,R1,#+10
   \   0000000A   0xEE00 0x2A10      VMOV     S0,R2
   \   0000000E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000012   0xEB10 0x0281      ADDS     R2,R0,R1, LSL #+2
   \   00000016   0xED82 0x0A54      VSTR     S0,[R2, #+336]
     77          		engineConfiguration->sparkDwell[i] = -1;
   \   0000001A   0xEB10 0x0281      ADDS     R2,R0,R1, LSL #+2
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable16_9  ;; 0xbf800000
   \   00000022   0xF8C2 0x3170      STR      R3,[R2, #+368]
     78          	}
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0xE7EB             B.N      ??setSingleCoilDwell_0
     79          
     80          	engineConfiguration->sparkDwellBins[5] = 1;
   \                     ??setSingleCoilDwell_1:
   \   0000002A   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   0000002E   0xF8C0 0x1164      STR      R1,[R0, #+356]
     81          	engineConfiguration->sparkDwell[5] = 4;
   \   00000032   0xF05F 0x4181      MOVS     R1,#+1082130432
   \   00000036   0xF8C0 0x1184      STR      R1,[R0, #+388]
     82          
     83          	engineConfiguration->sparkDwellBins[6] = 4500;
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable16_10  ;; 0x458ca000
   \   0000003E   0xF8C0 0x1168      STR      R1,[R0, #+360]
     84          	engineConfiguration->sparkDwell[6] = 4;
   \   00000042   0xF05F 0x4181      MOVS     R1,#+1082130432
   \   00000046   0xF8C0 0x1188      STR      R1,[R0, #+392]
     85          
     86          	engineConfiguration->sparkDwellBins[7] = 12500;
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable16_11  ;; 0x46435000
   \   0000004E   0xF8C0 0x116C      STR      R1,[R0, #+364]
     87          	engineConfiguration->sparkDwell[7] = 0;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF8C0 0x118C      STR      R1,[R0, #+396]
     88          }
   \   00000058   0x4770             BX       LR               ;; return
     89          
     90          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
     91          

   \                                 In section .text, align 2, keep-with-next
     92          void initializeIgnitionActions(angle_t advance, angle_t dwellAngle,
     93          		IgnitionEventList *list DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z25initializeIgnitionActionsffP9ArrayListI13IgnitionEventLi80EE:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   0000000A   0xEEB0 0x8A60      VMOV.F32 S16,S1
   \   0000000E   0x0004             MOVS     R4,R0
     94          	efiAssertVoid(engineConfiguration->specs.cylindersCount > 0, "cylindersCount");
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF8D0 0x0194      LDR      R0,[R0, #+404]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xDA04             BGE.N    ??initializeIgnitionActions_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   00000022   0x.... 0x....      BL       firmwareError
   \   00000026   0xE034             B.N      ??initializeIgnitionActions_1
     95          
     96          	list->reset();
   \                     ??initializeIgnitionActions_0:
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN9ArrayListI13IgnitionEventLi80EE5resetEv
     97          
     98          	for (int i = 0; i < CONFIG(specs.cylindersCount); i++) {
   \   0000002E   0x2500             MOVS     R5,#+0
   \                     ??initializeIgnitionActions_2:
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000034   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xDA2A             BGE.N    ??initializeIgnitionActions_3
     99          		angle_t localAdvance = advance + ENGINE(angleExtra[i]);
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \   00000040   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   00000044   0xF500 0x50E8      ADD      R0,R0,#+7424
   \   00000048   0x30F0             ADDS     R0,R0,#+240
   \   0000004A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000004E   0xEE38 0x9A80      VADD.F32 S18,S17,S0
    100          		NamedOutputPin *output = ENGINE(ignitionPin[i]);
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \   00000056   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   0000005A   0xF510 0x50F1      ADDS     R0,R0,#+7712
   \   0000005E   0x6806             LDR      R6,[R0, #+0]
    101          
    102          		IgnitionEvent *event = list->add();
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       _ZN9ArrayListI13IgnitionEventLi80EE3addEv
   \   00000066   0x0007             MOVS     R7,R0
    103          
    104          		if (!isPinAssigned(output)) {
   \   00000068   0x6830             LDR      R0,[R6, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD106             BNE.N    ??initializeIgnitionActions_4
    105          			// todo: extact method for this index math
    106          			warning(OBD_PCM_Processor_Fault, "no_pin_cl #%s", output->name);
   \   0000006E   0x6932             LDR      R2,[R6, #+16]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable16_15
   \   00000074   0xF240 0x205E      MOVW     R0,#+606
   \   00000078   0x.... 0x....      BL       warning
    107          		}
    108          		event->output = output;
   \                     ??initializeIgnitionActions_4:
   \   0000007C   0x603E             STR      R6,[R7, #+0]
    109          		event->advance = localAdvance;
   \   0000007E   0xED87 0x9A0E      VSTR     S18,[R7, #+56]
    110          
    111          		findTriggerPosition(&event->dwellPosition, localAdvance - dwellAngle PASS_ENGINE_PARAMETER);
   \   00000082   0xEE39 0x0A48      VSUB.F32 S0,S18,S16
   \   00000086   0xF117 0x003C      ADDS     R0,R7,#+60
   \   0000008A   0x.... 0x....      BL       _Z19findTriggerPositionP24event_trigger_position_sf
    112          	}
   \   0000008E   0x1C6D             ADDS     R5,R5,#+1
   \   00000090   0xE7CE             B.N      ??initializeIgnitionActions_2
    113          }
   \                     ??initializeIgnitionActions_3:
   \                     ??initializeIgnitionActions_1:
   \   00000092   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000096   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    114          

   \                                 In section .text, align 2, keep-with-next
    115          void FuelSchedule::registerInjectionEvent(NamedOutputPin *output, float angle,
    116          		bool_t isSimultanious DECLARE_ENGINE_PARAMETER_S) {
   \                     _ZN12FuelSchedule22registerInjectionEventEP14NamedOutputPinfb:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000E   0x0016             MOVS     R6,R2
    117          	if (!isSimultanious && !isPinAssigned(output)) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD109             BNE.N    ??registerInjectionEvent_0
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD106             BNE.N    ??registerInjectionEvent_0
    118          		// todo: extact method for this index math
    119          		warning(OBD_PCM_Processor_Fault, "no_pin_inj #%s", output->name);
   \   0000001C   0x692A             LDR      R2,[R5, #+16]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_16
   \   00000022   0xF240 0x205E      MOVW     R0,#+606
   \   00000026   0x.... 0x....      BL       warning
    120          	}
    121          
    122          	InjectionEvent *ev = events.add();
   \                     ??registerInjectionEvent_0:
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN9ArrayListI14InjectionEventLi45EE3addEv
   \   00000030   0x0007             MOVS     R7,R0
    123          	if (ev == NULL) {
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD026             BEQ.N    ??registerInjectionEvent_1
    124          		// error already reported
    125          		return;
    126          	}
    127          
    128          	ev->actuator.output = output;
   \                     ??registerInjectionEvent_2:
   \   00000036   0x613D             STR      R5,[R7, #+16]
    129          
    130          	ev->isSimultanious = isSimultanious;
   \   00000038   0xF887 0x6078      STRB     R6,[R7, #+120]
    131          
    132          	efiAssertVoid(TRIGGER_SHAPE(getSize()) > 0, "uninitialized TriggerShape");
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_17
   \   00000040   0x.... 0x....      BL       _ZNK12TriggerShape7getSizeEv
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xDA04             BGE.N    ??registerInjectionEvent_3
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_18
   \   0000004C   0x.... 0x....      BL       firmwareError
   \   00000050   0xE018             B.N      ??registerInjectionEvent_1
    133          
    134          	findTriggerPosition(&ev->injectionStart, angle PASS_ENGINE_PARAMETER);
   \                     ??registerInjectionEvent_3:
   \   00000052   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       _Z19findTriggerPositionP24event_trigger_position_sf
    135          	if (!hasEvents[ev->injectionStart.eventIndex]) {
   \   0000005C   0xF241 0x6088      MOVW     R0,#+5768
   \   00000060   0x6839             LDR      R1,[R7, #+0]
   \   00000062   0x1909             ADDS     R1,R1,R4
   \   00000064   0x5C40             LDRB     R0,[R0, R1]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD10C             BNE.N    ??registerInjectionEvent_4
    136          		hasEvents[ev->injectionStart.eventIndex] = true;
   \   0000006A   0xF241 0x6088      MOVW     R0,#+5768
   \   0000006E   0x6839             LDR      R1,[R7, #+0]
   \   00000070   0x1909             ADDS     R1,R1,R4
   \   00000072   0x2201             MOVS     R2,#+1
   \   00000074   0x5442             STRB     R2,[R0, R1]
    137          		eventsCount++;
   \   00000076   0xF241 0x7084      MOVW     R0,#+6020
   \   0000007A   0x5900             LDR      R0,[R0, R4]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0xF241 0x7184      MOVW     R1,#+6020
   \   00000082   0x5108             STR      R0,[R1, R4]
    138          	}
    139          }
   \                     ??registerInjectionEvent_4:
   \                     ??registerInjectionEvent_1:
   \   00000084   0xECBD 0x8B02      VPOP     {D8}
   \   00000088   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    140          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp FuelSchedule::subobject FuelSchedule()
   \                     _ZN12FuelScheduleC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN12FuelScheduleC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    141          FuelSchedule::FuelSchedule() {
   \                     _ZN12FuelScheduleC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9ArrayListI14InjectionEventLi45EEC1Ev
    142          	clear();
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN12FuelSchedule5clearEv
    143          }
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void FuelSchedule::clear() {
   \                     _ZN12FuelSchedule5clearEv:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    146          	memset(hasEvents, 0, sizeof(hasEvents));
   \   00000004   0x22FC             MOVS     R2,#+252
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF504 0x50B0      ADD      R0,R4,#+5632
   \   0000000C   0x3088             ADDS     R0,R0,#+136
   \   0000000E   0x.... 0x....      BL       memset
    147          	eventsCount = 0;
   \   00000012   0xF241 0x7084      MOVW     R0,#+6020
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x5101             STR      R1,[R0, R4]
    148          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    149          

   \                                 In section .text, align 4, keep-with-next
    150          void FuelSchedule::addFuelEvents(injection_mode_e mode DECLARE_ENGINE_PARAMETER_S) {
   \                     _ZN12FuelSchedule13addFuelEventsE16injection_mode_e:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    151          	clear(); // this method is relatively heavy
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN12FuelSchedule5clearEv
    152          //	sourceList->reset();
    153          
    154          	events.reset();
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       _ZN9ArrayListI14InjectionEventLi45EE5resetEv
    155          
    156          	efiAssertVoid(engine!=NULL, "engine is NULL");
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD104             BNE.N    ??addFuelEvents_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_19
   \   00000024   0x.... 0x....      BL       firmwareError
   \   00000028   0xE0F3             B.N      ??addFuelEvents_1
    157          
    158          	if (cisnan(engine->rpmCalculator.oneDegreeUs))
   \                     ??addFuelEvents_0:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000034   0x.... 0x....      BL       __iar_FDtest
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xF000 0x80EA      BEQ.W    ??addFuelEvents_1
    159          		return;
    160          
    161          	efiAssertVoid(!cisnan(engine->rpmCalculator.oneDegreeUs), "NAN one deg");
   \                     ??addFuelEvents_2:
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   00000048   0x.... 0x....      BL       __iar_FDtest
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD104             BNE.N    ??addFuelEvents_3
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable16_20
   \   00000054   0x.... 0x....      BL       firmwareError
   \   00000058   0xE0DB             B.N      ??addFuelEvents_1
    162          
    163          	/**
    164          	 * injection phase is scheduled by injection end, so we need to step the angle back
    165          	 * for the duration of the injection
    166          	 */
    167          	float baseAngle = ENGINE(engineState.injectionOffset)
    168          			+ CONFIG(injectionOffset) - MS2US(ENGINE(fuelMs)) / ENGINE(rpmCalculator.oneDegreeUs);
   \                     ??addFuelEvents_3:
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable16_21
   \   0000005E   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000066   0xEDD0 0x0A6F      VLDR     S1,[R0, #+444]
   \   0000006A   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \   00000072   0xEDD0 0x0A98      VLDR     S1,[R0, #+608]
   \   00000076   0xED9F 0x....      VLDR.W   S2,??DataTable7  ;; 0x447a0000
   \   0000007A   0xEE60 0x0A81      VMUL.F32 S1,S1,S2
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \   00000082   0xED90 0x1A02      VLDR     S2,[R0, #+8]
   \   00000086   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   0000008A   0xEE30 0x8A60      VSUB.F32 S16,S0,S1
    169          
    170          	switch (mode) {
   \   0000008E   0x2D00             CMP      R5,#+0
   \   00000090   0xD039             BEQ.N    ??addFuelEvents_4
   \   00000092   0x2D02             CMP      R5,#+2
   \   00000094   0xD05E             BEQ.N    ??addFuelEvents_5
   \   00000096   0xF080 0x80B5      BCS.W    ??addFuelEvents_6
    171          	case IM_SEQUENTIAL:
    172          		for (int i = 0; i < CONFIG(specs.cylindersCount); i++) {
   \                     ??addFuelEvents_7:
   \   0000009A   0x2600             MOVS     R6,#+0
   \                     ??addFuelEvents_8:
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   000000A0   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   000000A4   0x4286             CMP      R6,R0
   \   000000A6   0xDA2D             BGE.N    ??addFuelEvents_9
    173          			int index = getCylinderId(engineConfiguration->specs.firingOrder, i) - 1;
   \   000000A8   0x0031             MOVS     R1,R6
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF8D0 0x0198      LDR      R0,[R0, #+408]
   \   000000B4   0x.... 0x....      BL       _Z13getCylinderId14firing_order_ei
   \   000000B8   0x1E47             SUBS     R7,R0,#+1
    174          			float angle = baseAngle
    175          					+ (float) CONFIG(engineCycle) * i / CONFIG(specs.cylindersCount);
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   000000BE   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   000000C2   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000C6   0xEE00 0x6A90      VMOV     S1,R6
   \   000000CA   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000CE   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   000000D6   0xEDD0 0x0A67      VLDR     S1,[R0, #+412]
   \   000000DA   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000DE   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000E2   0xEE70 0x8A08      VADD.F32 S17,S0,S16
    176          			registerInjectionEvent(&enginePins.injectors[index], angle, false PASS_ENGINE_PARAMETER);
   \   000000E6   0x2200             MOVS     R2,#+0
   \   000000E8   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000000EC   0x2014             MOVS     R0,#+20
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   000000F2   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000F6   0xF110 0x0160      ADDS     R1,R0,#+96
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       _ZN12FuelSchedule22registerInjectionEventEP14NamedOutputPinfb
    177          		}
   \   00000100   0x1C76             ADDS     R6,R6,#+1
   \   00000102   0xE7CB             B.N      ??addFuelEvents_8
    178          		break;
   \                     ??addFuelEvents_9:
   \   00000104   0xE085             B.N      ??addFuelEvents_10
    179          	case IM_SIMULTANEOUS:
    180          		for (int i = 0; i < CONFIG(specs.cylindersCount); i++) {
   \                     ??addFuelEvents_4:
   \   00000106   0x2600             MOVS     R6,#+0
   \                     ??addFuelEvents_11:
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000010C   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   00000110   0x4286             CMP      R6,R0
   \   00000112   0xDA1E             BGE.N    ??addFuelEvents_12
    181          			float angle = baseAngle
    182          					+ (float) CONFIG(engineCycle) * i / CONFIG(specs.cylindersCount);
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000118   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   0000011C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000120   0xEE00 0x6A90      VMOV     S1,R6
   \   00000124   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000128   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000130   0xEDD0 0x0A67      VLDR     S1,[R0, #+412]
   \   00000134   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000138   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000013C   0xEE70 0x8A08      VADD.F32 S17,S0,S16
    183          
    184          			/**
    185          			 * We do not need injector pin here because we will control all injectors
    186          			 * simultaneously
    187          			 */
    188          			registerInjectionEvent(NULL, angle, true PASS_ENGINE_PARAMETER);
   \   00000140   0x2201             MOVS     R2,#+1
   \   00000142   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000146   0x2100             MOVS     R1,#+0
   \   00000148   0x0020             MOVS     R0,R4
   \   0000014A   0x.... 0x....      BL       _ZN12FuelSchedule22registerInjectionEventEP14NamedOutputPinfb
    189          		}
   \   0000014E   0x1C76             ADDS     R6,R6,#+1
   \   00000150   0xE7DA             B.N      ??addFuelEvents_11
    190          		break;
   \                     ??addFuelEvents_12:
   \   00000152   0xE05E             B.N      ??addFuelEvents_10
    191          	case IM_BATCH:
    192          		for (int i = 0; i < CONFIG(specs.cylindersCount); i++) {
   \                     ??addFuelEvents_5:
   \   00000154   0x2600             MOVS     R6,#+0
   \                     ??addFuelEvents_13:
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000015A   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   0000015E   0x4286             CMP      R6,R0
   \   00000160   0xDA4F             BGE.N    ??addFuelEvents_14
    193          			int index = i % (engineConfiguration->specs.cylindersCount / 2);
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0xF8D0 0x0194      LDR      R0,[R0, #+404]
   \   0000016C   0x2102             MOVS     R1,#+2
   \   0000016E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000172   0xFB96 0xF1F0      SDIV     R1,R6,R0
   \   00000176   0xFB00 0x6711      MLS      R7,R0,R1,R6
    194          			float angle = baseAngle
    195          					+ i * (float) CONFIG(engineCycle) / CONFIG(specs.cylindersCount);
   \   0000017A   0xEE00 0x6A10      VMOV     S0,R6
   \   0000017E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000186   0xEDD0 0x0A6A      VLDR     S1,[R0, #+424]
   \   0000018A   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000018E   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000196   0xEDD0 0x0A67      VLDR     S1,[R0, #+412]
   \   0000019A   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000019E   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000001A2   0xEE70 0x8A08      VADD.F32 S17,S0,S16
    196          			registerInjectionEvent(&enginePins.injectors[index], angle, false PASS_ENGINE_PARAMETER);
   \   000001A6   0x2200             MOVS     R2,#+0
   \   000001A8   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001AC   0x2014             MOVS     R0,#+20
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   000001B2   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000001B6   0xF110 0x0160      ADDS     R1,R0,#+96
   \   000001BA   0x0020             MOVS     R0,R4
   \   000001BC   0x.... 0x....      BL       _ZN12FuelSchedule22registerInjectionEventEP14NamedOutputPinfb
    197          
    198          			if (CONFIG(twoWireBatch)) {
   \   000001C0   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   000001C4   0xF890 0x05ED      LDRB     R0,[R0, #+1517]
   \   000001C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CA   0x0940             LSRS     R0,R0,#+5
   \   000001CC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD014             BEQ.N    ??addFuelEvents_15
    199          
    200          				/**
    201          				 * also fire the 2nd half of the injectors so that we can implement a batch mode on individual wires
    202          				 */
    203          				index = index + (CONFIG(specs.cylindersCount) / 2);
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   000001D8   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   000001DC   0x2102             MOVS     R1,#+2
   \   000001DE   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001E2   0x19C7             ADDS     R7,R0,R7
    204          				registerInjectionEvent(&enginePins.injectors[index], angle, false PASS_ENGINE_PARAMETER);
   \   000001E4   0x2200             MOVS     R2,#+0
   \   000001E6   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   000001EA   0x2014             MOVS     R0,#+20
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable16_22
   \   000001F0   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000001F4   0xF110 0x0160      ADDS     R1,R0,#+96
   \   000001F8   0x0020             MOVS     R0,R4
   \   000001FA   0x.... 0x....      BL       _ZN12FuelSchedule22registerInjectionEventEP14NamedOutputPinfb
    205          			}
    206          		}
   \                     ??addFuelEvents_15:
   \   000001FE   0x1C76             ADDS     R6,R6,#+1
   \   00000200   0xE7A9             B.N      ??addFuelEvents_13
    207          		break;
   \                     ??addFuelEvents_14:
   \   00000202   0xE006             B.N      ??addFuelEvents_10
    208          	default:
    209          		warning(OBD_PCM_Processor_Fault, "Unexpected injection mode %d", mode);
   \                     ??addFuelEvents_6:
   \   00000204   0x002A             MOVS     R2,R5
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable16_23
   \   0000020A   0xF240 0x205E      MOVW     R0,#+606
   \   0000020E   0x.... 0x....      BL       warning
    210          	}
    211          }
   \                     ??addFuelEvents_10:
   \                     ??addFuelEvents_1:
   \   00000212   0xECBD 0x8B02      VPOP     {D8}
   \   00000216   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    212          
    213          #endif
    214          
    215          /**
    216           * @return Spark dwell time, in milliseconds.
    217           */

   \                                 In section .text, align 4, keep-with-next
    218          float getSparkDwellMsT(int rpm DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z16getSparkDwellMsTi:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    219          	if (isCrankingR(rpm)) {
   \   00000004   0x2C01             CMP      R4,#+1
   \   00000006   0xDB26             BLT.N    ??getSparkDwellMsT_0
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000000C   0xF9B0 0x0068      LDRSH    R0,[R0, #+104]
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xDA20             BGE.N    ??getSparkDwellMsT_0
    220          		if (engineConfiguration->useConstantDwellDuringCranking) {
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF890 0x05D8      LDRB     R0,[R0, #+1496]
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x0900             LSRS     R0,R0,#+4
   \   00000022   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD005             BEQ.N    ??getSparkDwellMsT_1
    221          			return engineConfiguration->ignitionDwellForCrankingMs;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xED90 0x0A1A      VLDR     S0,[R0, #+104]
   \   00000034   0xE030             B.N      ??getSparkDwellMsT_2
    222          		} else {
    223          			// technically this could be implemented via interpolate2d
    224          			float angle = engineConfiguration->crankingChargeAngle;
   \                     ??getSparkDwellMsT_1:
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xED90 0x0A1B      VLDR     S0,[R0, #+108]
    225          			return getOneDegreeTimeMs(rpm) * angle;
   \   00000040   0xEE00 0x4A90      VMOV     S1,R4
   \   00000044   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000048   0xED9F 0x....      VLDR.W   S2,??DataTable10  ;; 0x4326aaab
   \   0000004C   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \   00000050   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000054   0xE020             B.N      ??getSparkDwellMsT_2
    226          		}
    227          	}
    228          	efiAssert(!cisnan(rpm), "invalid rpm", NAN);
   \                     ??getSparkDwellMsT_0:
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       __aeabi_i2d
   \   0000005C   0xEC41 0x0B10      VMOV     D0,R0,R1
   \   00000060   0x.... 0x....      BL       __iar_Dtest
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD106             BNE.N    ??getSparkDwellMsT_3
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_24
   \   0000006C   0x.... 0x....      BL       firmwareError
   \   00000070   0xED9F 0x....      VLDR.W   S0,??DataTable10_1  ;; 0x7fffffff
   \   00000074   0xE010             B.N      ??getSparkDwellMsT_2
    229          
    230          	return interpolate2d(rpm, engineConfiguration->sparkDwellBins, engineConfiguration->sparkDwell, DWELL_CURVE_SIZE);
   \                     ??getSparkDwellMsT_3:
   \   00000076   0x2208             MOVS     R2,#+8
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF510 0x71B8      ADDS     R1,R0,#+368
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF510 0x70A8      ADDS     R0,R0,#+336
   \   0000008C   0xEE00 0x4A10      VMOV     S0,R4
   \   00000090   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000094   0x.... 0x....      BL       _Z13interpolate2dfPfS_i
   \                     ??getSparkDwellMsT_2:
   \   00000098   0xBD10             POP      {R4,PC}          ;; return
    231          }
    232          

   \                                 In section .text, align 2, keep-with-next
    233          static int findAngleIndex(float angleOffset DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z14findAngleIndexf:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
    234          	/**
    235          	 * Here we rely on this to be pre-calculated, that's a performance optimization
    236          	 */
    237          	int engineCycleEventCount = engine->engineCycleEventCount;
   \   0000000A   0xF641 0x60FC      MOVW     R0,#+7932
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x5844             LDR      R4,[R0, R1]
    238          
    239          	efiAssert(engineCycleEventCount > 0, "engineCycleEventCount", 0);
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xDA05             BGE.N    ??findAngleIndex_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_25
   \   0000001E   0x.... 0x....      BL       firmwareError
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE01C             B.N      ??findAngleIndex_1
    240          
    241          	uint32_t middle;
    242          	uint32_t left = 0;
   \                     ??findAngleIndex_0:
   \   00000026   0x2100             MOVS     R1,#+0
    243          	uint32_t right = engineCycleEventCount - 1;
   \   00000028   0x1E62             SUBS     R2,R4,#+1
    244          
    245          	/**
    246          	 * Let's find the last trigger angle which is less or equal to the desired angle
    247          	 * todo: extract binary search as template method?
    248          	 */
    249          	while (true) {
    250          		middle = (left + right) / 2;
   \                     ??findAngleIndex_2:
   \   0000002A   0x1853             ADDS     R3,R2,R1
   \   0000002C   0x085B             LSRS     R3,R3,#+1
   \   0000002E   0x0018             MOVS     R0,R3
    251          		float eventAngle = TRIGGER_SHAPE(eventAngles[middle]);
   \   00000030   0x.... 0x....      LDR.W    R3,??DataTable16_14
   \   00000034   0xEB13 0x0380      ADDS     R3,R3,R0, LSL #+2
   \   00000038   0xF8D3 0x3E10      LDR      R3,[R3, #+3600]
   \   0000003C   0xEE00 0x3A10      VMOV     S0,R3
    252          
    253          		if (middle == left) {
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD00D             BEQ.N    ??findAngleIndex_1
    254          			return middle;
    255          		}
    256          		if (angleOffset < eventAngle) {
   \                     ??findAngleIndex_3:
   \   00000044   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000048   0xEEF1 0xFA10      FMSTAT   
   \   0000004C   0xD501             BPL.N    ??findAngleIndex_4
    257          			right = middle;
   \   0000004E   0x0002             MOVS     R2,R0
   \   00000050   0xE7EB             B.N      ??findAngleIndex_2
    258          		} else if (angleOffset > eventAngle) {
   \                     ??findAngleIndex_4:
   \   00000052   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   00000056   0xEEF1 0xFA10      FMSTAT   
   \   0000005A   0xD501             BPL.N    ??findAngleIndex_5
    259          			left = middle;
   \   0000005C   0x0001             MOVS     R1,R0
   \   0000005E   0xE7E4             B.N      ??findAngleIndex_2
    260          		} else {
    261          			return middle;
   \                     ??findAngleIndex_5:
   \                     ??findAngleIndex_1:
   \   00000060   0xECBD 0x8B02      VPOP     {D8}
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    262          		}
    263          	}
    264          }
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void findTriggerPosition(event_trigger_position_s *position, angle_t angleOffset DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z19findTriggerPositionP24event_trigger_position_sf:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
    267          	angleOffset += tdcPosition();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_26
   \   00000012   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000001A   0xEDD0 0x0A75      VLDR     S1,[R0, #+468]
   \   0000001E   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000022   0xEE30 0x8A08      VADD.F32 S16,S0,S16
    268          	fixAngle(angleOffset);
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000002A   0xF8D0 0x01A8      LDR      R0,[R0, #+424]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD103             BNE.N    ??findTriggerPosition_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_27
   \   00000036   0x.... 0x....      BL       firmwareError
   \                     ??findTriggerPosition_0:
   \   0000003A   0xEEB5 0x8A40      VCMP.F32 S16,#0.0
   \   0000003E   0xEEF1 0xFA10      FMSTAT   
   \   00000042   0xD508             BPL.N    ??findTriggerPosition_1
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000048   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   0000004C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000050   0xEE30 0x8A08      VADD.F32 S16,S0,S16
   \   00000054   0xE7F1             B.N      ??findTriggerPosition_0
   \                     ??findTriggerPosition_1:
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000005A   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   0000005E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000062   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000066   0xEEF1 0xFA10      FMSTAT   
   \   0000006A   0xDB08             BLT.N    ??findTriggerPosition_2
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000070   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   00000074   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000078   0xEE38 0x8A40      VSUB.F32 S16,S16,S0
   \   0000007C   0xE7EB             B.N      ??findTriggerPosition_1
    269          
    270          	int index = TRIGGER_SHAPE(triggerIndexByAngle[(int)angleOffset]);
   \                     ??findTriggerPosition_2:
   \   0000007E   0xEEBD 0x0AC8      VCVT.S32.F32 S0,S16
   \   00000082   0xEE10 0x0A10      VMOV     R0,S0
   \   00000086   0x....             LDR.N    R1,??DataTable16_14
   \   00000088   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   0000008C   0xF8D0 0x529C      LDR      R5,[R0, #+668]
    271          	angle_t eventAngle = TRIGGER_SHAPE(eventAngles[index]);
   \   00000090   0x....             LDR.N    R0,??DataTable16_14
   \   00000092   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   00000096   0xF8D0 0x0E10      LDR      R0,[R0, #+3600]
   \   0000009A   0xEE08 0x0A90      VMOV     S17,R0
    272          	if (angleOffset < eventAngle) {
   \   0000009E   0xEEB4 0x8A68      VCMP.F32 S16,S17
   \   000000A2   0xEEF1 0xFA10      FMSTAT   
   \   000000A6   0xD511             BPL.N    ??findTriggerPosition_3
    273          		warning(OBD_PCM_Processor_Fault, "angle constraint violation in findTriggerPosition(): %f/%f", angleOffset, eventAngle);
   \   000000A8   0xEE18 0x0A90      VMOV     R0,S17
   \   000000AC   0x.... 0x....      BL       __aeabi_f2d
   \   000000B0   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000000B4   0xEE18 0x0A10      VMOV     R0,S16
   \   000000B8   0x.... 0x....      BL       __aeabi_f2d
   \   000000BC   0x0002             MOVS     R2,R0
   \   000000BE   0x000B             MOVS     R3,R1
   \   000000C0   0x....             LDR.N    R1,??DataTable16_28
   \   000000C2   0xF240 0x205E      MOVW     R0,#+606
   \   000000C6   0x.... 0x....      BL       warning
    274          		return;
   \   000000CA   0xE006             B.N      ??findTriggerPosition_4
    275          	}
    276          
    277          	position->eventIndex = index;
   \                     ??findTriggerPosition_3:
   \   000000CC   0x6025             STR      R5,[R4, #+0]
    278          	position->eventAngle = eventAngle;
   \   000000CE   0xEDC4 0x8A01      VSTR     S17,[R4, #+4]
    279          	position->angleOffset = angleOffset - eventAngle;
   \   000000D2   0xEE38 0x0A68      VSUB.F32 S0,S16,S17
   \   000000D6   0xED84 0x0A02      VSTR     S0,[R4, #+8]
    280          }
   \                     ??findTriggerPosition_4:
   \   000000DA   0xB002             ADD      SP,SP,#+8
   \   000000DC   0xECBD 0x8B02      VPOP     {D8}
   \   000000E0   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    281          

   \                                 In section .data, align 4
    282          static int order_1_THEN_3_THEN_4_THEN2[] = { 1, 3, 4, 2 };
   \                     order_1_THEN_3_THEN_4_THEN2:
   \   00000000   0x00000001         DC32 1, 3, 4, 2
   \              0x00000003   
   \              0x00000004   
   \              0x00000002   

   \                                 In section .data, align 4
    283          static int order_1_THEN_2_THEN_4_THEN3[] = { 1, 2, 4, 3 };
   \                     order_1_THEN_2_THEN_4_THEN3:
   \   00000000   0x00000001         DC32 1, 2, 4, 3
   \              0x00000002   
   \              0x00000004   
   \              0x00000003   

   \                                 In section .data, align 4
    284          static int order_1_THEN_3_THEN_2_THEN4[] = { 1, 3, 2, 4 };
   \                     order_1_THEN_3_THEN_2_THEN4:
   \   00000000   0x00000001         DC32 1, 3, 2, 4
   \              0x00000003   
   \              0x00000002   
   \              0x00000004   
    285          

   \                                 In section .data, align 4
    286          static int order_1_2_4_5_3[] = {1, 2, 4, 5, 3};
   \                     order_1_2_4_5_3:
   \   00000000   0x00000001         DC32 1, 2, 4, 5, 3
   \              0x00000002   
   \              0x00000004   
   \              0x00000005   
   \              0x00000003   
    287          

   \                                 In section .data, align 4
    288          static int order_1_THEN_5_THEN_3_THEN_6_THEN_2_THEN_4[] = { 1, 5, 3, 6, 2, 4 };
   \                     order_1_THEN_5_THEN_3_THEN_6_THEN_2_THEN_4:
   \   00000000   0x00000001         DC32 1, 5, 3, 6, 2, 4
   \              0x00000005   
   \              0x00000003   
   \              0x00000006   
   \              0x00000002   
   \              0x00000004   

   \                                 In section .data, align 4
    289          static int order_1_THEN_4_THEN_2_THEN_5_THEN_3_THEN_6[] = { 1, 4, 2, 5, 3, 6 };
   \                     order_1_THEN_4_THEN_2_THEN_5_THEN_3_THEN_6:
   \   00000000   0x00000001         DC32 1, 4, 2, 5, 3, 6
   \              0x00000004   
   \              0x00000002   
   \              0x00000005   
   \              0x00000003   
   \              0x00000006   
    290          

   \                                 In section .data, align 4
    291          static int order_1_8_4_3_6_5_7_2[] = { 1, 8, 4, 3, 6, 5, 7, 2 };
   \                     order_1_8_4_3_6_5_7_2:
   \   00000000   0x00000001         DC32 1, 8, 4, 3, 6, 5, 7, 2
   \              0x00000008   
   \              0x00000004   
   \              0x00000003   
   \              0x00000006   
   \              0x00000005   
   \              0x00000007   
   \              0x00000002   
    292          

   \                                 In section .data, align 4
    293          static int order_1_2[] = {1, 2};
   \                     order_1_2:
   \   00000000   0x00000001         DC32 1, 2
   \              0x00000002   
    294          
    295          /**
    296           * @param index from zero to cylindersCount - 1
    297           * @return cylinderId from one to cylindersCount
    298           */

   \                                 In section .text, align 2, keep-with-next
    299          int getCylinderId(firing_order_e firingOrder, int index) {
   \                     _Z13getCylinderId14firing_order_ei:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    300          
    301          	switch (firingOrder) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00C             BEQ.N    ??getCylinderId_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD014             BEQ.N    ??getCylinderId_1
   \   0000000E   0xD30F             BCC.N    ??getCylinderId_2
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD01D             BEQ.N    ??getCylinderId_3
   \   00000014   0xD314             BCC.N    ??getCylinderId_4
   \   00000016   0x2C06             CMP      R4,#+6
   \   00000018   0xD016             BEQ.N    ??getCylinderId_5
   \   0000001A   0xD321             BCC.N    ??getCylinderId_6
   \   0000001C   0x2C08             CMP      R4,#+8
   \   0000001E   0xD003             BEQ.N    ??getCylinderId_7
   \   00000020   0xD31A             BCC.N    ??getCylinderId_8
   \   00000022   0xE021             B.N      ??getCylinderId_9
    302          	case FO_ONE_CYLINDER:
    303          		return 1;
   \                     ??getCylinderId_0:
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE026             B.N      ??getCylinderId_10
    304          
    305          	case FO_1_THEN_2:
    306          		return order_1_2[index];
   \                     ??getCylinderId_7:
   \   00000028   0x....             LDR.N    R0,??DataTable16_29
   \   0000002A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000002E   0xE022             B.N      ??getCylinderId_10
    307          // 4 cylinder
    308          	case FO_1_THEN_3_THEN_4_THEN2:
    309          		return order_1_THEN_3_THEN_4_THEN2[index];
   \                     ??getCylinderId_2:
   \   00000030   0x....             LDR.N    R0,??DataTable16_30
   \   00000032   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000036   0xE01E             B.N      ??getCylinderId_10
    310          	case FO_1_THEN_2_THEN_4_THEN3:
    311          		return order_1_THEN_2_THEN_4_THEN3[index];
   \                     ??getCylinderId_1:
   \   00000038   0x....             LDR.N    R0,??DataTable16_31
   \   0000003A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000003E   0xE01A             B.N      ??getCylinderId_10
    312          	case FO_1_THEN_3_THEN_2_THEN4:
    313          		return order_1_THEN_3_THEN_2_THEN4[index];
   \                     ??getCylinderId_4:
   \   00000040   0x....             LDR.N    R0,??DataTable16_32
   \   00000042   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000046   0xE016             B.N      ??getCylinderId_10
    314          // 5 cylinder
    315          	case FO_1_2_4_5_3:
    316          		return order_1_2_4_5_3[index];
   \                     ??getCylinderId_5:
   \   00000048   0x....             LDR.N    R0,??DataTable16_33
   \   0000004A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000004E   0xE012             B.N      ??getCylinderId_10
    317          
    318          // 6 cylinder
    319          	case FO_1_THEN_5_THEN_3_THEN_6_THEN_2_THEN_4:
    320          		return order_1_THEN_5_THEN_3_THEN_6_THEN_2_THEN_4[index];
   \                     ??getCylinderId_3:
   \   00000050   0x....             LDR.N    R0,??DataTable16_34
   \   00000052   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000056   0xE00E             B.N      ??getCylinderId_10
    321          	case FO_1_THEN_4_THEN_2_THEN_5_THEN_3_THEN_6:
    322          		return order_1_THEN_4_THEN_2_THEN_5_THEN_3_THEN_6[index];
   \                     ??getCylinderId_8:
   \   00000058   0x....             LDR.N    R0,??DataTable16_35
   \   0000005A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000005E   0xE00A             B.N      ??getCylinderId_10
    323          // 8 cylinder
    324          	case FO_1_8_4_3_6_5_7_2:
    325          		return order_1_8_4_3_6_5_7_2[index];
   \                     ??getCylinderId_6:
   \   00000060   0x....             LDR.N    R0,??DataTable16_36
   \   00000062   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000066   0xE006             B.N      ??getCylinderId_10
    326          
    327          	default:
    328          		warning(OBD_PCM_Processor_Fault, "getCylinderId not supported for %d", firingOrder);
   \                     ??getCylinderId_9:
   \   00000068   0x0022             MOVS     R2,R4
   \   0000006A   0x....             LDR.N    R1,??DataTable16_37
   \   0000006C   0xF240 0x205E      MOVW     R0,#+606
   \   00000070   0x.... 0x....      BL       warning
    329          	}
    330          	return 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \                     ??getCylinderId_10:
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    331          }
    332          

   \                                 In section .text, align 2, keep-with-next
    333          static NamedOutputPin * getIgnitionPinForIndex(int i DECLARE_ENGINE_PARAMETER_S
    334          ) {
   \                     _Z22getIgnitionPinForIndexi:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    335          	switch (CONFIG(ignitionMode)) {
   \   00000004   0x....             LDR.N    R0,??DataTable16_13
   \   00000006   0xF8D0 0x01C4      LDR      R0,[R0, #+452]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??getIgnitionPinForIndex_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD003             BEQ.N    ??getIgnitionPinForIndex_1
   \   00000012   0xD319             BCC.N    ??getIgnitionPinForIndex_2
   \   00000014   0xE025             B.N      ??getIgnitionPinForIndex_3
    336          	case IM_ONE_COIL:
    337          		return &enginePins.coils[0];
   \                     ??getIgnitionPinForIndex_0:
   \   00000016   0x....             LDR.N    R0,??DataTable16_38
   \   00000018   0xE02D             B.N      ??getIgnitionPinForIndex_4
    338          		break;
    339          	case IM_WASTED_SPARK: {
    340          		int wastedIndex = i % (CONFIG(specs.cylindersCount) / 2);
   \                     ??getIgnitionPinForIndex_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable16_13
   \   0000001C   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000026   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   0000002A   0xFB00 0x4511      MLS      R5,R0,R1,R4
    341          		int id = getCylinderId(CONFIG(specs.firingOrder), wastedIndex);
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0x....             LDR.N    R0,??DataTable16_13
   \   00000032   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   00000036   0x.... 0x....      BL       _Z13getCylinderId14firing_order_ei
    342          		return &enginePins.coils[ID2INDEX(id)];
   \   0000003A   0x2114             MOVS     R1,#+20
   \   0000003C   0x....             LDR.N    R2,??DataTable16_22
   \   0000003E   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000042   0xF510 0x709E      ADDS     R0,R0,#+316
   \   00000046   0xE016             B.N      ??getIgnitionPinForIndex_4
    343          	}
    344          		break;
    345          	case IM_INDIVIDUAL_COILS:
    346          		return &enginePins.coils[ID2INDEX(getCylinderId(CONFIG(specs.firingOrder), i))];
   \                     ??getIgnitionPinForIndex_2:
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0x....             LDR.N    R0,??DataTable16_13
   \   0000004C   0xF8D0 0x01A0      LDR      R0,[R0, #+416]
   \   00000050   0x.... 0x....      BL       _Z13getCylinderId14firing_order_ei
   \   00000054   0x2114             MOVS     R1,#+20
   \   00000056   0x....             LDR.N    R2,??DataTable16_22
   \   00000058   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000005C   0xF510 0x709E      ADDS     R0,R0,#+316
   \   00000060   0xE009             B.N      ??getIgnitionPinForIndex_4
    347          		break;
    348          
    349          	default:
    350          		warning(OBD_PCM_Processor_Fault, "unsupported ignitionMode %d in initializeIgnitionActions()", engineConfiguration->ignitionMode);
   \                     ??getIgnitionPinForIndex_3:
   \   00000062   0x....             LDR.N    R0,??DataTable16_5
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF8D0 0x21BC      LDR      R2,[R0, #+444]
   \   0000006A   0x....             LDR.N    R1,??DataTable16_39
   \   0000006C   0xF240 0x205E      MOVW     R0,#+606
   \   00000070   0x.... 0x....      BL       warning
    351          		return &enginePins.coils[0];
   \   00000074   0x....             LDR.N    R0,??DataTable16_38
   \                     ??getIgnitionPinForIndex_4:
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    352          	}
    353          }
    354          
    355          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
    356          

   \                                 In section .text, align 2, keep-with-next
    357          void prepareOutputSignals(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z20prepareOutputSignalsv:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    358          
    359          	engine_configuration2_s *engineConfiguration2 = engine->engineConfiguration2;
   \   00000002   0x....             LDR.N    R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6A84             LDR      R4,[R0, #+40]
    360          
    361          	for (int i = 0; i < CONFIG(specs.cylindersCount); i++) {
   \   00000008   0x2500             MOVS     R5,#+0
   \                     ??prepareOutputSignals_0:
   \   0000000A   0x....             LDR.N    R0,??DataTable16_13
   \   0000000C   0xF8D0 0x019C      LDR      R0,[R0, #+412]
   \   00000010   0x4285             CMP      R5,R0
   \   00000012   0xDA24             BGE.N    ??prepareOutputSignals_1
    362          		ENGINE(angleExtra[i])= (float) CONFIG(engineCycle) * i / CONFIG(specs.cylindersCount);
   \   00000014   0x....             LDR.N    R0,??DataTable16_13
   \   00000016   0xED90 0x0A6A      VLDR     S0,[R0, #+424]
   \   0000001A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001E   0xEE00 0x5A90      VMOV     S1,R5
   \   00000022   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000026   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   0000002A   0x....             LDR.N    R0,??DataTable16_13
   \   0000002C   0xEDD0 0x0A67      VLDR     S1,[R0, #+412]
   \   00000030   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000034   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000038   0x....             LDR.N    R0,??DataTable16_14
   \   0000003A   0xEB10 0x0085      ADDS     R0,R0,R5, LSL #+2
   \   0000003E   0xF500 0x50E8      ADD      R0,R0,#+7424
   \   00000042   0x30F0             ADDS     R0,R0,#+240
   \   00000044   0xED80 0x0A00      VSTR     S0,[R0, #0]
    363          
    364          		ENGINE(ignitionPin[i]) = getIgnitionPinForIndex(i PASS_ENGINE_PARAMETER);
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       _Z22getIgnitionPinForIndexi
   \   0000004E   0x....             LDR.N    R1,??DataTable16_14
   \   00000050   0xEB11 0x0185      ADDS     R1,R1,R5, LSL #+2
   \   00000054   0xF511 0x51F1      ADDS     R1,R1,#+7712
   \   00000058   0x6008             STR      R0,[R1, #+0]
    365          
    366          	}
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \   0000005C   0xE7D5             B.N      ??prepareOutputSignals_0
    367          
    368          	for (int angle = 0; angle < CONFIG(engineCycle); angle++) {
   \                     ??prepareOutputSignals_1:
   \   0000005E   0x2500             MOVS     R5,#+0
   \                     ??prepareOutputSignals_2:
   \   00000060   0x....             LDR.N    R0,??DataTable16_13
   \   00000062   0xF8D0 0x01A8      LDR      R0,[R0, #+424]
   \   00000066   0x4285             CMP      R5,R0
   \   00000068   0xDA18             BGE.N    ??prepareOutputSignals_3
    369          		int triggerShapeIndex = findAngleIndex(angle PASS_ENGINE_PARAMETER);
   \   0000006A   0xEE00 0x5A10      VMOV     S0,R5
   \   0000006E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000072   0x.... 0x....      BL       _Z14findAngleIndexf
    370          		if (engineConfiguration->useOnlyFrontForTrigger)
   \   00000076   0x....             LDR.N    R1,??DataTable16_5
   \   00000078   0x6809             LDR      R1,[R1, #+0]
   \   0000007A   0xF891 0x15E5      LDRB     R1,[R1, #+1509]
   \   0000007E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   0x0989             LSRS     R1,R1,#+6
   \   00000082   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD001             BEQ.N    ??prepareOutputSignals_4
    371          			triggerShapeIndex = triggerShapeIndex & 0xFFFFFFFE; // we need even index for front_only
   \   0000008A   0xF030 0x0001      BICS     R0,R0,#0x1
    372          		TRIGGER_SHAPE(triggerIndexByAngle[angle]) = triggerShapeIndex;
   \                     ??prepareOutputSignals_4:
   \   0000008E   0x....             LDR.N    R1,??DataTable16_14
   \   00000090   0xEB11 0x0185      ADDS     R1,R1,R5, LSL #+2
   \   00000094   0xF8C1 0x029C      STR      R0,[R1, #+668]
    373          	}
   \   00000098   0x1C6D             ADDS     R5,R5,#+1
   \   0000009A   0xE7E1             B.N      ??prepareOutputSignals_2
    374          
    375          	engineConfiguration2->crankingInjectionEvents.addFuelEvents(
    376          			engineConfiguration->crankingInjectionMode PASS_ENGINE_PARAMETER);
   \                     ??prepareOutputSignals_3:
   \   0000009C   0x....             LDR.N    R0,??DataTable16_5
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF8D0 0x11AC      LDR      R1,[R0, #+428]
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       _ZN12FuelSchedule13addFuelEventsE16injection_mode_e
    377          	engineConfiguration2->injectionEvents.addFuelEvents(
    378          			engineConfiguration->injectionMode PASS_ENGINE_PARAMETER);
   \   000000AA   0x....             LDR.N    R0,??DataTable16_5
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0xF8D0 0x11B0      LDR      R1,[R0, #+432]
   \   000000B2   0xF504 0x50B8      ADD      R0,R4,#+5888
   \   000000B6   0x3088             ADDS     R0,R0,#+136
   \   000000B8   0x.... 0x....      BL       _ZN12FuelSchedule13addFuelEventsE16injection_mode_e
    379          }
   \   000000BC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    380          
    381          #endif
    382          

   \                                 In section .text, align 2, keep-with-next
    383          void setFuelRpmBin(float from, float to DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z13setFuelRpmBinff:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0xEEF0 0x8A60      VMOV.F32 S17,S1
    384          	setTableBin(config->fuelRpmBins, FUEL_RPM_COUNT, from, to);
   \   0000000E   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   00000012   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable16_40
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF500 0x5034      ADD      R0,R0,#+11520
   \   00000020   0x30F8             ADDS     R0,R0,#+248
   \   00000022   0x.... 0x....      BL       _Z11setTableBinPfiff
    385          }
   \   00000026   0xECBD 0x8B02      VPOP     {D8}
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    386          

   \                                 In section .text, align 2, keep-with-next
    387          void setFuelLoadBin(float from, float to DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z14setFuelLoadBinff:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0xEEF0 0x8A60      VMOV.F32 S17,S1
    388          	setTableBin(config->fuelLoadBins, FUEL_LOAD_COUNT, from, to);
   \   0000000E   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   00000012   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable16_40
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF500 0x5034      ADD      R0,R0,#+11520
   \   00000020   0x30B8             ADDS     R0,R0,#+184
   \   00000022   0x.... 0x....      BL       _Z11setTableBinPfiff
    389          }
   \   00000026   0xECBD 0x8B02      VPOP     {D8}
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    390          

   \                                 In section .text, align 2, keep-with-next
    391          void setTimingRpmBin(float from, float to DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z15setTimingRpmBinff:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0xEEF0 0x8A60      VMOV.F32 S17,S1
    392          	setTableBin(config->ignitionRpmBins, IGN_RPM_COUNT, from, to);
   \   0000000E   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   00000012   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable16_40
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF500 0x5048      ADD      R0,R0,#+12800
   \   00000020   0x3078             ADDS     R0,R0,#+120
   \   00000022   0x.... 0x....      BL       _Z11setTableBinPfiff
    393          }
   \   00000026   0xECBD 0x8B02      VPOP     {D8}
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    394          

   \                                 In section .text, align 2, keep-with-next
    395          void setTimingLoadBin(float from, float to DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z16setTimingLoadBinff:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0xEEF0 0x8A60      VMOV.F32 S17,S1
    396          	setTableBin(config->ignitionLoadBins, IGN_LOAD_COUNT, from, to);
   \   0000000E   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   00000012   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable16_40
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF500 0x5048      ADD      R0,R0,#+12800
   \   00000020   0x3038             ADDS     R0,R0,#+56
   \   00000022   0x.... 0x....      BL       _Z11setTableBinPfiff
    397          }
   \   00000026   0xECBD 0x8B02      VPOP     {D8}
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    398          

   \                                 In section .text, align 2, keep-with-next
    399          int isInjectionEnabled(engine_configuration_s *engineConfiguration) {
    400          	// todo: is this worth a method? should this be inlined?
    401          	return engineConfiguration->isInjectionEnabled;
   \                     _Z18isInjectionEnabledP22engine_configuration_s:
   \   00000000   0xF890 0x05E4      LDRB     R0,[R0, #+1508]
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    402          }
    403          
    404          /**
    405           * this method sets algorithm and ignition table scale
    406           */

   \                                 In section .text, align 4, keep-with-next
    407          void setAlgorithm(engine_load_mode_e algo DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z12setAlgorithm18engine_load_mode_e:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    408          	engineConfiguration->algorithm = algo;
   \   00000004   0x....             LDR.N    R0,??DataTable16_5
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF8C0 0x41A8      STR      R4,[R0, #+424]
    409          	if (algo == LM_ALPHA_N) {
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD106             BNE.N    ??setAlgorithm_0
    410          		setTimingLoadBin(0, 100 PASS_ENGINE_PARAMETER);
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable16  ;; 0x42c80000
   \   00000014   0xED9F 0x....      VLDR.W   S0,??DataTable16_1  ;; 0x0
   \   00000018   0x.... 0x....      BL       _Z16setTimingLoadBinff
   \   0000001C   0xE007             B.N      ??setAlgorithm_1
    411          	} else if (algo == LM_SPEED_DENSITY) {
   \                     ??setAlgorithm_0:
   \   0000001E   0x2C03             CMP      R4,#+3
   \   00000020   0xD105             BNE.N    ??setAlgorithm_1
    412          		setTimingLoadBin(0, 160 PASS_ENGINE_PARAMETER);
   \   00000022   0xEDDF 0x....      VLDR.W   S1,??DataTable16_2  ;; 0x43200000
   \   00000026   0xED9F 0x....      VLDR.W   S0,??DataTable16_1  ;; 0x0
   \   0000002A   0x.... 0x....      BL       _Z16setTimingLoadBinff
    413          	}
    414          }
   \                     ??setAlgorithm_1:
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x4326AAAB         DC32     0x4326aaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x43B40000         DC32     0x43b40000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x6D 0x61          DC8      "maf"
   \              0x66 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x3A400C01         DC32     0x3a400c01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x4326AAAB         DC32     0x4326aaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x43200000         DC32     0x43200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     `?<Constant "engine 2NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     `?<Constant "engineConfiguration 2...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     `?<Constant "MAF sensor needed for...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     `?<Constant "Unexpected engine loa...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x458CA000         DC32     0x458ca000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x46435000         DC32     0x46435000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     `?<Constant "cylindersCount">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     persistentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x........         DC32     _engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x........         DC32     `?<Constant "no_pin_cl #%s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x........         DC32     `?<Constant "no_pin_inj #%s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x........         DC32     _engine+0x284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x........         DC32     `?<Constant "uninitialized Trigger...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x........         DC32     `?<Constant "engine is NULL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   0x........         DC32     `?<Constant "NAN one deg">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   0x........         DC32     _engine+0x1EE4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   0x........         DC32     enginePins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \   00000000   0x........         DC32     `?<Constant "Unexpected injection ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \   00000000   0x........         DC32     `?<Constant "invalid rpm">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \   00000000   0x........         DC32     `?<Constant "engineCycleEventCount">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \   00000000   0x........         DC32     _engine+0xDE4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_27:
   \   00000000   0x........         DC32     `?<Constant "zero engineCycle">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_28:
   \   00000000   0x........         DC32     `?<Constant "angle constraint viol...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_29:
   \   00000000   0x........         DC32     order_1_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_30:
   \   00000000   0x........         DC32     order_1_THEN_3_THEN_4_THEN2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_31:
   \   00000000   0x........         DC32     order_1_THEN_2_THEN_4_THEN3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_32:
   \   00000000   0x........         DC32     order_1_THEN_3_THEN_2_THEN4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_33:
   \   00000000   0x........         DC32     order_1_2_4_5_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_34:
   \   00000000   0x........         DC32     order_1_THEN_5_THEN_3_THEN_6_THEN_2_THEN_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_35:
   \   00000000   0x........         DC32     order_1_THEN_4_THEN_2_THEN_5_THEN_3_THEN_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_36:
   \   00000000   0x........         DC32     order_1_8_4_3_6_5_7_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_37:
   \   00000000   0x........         DC32     `?<Constant "getCylinderId not sup...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_38:
   \   00000000   0x........         DC32     enginePins+0x150

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_39:
   \   00000000   0x........         DC32     `?<Constant "unsupported ignitionM...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_40:
   \   00000000   0x........         DC32     config

   \                                 In section .rodata, align 4
   \                     `?<Constant "engine 2NULL">`:
   \   00000000   0x65 0x6E          DC8 "engine 2NULL"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x20 0x32    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "engineConfiguration 2...">`:
   \   00000000   0x65 0x6E          DC8 "engineConfiguration 2NULL"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x32 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MAF sensor needed for...">`:
   \   00000000   0x4D 0x41          DC8 "MAF sensor needed for current fuel algorithm"
   \              0x46 0x20    
   \              0x73 0x65    
   \              0x6E 0x73    
   \              0x6F 0x72    
   \              0x20 0x6E    
   \              0x65 0x65    
   \              0x64 0x65    
   \              0x64 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x63 0x75    
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x66 0x75    
   \              0x65 0x6C    
   \              0x20 0x61    
   \              0x6C 0x67    
   \              0x6F 0x72    
   \              0x69 0x74    
   \              0x68 0x6D    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x6D 0x61          DC8 "maf"
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Unexpected engine loa...">`:
   \   00000000   0x55 0x6E          DC8 "Unexpected engine load parameter: %d"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x6E 0x67    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x70    
   \              0x61 0x72    
   \              0x61 0x6D    
   \              0x65 0x74    
   \              0x65 0x72    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "cylindersCount">`:
   \   00000000   0x63 0x79          DC8 "cylindersCount"
   \              0x6C 0x69    
   \              0x6E 0x64    
   \              0x65 0x72    
   \              0x73 0x43    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "no_pin_cl #%s">`:
   \   00000000   0x6E 0x6F          DC8 "no_pin_cl #%s"
   \              0x5F 0x70    
   \              0x69 0x6E    
   \              0x5F 0x63    
   \              0x6C 0x20    
   \              0x23 0x25    
   \              0x73 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid rpm">`:
   \   00000000   0x69 0x6E          DC8 "invalid rpm"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x72 0x70    
   \              0x6D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "engineCycleEventCount">`:
   \   00000000   0x65 0x6E          DC8 "engineCycleEventCount"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x43 0x79    
   \              0x63 0x6C    
   \              0x65 0x45    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x43 0x6F    
   \              0x75 0x6E    
   \              0x74 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "zero engineCycle">`:
   \   00000000   0x7A 0x65          DC8 "zero engineCycle"
   \              0x72 0x6F    
   \              0x20 0x65    
   \              0x6E 0x67    
   \              0x69 0x6E    
   \              0x65 0x43    
   \              0x79 0x63    
   \              0x6C 0x65    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "angle constraint viol...">`:
   \   00000000   0x61 0x6E          DC8 61H, 6EH, 67H, 6CH, 65H, 20H, 63H, 6FH
   \              0x67 0x6C    
   \              0x65 0x20    
   \              0x63 0x6F    
   \   00000008   0x6E 0x73          DC8 6EH, 73H, 74H, 72H, 61H, 69H, 6EH, 74H
   \              0x74 0x72    
   \              0x61 0x69    
   \              0x6E 0x74    
   \   00000010   0x20 0x76          DC8 20H, 76H, 69H, 6FH, 6CH, 61H, 74H, 69H
   \              0x69 0x6F    
   \              0x6C 0x61    
   \              0x74 0x69    
   \   00000018   0x6F 0x6E          DC8 6FH, 6EH, 20H, 69H, 6EH, 20H, 66H, 69H
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x66 0x69    
   \   00000020   0x6E 0x64          DC8 6EH, 64H, 54H, 72H, 69H, 67H, 67H, 65H
   \              0x54 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \   00000028   0x72 0x50          DC8 72H, 50H, 6FH, 73H, 69H, 74H, 69H, 6FH
   \              0x6F 0x73    
   \              0x69 0x74    
   \              0x69 0x6F    
   \   00000030   0x6E 0x28          DC8 6EH, 28H, 29H, 3AH, 20H, 25H, 66H, 2FH
   \              0x29 0x3A    
   \              0x20 0x25    
   \              0x66 0x2F    
   \   00000038   0x25 0x66          DC8 25H, 66H, 0
   \              0x00         
   \   0000003B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "getCylinderId not sup...">`:
   \   00000000   0x67 0x65          DC8 "getCylinderId not supported for %d"
   \              0x74 0x43    
   \              0x79 0x6C    
   \              0x69 0x6E    
   \              0x64 0x65    
   \              0x72 0x49    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6F 0x72    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "unsupported ignitionM...">`:
   \   00000000   0x75 0x6E          DC8 75H, 6EH, 73H, 75H, 70H, 70H, 6FH, 72H
   \              0x73 0x75    
   \              0x70 0x70    
   \              0x6F 0x72    
   \   00000008   0x74 0x65          DC8 74H, 65H, 64H, 20H, 69H, 67H, 6EH, 69H
   \              0x64 0x20    
   \              0x69 0x67    
   \              0x6E 0x69    
   \   00000010   0x74 0x69          DC8 74H, 69H, 6FH, 6EH, 4DH, 6FH, 64H, 65H
   \              0x6F 0x6E    
   \              0x4D 0x6F    
   \              0x64 0x65    
   \   00000018   0x20 0x25          DC8 20H, 25H, 64H, 20H, 69H, 6EH, 20H, 69H
   \              0x64 0x20    
   \              0x69 0x6E    
   \              0x20 0x69    
   \   00000020   0x6E 0x69          DC8 6EH, 69H, 74H, 69H, 61H, 6CH, 69H, 7AH
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \   00000028   0x65 0x49          DC8 65H, 49H, 67H, 6EH, 69H, 74H, 69H, 6FH
   \              0x67 0x6E    
   \              0x69 0x74    
   \              0x69 0x6F    
   \   00000030   0x6E 0x41          DC8 6EH, 41H, 63H, 74H, 69H, 6FH, 6EH, 73H
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x73    
   \   00000038   0x28 0x29          DC8 28H, 29H, 0
   \              0x00         
   \   0000003B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "engine is NULL">`:
   \   00000000   0x65 0x6E          DC8 "engine is NULL"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "NAN one deg">`:
   \   00000000   0x4E 0x41          DC8 "NAN one deg"
   \              0x4E 0x20    
   \              0x6F 0x6E    
   \              0x65 0x20    
   \              0x64 0x65    
   \              0x67 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Unexpected injection ...">`:
   \   00000000   0x55 0x6E          DC8 "Unexpected injection mode %d"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x69    
   \              0x6E 0x6A    
   \              0x65 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x25 0x64    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "no_pin_inj #%s">`:
   \   00000000   0x6E 0x6F          DC8 "no_pin_inj #%s"
   \              0x5F 0x70    
   \              0x69 0x6E    
   \              0x5F 0x69    
   \              0x6E 0x6A    
   \              0x20 0x23    
   \              0x25 0x73    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "uninitialized Trigger...">`:
   \   00000000   0x75 0x6E          DC8 "uninitialized TriggerShape"
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x65    
   \              0x64 0x20    
   \              0x54 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x53    
   \              0x68 0x61    
   \              0x70 0x65    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 2
   \   __code __interwork __softfp ArrayList<InjectionEvent, 45>::subobject ArrayList()
   \                     _ZN9ArrayListI14InjectionEventLi45EEC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN9ArrayListI14InjectionEventLi45EEC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ArrayList<IgnitionEvent, 80>::add()
         8   -> firmwareError
       0   ArrayList<IgnitionEvent, 80>::reset()
       8   ArrayList<InjectionEvent, 45>::ArrayList()
         8   -> ArrayList<InjectionEvent, 45>::reset()
         8   -> __aeabi_vec_ctor_nocookie_nodtor
         8   -> memset
       8   ArrayList<InjectionEvent, 45>::add()
         8   -> firmwareError
       0   ArrayList<InjectionEvent, 45>::reset()
       8   ArrayList<InjectionEvent, 45>::subobject ArrayList()
         8   -> ArrayList<InjectionEvent, 45>::ArrayList()
       8   FuelSchedule::FuelSchedule()
         8   -> ArrayList<InjectionEvent, 45>::ArrayList()
         8   -> FuelSchedule::clear()
      32   FuelSchedule::addFuelEvents(injection_mode_e)
        32   -> ArrayList<InjectionEvent, 45>::reset()
        32   -> FuelSchedule::clear()
        32   -> FuelSchedule::registerInjectionEvent(NamedOutputPin *, float, bool)
        32   -> __iar_FDtest
        32   -> firmwareError
        32   -> getCylinderId(firing_order_e, int)
        32   -> warning
       8   FuelSchedule::clear()
         8   -> memset
      32   FuelSchedule::registerInjectionEvent(NamedOutputPin *, float, bool)
        32   -> ArrayList<InjectionEvent, 45>::add()
        32   -> TriggerShape::getSize() const
        32   -> findTriggerPosition(event_trigger_position_s *, float)
        32   -> firmwareError
        32   -> warning
       8   FuelSchedule::subobject FuelSchedule()
         8   -> FuelSchedule::FuelSchedule()
      16   findAngleIndex(float)
        16   -> firmwareError
      32   findTriggerPosition(event_trigger_position_s *, float)
        32   -> __aeabi_f2d
        32   -> firmwareError
        32   -> warning
       0   getCrankshaftRevolutionTimeMs(int)
      16   getCylinderId(firing_order_e, int)
        16   -> warning
       8   getEngineLoadT()
         8   -> firmwareError
         8   -> getInternalAdcValue(char const *, adc_channel_e)
         8   -> getMap()
         8   -> getRealMaf()
         8   -> getTPS()
         8   -> hasMafSensor()
         8   -> warning
      16   getIgnitionPinForIndex(int)
        16   -> getCylinderId(firing_order_e, int)
        16   -> warning
       8   getSparkDwellMsT(int)
         8   -> __aeabi_i2d
         8   -> __iar_Dtest
         8   -> firmwareError
         8   -> interpolate2d(float, float *, float *, int)
      40   initializeIgnitionActions(float, float, IgnitionEventList *)
        40   -> ArrayList<IgnitionEvent, 80>::add()
        40   -> ArrayList<IgnitionEvent, 80>::reset()
        40   -> findTriggerPosition(event_trigger_position_s *, float)
        40   -> firmwareError
        40   -> warning
       0   isInjectionEnabled(engine_configuration_s *)
      16   memset
        16   -> __aeabi_memset
      16   prepareOutputSignals()
        16   -> FuelSchedule::addFuelEvents(injection_mode_e)
        16   -> findAngleIndex(float)
        16   -> getIgnitionPinForIndex(int)
       8   setAlgorithm(engine_load_mode_e)
         8   -> setTimingLoadBin(float, float)
      16   setFuelLoadBin(float, float)
        16   -> setTableBin(float *, int, float, float)
      16   setFuelRpmBin(float, float)
        16   -> setTableBin(float *, int, float, float)
       0   setSingleCoilDwell(engine_configuration_s *)
      16   setTimingLoadBin(float, float)
        16   -> setTableBin(float *, int, float, float)
      16   setTimingRpmBin(float, float)
        16   -> setTableBin(float *, int, float, float)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      48  ?<Constant "MAF sensor needed for...">
      12  ?<Constant "NAN one deg">
      40  ?<Constant "Unexpected engine loa...">
      32  ?<Constant "Unexpected injection ...">
      60  ?<Constant "angle constraint viol...">
      16  ?<Constant "cylindersCount">
      16  ?<Constant "engine 2NULL">
      16  ?<Constant "engine is NULL">
      28  ?<Constant "engineConfiguration 2...">
      24  ?<Constant "engineCycleEventCount">
      36  ?<Constant "getCylinderId not sup...">
      12  ?<Constant "invalid rpm">
       4  ?<Constant "maf">
      16  ?<Constant "no_pin_cl #%s">
      16  ?<Constant "no_pin_inj #%s">
      28  ?<Constant "uninitialized Trigger...">
      60  ?<Constant "unsupported ignitionM...">
      20  ?<Constant "zero engineCycle">
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_34
       4  ??DataTable16_35
       4  ??DataTable16_36
       4  ??DataTable16_37
       4  ??DataTable16_38
       4  ??DataTable16_39
       4  ??DataTable16_4
       4  ??DataTable16_40
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable7
      40  ArrayList<IgnitionEvent, 80>::add()
       6  ArrayList<IgnitionEvent, 80>::reset()
      48  ArrayList<InjectionEvent, 45>::ArrayList()
      40  ArrayList<InjectionEvent, 45>::add()
       6  ArrayList<InjectionEvent, 45>::reset()
      12  ArrayList<InjectionEvent, 45>::subobject ArrayList()
      20  FuelSchedule::FuelSchedule()
     536  FuelSchedule::addFuelEvents(injection_mode_e)
      28  FuelSchedule::clear()
     138  FuelSchedule::registerInjectionEvent(NamedOutputPin *, float, bool)
      12  FuelSchedule::subobject FuelSchedule()
     102  findAngleIndex(float)
     226  findTriggerPosition(event_trigger_position_s *, float)
      26  getCrankshaftRevolutionTimeMs(int)
     120  getCylinderId(firing_order_e, int)
     198  getEngineLoadT()
     120  getIgnitionPinForIndex(int)
     154  getSparkDwellMsT(int)
     152  initializeIgnitionActions(float, float, IgnitionEventList *)
      10  isInjectionEnabled(engine_configuration_s *)
      22  memset
       8  order_1_2
      20  order_1_2_4_5_3
      32  order_1_8_4_3_6_5_7_2
      16  order_1_THEN_2_THEN_4_THEN3
      16  order_1_THEN_3_THEN_2_THEN4
      16  order_1_THEN_3_THEN_4_THEN2
      24  order_1_THEN_4_THEN_2_THEN_5_THEN_3_THEN_6
      24  order_1_THEN_5_THEN_3_THEN_6_THEN_2_THEN_4
     190  prepareOutputSignals()
      48  setAlgorithm(engine_load_mode_e)
      44  setFuelLoadBin(float, float)
      44  setFuelRpmBin(float, float)
      90  setSingleCoilDwell(engine_configuration_s *)
      44  setTimingLoadBin(float, float)
      44  setTimingRpmBin(float, float)
      48  -- Other

 
   156 bytes in section .data
   532 bytes in section .rodata
 2 716 bytes in section .text
 
 2 542 bytes of CODE  memory (+ 174 bytes shared)
   484 bytes of CONST memory (+  48 bytes shared)
   156 bytes of DATA  memory

Errors: none
Warnings: 1
