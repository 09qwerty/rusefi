###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:23 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\SPIv1\spi_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\SPIv1\spi_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\s #
#                       pi_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\sp #
#                       i_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\SPIv1\spi_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/SPIv1/spi_lld.c
     19           * @brief   STM32 SPI subsystem low level driver source.
     20           *
     21           * @addtogroup SPI
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_SPI || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          #define SPI1_RX_DMA_CHANNEL                                                 \
     35            STM32_DMA_GETCHANNEL(STM32_SPI_SPI1_RX_DMA_STREAM,                        \
     36                                 STM32_SPI1_RX_DMA_CHN)
     37          
     38          #define SPI1_TX_DMA_CHANNEL                                                 \
     39            STM32_DMA_GETCHANNEL(STM32_SPI_SPI1_TX_DMA_STREAM,                        \
     40                                 STM32_SPI1_TX_DMA_CHN)
     41          
     42          #define SPI2_RX_DMA_CHANNEL                                                 \
     43            STM32_DMA_GETCHANNEL(STM32_SPI_SPI2_RX_DMA_STREAM,                        \
     44                                 STM32_SPI2_RX_DMA_CHN)
     45          
     46          #define SPI2_TX_DMA_CHANNEL                                                 \
     47            STM32_DMA_GETCHANNEL(STM32_SPI_SPI2_TX_DMA_STREAM,                        \
     48                                 STM32_SPI2_TX_DMA_CHN)
     49          
     50          #define SPI3_RX_DMA_CHANNEL                                                 \
     51            STM32_DMA_GETCHANNEL(STM32_SPI_SPI3_RX_DMA_STREAM,                        \
     52                                 STM32_SPI3_RX_DMA_CHN)
     53          
     54          #define SPI3_TX_DMA_CHANNEL                                                 \
     55            STM32_DMA_GETCHANNEL(STM32_SPI_SPI3_TX_DMA_STREAM,                        \
     56                                 STM32_SPI3_TX_DMA_CHN)
     57          
     58          #define SPI4_RX_DMA_CHANNEL                                                 \
     59            STM32_DMA_GETCHANNEL(STM32_SPI_SPI4_RX_DMA_STREAM,                        \
     60                                 STM32_SPI4_RX_DMA_CHN)
     61          
     62          #define SPI4_TX_DMA_CHANNEL                                                 \
     63            STM32_DMA_GETCHANNEL(STM32_SPI_SPI4_TX_DMA_STREAM,                        \
     64                                 STM32_SPI4_TX_DMA_CHN)
     65          
     66          #define SPI5_RX_DMA_CHANNEL                                                 \
     67            STM32_DMA_GETCHANNEL(STM32_SPI_SPI5_RX_DMA_STREAM,                        \
     68                                 STM32_SPI5_RX_DMA_CHN)
     69          
     70          #define SPI5_TX_DMA_CHANNEL                                                 \
     71            STM32_DMA_GETCHANNEL(STM32_SPI_SPI5_TX_DMA_STREAM,                        \
     72                                 STM32_SPI5_TX_DMA_CHN)
     73          
     74          #define SPI6_RX_DMA_CHANNEL                                                 \
     75            STM32_DMA_GETCHANNEL(STM32_SPI_SPI6_RX_DMA_STREAM,                        \
     76                                 STM32_SPI6_RX_DMA_CHN)
     77          
     78          #define SPI6_TX_DMA_CHANNEL                                                 \
     79            STM32_DMA_GETCHANNEL(STM32_SPI_SPI6_TX_DMA_STREAM,                        \
     80                                 STM32_SPI6_TX_DMA_CHN)
     81          
     82          /*===========================================================================*/
     83          /* Driver exported variables.                                                */
     84          /*===========================================================================*/
     85          
     86          /** @brief SPI1 driver identifier.*/
     87          #if STM32_SPI_USE_SPI1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     88          SPIDriver SPID1;
   \                     SPID1:
   \   00000000                      DS8 48
     89          #endif
     90          
     91          /** @brief SPI2 driver identifier.*/
     92          #if STM32_SPI_USE_SPI2 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     93          SPIDriver SPID2;
   \                     SPID2:
   \   00000000                      DS8 48
     94          #endif
     95          
     96          /** @brief SPI3 driver identifier.*/
     97          #if STM32_SPI_USE_SPI3 || defined(__DOXYGEN__)

   \                                 In section .bss, align 4
     98          SPIDriver SPID3;
   \                     SPID3:
   \   00000000                      DS8 48
     99          #endif
    100          
    101          /** @brief SPI4 driver identifier.*/
    102          #if STM32_SPI_USE_SPI4 || defined(__DOXYGEN__)
    103          SPIDriver SPID4;
    104          #endif
    105          
    106          /** @brief SPI5 driver identifier.*/
    107          #if STM32_SPI_USE_SPI5 || defined(__DOXYGEN__)
    108          SPIDriver SPID5;
    109          #endif
    110          
    111          /** @brief SPI6 driver identifier.*/
    112          #if STM32_SPI_USE_SPI6 || defined(__DOXYGEN__)
    113          SPIDriver SPID6;
    114          #endif
    115          
    116          /*===========================================================================*/
    117          /* Driver local variables and types.                                         */
    118          /*===========================================================================*/
    119          

   \                                 In section .bss, align 2
    120          static uint16_t dummytx;
   \                     dummytx:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    121          static uint16_t dummyrx;
   \                     dummyrx:
   \   00000000                      DS8 2
    122          
    123          /*===========================================================================*/
    124          /* Driver local functions.                                                   */
    125          /*===========================================================================*/
    126          
    127          /**
    128           * @brief   Shared end-of-rx service routine.
    129           *
    130           * @param[in] spip      pointer to the @p SPIDriver object
    131           * @param[in] flags     pre-shifted content of the ISR register
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
   \                     spi_lld_serve_rx_interrupt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    134          
    135            /* DMA errors handling.*/
    136          #if defined(STM32_SPI_DMA_ERROR_HOOK)
    137            if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
   \   00000006   0xF015 0x0F0C      TST      R5,#0xC
    138              STM32_SPI_DMA_ERROR_HOOK(spip);
    139            }
    140          #else
    141            (void)flags;
    142          #endif
    143          
    144            /* Stop everything.*/
    145            dmaStreamDisable(spip->dmatx);
   \                     ??spi_lld_serve_rx_interrupt_0:
   \   0000000A   0x6A60             LDR      R0,[R4, #+36]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0940             LSRS     R0,R0,#+5
   \   00000012   0x0140             LSLS     R0,R0,#+5
   \   00000014   0x6A61             LDR      R1,[R4, #+36]
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \                     ??spi_lld_serve_rx_interrupt_1:
   \   0000001A   0x6A60             LDR      R0,[R4, #+36]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD4FA             BMI.N    ??spi_lld_serve_rx_interrupt_1
   \   00000024   0x203D             MOVS     R0,#+61
   \   00000026   0x6A61             LDR      R1,[R4, #+36]
   \   00000028   0xF991 0x1008      LDRSB    R1,[R1, #+8]
   \   0000002C   0x4088             LSLS     R0,R0,R1
   \   0000002E   0x6A61             LDR      R1,[R4, #+36]
   \   00000030   0x6849             LDR      R1,[R1, #+4]
   \   00000032   0x6008             STR      R0,[R1, #+0]
    146            dmaStreamDisable(spip->dmarx);
   \   00000034   0x6A20             LDR      R0,[R4, #+32]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0940             LSRS     R0,R0,#+5
   \   0000003C   0x0140             LSLS     R0,R0,#+5
   \   0000003E   0x6A21             LDR      R1,[R4, #+32]
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \                     ??spi_lld_serve_rx_interrupt_2:
   \   00000044   0x6A20             LDR      R0,[R4, #+32]
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x07C0             LSLS     R0,R0,#+31
   \   0000004C   0xD4FA             BMI.N    ??spi_lld_serve_rx_interrupt_2
   \   0000004E   0x203D             MOVS     R0,#+61
   \   00000050   0x6A21             LDR      R1,[R4, #+32]
   \   00000052   0xF991 0x1008      LDRSB    R1,[R1, #+8]
   \   00000056   0x4088             LSLS     R0,R0,R1
   \   00000058   0x6A21             LDR      R1,[R4, #+32]
   \   0000005A   0x6849             LDR      R1,[R1, #+4]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    147          
    148            /* Portable SPI ISR code defined in the high level driver, note, it is
    149               a macro.*/
    150            _spi_isr_code(spip);
   \   0000005E   0x6860             LDR      R0,[R4, #+4]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD00B             BEQ.N    ??spi_lld_serve_rx_interrupt_3
   \   00000066   0x2004             MOVS     R0,#+4
   \   00000068   0x7020             STRB     R0,[R4, #+0]
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x6861             LDR      R1,[R4, #+4]
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0x4788             BLX      R1
   \   00000072   0x7820             LDRB     R0,[R4, #+0]
   \   00000074   0x2804             CMP      R0,#+4
   \   00000076   0xD104             BNE.N    ??spi_lld_serve_rx_interrupt_4
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0x7020             STRB     R0,[R4, #+0]
   \   0000007C   0xE001             B.N      ??spi_lld_serve_rx_interrupt_4
   \                     ??spi_lld_serve_rx_interrupt_3:
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x7020             STRB     R0,[R4, #+0]
   \                     ??spi_lld_serve_rx_interrupt_4:
   \   00000082   0x2020             MOVS     R0,#+32
   \   00000084   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000088   0x.... 0x....      BL       dbg_check_lock_from_isr
   \   0000008C   0x68A0             LDR      R0,[R4, #+8]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD008             BEQ.N    ??spi_lld_serve_rx_interrupt_5
   \   00000092   0x68A0             LDR      R0,[R4, #+8]
   \   00000094   0x0006             MOVS     R6,R0
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x60A0             STR      R0,[R4, #+8]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x62B0             STR      R0,[R6, #+40]
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       chSchReadyI
   \                     ??spi_lld_serve_rx_interrupt_5:
   \   000000A4   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF380 0x8811      MSR      BASEPRI,R0
    151          }
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    152          
    153          /**
    154           * @brief   Shared end-of-tx service routine.
    155           *
    156           * @param[in] spip      pointer to the @p SPIDriver object
    157           * @param[in] flags     pre-shifted content of the ISR register
    158           */

   \                                 In section .text, align 2, keep-with-next
    159          static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
    160          
    161            /* DMA errors handling.*/
    162          #if defined(STM32_SPI_DMA_ERROR_HOOK)
    163            (void)spip;
    164            if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
   \                     spi_lld_serve_tx_interrupt:
   \   00000000   0xF011 0x0F0C      TST      R1,#0xC
    165              STM32_SPI_DMA_ERROR_HOOK(spip);
    166            }
    167          #else
    168            (void)spip;
    169            (void)flags;
    170          #endif
    171          }
   \                     ??spi_lld_serve_tx_interrupt_0:
   \   00000004   0x4770             BX       LR               ;; return
    172          
    173          /*===========================================================================*/
    174          /* Driver interrupt handlers.                                                */
    175          /*===========================================================================*/
    176          
    177          /*===========================================================================*/
    178          /* Driver exported functions.                                                */
    179          /*===========================================================================*/
    180          
    181          /**
    182           * @brief   Low level SPI driver initialization.
    183           *
    184           * @notapi
    185           */

   \                                 In section .text, align 2, keep-with-next
    186          void spi_lld_init(void) {
   \                     spi_lld_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    187          
    188            dummytx = 0xFFFF;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000006   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000A   0x8001             STRH     R1,[R0, #+0]
    189          
    190          #if STM32_SPI_USE_SPI1
    191            spiObjectInit(&SPID1);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       spiObjectInit
    192            SPID1.spi       = SPI1;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x40013000
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
    193            SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable5_3
   \   00000026   0x6201             STR      R1,[R0, #+32]
    194            SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable5_4
   \   00000030   0x6241             STR      R1,[R0, #+36]
    195            SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
    196                              STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
    197                              STM32_DMA_CR_DIR_P2M |
    198                              STM32_DMA_CR_TCIE |
    199                              STM32_DMA_CR_DMEIE |
    200                              STM32_DMA_CR_TEIE;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable5_5  ;; 0x6010016
   \   0000003A   0x6281             STR      R1,[R0, #+40]
    201            SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
    202                              STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
    203                              STM32_DMA_CR_DIR_M2P |
    204                              STM32_DMA_CR_DMEIE |
    205                              STM32_DMA_CR_TEIE;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x6010046
   \   00000044   0x62C1             STR      R1,[R0, #+44]
    206          #endif
    207          
    208          #if STM32_SPI_USE_SPI2
    209            spiObjectInit(&SPID2);
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable5_7
   \   0000004A   0x.... 0x....      BL       spiObjectInit
    210            SPID2.spi       = SPI2;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable5_7
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable5_8  ;; 0x40003800
   \   00000056   0x61C1             STR      R1,[R0, #+28]
    211            SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable5_7
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable5_9
   \   00000060   0x6201             STR      R1,[R0, #+32]
    212            SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable5_7
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable5_10
   \   0000006A   0x6241             STR      R1,[R0, #+36]
    213            SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
    214                              STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
    215                              STM32_DMA_CR_DIR_P2M |
    216                              STM32_DMA_CR_TCIE |
    217                              STM32_DMA_CR_DMEIE |
    218                              STM32_DMA_CR_TEIE;
   \   0000006C   0x....             LDR.N    R0,??DataTable5_7
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable5_11  ;; 0x10016
   \   00000072   0x6281             STR      R1,[R0, #+40]
    219            SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
    220                              STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
    221                              STM32_DMA_CR_DIR_M2P |
    222                              STM32_DMA_CR_DMEIE |
    223                              STM32_DMA_CR_TEIE;
   \   00000074   0x....             LDR.N    R0,??DataTable5_7
   \   00000076   0x....             LDR.N    R1,??DataTable5_12  ;; 0x10046
   \   00000078   0x62C1             STR      R1,[R0, #+44]
    224          #endif
    225          
    226          #if STM32_SPI_USE_SPI3
    227            spiObjectInit(&SPID3);
   \   0000007A   0x....             LDR.N    R0,??DataTable5_13
   \   0000007C   0x.... 0x....      BL       spiObjectInit
    228            SPID3.spi       = SPI3;
   \   00000080   0x....             LDR.N    R0,??DataTable5_13
   \   00000082   0x....             LDR.N    R1,??DataTable5_14  ;; 0x40003c00
   \   00000084   0x61C1             STR      R1,[R0, #+28]
    229            SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
   \   00000086   0x....             LDR.N    R0,??DataTable5_13
   \   00000088   0x....             LDR.N    R1,??DataTable5_15
   \   0000008A   0x6201             STR      R1,[R0, #+32]
    230            SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
   \   0000008C   0x....             LDR.N    R0,??DataTable5_13
   \   0000008E   0x....             LDR.N    R1,??DataTable5_16
   \   00000090   0x6241             STR      R1,[R0, #+36]
    231            SPID3.rxdmamode = STM32_DMA_CR_CHSEL(SPI3_RX_DMA_CHANNEL) |
    232                              STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
    233                              STM32_DMA_CR_DIR_P2M |
    234                              STM32_DMA_CR_TCIE |
    235                              STM32_DMA_CR_DMEIE |
    236                              STM32_DMA_CR_TEIE;
   \   00000092   0x....             LDR.N    R0,??DataTable5_13
   \   00000094   0x....             LDR.N    R1,??DataTable5_11  ;; 0x10016
   \   00000096   0x6281             STR      R1,[R0, #+40]
    237            SPID3.txdmamode = STM32_DMA_CR_CHSEL(SPI3_TX_DMA_CHANNEL) |
    238                              STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
    239                              STM32_DMA_CR_DIR_M2P |
    240                              STM32_DMA_CR_DMEIE |
    241                              STM32_DMA_CR_TEIE;
   \   00000098   0x....             LDR.N    R0,??DataTable5_13
   \   0000009A   0x....             LDR.N    R1,??DataTable5_12  ;; 0x10046
   \   0000009C   0x62C1             STR      R1,[R0, #+44]
    242          #endif
    243          
    244          #if STM32_SPI_USE_SPI4
    245            spiObjectInit(&SPID4);
    246            SPID4.spi       = SPI4;
    247            SPID4.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI4_RX_DMA_STREAM);
    248            SPID4.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI4_TX_DMA_STREAM);
    249            SPID4.rxdmamode = STM32_DMA_CR_CHSEL(SPI4_RX_DMA_CHANNEL) |
    250                              STM32_DMA_CR_PL(STM32_SPI_SPI4_DMA_PRIORITY) |
    251                              STM32_DMA_CR_DIR_P2M |
    252                              STM32_DMA_CR_TCIE |
    253                              STM32_DMA_CR_DMEIE |
    254                              STM32_DMA_CR_TEIE;
    255            SPID4.txdmamode = STM32_DMA_CR_CHSEL(SPI4_TX_DMA_CHANNEL) |
    256                              STM32_DMA_CR_PL(STM32_SPI_SPI4_DMA_PRIORITY) |
    257                              STM32_DMA_CR_DIR_M2P |
    258                              STM32_DMA_CR_DMEIE |
    259                              STM32_DMA_CR_TEIE;
    260          #endif
    261          
    262          #if STM32_SPI_USE_SPI5
    263            spiObjectInit(&SPID5);
    264            SPID5.spi       = SPI5;
    265            SPID5.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI5_RX_DMA_STREAM);
    266            SPID5.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI5_TX_DMA_STREAM);
    267            SPID5.rxdmamode = STM32_DMA_CR_CHSEL(SPI5_RX_DMA_CHANNEL) |
    268                              STM32_DMA_CR_PL(STM32_SPI_SPI5_DMA_PRIORITY) |
    269                              STM32_DMA_CR_DIR_P2M |
    270                              STM32_DMA_CR_TCIE |
    271                              STM32_DMA_CR_DMEIE |
    272                              STM32_DMA_CR_TEIE;
    273            SPID5.txdmamode = STM32_DMA_CR_CHSEL(SPI5_TX_DMA_CHANNEL) |
    274                              STM32_DMA_CR_PL(STM32_SPI_SPI5_DMA_PRIORITY) |
    275                              STM32_DMA_CR_DIR_M2P |
    276                              STM32_DMA_CR_DMEIE |
    277                              STM32_DMA_CR_TEIE;
    278          #endif
    279          
    280          #if STM32_SPI_USE_SPI6
    281            spiObjectInit(&SPID6);
    282            SPID6.spi       = SPI6;
    283            SPID6.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI6_RX_DMA_STREAM);
    284            SPID6.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI6_TX_DMA_STREAM);
    285            SPID6.rxdmamode = STM32_DMA_CR_CHSEL(SPI6_RX_DMA_CHANNEL) |
    286                              STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
    287                              STM32_DMA_CR_DIR_P2M |
    288                              STM32_DMA_CR_TCIE |
    289                              STM32_DMA_CR_DMEIE |
    290                              STM32_DMA_CR_TEIE;
    291            SPID6.txdmamode = STM32_DMA_CR_CHSEL(SPI6_TX_DMA_CHANNEL) |
    292                              STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
    293                              STM32_DMA_CR_DIR_M2P |
    294                              STM32_DMA_CR_DMEIE |
    295                              STM32_DMA_CR_TEIE;
    296          #endif
    297          }
   \   0000009E   0xBD01             POP      {R0,PC}          ;; return
    298          
    299          /**
    300           * @brief   Configures and activates the SPI peripheral.
    301           *
    302           * @param[in] spip      pointer to the @p SPIDriver object
    303           *
    304           * @notapi
    305           */

   \                                 In section .text, align 2, keep-with-next
    306          void spi_lld_start(SPIDriver *spip) {
   \                     spi_lld_start:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    307          
    308            /* If in stopped state then enables the SPI and DMA clocks.*/
    309            if (spip->state == SPI_STOP) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD172             BNE.N    ??spi_lld_start_0
    310          #if STM32_SPI_USE_SPI1
    311              if (&SPID1 == spip) {
   \   0000000A   0x....             LDR.N    R0,??DataTable5_1
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD11F             BNE.N    ??spi_lld_start_1
    312                bool_t b;
    313                b = dmaStreamAllocate(spip->dmarx,
    314                                      STM32_SPI_SPI1_IRQ_PRIORITY,
    315                                      (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
    316                                      (void *)spip);
   \   00000010   0x0023             MOVS     R3,R4
   \   00000012   0x....             LDR.N    R2,??DataTable5_17
   \   00000014   0x210A             MOVS     R1,#+10
   \   00000016   0x6A20             LDR      R0,[R4, #+32]
   \   00000018   0x.... 0x....      BL       dmaStreamAllocate
   \   0000001C   0x0005             MOVS     R5,R0
    317                chDbgAssert(!b, "spi_lld_start(), #1", "stream already allocated");
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD002             BEQ.N    ??spi_lld_start_2
   \   00000024   0x....             LDR.N    R0,??DataTable5_18
   \   00000026   0x.... 0x....      BL       chDbgPanic
    318                b = dmaStreamAllocate(spip->dmatx,
    319                                      STM32_SPI_SPI1_IRQ_PRIORITY,
    320                                      (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
    321                                      (void *)spip);
   \                     ??spi_lld_start_2:
   \   0000002A   0x0023             MOVS     R3,R4
   \   0000002C   0x....             LDR.N    R2,??DataTable5_19
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x6A60             LDR      R0,[R4, #+36]
   \   00000032   0x.... 0x....      BL       dmaStreamAllocate
   \   00000036   0x0005             MOVS     R5,R0
    322                chDbgAssert(!b, "spi_lld_start(), #2", "stream already allocated");
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD002             BEQ.N    ??spi_lld_start_3
   \   0000003E   0x....             LDR.N    R0,??DataTable5_20
   \   00000040   0x.... 0x....      BL       chDbgPanic
    323                rccEnableSPI1(FALSE);
   \                     ??spi_lld_start_3:
   \   00000044   0x....             LDR.N    R0,??DataTable5_21  ;; 0x40023844
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000004C   0x....             LDR.N    R1,??DataTable5_21  ;; 0x40023844
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    324              }
    325          #endif
    326          #if STM32_SPI_USE_SPI2
    327              if (&SPID2 == spip) {
   \                     ??spi_lld_start_1:
   \   00000050   0x....             LDR.N    R0,??DataTable5_7
   \   00000052   0x42A0             CMP      R0,R4
   \   00000054   0xD11F             BNE.N    ??spi_lld_start_4
    328                bool_t b;
    329                b = dmaStreamAllocate(spip->dmarx,
    330                                      STM32_SPI_SPI2_IRQ_PRIORITY,
    331                                      (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
    332                                      (void *)spip);
   \   00000056   0x0023             MOVS     R3,R4
   \   00000058   0x....             LDR.N    R2,??DataTable5_17
   \   0000005A   0x210A             MOVS     R1,#+10
   \   0000005C   0x6A20             LDR      R0,[R4, #+32]
   \   0000005E   0x.... 0x....      BL       dmaStreamAllocate
   \   00000062   0x0005             MOVS     R5,R0
    333                chDbgAssert(!b, "spi_lld_start(), #3", "stream already allocated");
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0xD002             BEQ.N    ??spi_lld_start_5
   \   0000006A   0x....             LDR.N    R0,??DataTable5_22
   \   0000006C   0x.... 0x....      BL       chDbgPanic
    334                b = dmaStreamAllocate(spip->dmatx,
    335                                      STM32_SPI_SPI2_IRQ_PRIORITY,
    336                                      (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
    337                                      (void *)spip);
   \                     ??spi_lld_start_5:
   \   00000070   0x0023             MOVS     R3,R4
   \   00000072   0x....             LDR.N    R2,??DataTable5_19
   \   00000074   0x210A             MOVS     R1,#+10
   \   00000076   0x6A60             LDR      R0,[R4, #+36]
   \   00000078   0x.... 0x....      BL       dmaStreamAllocate
   \   0000007C   0x0005             MOVS     R5,R0
    338                chDbgAssert(!b, "spi_lld_start(), #4", "stream already allocated");
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0x2D00             CMP      R5,#+0
   \   00000082   0xD002             BEQ.N    ??spi_lld_start_6
   \   00000084   0x....             LDR.N    R0,??DataTable5_23
   \   00000086   0x.... 0x....      BL       chDbgPanic
    339                rccEnableSPI2(FALSE);
   \                     ??spi_lld_start_6:
   \   0000008A   0x....             LDR.N    R0,??DataTable5_24  ;; 0x40023840
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000092   0x....             LDR.N    R1,??DataTable5_24  ;; 0x40023840
   \   00000094   0x6008             STR      R0,[R1, #+0]
    340              }
    341          #endif
    342          #if STM32_SPI_USE_SPI3
    343              if (&SPID3 == spip) {
   \                     ??spi_lld_start_4:
   \   00000096   0x....             LDR.N    R0,??DataTable5_13
   \   00000098   0x42A0             CMP      R0,R4
   \   0000009A   0xD11F             BNE.N    ??spi_lld_start_7
    344                bool_t b;
    345                b = dmaStreamAllocate(spip->dmarx,
    346                                      STM32_SPI_SPI3_IRQ_PRIORITY,
    347                                      (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
    348                                      (void *)spip);
   \   0000009C   0x0023             MOVS     R3,R4
   \   0000009E   0x....             LDR.N    R2,??DataTable5_17
   \   000000A0   0x210A             MOVS     R1,#+10
   \   000000A2   0x6A20             LDR      R0,[R4, #+32]
   \   000000A4   0x.... 0x....      BL       dmaStreamAllocate
   \   000000A8   0x0005             MOVS     R5,R0
    349                chDbgAssert(!b, "spi_lld_start(), #5", "stream already allocated");
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0x2D00             CMP      R5,#+0
   \   000000AE   0xD002             BEQ.N    ??spi_lld_start_8
   \   000000B0   0x....             LDR.N    R0,??DataTable5_25
   \   000000B2   0x.... 0x....      BL       chDbgPanic
    350                b = dmaStreamAllocate(spip->dmatx,
    351                                      STM32_SPI_SPI3_IRQ_PRIORITY,
    352                                      (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
    353                                      (void *)spip);
   \                     ??spi_lld_start_8:
   \   000000B6   0x0023             MOVS     R3,R4
   \   000000B8   0x....             LDR.N    R2,??DataTable5_19
   \   000000BA   0x210A             MOVS     R1,#+10
   \   000000BC   0x6A60             LDR      R0,[R4, #+36]
   \   000000BE   0x.... 0x....      BL       dmaStreamAllocate
   \   000000C2   0x0005             MOVS     R5,R0
    354                chDbgAssert(!b, "spi_lld_start(), #6", "stream already allocated");
   \   000000C4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C6   0x2D00             CMP      R5,#+0
   \   000000C8   0xD002             BEQ.N    ??spi_lld_start_9
   \   000000CA   0x....             LDR.N    R0,??DataTable5_26
   \   000000CC   0x.... 0x....      BL       chDbgPanic
    355                rccEnableSPI3(FALSE);
   \                     ??spi_lld_start_9:
   \   000000D0   0x....             LDR.N    R0,??DataTable5_24  ;; 0x40023840
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000D8   0x....             LDR.N    R1,??DataTable5_24  ;; 0x40023840
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    356              }
    357          #endif
    358          #if STM32_SPI_USE_SPI4
    359              if (&SPID4 == spip) {
    360                bool_t b;
    361                b = dmaStreamAllocate(spip->dmarx,
    362                                      STM32_SPI_SPI4_IRQ_PRIORITY,
    363                                      (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
    364                                      (void *)spip);
    365                chDbgAssert(!b, "spi_lld_start(), #7", "stream already allocated");
    366                b = dmaStreamAllocate(spip->dmatx,
    367                                      STM32_SPI_SPI4_IRQ_PRIORITY,
    368                                      (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
    369                                      (void *)spip);
    370                chDbgAssert(!b, "spi_lld_start(), #8", "stream already allocated");
    371                rccEnableSPI4(FALSE);
    372              }
    373          #endif
    374          #if STM32_SPI_USE_SPI5
    375              if (&SPID5 == spip) {
    376                bool_t b;
    377                b = dmaStreamAllocate(spip->dmarx,
    378                                      STM32_SPI_SPI5_IRQ_PRIORITY,
    379                                      (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
    380                                      (void *)spip);
    381                chDbgAssert(!b, "spi_lld_start(), #9", "stream already allocated");
    382                b = dmaStreamAllocate(spip->dmatx,
    383                                      STM32_SPI_SPI5_IRQ_PRIORITY,
    384                                      (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
    385                                      (void *)spip);
    386                chDbgAssert(!b, "spi_lld_start(), #10", "stream already allocated");
    387                rccEnableSPI5(FALSE);
    388              }
    389          #endif
    390          #if STM32_SPI_USE_SPI6
    391              if (&SPID6 == spip) {
    392                bool_t b;
    393                b = dmaStreamAllocate(spip->dmarx,
    394                                      STM32_SPI_SPI6_IRQ_PRIORITY,
    395                                      (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
    396                                      (void *)spip);
    397                chDbgAssert(!b, "spi_lld_start(), #11", "stream already allocated");
    398                b = dmaStreamAllocate(spip->dmatx,
    399                                      STM32_SPI_SPI6_IRQ_PRIORITY,
    400                                      (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
    401                                      (void *)spip);
    402                chDbgAssert(!b, "spi_lld_start(), #12", "stream already allocated");
    403                rccEnableSPI6(FALSE);
    404              }
    405          #endif
    406          
    407              /* DMA setup.*/
    408              dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
   \                     ??spi_lld_start_7:
   \   000000DC   0x6A20             LDR      R0,[R4, #+32]
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x69E1             LDR      R1,[R4, #+28]
   \   000000E2   0x310C             ADDS     R1,R1,#+12
   \   000000E4   0x6081             STR      R1,[R0, #+8]
    409              dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
   \   000000E6   0x6A60             LDR      R0,[R4, #+36]
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x69E1             LDR      R1,[R4, #+28]
   \   000000EC   0x310C             ADDS     R1,R1,#+12
   \   000000EE   0x6081             STR      R1,[R0, #+8]
    410            }
    411          
    412            /* Configuration-specific DMA setup.*/
    413            if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
   \                     ??spi_lld_start_0:
   \   000000F0   0x6860             LDR      R0,[R4, #+4]
   \   000000F2   0x8940             LDRH     R0,[R0, #+10]
   \   000000F4   0x0500             LSLS     R0,R0,#+20
   \   000000F6   0xD408             BMI.N    ??spi_lld_start_10
    414              /* Frame width is 8 bits or smaller.*/
    415              spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
    416                                STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
   \   000000F8   0x6AA0             LDR      R0,[R4, #+40]
   \   000000FA   0xF430 0x40F0      BICS     R0,R0,#0x7800
   \   000000FE   0x62A0             STR      R0,[R4, #+40]
    417              spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
    418                                STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
   \   00000100   0x6AE0             LDR      R0,[R4, #+44]
   \   00000102   0xF430 0x40F0      BICS     R0,R0,#0x7800
   \   00000106   0x62E0             STR      R0,[R4, #+44]
   \   00000108   0xE009             B.N      ??spi_lld_start_11
    419            }
    420            else {
    421              /* Frame width is larger than 8 bits.*/
    422              spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
    423                                STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
   \                     ??spi_lld_start_10:
   \   0000010A   0x2005             MOVS     R0,#+5
   \   0000010C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000010E   0xF360 0x21CE      BFI      R1,R0,#+11,#+4
   \   00000112   0x62A1             STR      R1,[R4, #+40]
    424              spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
    425                                STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
   \   00000114   0x2005             MOVS     R0,#+5
   \   00000116   0x6AE1             LDR      R1,[R4, #+44]
   \   00000118   0xF360 0x21CE      BFI      R1,R0,#+11,#+4
   \   0000011C   0x62E1             STR      R1,[R4, #+44]
    426            }
    427            /* SPI setup and enable.*/
    428            spip->spi->CR1  = 0;
   \                     ??spi_lld_start_11:
   \   0000011E   0x69E0             LDR      R0,[R4, #+28]
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x8001             STRH     R1,[R0, #+0]
    429            spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
    430                              SPI_CR1_SSI;
   \   00000124   0x6860             LDR      R0,[R4, #+4]
   \   00000126   0x8940             LDRH     R0,[R0, #+10]
   \   00000128   0xF450 0x7041      ORRS     R0,R0,#0x304
   \   0000012C   0x69E1             LDR      R1,[R4, #+28]
   \   0000012E   0x8008             STRH     R0,[R1, #+0]
    431            spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
   \   00000130   0x69E0             LDR      R0,[R4, #+28]
   \   00000132   0x2107             MOVS     R1,#+7
   \   00000134   0x8081             STRH     R1,[R0, #+4]
    432            spip->spi->CR1 |= SPI_CR1_SPE;
   \   00000136   0x69E0             LDR      R0,[R4, #+28]
   \   00000138   0x8800             LDRH     R0,[R0, #+0]
   \   0000013A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000013E   0x69E1             LDR      R1,[R4, #+28]
   \   00000140   0x8008             STRH     R0,[R1, #+0]
    433          }
   \   00000142   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    434          
    435          /**
    436           * @brief   Deactivates the SPI peripheral.
    437           *
    438           * @param[in] spip      pointer to the @p SPIDriver object
    439           *
    440           * @notapi
    441           */

   \                                 In section .text, align 2, keep-with-next
    442          void spi_lld_stop(SPIDriver *spip) {
   \                     spi_lld_stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    443          
    444            /* If in ready state then disables the SPI clock.*/
    445            if (spip->state == SPI_READY) {
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD126             BNE.N    ??spi_lld_stop_0
    446          
    447              /* SPI disable.*/
    448              spip->spi->CR1 = 0;
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    449              spip->spi->CR2 = 0;
   \   00000010   0x69E0             LDR      R0,[R4, #+28]
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x8081             STRH     R1,[R0, #+4]
    450              dmaStreamRelease(spip->dmarx);
   \   00000016   0x6A20             LDR      R0,[R4, #+32]
   \   00000018   0x.... 0x....      BL       dmaStreamRelease
    451              dmaStreamRelease(spip->dmatx);
   \   0000001C   0x6A60             LDR      R0,[R4, #+36]
   \   0000001E   0x.... 0x....      BL       dmaStreamRelease
    452          
    453          #if STM32_SPI_USE_SPI1
    454              if (&SPID1 == spip)
   \   00000022   0x....             LDR.N    R0,??DataTable5_1
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD105             BNE.N    ??spi_lld_stop_1
    455                rccDisableSPI1(FALSE);
   \   00000028   0x....             LDR.N    R0,??DataTable5_21  ;; 0x40023844
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   00000030   0x....             LDR.N    R1,??DataTable5_21  ;; 0x40023844
   \   00000032   0x6008             STR      R0,[R1, #+0]
    456          #endif
    457          #if STM32_SPI_USE_SPI2
    458              if (&SPID2 == spip)
   \                     ??spi_lld_stop_1:
   \   00000034   0x....             LDR.N    R0,??DataTable5_7
   \   00000036   0x42A0             CMP      R0,R4
   \   00000038   0xD105             BNE.N    ??spi_lld_stop_2
    459                rccDisableSPI2(FALSE);
   \   0000003A   0x....             LDR.N    R0,??DataTable5_24  ;; 0x40023840
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000042   0x....             LDR.N    R1,??DataTable5_24  ;; 0x40023840
   \   00000044   0x6008             STR      R0,[R1, #+0]
    460          #endif
    461          #if STM32_SPI_USE_SPI3
    462              if (&SPID3 == spip)
   \                     ??spi_lld_stop_2:
   \   00000046   0x....             LDR.N    R0,??DataTable5_13
   \   00000048   0x42A0             CMP      R0,R4
   \   0000004A   0xD105             BNE.N    ??spi_lld_stop_0
    463                rccDisableSPI3(FALSE);
   \   0000004C   0x....             LDR.N    R0,??DataTable5_24  ;; 0x40023840
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000054   0x....             LDR.N    R1,??DataTable5_24  ;; 0x40023840
   \   00000056   0x6008             STR      R0,[R1, #+0]
    464          #endif
    465          #if STM32_SPI_USE_SPI4
    466              if (&SPID4 == spip)
    467                rccDisableSPI4(FALSE);
    468          #endif
    469          #if STM32_SPI_USE_SPI5
    470              if (&SPID5 == spip)
    471                rccDisableSPI5(FALSE);
    472          #endif
    473          #if STM32_SPI_USE_SPI6
    474              if (&SPID6 == spip)
    475                rccDisableSPI6(FALSE);
    476          #endif
    477            }
    478          }
   \                     ??spi_lld_stop_0:
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    479          
    480          /**
    481           * @brief   Asserts the slave select signal and prepares for transfers.
    482           *
    483           * @param[in] spip      pointer to the @p SPIDriver object
    484           *
    485           * @notapi
    486           */

   \                                 In section .text, align 2, keep-with-next
    487          void spi_lld_select(SPIDriver *spip) {
    488          
    489            palClearPad(spip->config->ssport, spip->config->sspad);
   \                     spi_lld_select:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0x8912             LDRH     R2,[R2, #+8]
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x6852             LDR      R2,[R2, #+4]
   \   0000000C   0x8351             STRH     R1,[R2, #+26]
    490          }
   \   0000000E   0x4770             BX       LR               ;; return
    491          
    492          /**
    493           * @brief   Deasserts the slave select signal.
    494           * @details The previously selected peripheral is unselected.
    495           *
    496           * @param[in] spip      pointer to the @p SPIDriver object
    497           *
    498           * @notapi
    499           */

   \                                 In section .text, align 2, keep-with-next
    500          void spi_lld_unselect(SPIDriver *spip) {
    501          
    502            palSetPad(spip->config->ssport, spip->config->sspad);
   \                     spi_lld_unselect:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   \   00000004   0x8912             LDRH     R2,[R2, #+8]
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x6852             LDR      R2,[R2, #+4]
   \   0000000C   0x8311             STRH     R1,[R2, #+24]
    503          }
   \   0000000E   0x4770             BX       LR               ;; return
    504          
    505          /**
    506           * @brief   Ignores data on the SPI bus.
    507           * @details This asynchronous function starts the transmission of a series of
    508           *          idle words on the SPI bus and ignores the received data.
    509           * @post    At the end of the operation the configured callback is invoked.
    510           *
    511           * @param[in] spip      pointer to the @p SPIDriver object
    512           * @param[in] n         number of words to be ignored
    513           *
    514           * @notapi
    515           */

   \                                 In section .text, align 2, keep-with-next
    516          void spi_lld_ignore(SPIDriver *spip, size_t n) {
    517          
    518            dmaStreamSetMemory0(spip->dmarx, &dummyrx);
   \                     spi_lld_ignore:
   \   00000000   0x6A02             LDR      R2,[R0, #+32]
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x....             LDR.N    R3,??DataTable5_27
   \   00000006   0x60D3             STR      R3,[R2, #+12]
    519            dmaStreamSetTransactionSize(spip->dmarx, n);
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x6051             STR      R1,[R2, #+4]
    520            dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x6A83             LDR      R3,[R0, #+40]
   \   00000014   0x6013             STR      R3,[R2, #+0]
    521          
    522            dmaStreamSetMemory0(spip->dmatx, &dummytx);
   \   00000016   0x6A42             LDR      R2,[R0, #+36]
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x....             LDR.N    R3,??DataTable5
   \   0000001C   0x60D3             STR      R3,[R2, #+12]
    523            dmaStreamSetTransactionSize(spip->dmatx, n);
   \   0000001E   0x6A42             LDR      R2,[R0, #+36]
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x6051             STR      R1,[R2, #+4]
    524            dmaStreamSetMode(spip->dmatx, spip->txdmamode);
   \   00000024   0x6A42             LDR      R2,[R0, #+36]
   \   00000026   0x6812             LDR      R2,[R2, #+0]
   \   00000028   0x6AC3             LDR      R3,[R0, #+44]
   \   0000002A   0x6013             STR      R3,[R2, #+0]
    525          
    526            dmaStreamEnable(spip->dmarx);
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000036   0x6A03             LDR      R3,[R0, #+32]
   \   00000038   0x681B             LDR      R3,[R3, #+0]
   \   0000003A   0x601A             STR      R2,[R3, #+0]
    527            dmaStreamEnable(spip->dmatx);
   \   0000003C   0x6A42             LDR      R2,[R0, #+36]
   \   0000003E   0x6812             LDR      R2,[R2, #+0]
   \   00000040   0x6812             LDR      R2,[R2, #+0]
   \   00000042   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000046   0x6A43             LDR      R3,[R0, #+36]
   \   00000048   0x681B             LDR      R3,[R3, #+0]
   \   0000004A   0x601A             STR      R2,[R3, #+0]
    528          }
   \   0000004C   0x4770             BX       LR               ;; return
    529          
    530          /**
    531           * @brief   Exchanges data on the SPI bus.
    532           * @details This asynchronous function starts a simultaneous transmit/receive
    533           *          operation.
    534           * @post    At the end of the operation the configured callback is invoked.
    535           * @note    The buffers are organized as uint8_t arrays for data sizes below or
    536           *          equal to 8 bits else it is organized as uint16_t arrays.
    537           *
    538           * @param[in] spip      pointer to the @p SPIDriver object
    539           * @param[in] n         number of words to be exchanged
    540           * @param[in] txbuf     the pointer to the transmit buffer
    541           * @param[out] rxbuf    the pointer to the receive buffer
    542           *
    543           * @notapi
    544           */

   \                                 In section .text, align 2, keep-with-next
    545          void spi_lld_exchange(SPIDriver *spip, size_t n,
    546                                const void *txbuf, void *rxbuf) {
   \                     spi_lld_exchange:
   \   00000000   0xB430             PUSH     {R4,R5}
    547          
    548            dmaStreamSetMemory0(spip->dmarx, rxbuf);
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0x6824             LDR      R4,[R4, #+0]
   \   00000006   0x60E3             STR      R3,[R4, #+12]
    549            dmaStreamSetTransactionSize(spip->dmarx, n);
   \   00000008   0x6A04             LDR      R4,[R0, #+32]
   \   0000000A   0x6824             LDR      R4,[R4, #+0]
   \   0000000C   0x6061             STR      R1,[R4, #+4]
    550            dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
   \   0000000E   0x6A84             LDR      R4,[R0, #+40]
   \   00000010   0xF454 0x6480      ORRS     R4,R4,#0x400
   \   00000014   0x6A05             LDR      R5,[R0, #+32]
   \   00000016   0x682D             LDR      R5,[R5, #+0]
   \   00000018   0x602C             STR      R4,[R5, #+0]
    551          
    552            dmaStreamSetMemory0(spip->dmatx, txbuf);
   \   0000001A   0x6A44             LDR      R4,[R0, #+36]
   \   0000001C   0x6824             LDR      R4,[R4, #+0]
   \   0000001E   0x60E2             STR      R2,[R4, #+12]
    553            dmaStreamSetTransactionSize(spip->dmatx, n);
   \   00000020   0x6A44             LDR      R4,[R0, #+36]
   \   00000022   0x6824             LDR      R4,[R4, #+0]
   \   00000024   0x6061             STR      R1,[R4, #+4]
    554            dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
   \   00000026   0x6AC4             LDR      R4,[R0, #+44]
   \   00000028   0xF454 0x6480      ORRS     R4,R4,#0x400
   \   0000002C   0x6A45             LDR      R5,[R0, #+36]
   \   0000002E   0x682D             LDR      R5,[R5, #+0]
   \   00000030   0x602C             STR      R4,[R5, #+0]
    555          
    556            dmaStreamEnable(spip->dmarx);
   \   00000032   0x6A04             LDR      R4,[R0, #+32]
   \   00000034   0x6824             LDR      R4,[R4, #+0]
   \   00000036   0x6824             LDR      R4,[R4, #+0]
   \   00000038   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   0000003C   0x6A05             LDR      R5,[R0, #+32]
   \   0000003E   0x682D             LDR      R5,[R5, #+0]
   \   00000040   0x602C             STR      R4,[R5, #+0]
    557            dmaStreamEnable(spip->dmatx);
   \   00000042   0x6A44             LDR      R4,[R0, #+36]
   \   00000044   0x6824             LDR      R4,[R4, #+0]
   \   00000046   0x6824             LDR      R4,[R4, #+0]
   \   00000048   0xF054 0x0401      ORRS     R4,R4,#0x1
   \   0000004C   0x6A45             LDR      R5,[R0, #+36]
   \   0000004E   0x682D             LDR      R5,[R5, #+0]
   \   00000050   0x602C             STR      R4,[R5, #+0]
    558          }
   \   00000052   0xBC30             POP      {R4,R5}
   \   00000054   0x4770             BX       LR               ;; return
    559          
    560          /**
    561           * @brief   Sends data over the SPI bus.
    562           * @details This asynchronous function starts a transmit operation.
    563           * @post    At the end of the operation the configured callback is invoked.
    564           * @note    The buffers are organized as uint8_t arrays for data sizes below or
    565           *          equal to 8 bits else it is organized as uint16_t arrays.
    566           *
    567           * @param[in] spip      pointer to the @p SPIDriver object
    568           * @param[in] n         number of words to send
    569           * @param[in] txbuf     the pointer to the transmit buffer
    570           *
    571           * @notapi
    572           */

   \                                 In section .text, align 2, keep-with-next
    573          void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
   \                     spi_lld_send:
   \   00000000   0xB410             PUSH     {R4}
    574          
    575            dmaStreamSetMemory0(spip->dmarx, &dummyrx);
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x....             LDR.N    R4,??DataTable5_27
   \   00000008   0x60DC             STR      R4,[R3, #+12]
    576            dmaStreamSetTransactionSize(spip->dmarx, n);
   \   0000000A   0x6A03             LDR      R3,[R0, #+32]
   \   0000000C   0x681B             LDR      R3,[R3, #+0]
   \   0000000E   0x6059             STR      R1,[R3, #+4]
    577            dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
   \   00000010   0x6A03             LDR      R3,[R0, #+32]
   \   00000012   0x681B             LDR      R3,[R3, #+0]
   \   00000014   0x6A84             LDR      R4,[R0, #+40]
   \   00000016   0x601C             STR      R4,[R3, #+0]
    578          
    579            dmaStreamSetMemory0(spip->dmatx, txbuf);
   \   00000018   0x6A43             LDR      R3,[R0, #+36]
   \   0000001A   0x681B             LDR      R3,[R3, #+0]
   \   0000001C   0x60DA             STR      R2,[R3, #+12]
    580            dmaStreamSetTransactionSize(spip->dmatx, n);
   \   0000001E   0x6A43             LDR      R3,[R0, #+36]
   \   00000020   0x681B             LDR      R3,[R3, #+0]
   \   00000022   0x6059             STR      R1,[R3, #+4]
    581            dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
   \   00000024   0x6AC3             LDR      R3,[R0, #+44]
   \   00000026   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   0000002A   0x6A44             LDR      R4,[R0, #+36]
   \   0000002C   0x6824             LDR      R4,[R4, #+0]
   \   0000002E   0x6023             STR      R3,[R4, #+0]
    582          
    583            dmaStreamEnable(spip->dmarx);
   \   00000030   0x6A03             LDR      R3,[R0, #+32]
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0x681B             LDR      R3,[R3, #+0]
   \   00000036   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   0000003A   0x6A04             LDR      R4,[R0, #+32]
   \   0000003C   0x6824             LDR      R4,[R4, #+0]
   \   0000003E   0x6023             STR      R3,[R4, #+0]
    584            dmaStreamEnable(spip->dmatx);
   \   00000040   0x6A43             LDR      R3,[R0, #+36]
   \   00000042   0x681B             LDR      R3,[R3, #+0]
   \   00000044   0x681B             LDR      R3,[R3, #+0]
   \   00000046   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   0000004A   0x6A44             LDR      R4,[R0, #+36]
   \   0000004C   0x6824             LDR      R4,[R4, #+0]
   \   0000004E   0x6023             STR      R3,[R4, #+0]
    585          }
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
    586          
    587          /**
    588           * @brief   Receives data from the SPI bus.
    589           * @details This asynchronous function starts a receive operation.
    590           * @post    At the end of the operation the configured callback is invoked.
    591           * @note    The buffers are organized as uint8_t arrays for data sizes below or
    592           *          equal to 8 bits else it is organized as uint16_t arrays.
    593           *
    594           * @param[in] spip      pointer to the @p SPIDriver object
    595           * @param[in] n         number of words to receive
    596           * @param[out] rxbuf    the pointer to the receive buffer
    597           *
    598           * @notapi
    599           */

   \                                 In section .text, align 2, keep-with-next
    600          void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
   \                     spi_lld_receive:
   \   00000000   0xB410             PUSH     {R4}
    601          
    602            dmaStreamSetMemory0(spip->dmarx, rxbuf);
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x60DA             STR      R2,[R3, #+12]
    603            dmaStreamSetTransactionSize(spip->dmarx, n);
   \   00000008   0x6A03             LDR      R3,[R0, #+32]
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0x6059             STR      R1,[R3, #+4]
    604            dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
   \   0000000E   0x6A83             LDR      R3,[R0, #+40]
   \   00000010   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   00000014   0x6A04             LDR      R4,[R0, #+32]
   \   00000016   0x6824             LDR      R4,[R4, #+0]
   \   00000018   0x6023             STR      R3,[R4, #+0]
    605          
    606            dmaStreamSetMemory0(spip->dmatx, &dummytx);
   \   0000001A   0x6A43             LDR      R3,[R0, #+36]
   \   0000001C   0x681B             LDR      R3,[R3, #+0]
   \   0000001E   0x....             LDR.N    R4,??DataTable5
   \   00000020   0x60DC             STR      R4,[R3, #+12]
    607            dmaStreamSetTransactionSize(spip->dmatx, n);
   \   00000022   0x6A43             LDR      R3,[R0, #+36]
   \   00000024   0x681B             LDR      R3,[R3, #+0]
   \   00000026   0x6059             STR      R1,[R3, #+4]
    608            dmaStreamSetMode(spip->dmatx, spip->txdmamode);
   \   00000028   0x6A43             LDR      R3,[R0, #+36]
   \   0000002A   0x681B             LDR      R3,[R3, #+0]
   \   0000002C   0x6AC4             LDR      R4,[R0, #+44]
   \   0000002E   0x601C             STR      R4,[R3, #+0]
    609          
    610            dmaStreamEnable(spip->dmarx);
   \   00000030   0x6A03             LDR      R3,[R0, #+32]
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0x681B             LDR      R3,[R3, #+0]
   \   00000036   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   0000003A   0x6A04             LDR      R4,[R0, #+32]
   \   0000003C   0x6824             LDR      R4,[R4, #+0]
   \   0000003E   0x6023             STR      R3,[R4, #+0]
    611            dmaStreamEnable(spip->dmatx);
   \   00000040   0x6A43             LDR      R3,[R0, #+36]
   \   00000042   0x681B             LDR      R3,[R3, #+0]
   \   00000044   0x681B             LDR      R3,[R3, #+0]
   \   00000046   0xF053 0x0301      ORRS     R3,R3,#0x1
   \   0000004A   0x6A44             LDR      R4,[R0, #+36]
   \   0000004C   0x6824             LDR      R4,[R4, #+0]
   \   0000004E   0x6023             STR      R3,[R4, #+0]
    612          }
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
    613          
    614          /**
    615           * @brief   Exchanges one frame using a polled wait.
    616           * @details This synchronous function exchanges one frame using a polled
    617           *          synchronization method. This function is useful when exchanging
    618           *          small amount of data on high speed channels, usually in this
    619           *          situation is much more efficient just wait for completion using
    620           *          polling than suspending the thread waiting for an interrupt.
    621           *
    622           * @param[in] spip      pointer to the @p SPIDriver object
    623           * @param[in] frame     the data frame to send over the SPI bus
    624           * @return              The received data frame from the SPI bus.
    625           */

   \                                 In section .text, align 2, keep-with-next
    626          uint16_t spi_lld_polled_exchange(SPIDriver *spip, uint16_t frame) {
    627          
    628            spip->spi->DR = frame;
   \                     spi_lld_polled_exchange:
   \   00000000   0x69C2             LDR      R2,[R0, #+28]
   \   00000002   0x8191             STRH     R1,[R2, #+12]
    629            while ((spip->spi->SR & SPI_SR_RXNE) == 0)
   \                     ??spi_lld_polled_exchange_0:
   \   00000004   0x69C2             LDR      R2,[R0, #+28]
   \   00000006   0x8912             LDRH     R2,[R2, #+8]
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD5FB             BPL.N    ??spi_lld_polled_exchange_0
    630              ;
    631            return spip->spi->DR;
   \   0000000C   0x69C0             LDR      R0,[R0, #+28]
   \   0000000E   0x8980             LDRH     R0,[R0, #+12]
   \   00000010   0x4770             BX       LR               ;; return
    632          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     dummytx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     SPID1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x06010016         DC32     0x6010016

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x06010046         DC32     0x6010046

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     SPID2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x00010016         DC32     0x10016

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x00010046         DC32     0x10046

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     SPID3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     _stm32_dma_streams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x........         DC32     _stm32_dma_streams+0x54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x........         DC32     spi_lld_serve_rx_interrupt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x........         DC32     `?<Constant "spi_lld_start(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     spi_lld_serve_tx_interrupt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x........         DC32     `?<Constant "spi_lld_start(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x........         DC32     `?<Constant "spi_lld_start(), #3">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x........         DC32     `?<Constant "spi_lld_start(), #4">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \   00000000   0x........         DC32     `?<Constant "spi_lld_start(), #5">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_26:
   \   00000000   0x........         DC32     `?<Constant "spi_lld_start(), #6">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_27:
   \   00000000   0x........         DC32     dummyrx

   \                                 In section .rodata, align 4
   \                     `?<Constant "spi_lld_start(), #1">`:
   \   00000000   0x73 0x70          DC8 "spi_lld_start(), #1"
   \              0x69 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spi_lld_start(), #2">`:
   \   00000000   0x73 0x70          DC8 "spi_lld_start(), #2"
   \              0x69 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x32 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spi_lld_start(), #3">`:
   \   00000000   0x73 0x70          DC8 "spi_lld_start(), #3"
   \              0x69 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x33 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spi_lld_start(), #4">`:
   \   00000000   0x73 0x70          DC8 "spi_lld_start(), #4"
   \              0x69 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x34 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spi_lld_start(), #5">`:
   \   00000000   0x73 0x70          DC8 "spi_lld_start(), #5"
   \              0x69 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x35 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "spi_lld_start(), #6">`:
   \   00000000   0x73 0x70          DC8 "spi_lld_start(), #6"
   \              0x69 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x73 0x74    
   \              0x61 0x72    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x36 0x00    
    633          
    634          #endif /* HAL_USE_SPI */
    635          
    636          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   spi_lld_exchange
       0   spi_lld_ignore
       8   spi_lld_init
         8   -> spiObjectInit
       0   spi_lld_polled_exchange
       4   spi_lld_receive
       0   spi_lld_select
       4   spi_lld_send
      16   spi_lld_serve_rx_interrupt
        16   -- Indirect call
        16   -> chSchReadyI
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
       0   spi_lld_serve_tx_interrupt
      16   spi_lld_start
        16   -> chDbgPanic
        16   -> dmaStreamAllocate
       8   spi_lld_stop
         8   -> dmaStreamRelease
       0   spi_lld_unselect


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "spi_lld_start(), #1">
      20  ?<Constant "spi_lld_start(), #2">
      20  ?<Constant "spi_lld_start(), #3">
      20  ?<Constant "spi_lld_start(), #4">
      20  ?<Constant "spi_lld_start(), #5">
      20  ?<Constant "spi_lld_start(), #6">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      48  SPID1
      48  SPID2
      48  SPID3
       2  dummyrx
       2  dummytx
      86  spi_lld_exchange
      78  spi_lld_ignore
     160  spi_lld_init
      18  spi_lld_polled_exchange
      84  spi_lld_receive
      16  spi_lld_select
      84  spi_lld_send
     176  spi_lld_serve_rx_interrupt
       6  spi_lld_serve_tx_interrupt
     324  spi_lld_start
      90  spi_lld_stop
      16  spi_lld_unselect

 
   148 bytes in section .bss
   120 bytes in section .rodata
 1 250 bytes in section .text
 
 1 250 bytes of CODE  memory
   120 bytes of CONST memory
   148 bytes of DATA  memory

Errors: none
Warnings: none
