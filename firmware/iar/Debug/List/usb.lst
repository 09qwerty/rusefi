###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:05 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\usb.c                                              #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\usb.c -lCN F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\Obj\ --no_cse --no_unroll --no_inline  #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\u #
#                       sb.lst                                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\us #
#                       b.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\usb.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    usb.c
     30           * @brief   USB Driver code.
     31           *
     32           * @addtogroup USB
     33           * @{
     34           */
     35          
     36          #include <string.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     37          
     38          #include "ch.h"
     39          #include "hal.h"
     40          #include "usb.h"
     41          
     42          #if HAL_USE_USB || defined(__DOXYGEN__)
     43          
     44          /*===========================================================================*/
     45          /* Driver local definitions.                                                 */
     46          /*===========================================================================*/
     47          
     48          /*===========================================================================*/
     49          /* Driver exported variables.                                                */
     50          /*===========================================================================*/
     51          
     52          /*===========================================================================*/
     53          /* Driver local variables and types.                                         */
     54          /*===========================================================================*/
     55          

   \                                 In section .rodata, align 2
     56          static const uint8_t zero_status[] = {0x00, 0x00};
   \                     zero_status:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
     57          static const uint8_t active_status[] ={0x00, 0x00};
   \                     active_status:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
     58          static const uint8_t halted_status[] = {0x01, 0x00};
   \                     halted_status:
   \   00000000   0x01 0x00          DC8 1, 0
     59          
     60          /*===========================================================================*/
     61          /* Driver local functions.                                                   */
     62          /*===========================================================================*/
     63          
     64          /**
     65           * @brief  SET ADDRESS transaction callback.
     66           *
     67           * @param[in] usbp      pointer to the @p USBDriver object
     68           */

   \                                 In section .text, align 2, keep-with-next
     69          static void set_address(USBDriver *usbp) {
   \                     set_address:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     70          
     71            usbp->address = usbp->setup[2];
   \   00000004   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \   00000008   0xF884 0x004E      STRB     R0,[R4, #+78]
     72            usb_lld_set_address(usbp);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       usb_lld_set_address
     73            _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??set_address_0
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x6862             LDR      R2,[R4, #+4]
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x4790             BLX      R2
     74            usbp->state = USB_SELECTED;
   \                     ??set_address_0:
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x7020             STRB     R0,[R4, #+0]
     75          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     76          
     77          /**
     78           * @brief   Standard requests handler.
     79           * @details This is the standard requests default handler, most standard
     80           *          requests are handled here, the user can override the standard
     81           *          handling using the @p requests_hook_cb hook in the
     82           *          @p USBConfig structure.
     83           *
     84           * @param[in] usbp      pointer to the @p USBDriver object
     85           * @return              The request handling exit code.
     86           * @retval FALSE        Request not recognized by the handler or error.
     87           * @retval TRUE         Request handled.
     88           */

   \                                 In section .text, align 2, keep-with-next
     89          static bool_t default_handler(USBDriver *usbp) {
   \                     default_handler:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     90            const USBDescriptor *dp;
     91          
     92            /* Decoding the request.*/
     93            switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
     94                                        USB_RTYPE_TYPE_MASK)) |
     95                     (usbp->setup[1] << 8))) {
   \   00000004   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000008   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000000C   0xF894 0x1045      LDRB     R1,[R4, #+69]
   \   00000010   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD026             BEQ.N    ??default_handler_0
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xF000 0x80AC      BEQ.W    ??default_handler_1
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xF000 0x80B2      BEQ.W    ??default_handler_2
   \   00000026   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000002A   0xD026             BEQ.N    ??default_handler_3
   \   0000002C   0xF5B0 0x7F81      CMP      R0,#+258
   \   00000030   0xF000 0x80EF      BEQ.W    ??default_handler_4
   \   00000034   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000038   0xD034             BEQ.N    ??default_handler_5
   \   0000003A   0xF240 0x3102      MOVW     R1,#+770
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xF000 0x810E      BEQ.W    ??default_handler_6
   \   00000044   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   00000048   0xD040             BEQ.N    ??default_handler_7
   \   0000004A   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   0000004E   0xD050             BEQ.N    ??default_handler_8
   \   00000050   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000054   0xD069             BEQ.N    ??default_handler_9
   \   00000056   0xF5B0 0x6F10      CMP      R0,#+2304
   \   0000005A   0xD06F             BEQ.N    ??default_handler_10
   \   0000005C   0xF640 0x4102      MOVW     R1,#+3074
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xF000 0x8089      BEQ.W    ??default_handler_1
   \   00000066   0xE122             B.N      ??default_handler_11
     96            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_STATUS << 8):
     97              /* Just returns the current status word.*/
     98              usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
   \                     ??default_handler_0:
   \   00000068   0xF114 0x004C      ADDS     R0,R4,#+76
   \   0000006C   0x63A0             STR      R0,[R4, #+56]
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x63E0             STR      R0,[R4, #+60]
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6420             STR      R0,[R4, #+64]
     99              return TRUE;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE11A             B.N      ??default_handler_12
    100            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_CLEAR_FEATURE << 8):
    101              /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
    102                 number is handled as an error.*/
    103              if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
   \                     ??default_handler_3:
   \   0000007A   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD10E             BNE.N    ??default_handler_13
    104                usbp->status &= ~2;
   \   00000082   0xF8B4 0x004C      LDRH     R0,[R4, #+76]
   \   00000086   0xF64F 0x71FD      MOVW     R1,#+65533
   \   0000008A   0x4008             ANDS     R0,R1,R0
   \   0000008C   0xF8A4 0x004C      STRH     R0,[R4, #+76]
    105                usbSetupTransfer(usbp, NULL, 0, NULL);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x63A0             STR      R0,[R4, #+56]
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x63E0             STR      R0,[R4, #+60]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x6420             STR      R0,[R4, #+64]
    106                return TRUE;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE107             B.N      ??default_handler_12
    107              }
    108              return FALSE;
   \                     ??default_handler_13:
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE105             B.N      ??default_handler_12
    109            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_FEATURE << 8):
    110              /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
    111                 number is handled as an error.*/
    112              if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
   \                     ??default_handler_5:
   \   000000A4   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \   000000A8   0x2801             CMP      R0,#+1
   \   000000AA   0xD10D             BNE.N    ??default_handler_14
    113                usbp->status |= 2;
   \   000000AC   0xF8B4 0x004C      LDRH     R0,[R4, #+76]
   \   000000B0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000B4   0xF8A4 0x004C      STRH     R0,[R4, #+76]
    114                usbSetupTransfer(usbp, NULL, 0, NULL);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x63A0             STR      R0,[R4, #+56]
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x63E0             STR      R0,[R4, #+60]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x6420             STR      R0,[R4, #+64]
    115                return TRUE;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xE0F3             B.N      ??default_handler_12
    116              }
    117              return FALSE;
   \                     ??default_handler_14:
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xE0F1             B.N      ??default_handler_12
    118            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_ADDRESS << 8):
    119              /* The SET_ADDRESS handling can be performed here or postponed after
    120                 the status packed depending on the USB_SET_ADDRESS_MODE low
    121                 driver setting.*/
    122          #if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    123              if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
    124                  (usbp->setup[1] == USB_REQ_SET_ADDRESS))
   \                     ??default_handler_7:
   \   000000CC   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD106             BNE.N    ??default_handler_15
   \   000000D4   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \   000000D8   0x2805             CMP      R0,#+5
   \   000000DA   0xD102             BNE.N    ??default_handler_15
    125                set_address(usbp);
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       set_address
    126              usbSetupTransfer(usbp, NULL, 0, NULL);
   \                     ??default_handler_15:
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x63A0             STR      R0,[R4, #+56]
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x63E0             STR      R0,[R4, #+60]
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x6420             STR      R0,[R4, #+64]
    127          #else
    128              usbSetupTransfer(usbp, NULL, 0, set_address);
    129          #endif
    130              return TRUE;
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0xE0DE             B.N      ??default_handler_12
    131            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_DESCRIPTOR << 8):
    132              /* Handling descriptor requests from the host.*/
    133              dp = usbp->config->get_descriptor_cb(
    134                     usbp, usbp->setup[3], usbp->setup[2],
    135                     usbFetchWord(&usbp->setup[4]));
   \                     ??default_handler_8:
   \   000000F2   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   000000F6   0xF894 0x1049      LDRB     R1,[R4, #+73]
   \   000000FA   0xEA50 0x2301      ORRS     R3,R0,R1, LSL #+8
   \   000000FE   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000100   0xF894 0x2046      LDRB     R2,[R4, #+70]
   \   00000104   0xF894 0x1047      LDRB     R1,[R4, #+71]
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x6866             LDR      R6,[R4, #+4]
   \   0000010C   0x6876             LDR      R6,[R6, #+4]
   \   0000010E   0x47B0             BLX      R6
   \   00000110   0x0005             MOVS     R5,R0
    136              if (dp == NULL)
   \   00000112   0x2D00             CMP      R5,#+0
   \   00000114   0xD101             BNE.N    ??default_handler_16
    137                return FALSE;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xE0CA             B.N      ??default_handler_12
    138              usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
   \                     ??default_handler_16:
   \   0000011A   0x6868             LDR      R0,[R5, #+4]
   \   0000011C   0x63A0             STR      R0,[R4, #+56]
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0x63E0             STR      R0,[R4, #+60]
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x6420             STR      R0,[R4, #+64]
    139              return TRUE;
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0xE0C2             B.N      ??default_handler_12
    140            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_CONFIGURATION << 8):
    141              /* Returning the last selected configuration.*/
    142              usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
   \                     ??default_handler_9:
   \   0000012A   0xF204 0x004F      ADDW     R0,R4,#+79
   \   0000012E   0x63A0             STR      R0,[R4, #+56]
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0x63E0             STR      R0,[R4, #+60]
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x6420             STR      R0,[R4, #+64]
    143              return TRUE;
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xE0B9             B.N      ??default_handler_12
    144            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_CONFIGURATION << 8):
    145              /* Handling configuration selection from the host.*/
    146              usbp->configuration = usbp->setup[2];
   \                     ??default_handler_10:
   \   0000013C   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \   00000140   0xF884 0x004F      STRB     R0,[R4, #+79]
    147              if (usbp->configuration == 0)
   \   00000144   0xF894 0x004F      LDRB     R0,[R4, #+79]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD102             BNE.N    ??default_handler_17
    148                usbp->state = USB_SELECTED;
   \   0000014C   0x2003             MOVS     R0,#+3
   \   0000014E   0x7020             STRB     R0,[R4, #+0]
   \   00000150   0xE001             B.N      ??default_handler_18
    149              else
    150                usbp->state = USB_ACTIVE;
   \                     ??default_handler_17:
   \   00000152   0x2004             MOVS     R0,#+4
   \   00000154   0x7020             STRB     R0,[R4, #+0]
    151              _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
   \                     ??default_handler_18:
   \   00000156   0x6860             LDR      R0,[R4, #+4]
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD004             BEQ.N    ??default_handler_19
   \   0000015E   0x2102             MOVS     R1,#+2
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x6862             LDR      R2,[R4, #+4]
   \   00000164   0x6812             LDR      R2,[R2, #+0]
   \   00000166   0x4790             BLX      R2
    152              usbSetupTransfer(usbp, NULL, 0, NULL);
   \                     ??default_handler_19:
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x63A0             STR      R0,[R4, #+56]
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x63E0             STR      R0,[R4, #+60]
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x6420             STR      R0,[R4, #+64]
    153              return TRUE;
   \   00000174   0x2001             MOVS     R0,#+1
   \   00000176   0xE09B             B.N      ??default_handler_12
    154            case USB_RTYPE_RECIPIENT_INTERFACE | (USB_REQ_GET_STATUS << 8):
    155            case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_SYNCH_FRAME << 8):
    156              /* Just sending two zero bytes, the application can change the behavior
    157                 using a hook..*/
    158              usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
   \                     ??default_handler_1:
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000017C   0x63A0             STR      R0,[R4, #+56]
   \   0000017E   0x2002             MOVS     R0,#+2
   \   00000180   0x63E0             STR      R0,[R4, #+60]
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x6420             STR      R0,[R4, #+64]
    159              return TRUE;
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0xE092             B.N      ??default_handler_12
    160            case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_GET_STATUS << 8):
    161              /* Sending the EP status.*/
    162              if (usbp->setup[4] & 0x80) {
   \                     ??default_handler_2:
   \   0000018A   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000018E   0x0600             LSLS     R0,R0,#+24
   \   00000190   0xD51F             BPL.N    ??default_handler_20
    163                switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0F)) {
   \   00000192   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000196   0xF010 0x010F      ANDS     R1,R0,#0xF
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x.... 0x....      BL       usb_lld_get_status_in
   \   000001A0   0x2801             CMP      R0,#+1
   \   000001A2   0xD002             BEQ.N    ??default_handler_21
   \   000001A4   0x2802             CMP      R0,#+2
   \   000001A6   0xD009             BEQ.N    ??default_handler_22
   \   000001A8   0xE011             B.N      ??default_handler_23
    164                case EP_STATUS_STALLED:
    165                  usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
   \                     ??default_handler_21:
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   000001AE   0x63A0             STR      R0,[R4, #+56]
   \   000001B0   0x2002             MOVS     R0,#+2
   \   000001B2   0x63E0             STR      R0,[R4, #+60]
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0x6420             STR      R0,[R4, #+64]
    166                  return TRUE;
   \   000001B8   0x2001             MOVS     R0,#+1
   \   000001BA   0xE079             B.N      ??default_handler_12
    167                case EP_STATUS_ACTIVE:
    168                  usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
   \                     ??default_handler_22:
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   000001C0   0x63A0             STR      R0,[R4, #+56]
   \   000001C2   0x2002             MOVS     R0,#+2
   \   000001C4   0x63E0             STR      R0,[R4, #+60]
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0x6420             STR      R0,[R4, #+64]
    169                  return TRUE;
   \   000001CA   0x2001             MOVS     R0,#+1
   \   000001CC   0xE070             B.N      ??default_handler_12
    170                default:
    171                  return FALSE;
   \                     ??default_handler_23:
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0xE06E             B.N      ??default_handler_12
    172                }
    173              }
    174              else {
    175                switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0F)) {
   \                     ??default_handler_20:
   \   000001D2   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   000001D6   0xF010 0x010F      ANDS     R1,R0,#0xF
   \   000001DA   0x0020             MOVS     R0,R4
   \   000001DC   0x.... 0x....      BL       usb_lld_get_status_out
   \   000001E0   0x2801             CMP      R0,#+1
   \   000001E2   0xD002             BEQ.N    ??default_handler_24
   \   000001E4   0x2802             CMP      R0,#+2
   \   000001E6   0xD009             BEQ.N    ??default_handler_25
   \   000001E8   0xE011             B.N      ??default_handler_26
    176                case EP_STATUS_STALLED:
    177                  usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
   \                     ??default_handler_24:
   \   000001EA   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   000001EE   0x63A0             STR      R0,[R4, #+56]
   \   000001F0   0x2002             MOVS     R0,#+2
   \   000001F2   0x63E0             STR      R0,[R4, #+60]
   \   000001F4   0x2000             MOVS     R0,#+0
   \   000001F6   0x6420             STR      R0,[R4, #+64]
    178                  return TRUE;
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0xE059             B.N      ??default_handler_12
    179                case EP_STATUS_ACTIVE:
    180                  usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
   \                     ??default_handler_25:
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000200   0x63A0             STR      R0,[R4, #+56]
   \   00000202   0x2002             MOVS     R0,#+2
   \   00000204   0x63E0             STR      R0,[R4, #+60]
   \   00000206   0x2000             MOVS     R0,#+0
   \   00000208   0x6420             STR      R0,[R4, #+64]
    181                  return TRUE;
   \   0000020A   0x2001             MOVS     R0,#+1
   \   0000020C   0xE050             B.N      ??default_handler_12
    182                default:
    183                  return FALSE;
   \                     ??default_handler_26:
   \   0000020E   0x2000             MOVS     R0,#+0
   \   00000210   0xE04E             B.N      ??default_handler_12
    184                }
    185              }
    186            case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_CLEAR_FEATURE << 8):
    187              /* Only ENDPOINT_HALT is handled as feature.*/
    188              if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
   \                     ??default_handler_4:
   \   00000212   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \   00000216   0x2800             CMP      R0,#+0
   \   00000218   0xD001             BEQ.N    ??default_handler_27
    189                return FALSE;
   \   0000021A   0x2000             MOVS     R0,#+0
   \   0000021C   0xE048             B.N      ??default_handler_12
    190              /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    191              if ((usbp->setup[4] & 0x0F) > 0) {
   \                     ??default_handler_27:
   \   0000021E   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000222   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000226   0x2801             CMP      R0,#+1
   \   00000228   0xDB12             BLT.N    ??default_handler_28
    192                if (usbp->setup[4] & 0x80)
   \   0000022A   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000022E   0x0600             LSLS     R0,R0,#+24
   \   00000230   0xD507             BPL.N    ??default_handler_29
    193                  usb_lld_clear_in(usbp, usbp->setup[4] & 0x0F);
   \   00000232   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000236   0xF010 0x010F      ANDS     R1,R0,#0xF
   \   0000023A   0x0020             MOVS     R0,R4
   \   0000023C   0x.... 0x....      BL       usb_lld_clear_in
   \   00000240   0xE006             B.N      ??default_handler_28
    194                else
    195                  usb_lld_clear_out(usbp, usbp->setup[4] & 0x0F);
   \                     ??default_handler_29:
   \   00000242   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000246   0xF010 0x010F      ANDS     R1,R0,#0xF
   \   0000024A   0x0020             MOVS     R0,R4
   \   0000024C   0x.... 0x....      BL       usb_lld_clear_out
    196              }
    197              usbSetupTransfer(usbp, NULL, 0, NULL);
   \                     ??default_handler_28:
   \   00000250   0x2000             MOVS     R0,#+0
   \   00000252   0x63A0             STR      R0,[R4, #+56]
   \   00000254   0x2000             MOVS     R0,#+0
   \   00000256   0x63E0             STR      R0,[R4, #+60]
   \   00000258   0x2000             MOVS     R0,#+0
   \   0000025A   0x6420             STR      R0,[R4, #+64]
    198              return TRUE;
   \   0000025C   0x2001             MOVS     R0,#+1
   \   0000025E   0xE027             B.N      ??default_handler_12
    199            case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_SET_FEATURE << 8):
    200              /* Only ENDPOINT_HALT is handled as feature.*/
    201              if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
   \                     ??default_handler_6:
   \   00000260   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \   00000264   0x2800             CMP      R0,#+0
   \   00000266   0xD001             BEQ.N    ??default_handler_30
    202                return FALSE;
   \   00000268   0x2000             MOVS     R0,#+0
   \   0000026A   0xE021             B.N      ??default_handler_12
    203              /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    204              if ((usbp->setup[4] & 0x0F) > 0) {
   \                     ??default_handler_30:
   \   0000026C   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000270   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000274   0x2801             CMP      R0,#+1
   \   00000276   0xDB12             BLT.N    ??default_handler_31
    205                if (usbp->setup[4] & 0x80)
   \   00000278   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   0000027C   0x0600             LSLS     R0,R0,#+24
   \   0000027E   0xD507             BPL.N    ??default_handler_32
    206                  usb_lld_stall_in(usbp, usbp->setup[4] & 0x0F);
   \   00000280   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000284   0xF010 0x010F      ANDS     R1,R0,#0xF
   \   00000288   0x0020             MOVS     R0,R4
   \   0000028A   0x.... 0x....      BL       usb_lld_stall_in
   \   0000028E   0xE006             B.N      ??default_handler_31
    207                else
    208                  usb_lld_stall_out(usbp, usbp->setup[4] & 0x0F);
   \                     ??default_handler_32:
   \   00000290   0xF894 0x0048      LDRB     R0,[R4, #+72]
   \   00000294   0xF010 0x010F      ANDS     R1,R0,#0xF
   \   00000298   0x0020             MOVS     R0,R4
   \   0000029A   0x.... 0x....      BL       usb_lld_stall_out
    209              }
    210              usbSetupTransfer(usbp, NULL, 0, NULL);
   \                     ??default_handler_31:
   \   0000029E   0x2000             MOVS     R0,#+0
   \   000002A0   0x63A0             STR      R0,[R4, #+56]
   \   000002A2   0x2000             MOVS     R0,#+0
   \   000002A4   0x63E0             STR      R0,[R4, #+60]
   \   000002A6   0x2000             MOVS     R0,#+0
   \   000002A8   0x6420             STR      R0,[R4, #+64]
    211              return TRUE;
   \   000002AA   0x2001             MOVS     R0,#+1
   \   000002AC   0xE000             B.N      ??default_handler_12
    212            case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_DESCRIPTOR << 8):
    213            case USB_RTYPE_RECIPIENT_INTERFACE | (USB_REQ_CLEAR_FEATURE << 8):
    214            case USB_RTYPE_RECIPIENT_INTERFACE | (USB_REQ_SET_FEATURE << 8):
    215            case USB_RTYPE_RECIPIENT_INTERFACE | (USB_REQ_GET_INTERFACE << 8):
    216            case USB_RTYPE_RECIPIENT_INTERFACE | (USB_REQ_SET_INTERFACE << 8):
    217              /* All the above requests are not handled here, if you need them then
    218                 use the hook mechanism and provide handling.*/
    219            default:
    220              return FALSE;
   \                     ??default_handler_11:
   \   000002AE   0x2000             MOVS     R0,#+0
   \                     ??default_handler_12:
   \   000002B0   0xBD70             POP      {R4-R6,PC}       ;; return
    221            }
    222          }
    223          
    224          /*===========================================================================*/
    225          /* Driver exported functions.                                                */
    226          /*===========================================================================*/
    227          
    228          /**
    229           * @brief   USB Driver initialization.
    230           * @note    This function is implicitly invoked by @p halInit(), there is
    231           *          no need to explicitly initialize the driver.
    232           *
    233           * @init
    234           */

   \                                 In section .text, align 2, keep-with-next
    235          void usbInit(void) {
   \                     usbInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    236          
    237            usb_lld_init();
   \   00000002   0x.... 0x....      BL       usb_lld_init
    238          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    239          
    240          /**
    241           * @brief   Initializes the standard part of a @p USBDriver structure.
    242           *
    243           * @param[out] usbp     pointer to the @p USBDriver object
    244           *
    245           * @init
    246           */

   \                                 In section .text, align 2, keep-with-next
    247          void usbObjectInit(USBDriver *usbp) {
    248            unsigned i;
    249          
    250            usbp->state        = USB_STOP;
   \                     usbObjectInit:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x7002             STRB     R2,[R0, #+0]
    251            usbp->config       = NULL;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6042             STR      R2,[R0, #+4]
    252            for (i = 0; i < USB_MAX_ENDPOINTS; i++) {
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x0011             MOVS     R1,R2
   \                     ??usbObjectInit_0:
   \   0000000C   0x2903             CMP      R1,#+3
   \   0000000E   0xD209             BCS.N    ??usbObjectInit_1
    253              usbp->in_params[i]  = NULL;
   \   00000010   0xEB10 0x0281      ADDS     R2,R0,R1, LSL #+2
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x61D3             STR      R3,[R2, #+28]
    254              usbp->out_params[i] = NULL;
   \   00000018   0xEB10 0x0281      ADDS     R2,R0,R1, LSL #+2
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x6293             STR      R3,[R2, #+40]
    255            }
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \   00000022   0xE7F3             B.N      ??usbObjectInit_0
    256            usbp->transmitting = 0;
   \                     ??usbObjectInit_1:
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x8102             STRH     R2,[R0, #+8]
    257            usbp->receiving    = 0;
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x8142             STRH     R2,[R0, #+10]
    258          }
   \   0000002C   0x4770             BX       LR               ;; return
    259          
    260          /**
    261           * @brief   Configures and activates the USB peripheral.
    262           *
    263           * @param[in] usbp      pointer to the @p USBDriver object
    264           * @param[in] config    pointer to the @p USBConfig object
    265           *
    266           * @api
    267           */

   \                                 In section .text, align 2, keep-with-next
    268          void usbStart(USBDriver *usbp, const USBConfig *config) {
   \                     usbStart:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    269            unsigned i;
    270          
    271            chDbgCheck((usbp != NULL) && (config != NULL), "usbStart");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??usbStart_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD105             BNE.N    ??usbStart_1
   \                     ??usbStart_0:
   \   0000000E   0xF240 0x120F      MOVW     R2,#+271
   \   00000012   0x....             LDR.N    R1,??DataTable8_3
   \   00000014   0x....             LDR.N    R0,??DataTable8_4
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    272          
    273            chSysLock();
   \                     ??usbStart_1:
   \   0000001A   0x2020             MOVS     R0,#+32
   \   0000001C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000020   0x.... 0x....      BL       dbg_check_lock
    274            chDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
    275                        "usbStart(), #1", "invalid state");
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD005             BEQ.N    ??usbStart_2
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD002             BEQ.N    ??usbStart_2
   \   00000030   0x....             LDR.N    R0,??DataTable8_5
   \   00000032   0x.... 0x....      BL       chDbgPanic
    276            usbp->config = config;
   \                     ??usbStart_2:
   \   00000036   0x6065             STR      R5,[R4, #+4]
    277            for (i = 0; i <= USB_MAX_ENDPOINTS; i++)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0006             MOVS     R6,R0
   \                     ??usbStart_3:
   \   0000003C   0x2E04             CMP      R6,#+4
   \   0000003E   0xD205             BCS.N    ??usbStart_4
    278              usbp->epc[i] = NULL;
   \   00000040   0xEB14 0x0086      ADDS     R0,R4,R6, LSL #+2
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x60C1             STR      R1,[R0, #+12]
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \   0000004A   0xE7F7             B.N      ??usbStart_3
    279            usb_lld_start(usbp);
   \                     ??usbStart_4:
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       usb_lld_start
    280            usbp->state = USB_READY;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    281            chSysUnlock();
   \   00000056   0x.... 0x....      BL       dbg_check_unlock
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF380 0x8811      MSR      BASEPRI,R0
    282          }
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    283          
    284          /**
    285           * @brief   Deactivates the USB peripheral.
    286           *
    287           * @param[in] usbp      pointer to the @p USBDriver object
    288           *
    289           * @api
    290           */

   \                                 In section .text, align 2, keep-with-next
    291          void usbStop(USBDriver *usbp) {
   \                     usbStop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    292          
    293            chDbgCheck(usbp != NULL, "usbStop");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??usbStop_0
   \   00000008   0xF240 0x1225      MOVW     R2,#+293
   \   0000000C   0x....             LDR.N    R1,??DataTable8_3
   \   0000000E   0x....             LDR.N    R0,??DataTable8_6
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    294          
    295            chSysLock();
   \                     ??usbStop_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    296            chDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
    297                        (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE),
    298                        "usbStop(), #1", "invalid state");
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD00B             BEQ.N    ??usbStop_1
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD008             BEQ.N    ??usbStop_1
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD005             BEQ.N    ??usbStop_1
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD002             BEQ.N    ??usbStop_1
   \   00000036   0x....             LDR.N    R0,??DataTable8_7
   \   00000038   0x.... 0x....      BL       chDbgPanic
    299            usb_lld_stop(usbp);
   \                     ??usbStop_1:
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       usb_lld_stop
    300            usbp->state = USB_STOP;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x7020             STRB     R0,[R4, #+0]
    301            chSysUnlock();
   \   00000046   0x.... 0x....      BL       dbg_check_unlock
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF380 0x8811      MSR      BASEPRI,R0
    302          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    303          
    304          /**
    305           * @brief   Enables an endpoint.
    306           * @details This function enables an endpoint, both IN and/or OUT directions
    307           *          depending on the configuration structure.
    308           * @note    This function must be invoked in response of a SET_CONFIGURATION
    309           *          or SET_INTERFACE message.
    310           *
    311           * @param[in] usbp      pointer to the @p USBDriver object
    312           * @param[in] ep        endpoint number
    313           * @param[in] epcp      the endpoint configuration
    314           *
    315           * @iclass
    316           */

   \                                 In section .text, align 2, keep-with-next
    317          void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
    318                                const USBEndpointConfig *epcp) {
   \                     usbInitEndpointI:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    319          
    320            chDbgCheckClassI();
   \   00000008   0x.... 0x....      BL       chDbgCheckClassI
    321            chDbgCheck((usbp != NULL) && (epcp != NULL), "usbInitEndpointI");
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??usbInitEndpointI_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD105             BNE.N    ??usbInitEndpointI_1
   \                     ??usbInitEndpointI_0:
   \   00000014   0xF240 0x1241      MOVW     R2,#+321
   \   00000018   0x....             LDR.N    R1,??DataTable8_3
   \   0000001A   0x....             LDR.N    R0,??DataTable8_8
   \   0000001C   0x.... 0x....      BL       chDbgPanic3
    322            chDbgAssert(usbp->state == USB_ACTIVE,
    323                        "usbEnableEndpointI(), #1", "invalid state");
   \                     ??usbInitEndpointI_1:
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xD002             BEQ.N    ??usbInitEndpointI_2
   \   00000026   0x....             LDR.N    R0,??DataTable8_9
   \   00000028   0x.... 0x....      BL       chDbgPanic
    324            chDbgAssert(usbp->epc[ep] == NULL,
    325                        "usbEnableEndpointI(), #2", "already initialized");
   \                     ??usbInitEndpointI_2:
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ.N    ??usbInitEndpointI_3
   \   00000038   0x....             LDR.N    R0,??DataTable8_10
   \   0000003A   0x.... 0x....      BL       chDbgPanic
    326          
    327            /* Logically enabling the endpoint in the USBDriver structure.*/
    328            if (epcp->in_state != NULL)
   \                     ??usbInitEndpointI_3:
   \   0000003E   0x6970             LDR      R0,[R6, #+20]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??usbInitEndpointI_4
    329              memset(epcp->in_state, 0, sizeof(USBInEndpointState));
   \   00000044   0x2214             MOVS     R2,#+20
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x6970             LDR      R0,[R6, #+20]
   \   0000004A   0x.... 0x....      BL       memset
    330            if (epcp->out_state != NULL)
   \                     ??usbInitEndpointI_4:
   \   0000004E   0x69B0             LDR      R0,[R6, #+24]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD004             BEQ.N    ??usbInitEndpointI_5
    331              memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x69B0             LDR      R0,[R6, #+24]
   \   0000005A   0x.... 0x....      BL       memset
    332          
    333            usbp->epc[ep] = epcp;
   \                     ??usbInitEndpointI_5:
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000064   0x60C6             STR      R6,[R0, #+12]
    334          
    335            /* Low level endpoint activation.*/
    336            usb_lld_init_endpoint(usbp, ep);
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       usb_lld_init_endpoint
    337          }
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    338          
    339          /**
    340           * @brief   Disables all the active endpoints.
    341           * @details This function disables all the active endpoints except the
    342           *          endpoint zero.
    343           * @note    This function must be invoked in response of a SET_CONFIGURATION
    344           *          message with configuration number zero.
    345           *
    346           * @param[in] usbp      pointer to the @p USBDriver object
    347           *
    348           * @iclass
    349           */

   \                                 In section .text, align 2, keep-with-next
    350          void usbDisableEndpointsI(USBDriver *usbp) {
   \                     usbDisableEndpointsI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    351            unsigned i;
    352          
    353            chDbgCheckClassI();
   \   00000004   0x.... 0x....      BL       chDbgCheckClassI
    354            chDbgCheck(usbp != NULL, "usbDisableEndpointsI");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD105             BNE.N    ??usbDisableEndpointsI_0
   \   0000000C   0xF44F 0x72B1      MOV      R2,#+354
   \   00000010   0x....             LDR.N    R1,??DataTable8_3
   \   00000012   0x....             LDR.N    R0,??DataTable8_11
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    355            chDbgAssert(usbp->state == USB_SELECTED,
    356                        "usbDisableEndpointsI(), #1", "invalid state");
   \                     ??usbDisableEndpointsI_0:
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD002             BEQ.N    ??usbDisableEndpointsI_1
   \   0000001E   0x....             LDR.N    R0,??DataTable8_12
   \   00000020   0x.... 0x....      BL       chDbgPanic
    357          
    358            usbp->transmitting &= ~1;
   \                     ??usbDisableEndpointsI_1:
   \   00000024   0x8920             LDRH     R0,[R4, #+8]
   \   00000026   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000002A   0x4008             ANDS     R0,R1,R0
   \   0000002C   0x8120             STRH     R0,[R4, #+8]
    359            usbp->receiving    &= ~1;
   \   0000002E   0x8960             LDRH     R0,[R4, #+10]
   \   00000030   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000034   0x4008             ANDS     R0,R1,R0
   \   00000036   0x8160             STRH     R0,[R4, #+10]
    360            for (i = 1; i <= USB_MAX_ENDPOINTS; i++)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x0005             MOVS     R5,R0
   \                     ??usbDisableEndpointsI_2:
   \   0000003C   0x2D04             CMP      R5,#+4
   \   0000003E   0xD205             BCS.N    ??usbDisableEndpointsI_3
    361              usbp->epc[i] = NULL;
   \   00000040   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x60C1             STR      R1,[R0, #+12]
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
   \   0000004A   0xE7F7             B.N      ??usbDisableEndpointsI_2
    362          
    363            /* Low level endpoints deactivation.*/
    364            usb_lld_disable_endpoints(usbp);
   \                     ??usbDisableEndpointsI_3:
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       usb_lld_disable_endpoints
    365          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    366          
    367          /**
    368           * @brief   Prepares for a receive transaction on an OUT endpoint.
    369           * @post    The endpoint is ready for @p usbStartReceiveI().
    370           * @note    This function can be called both in ISR and thread context.
    371           *
    372           * @param[in] usbp      pointer to the @p USBDriver object
    373           * @param[in] ep        endpoint number
    374           * @param[out] buf      buffer where to copy the received data
    375           * @param[in] n         transaction size
    376           *
    377           * @special
    378           */

   \                                 In section .text, align 2, keep-with-next
    379          void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
   \                     usbPrepareReceive:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    380            USBOutEndpointState *osp = usbp->epc[ep]->out_state;
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF8D0 0x8018      LDR      R8,[R0, #+24]
    381          
    382            osp->rxqueued           = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF888 0x0000      STRB     R0,[R8, #+0]
    383            osp->mode.linear.rxbuf  = buf;
   \   0000001E   0xF8C8 0x600C      STR      R6,[R8, #+12]
    384            osp->rxsize             = n;
   \   00000022   0xF8C8 0x7004      STR      R7,[R8, #+4]
    385            osp->rxcnt              = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8C8 0x0008      STR      R0,[R8, #+8]
    386          
    387            usb_lld_prepare_receive(usbp, ep);
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       usb_lld_prepare_receive
    388          }
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    389          
    390          /**
    391           * @brief   Prepares for a transmit transaction on an IN endpoint.
    392           * @post    The endpoint is ready for @p usbStartTransmitI().
    393           * @note    This function can be called both in ISR and thread context.
    394           * @note    The queue must contain at least the amount of data specified
    395           *          as transaction size.
    396           *
    397           * @param[in] usbp      pointer to the @p USBDriver object
    398           * @param[in] ep        endpoint number
    399           * @param[in] buf       buffer where to fetch the data to be transmitted
    400           * @param[in] n         transaction size
    401           *
    402           * @special
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
    405                                  const uint8_t *buf, size_t n) {
   \                     usbPrepareTransmit:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    406            USBInEndpointState *isp = usbp->epc[ep]->in_state;
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF8D0 0x8014      LDR      R8,[R0, #+20]
    407          
    408            isp->txqueued           = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF888 0x0000      STRB     R0,[R8, #+0]
    409            isp->mode.linear.txbuf  = buf;
   \   0000001E   0xF8C8 0x600C      STR      R6,[R8, #+12]
    410            isp->txsize             = n;
   \   00000022   0xF8C8 0x7004      STR      R7,[R8, #+4]
    411            isp->txcnt              = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8C8 0x0008      STR      R0,[R8, #+8]
    412          
    413            usb_lld_prepare_transmit(usbp, ep);
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       usb_lld_prepare_transmit
    414          }
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    415          
    416          /**
    417           * @brief   Prepares for a receive transaction on an OUT endpoint.
    418           * @post    The endpoint is ready for @p usbStartReceiveI().
    419           * @note    This function can be called both in ISR and thread context.
    420           * @note    The queue must have enough free space to accommodate the
    421           *          specified transaction size rounded to the next packet size
    422           *          boundary. For example if the transaction size is 1 and the
    423           *          packet size is 64 then the queue must have space for at least
    424           *          64 bytes.
    425           *
    426           * @param[in] usbp      pointer to the @p USBDriver object
    427           * @param[in] ep        endpoint number
    428           * @param[in] iqp       input queue to be filled with incoming data
    429           * @param[in] n         transaction size
    430           *
    431           * @special
    432           */

   \                                 In section .text, align 2, keep-with-next
    433          void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
    434                                       InputQueue *iqp, size_t n) {
   \                     usbPrepareQueuedReceive:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    435            USBOutEndpointState *osp = usbp->epc[ep]->out_state;
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF8D0 0x8018      LDR      R8,[R0, #+24]
    436          
    437            osp->rxqueued           = TRUE;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF888 0x0000      STRB     R0,[R8, #+0]
    438            osp->mode.queue.rxqueue = iqp;
   \   0000001E   0xF8C8 0x600C      STR      R6,[R8, #+12]
    439            osp->rxsize             = n;
   \   00000022   0xF8C8 0x7004      STR      R7,[R8, #+4]
    440            osp->rxcnt              = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8C8 0x0008      STR      R0,[R8, #+8]
    441          
    442            usb_lld_prepare_receive(usbp, ep);
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       usb_lld_prepare_receive
    443          }
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    444          
    445          /**
    446           * @brief   Prepares for a transmit transaction on an IN endpoint.
    447           * @post    The endpoint is ready for @p usbStartTransmitI().
    448           * @note    This function can be called both in ISR and thread context.
    449           * @note    The transmit transaction size is equal to the data contained
    450           *          in the queue.
    451           *
    452           * @param[in] usbp      pointer to the @p USBDriver object
    453           * @param[in] ep        endpoint number
    454           * @param[in] oqp       output queue to be fetched for outgoing data
    455           * @param[in] n         transaction size
    456           *
    457           * @special
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
    460                                        OutputQueue *oqp, size_t n) {
   \                     usbPrepareQueuedTransmit:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    461            USBInEndpointState *isp = usbp->epc[ep]->in_state;
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF8D0 0x8014      LDR      R8,[R0, #+20]
    462          
    463            isp->txqueued           = TRUE;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF888 0x0000      STRB     R0,[R8, #+0]
    464            isp->mode.queue.txqueue = oqp;
   \   0000001E   0xF8C8 0x600C      STR      R6,[R8, #+12]
    465            isp->txsize             = n;
   \   00000022   0xF8C8 0x7004      STR      R7,[R8, #+4]
    466            isp->txcnt              = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8C8 0x0008      STR      R0,[R8, #+8]
    467          
    468            usb_lld_prepare_transmit(usbp, ep);
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       usb_lld_prepare_transmit
    469          }
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    470          
    471          /**
    472           * @brief   Starts a receive transaction on an OUT endpoint.
    473           * @post    The endpoint callback is invoked when the transfer has been
    474           *          completed.
    475           *
    476           * @param[in] usbp      pointer to the @p USBDriver object
    477           * @param[in] ep        endpoint number
    478           *
    479           * @return              The operation status.
    480           * @retval FALSE        Operation started successfully.
    481           * @retval TRUE         Endpoint busy, operation not started.
    482           *
    483           * @iclass
    484           */

   \                                 In section .text, align 2, keep-with-next
    485          bool_t usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
   \                     usbStartReceiveI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    486          
    487            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    488            chDbgCheck(usbp != NULL, "usbStartReceiveI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??usbStartReceiveI_0
   \   0000000E   0xF44F 0x72F4      MOV      R2,#+488
   \   00000012   0x....             LDR.N    R1,??DataTable8_3
   \   00000014   0x....             LDR.N    R0,??DataTable8_13
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    489          
    490            if (usbGetReceiveStatusI(usbp, ep))
   \                     ??usbStartReceiveI_0:
   \   0000001A   0x8960             LDRH     R0,[R4, #+10]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x40A9             LSLS     R1,R1,R5
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD001             BEQ.N    ??usbStartReceiveI_1
    491              return TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE00A             B.N      ??usbStartReceiveI_2
    492          
    493            usbp->receiving |= (1 << ep);
   \                     ??usbStartReceiveI_1:
   \   00000028   0x8960             LDRH     R0,[R4, #+10]
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x40A9             LSLS     R1,R1,R5
   \   0000002E   0x4308             ORRS     R0,R1,R0
   \   00000030   0x8160             STRH     R0,[R4, #+10]
    494            usb_lld_start_out(usbp, ep);
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       usb_lld_start_out
    495            return FALSE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??usbStartReceiveI_2:
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    496          }
    497          
    498          /**
    499           * @brief   Starts a transmit transaction on an IN endpoint.
    500           * @post    The endpoint callback is invoked when the transfer has been
    501           *          completed.
    502           *
    503           * @param[in] usbp      pointer to the @p USBDriver object
    504           * @param[in] ep        endpoint number
    505           *
    506           * @return              The operation status.
    507           * @retval FALSE        Operation started successfully.
    508           * @retval TRUE         Endpoint busy, operation not started.
    509           *
    510           * @iclass
    511           */

   \                                 In section .text, align 2, keep-with-next
    512          bool_t usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
   \                     usbStartTransmitI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    513          
    514            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    515            chDbgCheck(usbp != NULL, "usbStartTransmitI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??usbStartTransmitI_0
   \   0000000E   0xF240 0x2203      MOVW     R2,#+515
   \   00000012   0x....             LDR.N    R1,??DataTable8_3
   \   00000014   0x....             LDR.N    R0,??DataTable8_14
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    516          
    517            if (usbGetTransmitStatusI(usbp, ep))
   \                     ??usbStartTransmitI_0:
   \   0000001A   0x8920             LDRH     R0,[R4, #+8]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x40A9             LSLS     R1,R1,R5
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD001             BEQ.N    ??usbStartTransmitI_1
    518              return TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE00A             B.N      ??usbStartTransmitI_2
    519          
    520            usbp->transmitting |= (1 << ep);
   \                     ??usbStartTransmitI_1:
   \   00000028   0x8920             LDRH     R0,[R4, #+8]
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x40A9             LSLS     R1,R1,R5
   \   0000002E   0x4308             ORRS     R0,R1,R0
   \   00000030   0x8120             STRH     R0,[R4, #+8]
    521            usb_lld_start_in(usbp, ep);
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       usb_lld_start_in
    522            return FALSE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??usbStartTransmitI_2:
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    523          }
    524          
    525          /**
    526           * @brief   Stalls an OUT endpoint.
    527           *
    528           * @param[in] usbp      pointer to the @p USBDriver object
    529           * @param[in] ep        endpoint number
    530           *
    531           * @return              The operation status.
    532           * @retval FALSE        Endpoint stalled.
    533           * @retval TRUE         Endpoint busy, not stalled.
    534           *
    535           * @iclass
    536           */

   \                                 In section .text, align 2, keep-with-next
    537          bool_t usbStallReceiveI(USBDriver *usbp, usbep_t ep) {
   \                     usbStallReceiveI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    538          
    539            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    540            chDbgCheck(usbp != NULL, "usbStallReceiveI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??usbStallReceiveI_0
   \   0000000E   0xF44F 0x7207      MOV      R2,#+540
   \   00000012   0x....             LDR.N    R1,??DataTable8_3
   \   00000014   0x....             LDR.N    R0,??DataTable8_15
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    541          
    542            if (usbGetReceiveStatusI(usbp, ep))
   \                     ??usbStallReceiveI_0:
   \   0000001A   0x8960             LDRH     R0,[R4, #+10]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x40A9             LSLS     R1,R1,R5
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD001             BEQ.N    ??usbStallReceiveI_1
    543              return TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE005             B.N      ??usbStallReceiveI_2
    544          
    545            usb_lld_stall_out(usbp, ep);
   \                     ??usbStallReceiveI_1:
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       usb_lld_stall_out
    546            return FALSE;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??usbStallReceiveI_2:
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    547          }
    548          
    549          /**
    550           * @brief   Stalls an IN endpoint.
    551           *
    552           * @param[in] usbp      pointer to the @p USBDriver object
    553           * @param[in] ep        endpoint number
    554           *
    555           * @return              The operation status.
    556           * @retval FALSE        Endpoint stalled.
    557           * @retval TRUE         Endpoint busy, not stalled.
    558           *
    559           * @iclass
    560           */

   \                                 In section .text, align 2, keep-with-next
    561          bool_t usbStallTransmitI(USBDriver *usbp, usbep_t ep) {
   \                     usbStallTransmitI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    562          
    563            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    564            chDbgCheck(usbp != NULL, "usbStallTransmitI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??usbStallTransmitI_0
   \   0000000E   0xF44F 0x720D      MOV      R2,#+564
   \   00000012   0x....             LDR.N    R1,??DataTable8_3
   \   00000014   0x....             LDR.N    R0,??DataTable8_16
   \   00000016   0x.... 0x....      BL       chDbgPanic3
    565          
    566            if (usbGetTransmitStatusI(usbp, ep))
   \                     ??usbStallTransmitI_0:
   \   0000001A   0x8920             LDRH     R0,[R4, #+8]
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x40A9             LSLS     R1,R1,R5
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD001             BEQ.N    ??usbStallTransmitI_1
    567              return TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE005             B.N      ??usbStallTransmitI_2
    568          
    569            usb_lld_stall_in(usbp, ep);
   \                     ??usbStallTransmitI_1:
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       usb_lld_stall_in
    570            return FALSE;
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??usbStallTransmitI_2:
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    571          }
    572          
    573          /**
    574           * @brief   USB reset routine.
    575           * @details This function must be invoked when an USB bus reset condition is
    576           *          detected.
    577           *
    578           * @param[in] usbp      pointer to the @p USBDriver object
    579           *
    580           * @notapi
    581           */

   \                                 In section .text, align 2, keep-with-next
    582          void _usb_reset(USBDriver *usbp) {
   \                     _usb_reset:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    583            unsigned i;
    584          
    585            usbp->state         = USB_READY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    586            usbp->status        = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8A4 0x004C      STRH     R0,[R4, #+76]
    587            usbp->address       = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF884 0x004E      STRB     R0,[R4, #+78]
    588            usbp->configuration = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x004F      STRB     R0,[R4, #+79]
    589            usbp->transmitting  = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x8120             STRH     R0,[R4, #+8]
    590            usbp->receiving     = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x8160             STRH     R0,[R4, #+10]
    591          
    592            /* Invalidates all endpoints into the USBDriver structure.*/
    593            for (i = 0; i <= USB_MAX_ENDPOINTS; i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
   \                     ??_usb_reset_0:
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xD205             BCS.N    ??_usb_reset_1
    594              usbp->epc[i] = NULL;
   \   0000002A   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x60C1             STR      R1,[R0, #+12]
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xE7F7             B.N      ??_usb_reset_0
    595          
    596            /* EP0 state machine initialization.*/
    597            usbp->ep0state = USB_EP0_WAITING_SETUP;
   \                     ??_usb_reset_1:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
    598          
    599            /* Low level reset.*/
    600            usb_lld_reset(usbp);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       usb_lld_reset
    601          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    602          
    603          /**
    604           * @brief   Default EP0 SETUP callback.
    605           * @details This function is used by the low level driver as default handler
    606           *          for EP0 SETUP events.
    607           *
    608           * @param[in] usbp      pointer to the @p USBDriver object
    609           * @param[in] ep        endpoint number, always zero
    610           *
    611           * @notapi
    612           */

   \                                 In section .text, align 2, keep-with-next
    613          void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
   \                     _usb_ep0setup:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    614            size_t max;
    615          
    616            usbp->ep0state = USB_EP0_WAITING_SETUP;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF884 0x0034      STRB     R0,[R4, #+52]
    617            usbReadSetup(usbp, ep, usbp->setup);
   \   0000000C   0xF114 0x0244      ADDS     R2,R4,#+68
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       usb_lld_read_setup
    618          
    619            /* First verify if the application has an handler installed for this
    620               request.*/
    621            if (!(usbp->config->requests_hook_cb) ||
    622                !(usbp->config->requests_hook_cb(usbp))) {
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ.N    ??_usb_ep0setup_0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x6861             LDR      R1,[R4, #+4]
   \   00000026   0x6889             LDR      R1,[R1, #+8]
   \   00000028   0x4788             BLX      R1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD11E             BNE.N    ??_usb_ep0setup_1
    623              /* Invoking the default handler, if this fails then stalls the
    624                 endpoint zero as error.*/
    625              if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
    626                  !default_handler(usbp)) {
   \                     ??_usb_ep0setup_0:
   \   0000002E   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000032   0x2160             MOVS     R1,#+96
   \   00000034   0x4208             TST      R0,R1
   \   00000036   0xD104             BNE.N    ??_usb_ep0setup_2
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       default_handler
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD114             BNE.N    ??_usb_ep0setup_1
    627                /* Error response, the state machine goes into an error state, the low
    628                   level layer will have to reset it to USB_EP0_WAITING_SETUP after
    629                   receiving a SETUP packet.*/
    630                usb_lld_stall_in(usbp, 0);
   \                     ??_usb_ep0setup_2:
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       usb_lld_stall_in
    631                usb_lld_stall_out(usbp, 0);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       usb_lld_stall_out
    632                _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD004             BEQ.N    ??_usb_ep0setup_3
   \   0000005A   0x2105             MOVS     R1,#+5
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x6862             LDR      R2,[R4, #+4]
   \   00000060   0x6812             LDR      R2,[R2, #+0]
   \   00000062   0x4790             BLX      R2
    633                usbp->ep0state = USB_EP0_ERROR;
   \                     ??_usb_ep0setup_3:
   \   00000064   0x2006             MOVS     R0,#+6
   \   00000066   0xF884 0x0034      STRB     R0,[R4, #+52]
    634                return;
   \   0000006A   0xE073             B.N      ??_usb_ep0setup_4
    635              }
    636            }
    637          #if (USB_SET_ADDRESS_ACK_HANDLING == USB_SET_ADDRESS_ACK_HW)
    638            if (usbp->setup[1] == USB_REQ_SET_ADDRESS) {
    639              /* Zero-length packet sent by hardware */
    640              return;
    641            }
    642          #endif
    643            /* Transfer preparation. The request handler must have populated
    644               correctly the fields ep0next, ep0n and ep0endcb using the macro
    645               usbSetupTransfer().*/
    646            max = usbFetchWord(&usbp->setup[6]);
   \                     ??_usb_ep0setup_1:
   \   0000006C   0xF894 0x004A      LDRB     R0,[R4, #+74]
   \   00000070   0xF894 0x104B      LDRB     R1,[R4, #+75]
   \   00000074   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000078   0x0006             MOVS     R6,R0
    647            /* The transfer size cannot exceed the specified amount.*/
    648            if (usbp->ep0n > max)
   \   0000007A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD200             BCS.N    ??_usb_ep0setup_5
    649              usbp->ep0n = max;
   \   00000080   0x63E6             STR      R6,[R4, #+60]
    650            if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
   \                     ??_usb_ep0setup_5:
   \   00000082   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \   00000086   0x0600             LSLS     R0,R0,#+24
   \   00000088   0xD532             BPL.N    ??_usb_ep0setup_6
    651              /* IN phase.*/
    652              if (usbp->ep0n > 0) {
   \   0000008A   0x6BE0             LDR      R0,[R4, #+60]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD017             BEQ.N    ??_usb_ep0setup_7
    653                /* Starts the transmit phase.*/
    654                usbp->ep0state = USB_EP0_TX;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xF884 0x0034      STRB     R0,[R4, #+52]
    655                usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
   \   00000096   0x6BE3             LDR      R3,[R4, #+60]
   \   00000098   0x6BA2             LDR      R2,[R4, #+56]
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       usbPrepareTransmit
    656                chSysLockFromIsr();
   \   000000A2   0x2020             MOVS     R0,#+32
   \   000000A4   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000A8   0x.... 0x....      BL       dbg_check_lock_from_isr
    657                usbStartTransmitI(usbp, 0);
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       usbStartTransmitI
    658                chSysUnlockFromIsr();
   \   000000B4   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000BE   0xE049             B.N      ??_usb_ep0setup_8
    659              }
    660              else {
    661                /* No transmission phase, directly receiving the zero sized status
    662                   packet.*/
    663                usbp->ep0state = USB_EP0_WAITING_STS;
   \                     ??_usb_ep0setup_7:
   \   000000C0   0x2003             MOVS     R0,#+3
   \   000000C2   0xF884 0x0034      STRB     R0,[R4, #+52]
    664          #if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    665                usbPrepareReceive(usbp, 0, NULL, 0);
   \   000000C6   0x2300             MOVS     R3,#+0
   \   000000C8   0x2200             MOVS     R2,#+0
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       usbPrepareReceive
    666                chSysLockFromIsr();
   \   000000D2   0x2020             MOVS     R0,#+32
   \   000000D4   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000D8   0x.... 0x....      BL       dbg_check_lock_from_isr
    667                usbStartReceiveI(usbp, 0);
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       usbStartReceiveI
    668                chSysUnlockFromIsr();
   \   000000E4   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000EE   0xE031             B.N      ??_usb_ep0setup_8
    669          #else
    670                usb_lld_end_setup(usbp, ep);
    671          #endif
    672              }
    673            }
    674            else {
    675              /* OUT phase.*/
    676              if (usbp->ep0n > 0) {
   \                     ??_usb_ep0setup_6:
   \   000000F0   0x6BE0             LDR      R0,[R4, #+60]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD017             BEQ.N    ??_usb_ep0setup_9
    677                /* Starts the receive phase.*/
    678                usbp->ep0state = USB_EP0_RX;
   \   000000F6   0x2004             MOVS     R0,#+4
   \   000000F8   0xF884 0x0034      STRB     R0,[R4, #+52]
    679                usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
   \   000000FC   0x6BE3             LDR      R3,[R4, #+60]
   \   000000FE   0x6BA2             LDR      R2,[R4, #+56]
   \   00000100   0x2100             MOVS     R1,#+0
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0x.... 0x....      BL       usbPrepareReceive
    680                chSysLockFromIsr();
   \   00000108   0x2020             MOVS     R0,#+32
   \   0000010A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000010E   0x.... 0x....      BL       dbg_check_lock_from_isr
    681                usbStartReceiveI(usbp, 0);
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x.... 0x....      BL       usbStartReceiveI
    682                chSysUnlockFromIsr();
   \   0000011A   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000124   0xE016             B.N      ??_usb_ep0setup_8
    683              }
    684              else {
    685                /* No receive phase, directly sending the zero sized status
    686                   packet.*/
    687                usbp->ep0state = USB_EP0_SENDING_STS;
   \                     ??_usb_ep0setup_9:
   \   00000126   0x2005             MOVS     R0,#+5
   \   00000128   0xF884 0x0034      STRB     R0,[R4, #+52]
    688          #if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    689                usbPrepareTransmit(usbp, 0, NULL, 0);
   \   0000012C   0x2300             MOVS     R3,#+0
   \   0000012E   0x2200             MOVS     R2,#+0
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       usbPrepareTransmit
    690                chSysLockFromIsr();
   \   00000138   0x2020             MOVS     R0,#+32
   \   0000013A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000013E   0x.... 0x....      BL       dbg_check_lock_from_isr
    691                usbStartTransmitI(usbp, 0);
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x0020             MOVS     R0,R4
   \   00000146   0x.... 0x....      BL       usbStartTransmitI
    692                chSysUnlockFromIsr();
   \   0000014A   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF380 0x8811      MSR      BASEPRI,R0
    693          #else
    694                usb_lld_end_setup(usbp, ep);
    695          #endif
    696              }
    697            }
    698          }
   \                     ??_usb_ep0setup_8:
   \                     ??_usb_ep0setup_4:
   \   00000154   0xBD70             POP      {R4-R6,PC}       ;; return
    699          
    700          /**
    701           * @brief   Default EP0 IN callback.
    702           * @details This function is used by the low level driver as default handler
    703           *          for EP0 IN events.
    704           *
    705           * @param[in] usbp      pointer to the @p USBDriver object
    706           * @param[in] ep        endpoint number, always zero
    707           *
    708           * @notapi
    709           */

   \                                 In section .text, align 2, keep-with-next
    710          void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
   \                     _usb_ep0in:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    711            size_t max;
    712          
    713            (void)ep;
    714            switch (usbp->ep0state) {
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD004             BEQ.N    ??_usb_ep0in_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD02D             BEQ.N    ??_usb_ep0in_1
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD043             BEQ.N    ??_usb_ep0in_2
   \   00000016   0xE04C             B.N      ??_usb_ep0in_3
    715            case USB_EP0_TX:
    716              max = usbFetchWord(&usbp->setup[6]);
   \                     ??_usb_ep0in_0:
   \   00000018   0xF894 0x004A      LDRB     R0,[R4, #+74]
   \   0000001C   0xF894 0x104B      LDRB     R1,[R4, #+75]
   \   00000020   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000024   0x0006             MOVS     R6,R0
    717              /* If the transmitted size is less than the requested size and it is a
    718                 multiple of the maximum packet size then a zero size packet must be
    719                 transmitted.*/
    720              if ((usbp->ep0n < max) && ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0)) {
   \   00000026   0x6BE0             LDR      R0,[R4, #+60]
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xD220             BCS.N    ??_usb_ep0in_1
   \   0000002C   0x6BE0             LDR      R0,[R4, #+60]
   \   0000002E   0x68E1             LDR      R1,[R4, #+12]
   \   00000030   0x8A09             LDRH     R1,[R1, #+16]
   \   00000032   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000036   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD117             BNE.N    ??_usb_ep0in_1
    721                usbPrepareTransmit(usbp, 0, NULL, 0);
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       usbPrepareTransmit
    722                chSysLockFromIsr();
   \   0000004A   0x2020             MOVS     R0,#+32
   \   0000004C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000050   0x.... 0x....      BL       dbg_check_lock_from_isr
    723                usbStartTransmitI(usbp, 0);
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       usbStartTransmitI
    724                chSysUnlockFromIsr();
   \   0000005C   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF380 0x8811      MSR      BASEPRI,R0
    725                usbp->ep0state = USB_EP0_WAITING_TX0;
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0xF884 0x0034      STRB     R0,[R4, #+52]
    726                return;
   \   0000006C   0xE035             B.N      ??_usb_ep0in_4
    727              }
    728              /* Falls into, it is intentional.*/
    729            case USB_EP0_WAITING_TX0:
    730              /* Transmit phase over, receiving the zero sized status packet.*/
    731              usbp->ep0state = USB_EP0_WAITING_STS;
   \                     ??_usb_ep0in_1:
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xF884 0x0034      STRB     R0,[R4, #+52]
    732          #if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    733              usbPrepareReceive(usbp, 0, NULL, 0);
   \   00000074   0x2300             MOVS     R3,#+0
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       usbPrepareReceive
    734              chSysLockFromIsr();
   \   00000080   0x2020             MOVS     R0,#+32
   \   00000082   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000086   0x.... 0x....      BL       dbg_check_lock_from_isr
    735              usbStartReceiveI(usbp, 0);
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       usbStartReceiveI
    736              chSysUnlockFromIsr();
   \   00000092   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF380 0x8811      MSR      BASEPRI,R0
    737          #else
    738              usb_lld_end_setup(usbp, ep);
    739          #endif
    740              return;
   \   0000009C   0xE01D             B.N      ??_usb_ep0in_4
    741            case USB_EP0_SENDING_STS:
    742              /* Status packet sent, invoking the callback if defined.*/
    743              if (usbp->ep0endcb != NULL)
   \                     ??_usb_ep0in_2:
   \   0000009E   0x6C20             LDR      R0,[R4, #+64]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD002             BEQ.N    ??_usb_ep0in_5
    744                usbp->ep0endcb(usbp);
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x6C21             LDR      R1,[R4, #+64]
   \   000000A8   0x4788             BLX      R1
    745              usbp->ep0state = USB_EP0_WAITING_SETUP;
   \                     ??_usb_ep0in_5:
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
    746              return;
   \   000000B0   0xE013             B.N      ??_usb_ep0in_4
    747            default:
    748              ;
    749            }
    750            /* Error response, the state machine goes into an error state, the low
    751               level layer will have to reset it to USB_EP0_WAITING_SETUP after
    752               receiving a SETUP packet.*/
    753            usb_lld_stall_in(usbp, 0);
   \                     ??_usb_ep0in_3:
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       usb_lld_stall_in
    754            usb_lld_stall_out(usbp, 0);
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       usb_lld_stall_out
    755            _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
   \   000000C2   0x6860             LDR      R0,[R4, #+4]
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD004             BEQ.N    ??_usb_ep0in_6
   \   000000CA   0x2105             MOVS     R1,#+5
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x6862             LDR      R2,[R4, #+4]
   \   000000D0   0x6812             LDR      R2,[R2, #+0]
   \   000000D2   0x4790             BLX      R2
    756            usbp->ep0state = USB_EP0_ERROR;
   \                     ??_usb_ep0in_6:
   \   000000D4   0x2006             MOVS     R0,#+6
   \   000000D6   0xF884 0x0034      STRB     R0,[R4, #+52]
    757          }
   \                     ??_usb_ep0in_4:
   \   000000DA   0xBD70             POP      {R4-R6,PC}       ;; return
    758          
    759          /**
    760           * @brief   Default EP0 OUT callback.
    761           * @details This function is used by the low level driver as default handler
    762           *          for EP0 OUT events.
    763           *
    764           * @param[in] usbp      pointer to the @p USBDriver object
    765           * @param[in] ep        endpoint number, always zero
    766           *
    767           * @notapi
    768           */

   \                                 In section .text, align 2, keep-with-next
    769          void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
   \                     _usb_ep0out:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    770          
    771            (void)ep;
    772            switch (usbp->ep0state) {
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD019             BEQ.N    ??_usb_ep0out_0
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD126             BNE.N    ??_usb_ep0out_1
    773            case USB_EP0_RX:
    774              /* Receive phase over, sending the zero sized status packet.*/
    775              usbp->ep0state = USB_EP0_SENDING_STS;
   \                     ??_usb_ep0out_2:
   \   00000012   0x2005             MOVS     R0,#+5
   \   00000014   0xF884 0x0034      STRB     R0,[R4, #+52]
    776          #if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    777              usbPrepareTransmit(usbp, 0, NULL, 0);
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       usbPrepareTransmit
    778              chSysLockFromIsr();
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000002A   0x.... 0x....      BL       dbg_check_lock_from_isr
    779              usbStartTransmitI(usbp, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       usbStartTransmitI
    780              chSysUnlockFromIsr();
   \   00000036   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF380 0x8811      MSR      BASEPRI,R0
    781          #else
    782              usb_lld_end_setup(usbp, ep);
    783          #endif
    784              return;
   \   00000040   0xE022             B.N      ??_usb_ep0out_3
    785            case USB_EP0_WAITING_STS:
    786              /* Status packet received, it must be zero sized, invoking the callback
    787                 if defined.*/
    788          #if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    789              if (usbGetReceiveTransactionSizeI(usbp, 0) != 0)
   \                     ??_usb_ep0out_0:
   \   00000042   0x68E0             LDR      R0,[R4, #+12]
   \   00000044   0x6980             LDR      R0,[R0, #+24]
   \   00000046   0x6880             LDR      R0,[R0, #+8]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD109             BNE.N    ??_usb_ep0out_1
    790                break;
    791          #endif
    792              if (usbp->ep0endcb != NULL)
   \                     ??_usb_ep0out_4:
   \   0000004C   0x6C20             LDR      R0,[R4, #+64]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD002             BEQ.N    ??_usb_ep0out_5
    793                usbp->ep0endcb(usbp);
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x6C21             LDR      R1,[R4, #+64]
   \   00000056   0x4788             BLX      R1
    794              usbp->ep0state = USB_EP0_WAITING_SETUP;
   \                     ??_usb_ep0out_5:
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x0034      STRB     R0,[R4, #+52]
    795              return;
   \   0000005E   0xE013             B.N      ??_usb_ep0out_3
    796            default:
    797              ;
    798            }
    799            /* Error response, the state machine goes into an error state, the low
    800               level layer will have to reset it to USB_EP0_WAITING_SETUP after
    801               receiving a SETUP packet.*/
    802            usb_lld_stall_in(usbp, 0);
   \                     ??_usb_ep0out_1:
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       usb_lld_stall_in
    803            usb_lld_stall_out(usbp, 0);
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       usb_lld_stall_out
    804            _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
   \   00000070   0x6860             LDR      R0,[R4, #+4]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD004             BEQ.N    ??_usb_ep0out_6
   \   00000078   0x2105             MOVS     R1,#+5
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x6862             LDR      R2,[R4, #+4]
   \   0000007E   0x6812             LDR      R2,[R2, #+0]
   \   00000080   0x4790             BLX      R2
    805            usbp->ep0state = USB_EP0_ERROR;
   \                     ??_usb_ep0out_6:
   \   00000082   0x2006             MOVS     R0,#+6
   \   00000084   0xF884 0x0034      STRB     R0,[R4, #+52]
    806          }
   \                     ??_usb_ep0out_3:
   \   00000088   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     zero_status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     halted_status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     active_status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     `?<Constant "\\"usbStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     `?<Constant "usbStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     `?<Constant "\\"usbStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     `?<Constant "usbStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     `?<Constant "\\"usbInitEndpointI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     `?<Constant "usbEnableEndpointI(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     `?<Constant "usbEnableEndpointI(), #2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     `?<Constant "\\"usbDisableEndpointsI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     `?<Constant "usbDisableEndpointsI(...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     `?<Constant "\\"usbStartReceiveI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     `?<Constant "\\"usbStartTransmitI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x........         DC32     `?<Constant "\\"usbStallReceiveI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     `?<Constant "\\"usbStallTransmitI\\"()">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbStart\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbStart\"()"
   \              0x73 0x62    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x75 0x73          DC8 75H, 73H, 62H, 2EH, 63H, 0
   \              0x62 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "usbStart(), #1">`:
   \   00000000   0x75 0x73          DC8 "usbStart(), #1"
   \              0x62 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbStop\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbStop\"()"
   \              0x73 0x62    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "usbStop(), #1">`:
   \   00000000   0x75 0x73          DC8 "usbStop(), #1"
   \              0x62 0x53    
   \              0x74 0x6F    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbInitEndpointI\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbInitEndpointI\"()"
   \              0x73 0x62    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x45 0x6E    
   \              0x64 0x70    
   \              0x6F 0x69    
   \              0x6E 0x74    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "usbEnableEndpointI(), #1">`:
   \   00000000   0x75 0x73          DC8 "usbEnableEndpointI(), #1"
   \              0x62 0x45    
   \              0x6E 0x61    
   \              0x62 0x6C    
   \              0x65 0x45    
   \              0x6E 0x64    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x49    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "usbEnableEndpointI(), #2">`:
   \   00000000   0x75 0x73          DC8 "usbEnableEndpointI(), #2"
   \              0x62 0x45    
   \              0x6E 0x61    
   \              0x62 0x6C    
   \              0x65 0x45    
   \              0x6E 0x64    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x49    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x32    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbDisableEndpointsI\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbDisableEndpointsI\"()"
   \              0x73 0x62    
   \              0x44 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x45    
   \              0x6E 0x64    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x73    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "usbDisableEndpointsI(...">`:
   \   00000000   0x75 0x73          DC8 "usbDisableEndpointsI(), #1"
   \              0x62 0x44    
   \              0x69 0x73    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x45 0x6E    
   \              0x64 0x70    
   \              0x6F 0x69    
   \              0x6E 0x74    
   \              0x73 0x49    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbStartReceiveI\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbStartReceiveI\"()"
   \              0x73 0x62    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x52    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbStartTransmitI\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbStartTransmitI\"()"
   \              0x73 0x62    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x54    
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x6D 0x69    
   \              0x74 0x49    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbStallReceiveI\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbStallReceiveI\"()"
   \              0x73 0x62    
   \              0x53 0x74    
   \              0x61 0x6C    
   \              0x6C 0x52    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"usbStallTransmitI\\"()">`:
   \   00000000   0x22 0x75          DC8 "\"usbStallTransmitI\"()"
   \              0x73 0x62    
   \              0x53 0x74    
   \              0x61 0x6C    
   \              0x6C 0x54    
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x6D 0x69    
   \              0x74 0x49    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
    807          
    808          #endif /* HAL_USE_USB */
    809          
    810          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   _usb_ep0in
        16   -- Indirect call
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
        16   -> usbPrepareReceive
        16   -> usbPrepareTransmit
        16   -> usbStartReceiveI
        16   -> usbStartTransmitI
        16   -> usb_lld_stall_in
        16   -> usb_lld_stall_out
      16   _usb_ep0out
        16   -- Indirect call
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
        16   -> usbPrepareTransmit
        16   -> usbStartTransmitI
        16   -> usb_lld_stall_in
        16   -> usb_lld_stall_out
      16   _usb_ep0setup
        16   -- Indirect call
        16   -> dbg_check_lock_from_isr
        16   -> dbg_check_unlock_from_isr
        16   -> default_handler
        16   -> usbPrepareReceive
        16   -> usbPrepareTransmit
        16   -> usbStartReceiveI
        16   -> usbStartTransmitI
        16   -> usb_lld_read_setup
        16   -> usb_lld_stall_in
        16   -> usb_lld_stall_out
      16   _usb_reset
        16   -> usb_lld_reset
      16   default_handler
        16   -- Indirect call
        16   -> set_address
        16   -> usb_lld_clear_in
        16   -> usb_lld_clear_out
        16   -> usb_lld_get_status_in
        16   -> usb_lld_get_status_out
        16   -> usb_lld_stall_in
        16   -> usb_lld_stall_out
      16   memset
        16   -> __aeabi_memset
       8   set_address
         8   -- Indirect call
         8   -> usb_lld_set_address
      16   usbDisableEndpointsI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> usb_lld_disable_endpoints
       8   usbInit
         8   -> usb_lld_init
      16   usbInitEndpointI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> memset
        16   -> usb_lld_init_endpoint
       0   usbObjectInit
      24   usbPrepareQueuedReceive
        24   -> usb_lld_prepare_receive
      24   usbPrepareQueuedTransmit
        24   -> usb_lld_prepare_transmit
      24   usbPrepareReceive
        24   -> usb_lld_prepare_receive
      24   usbPrepareTransmit
        24   -> usb_lld_prepare_transmit
      16   usbStallReceiveI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> usb_lld_stall_out
      16   usbStallTransmitI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> usb_lld_stall_in
      16   usbStart
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
        16   -> usb_lld_start
      16   usbStartReceiveI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> usb_lld_start_out
      16   usbStartTransmitI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> usb_lld_start_in
       8   usbStop
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
         8   -> usb_lld_stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      64  ?<Constant "F:\\stuff\\rusefi_sourc...">
      28  ?<Constant "\"usbDisableEndpointsI\"()">
      24  ?<Constant "\"usbInitEndpointI\"()">
      24  ?<Constant "\"usbStallReceiveI\"()">
      24  ?<Constant "\"usbStallTransmitI\"()">
      24  ?<Constant "\"usbStartReceiveI\"()">
      24  ?<Constant "\"usbStartTransmitI\"()">
      16  ?<Constant "\"usbStart\"()">
      12  ?<Constant "\"usbStop\"()">
      28  ?<Constant "usbDisableEndpointsI(...">
      28  ?<Constant "usbEnableEndpointI(), #1">
      28  ?<Constant "usbEnableEndpointI(), #2">
      16  ?<Constant "usbStart(), #1">
      16  ?<Constant "usbStop(), #1">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
     220  _usb_ep0in
     138  _usb_ep0out
     342  _usb_ep0setup
      68  _usb_reset
       2  active_status
     690  default_handler
       2  halted_status
      22  memset
      42  set_address
      84  usbDisableEndpointsI
       8  usbInit
     114  usbInitEndpointI
      46  usbObjectInit
      58  usbPrepareQueuedReceive
      58  usbPrepareQueuedTransmit
      58  usbPrepareReceive
      58  usbPrepareTransmit
      54  usbStallReceiveI
      54  usbStallTransmitI
      98  usbStart
      64  usbStartReceiveI
      64  usbStartTransmitI
      82  usbStop
       2  zero_status

 
   362 bytes in section .rodata
 2 490 bytes in section .text
 
 2 468 bytes of CODE  memory (+ 22 bytes shared)
   362 bytes of CONST memory

Errors: none
Warnings: none
