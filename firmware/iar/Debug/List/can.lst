###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:40 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\can.c                                              #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\s #
#                       rc\can.c -lCN F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\Debug\List\ -lA F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\Debug\List\ -o F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\Debug\Obj\ --no_cse --no_unroll --no_inline  #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       an.lst                                                #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ca #
#                       n.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\src\can.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          
     28          /**
     29           * @file    can.c
     30           * @brief   CAN Driver code.
     31           *
     32           * @addtogroup CAN
     33           * @{
     34           */
     35          
     36          #include "ch.h"
     37          #include "hal.h"
     38          
     39          #if HAL_USE_CAN || defined(__DOXYGEN__)
     40          
     41          /*===========================================================================*/
     42          /* Driver local definitions.                                                 */
     43          /*===========================================================================*/
     44          
     45          /*===========================================================================*/
     46          /* Driver exported variables.                                                */
     47          /*===========================================================================*/
     48          
     49          /*===========================================================================*/
     50          /* Driver local variables and types.                                         */
     51          /*===========================================================================*/
     52          
     53          /*===========================================================================*/
     54          /* Driver local functions.                                                   */
     55          /*===========================================================================*/
     56          
     57          /*===========================================================================*/
     58          /* Driver exported functions.                                                */
     59          /*===========================================================================*/
     60          
     61          /**
     62           * @brief   CAN Driver initialization.
     63           * @note    This function is implicitly invoked by @p halInit(), there is
     64           *          no need to explicitly initialize the driver.
     65           *
     66           * @init
     67           */

   \                                 In section .text, align 2, keep-with-next
     68          void canInit(void) {
   \                     canInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     69          
     70            can_lld_init();
   \   00000002   0x.... 0x....      BL       can_lld_init
     71          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
     72          
     73          /**
     74           * @brief   Initializes the standard part of a @p CANDriver structure.
     75           *
     76           * @param[out] canp     pointer to the @p CANDriver object
     77           *
     78           * @init
     79           */

   \                                 In section .text, align 2, keep-with-next
     80          void canObjectInit(CANDriver *canp) {
   \                     canObjectInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     81          
     82            canp->state    = CAN_STOP;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x7020             STRB     R0,[R4, #+0]
     83            canp->config   = NULL;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6060             STR      R0,[R4, #+4]
     84            chSemInit(&canp->txsem, 0);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000012   0x.... 0x....      BL       chSemInit
     85            chSemInit(&canp->rxsem, 0);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF114 0x0014      ADDS     R0,R4,#+20
   \   0000001C   0x.... 0x....      BL       chSemInit
     86            chEvtInit(&canp->rxfull_event);
   \   00000020   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000024   0x6220             STR      R0,[R4, #+32]
     87            chEvtInit(&canp->txempty_event);
   \   00000026   0xF114 0x0024      ADDS     R0,R4,#+36
   \   0000002A   0x6260             STR      R0,[R4, #+36]
     88            chEvtInit(&canp->error_event);
   \   0000002C   0xF114 0x0028      ADDS     R0,R4,#+40
   \   00000030   0x62A0             STR      R0,[R4, #+40]
     89          #if CAN_USE_SLEEP_MODE
     90            chEvtInit(&canp->sleep_event);
   \   00000032   0xF114 0x002C      ADDS     R0,R4,#+44
   \   00000036   0x62E0             STR      R0,[R4, #+44]
     91            chEvtInit(&canp->wakeup_event);
   \   00000038   0xF114 0x0030      ADDS     R0,R4,#+48
   \   0000003C   0x6320             STR      R0,[R4, #+48]
     92          #endif /* CAN_USE_SLEEP_MODE */
     93          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
     94          
     95          /**
     96           * @brief   Configures and activates the CAN peripheral.
     97           * @note    Activating the CAN bus can be a slow operation this this function
     98           *          is not atomic, it waits internally for the initialization to
     99           *          complete.
    100           *
    101           * @param[in] canp      pointer to the @p CANDriver object
    102           * @param[in] config    pointer to the @p CANConfig object. Depending on
    103           *                      the implementation the value can be @p NULL.
    104           *
    105           * @api
    106           */

   \                                 In section .text, align 2, keep-with-next
    107          void canStart(CANDriver *canp, const CANConfig *config) {
   \                     canStart:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    108          
    109            chDbgCheck(canp != NULL, "canStart");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD104             BNE.N    ??canStart_0
   \   0000000A   0x226D             MOVS     R2,#+109
   \   0000000C   0x....             LDR.N    R1,??DataTable5
   \   0000000E   0x....             LDR.N    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    110          
    111            chSysLock();
   \                     ??canStart_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    112            chDbgAssert((canp->state == CAN_STOP) ||
    113                        (canp->state == CAN_STARTING) ||
    114                        (canp->state == CAN_READY),
    115                        "canStart(), #1", "invalid state");
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD008             BEQ.N    ??canStart_1
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD005             BEQ.N    ??canStart_1
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD002             BEQ.N    ??canStart_1
   \   00000030   0x....             LDR.N    R0,??DataTable5_2
   \   00000032   0x.... 0x....      BL       chDbgPanic
    116            while (canp->state == CAN_STARTING)
   \                     ??canStart_1:
   \   00000036   0x7820             LDRB     R0,[R4, #+0]
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD104             BNE.N    ??canStart_2
    117              chThdSleepS(1);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2006             MOVS     R0,#+6
   \   00000040   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \   00000044   0xE7F7             B.N      ??canStart_1
    118            if (canp->state == CAN_STOP) {
   \                     ??canStart_2:
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD105             BNE.N    ??canStart_3
    119              canp->config = config;
   \   0000004C   0x6065             STR      R5,[R4, #+4]
    120              can_lld_start(canp);
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       can_lld_start
    121              canp->state = CAN_READY;
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0x7020             STRB     R0,[R4, #+0]
    122            }
    123            chSysUnlock();
   \                     ??canStart_3:
   \   00000058   0x.... 0x....      BL       dbg_check_unlock
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF380 0x8811      MSR      BASEPRI,R0
    124          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    125          
    126          /**
    127           * @brief   Deactivates the CAN peripheral.
    128           *
    129           * @param[in] canp      pointer to the @p CANDriver object
    130           *
    131           * @api
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          void canStop(CANDriver *canp) {
   \                     canStop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    134          
    135            chDbgCheck(canp != NULL, "canStop");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??canStop_0
   \   00000008   0x2287             MOVS     R2,#+135
   \   0000000A   0x....             LDR.N    R1,??DataTable5
   \   0000000C   0x....             LDR.N    R0,??DataTable5_3
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    136          
    137            chSysLock();
   \                     ??canStop_0:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock
    138            chDbgAssert((canp->state == CAN_STOP) || (canp->state == CAN_READY),
    139                        "canStop(), #1", "invalid state");
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD005             BEQ.N    ??canStop_1
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD002             BEQ.N    ??canStop_1
   \   00000028   0x....             LDR.N    R0,??DataTable5_4
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    140            can_lld_stop(canp);
   \                     ??canStop_1:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       can_lld_stop
    141            canp->state  = CAN_STOP;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7020             STRB     R0,[R4, #+0]
    142            chSemResetI(&canp->rxsem, 0);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xF114 0x0014      ADDS     R0,R4,#+20
   \   0000003E   0x.... 0x....      BL       chSemResetI
    143            chSemResetI(&canp->txsem, 0);
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000048   0x.... 0x....      BL       chSemResetI
    144            chSchRescheduleS();
   \   0000004C   0x.... 0x....      BL       chSchRescheduleS
    145            chSysUnlock();
   \   00000050   0x.... 0x....      BL       dbg_check_unlock
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF380 0x8811      MSR      BASEPRI,R0
    146          }
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    147          
    148          /**
    149           * @brief   Can frame transmission.
    150           * @details The specified frame is queued for transmission, if the hardware
    151           *          queue is full then the invoking thread is queued.
    152           * @note    Trying to transmit while in sleep mode simply enqueues the thread.
    153           *
    154           * @param[in] canp      pointer to the @p CANDriver object
    155           * @param[in] mailbox   mailbox number, @p CAN_ANY_MAILBOX for any mailbox
    156           * @param[in] ctfp      pointer to the CAN frame to be transmitted
    157           * @param[in] timeout   the number of ticks before the operation timeouts,
    158           *                      the following special values are allowed:
    159           *                      - @a TIME_IMMEDIATE immediate timeout.
    160           *                      - @a TIME_INFINITE no timeout.
    161           *                      .
    162           * @return              The operation result.
    163           * @retval RDY_OK       the frame has been queued for transmission.
    164           * @retval RDY_TIMEOUT  The operation has timed out.
    165           * @retval RDY_RESET    The driver has been stopped while waiting.
    166           *
    167           * @api
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          msg_t canTransmit(CANDriver *canp,
    170                            canmbx_t mailbox,
    171                            const CANTxFrame *ctfp,
    172                            systime_t timeout) {
   \                     canTransmit:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    173          
    174            chDbgCheck((canp != NULL) && (ctfp != NULL) && (mailbox <= CAN_TX_MAILBOXES),
    175                       "canTransmit");
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD003             BEQ.N    ??canTransmit_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD001             BEQ.N    ??canTransmit_0
   \   00000014   0x2D04             CMP      R5,#+4
   \   00000016   0xD304             BCC.N    ??canTransmit_1
   \                     ??canTransmit_0:
   \   00000018   0x22AF             MOVS     R2,#+175
   \   0000001A   0x....             LDR.N    R1,??DataTable5
   \   0000001C   0x....             LDR.N    R0,??DataTable5_5
   \   0000001E   0x.... 0x....      BL       chDbgPanic3
    176          
    177            chSysLock();
   \                     ??canTransmit_1:
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000028   0x.... 0x....      BL       dbg_check_lock
    178            chDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
    179                        "canTransmit(), #1", "invalid state");
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD005             BEQ.N    ??canTransmit_2
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xD002             BEQ.N    ??canTransmit_2
   \   00000038   0x....             LDR.N    R0,??DataTable5_6
   \   0000003A   0x.... 0x....      BL       chDbgPanic
    180            while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
   \                     ??canTransmit_2:
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD005             BEQ.N    ??canTransmit_3
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       can_lld_is_tx_empty
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD10F             BNE.N    ??canTransmit_4
    181              msg_t msg = chSemWaitTimeoutS(&canp->txsem, timeout);
   \                     ??canTransmit_3:
   \   00000050   0x0039             MOVS     R1,R7
   \   00000052   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000056   0x.... 0x....      BL       chSemWaitTimeoutS
   \   0000005A   0x4680             MOV      R8,R0
    182              if (msg != RDY_OK) {
   \   0000005C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000060   0xD0ED             BEQ.N    ??canTransmit_2
    183                chSysUnlock();
   \   00000062   0x.... 0x....      BL       dbg_check_unlock
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF380 0x8811      MSR      BASEPRI,R0
    184                return msg;
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0xE00A             B.N      ??canTransmit_5
    185              }
    186            }
    187            can_lld_transmit(canp, mailbox, ctfp);
   \                     ??canTransmit_4:
   \   00000070   0x0032             MOVS     R2,R6
   \   00000072   0x0029             MOVS     R1,R5
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       can_lld_transmit
    188            chSysUnlock();
   \   0000007A   0x.... 0x....      BL       dbg_check_unlock
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
    189            return RDY_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??canTransmit_5:
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    190          }
    191          
    192          /**
    193           * @brief   Can frame receive.
    194           * @details The function waits until a frame is received.
    195           * @note    Trying to receive while in sleep mode simply enqueues the thread.
    196           *
    197           * @param[in] canp      pointer to the @p CANDriver object
    198           * @param[in] mailbox   mailbox number, @p CAN_ANY_MAILBOX for any mailbox
    199           * @param[out] crfp     pointer to the buffer where the CAN frame is copied
    200           * @param[in] timeout   the number of ticks before the operation timeouts,
    201           *                      the following special values are allowed:
    202           *                      - @a TIME_IMMEDIATE immediate timeout (useful in an
    203           *                        event driven scenario where a thread never blocks
    204           *                        for I/O).
    205           *                      - @a TIME_INFINITE no timeout.
    206           *                      .
    207           * @return              The operation result.
    208           * @retval RDY_OK       a frame has been received and placed in the buffer.
    209           * @retval RDY_TIMEOUT  The operation has timed out.
    210           * @retval RDY_RESET    The driver has been stopped while waiting.
    211           *
    212           * @api
    213           */

   \                                 In section .text, align 2, keep-with-next
    214          msg_t canReceive(CANDriver *canp,
    215                           canmbx_t mailbox,
    216                           CANRxFrame *crfp,
    217                           systime_t timeout) {
   \                     canReceive:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    218          
    219            chDbgCheck((canp != NULL) && (crfp != NULL) && (mailbox < CAN_RX_MAILBOXES),
    220                       "canReceive");
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD003             BEQ.N    ??canReceive_0
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD001             BEQ.N    ??canReceive_0
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD304             BCC.N    ??canReceive_1
   \                     ??canReceive_0:
   \   00000018   0x22DC             MOVS     R2,#+220
   \   0000001A   0x....             LDR.N    R1,??DataTable5
   \   0000001C   0x....             LDR.N    R0,??DataTable5_7
   \   0000001E   0x.... 0x....      BL       chDbgPanic3
    221          
    222            chSysLock();
   \                     ??canReceive_1:
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000028   0x.... 0x....      BL       dbg_check_lock
    223            chDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
    224                        "canReceive(), #1", "invalid state");
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD005             BEQ.N    ??canReceive_2
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xD002             BEQ.N    ??canReceive_2
   \   00000038   0x....             LDR.N    R0,??DataTable5_8
   \   0000003A   0x.... 0x....      BL       chDbgPanic
    225            while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
   \                     ??canReceive_2:
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD005             BEQ.N    ??canReceive_3
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       can_lld_is_rx_nonempty
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD10F             BNE.N    ??canReceive_4
    226              msg_t msg = chSemWaitTimeoutS(&canp->rxsem, timeout);
   \                     ??canReceive_3:
   \   00000050   0x0039             MOVS     R1,R7
   \   00000052   0xF114 0x0014      ADDS     R0,R4,#+20
   \   00000056   0x.... 0x....      BL       chSemWaitTimeoutS
   \   0000005A   0x4680             MOV      R8,R0
    227              if (msg != RDY_OK) {
   \   0000005C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000060   0xD0ED             BEQ.N    ??canReceive_2
    228                chSysUnlock();
   \   00000062   0x.... 0x....      BL       dbg_check_unlock
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF380 0x8811      MSR      BASEPRI,R0
    229                return msg;
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0xE00A             B.N      ??canReceive_5
    230              }
    231            }
    232            can_lld_receive(canp, mailbox, crfp);
   \                     ??canReceive_4:
   \   00000070   0x0032             MOVS     R2,R6
   \   00000072   0x0029             MOVS     R1,R5
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       can_lld_receive
    233            chSysUnlock();
   \   0000007A   0x.... 0x....      BL       dbg_check_unlock
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
    234            return RDY_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??canReceive_5:
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    235          }
    236          
    237          #if CAN_USE_SLEEP_MODE || defined(__DOXYGEN__)
    238          /**
    239           * @brief   Enters the sleep mode.
    240           * @details This function puts the CAN driver in sleep mode and broadcasts
    241           *          the @p sleep_event event source.
    242           * @pre     In order to use this function the option @p CAN_USE_SLEEP_MODE must
    243           *          be enabled and the @p CAN_SUPPORTS_SLEEP mode must be supported
    244           *          by the low level driver.
    245           *
    246           * @param[in] canp      pointer to the @p CANDriver object
    247           *
    248           * @api
    249           */

   \                                 In section .text, align 2, keep-with-next
    250          void canSleep(CANDriver *canp) {
   \                     canSleep:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    251          
    252            chDbgCheck(canp != NULL, "canSleep");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD104             BNE.N    ??canSleep_0
   \   00000008   0x22FC             MOVS     R2,#+252
   \   0000000A   0x....             LDR.N    R1,??DataTable5
   \   0000000C   0x....             LDR.N    R0,??DataTable5_9
   \   0000000E   0x.... 0x....      BL       chDbgPanic3
    253          
    254            chSysLock();
   \                     ??canSleep_0:
   \   00000012   0x2020             MOVS     R0,#+32
   \   00000014   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000018   0x.... 0x....      BL       dbg_check_lock
    255            chDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
    256                        "canSleep(), #1", "invalid state");
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD005             BEQ.N    ??canSleep_1
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xD002             BEQ.N    ??canSleep_1
   \   00000028   0x....             LDR.N    R0,??DataTable5_10
   \   0000002A   0x.... 0x....      BL       chDbgPanic
    257            if (canp->state == CAN_READY) {
   \                     ??canSleep_1:
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xD10B             BNE.N    ??canSleep_2
    258              can_lld_sleep(canp);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       can_lld_sleep
    259              canp->state = CAN_SLEEP;
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x7020             STRB     R0,[R4, #+0]
    260              chEvtBroadcastI(&canp->sleep_event);
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF114 0x002C      ADDS     R0,R4,#+44
   \   00000044   0x.... 0x....      BL       chEvtBroadcastFlagsI
    261              chSchRescheduleS();
   \   00000048   0x.... 0x....      BL       chSchRescheduleS
    262            }
    263            chSysUnlock();
   \                     ??canSleep_2:
   \   0000004C   0x.... 0x....      BL       dbg_check_unlock
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF380 0x8811      MSR      BASEPRI,R0
    264          }
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    265          
    266          /**
    267           * @brief   Enforces leaving the sleep mode.
    268           * @note    The sleep mode is supposed to be usually exited automatically by
    269           *          an hardware event.
    270           *
    271           * @param[in] canp      pointer to the @p CANDriver object
    272           */

   \                                 In section .text, align 2, keep-with-next
    273          void canWakeup(CANDriver *canp) {
   \                     canWakeup:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    274          
    275            chDbgCheck(canp != NULL, "canWakeup");
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD105             BNE.N    ??canWakeup_0
   \   00000008   0xF240 0x1213      MOVW     R2,#+275
   \   0000000C   0x....             LDR.N    R1,??DataTable5
   \   0000000E   0x....             LDR.N    R0,??DataTable5_11
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    276          
    277            chSysLock();
   \                     ??canWakeup_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    278            chDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
    279                        "canWakeup(), #1", "invalid state");
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD005             BEQ.N    ??canWakeup_1
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD002             BEQ.N    ??canWakeup_1
   \   0000002A   0x....             LDR.N    R0,??DataTable5_12
   \   0000002C   0x.... 0x....      BL       chDbgPanic
    280            if (canp->state == CAN_SLEEP) {
   \                     ??canWakeup_1:
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD10B             BNE.N    ??canWakeup_2
    281              can_lld_wakeup(canp);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       can_lld_wakeup
    282              canp->state = CAN_READY;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x7020             STRB     R0,[R4, #+0]
    283              chEvtBroadcastI(&canp->wakeup_event);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF114 0x0030      ADDS     R0,R4,#+48
   \   00000046   0x.... 0x....      BL       chEvtBroadcastFlagsI
    284              chSchRescheduleS();
   \   0000004A   0x.... 0x....      BL       chSchRescheduleS
    285            }
    286            chSysUnlock();
   \                     ??canWakeup_2:
   \   0000004E   0x.... 0x....      BL       dbg_check_unlock
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF380 0x8811      MSR      BASEPRI,R0
    287          }
   \   00000058   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     `?<Constant "\\"canStart\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     `?<Constant "canStart(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     `?<Constant "\\"canStop\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     `?<Constant "canStop(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     `?<Constant "\\"canTransmit\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     `?<Constant "canTransmit(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     `?<Constant "\\"canReceive\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     `?<Constant "canReceive(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     `?<Constant "\\"canSleep\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     `?<Constant "canSleep(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     `?<Constant "\\"canWakeup\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     `?<Constant "canWakeup(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canStart\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canStart\"()"
   \              0x61 0x6E    
   \              0x53 0x74    
   \              0x61 0x72    
   \              0x74 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x68 0x61          DC8 68H, 61H, 6CH, 5CH, 73H, 72H, 63H, 5CH
   \              0x6C 0x5C    
   \              0x73 0x72    
   \              0x63 0x5C    
   \   00000038   0x63 0x61          DC8 63H, 61H, 6EH, 2EH, 63H, 0
   \              0x6E 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "canStart(), #1">`:
   \   00000000   0x63 0x61          DC8 "canStart(), #1"
   \              0x6E 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canStop\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canStop\"()"
   \              0x61 0x6E    
   \              0x53 0x74    
   \              0x6F 0x70    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "canStop(), #1">`:
   \   00000000   0x63 0x61          DC8 "canStop(), #1"
   \              0x6E 0x53    
   \              0x74 0x6F    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canTransmit\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canTransmit\"()"
   \              0x61 0x6E    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "canTransmit(), #1">`:
   \   00000000   0x63 0x61          DC8 "canTransmit(), #1"
   \              0x6E 0x54    
   \              0x72 0x61    
   \              0x6E 0x73    
   \              0x6D 0x69    
   \              0x74 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canReceive\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canReceive\"()"
   \              0x61 0x6E    
   \              0x52 0x65    
   \              0x63 0x65    
   \              0x69 0x76    
   \              0x65 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "canReceive(), #1">`:
   \   00000000   0x63 0x61          DC8 "canReceive(), #1"
   \              0x6E 0x52    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canSleep\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canSleep\"()"
   \              0x61 0x6E    
   \              0x53 0x6C    
   \              0x65 0x65    
   \              0x70 0x22    
   \              0x28 0x29    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "canSleep(), #1">`:
   \   00000000   0x63 0x61          DC8 "canSleep(), #1"
   \              0x6E 0x53    
   \              0x6C 0x65    
   \              0x65 0x70    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"canWakeup\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"canWakeup\"()"
   \              0x61 0x6E    
   \              0x57 0x61    
   \              0x6B 0x65    
   \              0x75 0x70    
   \              0x22 0x28    
   \              0x29 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "canWakeup(), #1">`:
   \   00000000   0x63 0x61          DC8 "canWakeup(), #1"
   \              0x6E 0x57    
   \              0x61 0x6B    
   \              0x65 0x75    
   \              0x70 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
    288          #endif /* CAN_USE_SLEEP_MODE */
    289          
    290          #endif /* HAL_USE_CAN */
    291          
    292          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   canInit
         8   -> can_lld_init
       8   canObjectInit
         8   -> chSemInit
      24   canReceive
        24   -> can_lld_is_rx_nonempty
        24   -> can_lld_receive
        24   -> chDbgPanic
        24   -> chDbgPanic3
        24   -> chSemWaitTimeoutS
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
       8   canSleep
         8   -> can_lld_sleep
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> chEvtBroadcastFlagsI
         8   -> chSchRescheduleS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
      16   canStart
        16   -> can_lld_start
        16   -> chDbgPanic
        16   -> chDbgPanic3
        16   -> chSchGoSleepTimeoutS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
       8   canStop
         8   -> can_lld_stop
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> chSchRescheduleS
         8   -> chSemResetI
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
      24   canTransmit
        24   -> can_lld_is_tx_empty
        24   -> can_lld_transmit
        24   -> chDbgPanic
        24   -> chDbgPanic3
        24   -> chSemWaitTimeoutS
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
       8   canWakeup
         8   -> can_lld_wakeup
         8   -> chDbgPanic
         8   -> chDbgPanic3
         8   -> chEvtBroadcastFlagsI
         8   -> chSchRescheduleS
         8   -> dbg_check_lock
         8   -> dbg_check_unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      64  ?<Constant "F:\\stuff\\rusefi_sourc...">
      16  ?<Constant "\"canReceive\"()">
      16  ?<Constant "\"canSleep\"()">
      16  ?<Constant "\"canStart\"()">
      12  ?<Constant "\"canStop\"()">
      16  ?<Constant "\"canTransmit\"()">
      16  ?<Constant "\"canWakeup\"()">
      20  ?<Constant "canReceive(), #1">
      16  ?<Constant "canSleep(), #1">
      16  ?<Constant "canStart(), #1">
      16  ?<Constant "canStop(), #1">
      20  ?<Constant "canTransmit(), #1">
      16  ?<Constant "canWakeup(), #1">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       8  canInit
      64  canObjectInit
     138  canReceive
      88  canSleep
     100  canStart
      92  canStop
     138  canTransmit
      90  canWakeup

 
 260 bytes in section .rodata
 770 bytes in section .text
 
 770 bytes of CODE  memory
 260 bytes of CONST memory

Errors: none
Warnings: none
