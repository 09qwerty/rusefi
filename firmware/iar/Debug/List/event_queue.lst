###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:48 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\syst #
#                       em\event_queue.cpp                                    #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\syst #
#                       em\event_queue.cpp -lCN F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\List\ -lA                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\e #
#                       vent_queue.lst                                        #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ev #
#                       ent_queue.o                                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\system\event_queue.cpp
      1          /**
      2           * @file event_queue.cpp
      3           * This is a data structure which keeps track of all pending events
      4           * Implemented as a linked list, which is fine since the number of
      5           * pending events is pretty low
      6           * todo: MAYBE migrate to a better data structure, but that's low priority
      7           *
      8           * this data structure is NOT thread safe
      9           *
     10           * @date Apr 17, 2014
     11           * @author Andrey Belomutskiy, (c) 2012-2015
     12           */
     13          
     14          #include "main.h"
     15          #include "event_queue.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool assertNotInList<scheduling_s>(scheduling_s *, scheduling_s *)
   \                     _Z15assertNotInListI12scheduling_sEbPT_S2_:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x0026             MOVS     R6,R4
   \                     ??assertNotInList_0:
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD013             BEQ.N    ??assertNotInList_1
   \   0000000E   0x1C7F             ADDS     R7,R7,#+1
   \   00000010   0xF5B7 0x7F7A      CMP      R7,#+1000
   \   00000014   0xDD04             BLE.N    ??assertNotInList_2
   \   00000016   0x4809             LDR.N    R0,??assertNotInList_3
   \   00000018   0x.... 0x....      BL       firmwareError
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00B             B.N      ??assertNotInList_4
   \                     ??assertNotInList_2:
   \   00000020   0x42AE             CMP      R6,R5
   \   00000022   0xD106             BNE.N    ??assertNotInList_5
   \   00000024   0x4906             LDR.N    R1,??assertNotInList_3+0x4
   \   00000026   0xF240 0x205E      MOVW     R0,#+606
   \   0000002A   0x.... 0x....      BL       warning
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE002             B.N      ??assertNotInList_4
   \                     ??assertNotInList_5:
   \   00000032   0x6936             LDR      R6,[R6, #+16]
   \   00000034   0xE7E9             B.N      ??assertNotInList_0
   \                     ??assertNotInList_1:
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??assertNotInList_4:
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??assertNotInList_3:
   \   0000003C   0x........         DC32     _ZZ15assertNotInListI12scheduling_sEbPT_S2_Es
   \   00000040   0x........         DC32     _ZZ15assertNotInListI12scheduling_sEbPT_S2_Es_0
     16          #include "efitime.h"
     17          #include "efilib2.h"
     18          

   \                                 In section .bss, align 4
     19          int maxHowFarOff = 0;
   \                     maxHowFarOff:
   \   00000000                      DS8 4
     20          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp scheduling_s::subobject scheduling_s()
   \                     _ZN12scheduling_sC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN12scheduling_sC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     21          scheduling_s::scheduling_s() {
     22          	callback = NULL;
   \                     _ZN12scheduling_sC1Ev:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6081             STR      R1,[R0, #+8]
     23          	next = NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6101             STR      R1,[R0, #+16]
     24          	param = NULL;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
     25          	isScheduled = false;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7501             STRB     R1,[R0, #+20]
     26          	momentX = 0;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
     27          }
   \   00000018   0x4770             BX       LR               ;; return
     28          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp EventQueue::subobject EventQueue()
   \                     _ZN10EventQueueC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10EventQueueC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     29          EventQueue::EventQueue() {
   \                     _ZN10EventQueueC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     30          	head = NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
     31          	setLateDelay(100);
   \   00000008   0x2164             MOVS     R1,#+100
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10EventQueue12setLateDelayEi
     32          }
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     33          

   \                                 In section .text, align 2, keep-with-next
     34          bool EventQueue::checkIfPending(scheduling_s *scheduling) {
   \                     _ZN10EventQueue14checkIfPendingEP12scheduling_s:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     35          	return assertNotInList<scheduling_s>(head, scheduling);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       _Z15assertNotInListI12scheduling_sEbPT_S2_
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     36          }
     37          
     38          /**
     39           * @return true if inserted into the head of the list
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          bool_t EventQueue::insertTask(scheduling_s *scheduling, efitime_t timeX, schfunc_t callback, void *param) {
   \                     _ZN10EventQueue10insertTaskEP12scheduling_sxPFvPvES2_:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \   00000010   0xF8DD 0x9024      LDR      R9,[SP, #+36]
     42          #if EFI_UNIT_TEST
     43          	assertListIsSorted();
     44          #endif
     45          	efiAssert(callback != NULL, "NULL callback", false);
   \   00000014   0x4640             MOV      R0,R8
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD104             BNE.N    ??insertTask_0
   \   0000001A   0x....             LDR.N    R0,??DataTable1
   \   0000001C   0x.... 0x....      BL       firmwareError
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE02E             B.N      ??insertTask_1
     46          
     47          	if (scheduling->isScheduled)
   \                     ??insertTask_0:
   \   00000024   0x7D38             LDRB     R0,[R7, #+20]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??insertTask_2
     48          		return false;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE029             B.N      ??insertTask_1
     49          
     50          	scheduling->momentX = timeX;
   \                     ??insertTask_2:
   \   0000002E   0xE9C7 0x4500      STRD     R4,R5,[R7, #+0]
     51          	scheduling->callback = callback;
   \   00000032   0xF8C7 0x8008      STR      R8,[R7, #+8]
     52          	scheduling->param = param;
   \   00000036   0xF8C7 0x900C      STR      R9,[R7, #+12]
     53          	scheduling->isScheduled = true;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7538             STRB     R0,[R7, #+20]
     54          
     55          	if (head == NULL || timeX < head->momentX) {
   \   0000003E   0x6830             LDR      R0,[R6, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD007             BEQ.N    ??insertTask_3
   \   00000044   0x6832             LDR      R2,[R6, #+0]
   \   00000046   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   0000004A   0x428D             CMP      R5,R1
   \   0000004C   0xDC07             BGT.N    ??insertTask_4
   \   0000004E   0xDB01             BLT.N    ??insertTask_5
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD204             BCS.N    ??insertTask_4
     56          		LL_PREPEND(head, scheduling);
   \                     ??insertTask_5:
   \                     ??insertTask_3:
   \   00000054   0x6830             LDR      R0,[R6, #+0]
   \   00000056   0x6138             STR      R0,[R7, #+16]
   \   00000058   0x6037             STR      R7,[R6, #+0]
     57          #if EFI_UNIT_TEST
     58          		assertListIsSorted();
     59          #endif
     60          		return true;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE011             B.N      ??insertTask_1
     61          	} else {
     62          		scheduling_s *insertPosition = head;
   \                     ??insertTask_4:
   \   0000005E   0x6832             LDR      R2,[R6, #+0]
     63          		while (insertPosition->next != NULL && insertPosition->next->momentX < timeX) {
   \                     ??insertTask_6:
   \   00000060   0x6910             LDR      R0,[R2, #+16]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD009             BEQ.N    ??insertTask_7
   \   00000066   0x6913             LDR      R3,[R2, #+16]
   \   00000068   0xE9D3 0x0100      LDRD     R0,R1,[R3, #+0]
   \   0000006C   0x42A9             CMP      R1,R5
   \   0000006E   0xDC04             BGT.N    ??insertTask_7
   \   00000070   0xDB01             BLT.N    ??insertTask_8
   \   00000072   0x42A0             CMP      R0,R4
   \   00000074   0xD201             BCS.N    ??insertTask_7
     64          			insertPosition = insertPosition->next;
   \                     ??insertTask_8:
   \   00000076   0x6912             LDR      R2,[R2, #+16]
   \   00000078   0xE7F2             B.N      ??insertTask_6
     65          		}
     66          
     67          		scheduling->next = insertPosition->next;
   \                     ??insertTask_7:
   \   0000007A   0x6910             LDR      R0,[R2, #+16]
   \   0000007C   0x6138             STR      R0,[R7, #+16]
     68          		insertPosition->next = scheduling;
   \   0000007E   0x6117             STR      R7,[R2, #+16]
     69          #if EFI_UNIT_TEST
     70          		assertListIsSorted();
     71          #endif
     72          		return false;
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??insertTask_1:
   \   00000082   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
     73          	}
     74          }
     75          
     76          /**
     77           * On this layer it does not matter which units are used - us, ms ot nt.
     78           *
     79           * This method is always invoked under a lock
     80           * @return Get the timestamp of the soonest pending action, skipping all the actions in the past
     81           */

   \                                 In section .text, align 2, keep-with-next
     82          efitime_t EventQueue::getNextEventTime(efitime_t nowX) {
   \                     _ZN10EventQueue16getNextEventTimeEx:
   \   00000000   0xE92D 0x03D0      PUSH     {R4,R6-R9}
   \   00000004   0x0004             MOVS     R4,R0
     83          	efitime_t nextTimeUs = EMPTY_QUEUE;
   \   00000006   0xF05F 0x36FF      MOVS     R6,#-1
   \   0000000A   0xF07F 0x4770      MVNS     R7,#-268435456
     84          
     85          	if (head != NULL) {
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD010             BEQ.N    ??getNextEventTime_0
     86          		if (head->momentX <= nowX) {
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0xE9D0 0x8900      LDRD     R8,R9,[R0, #+0]
   \   0000001A   0x454B             CMP      R3,R9
   \   0000001C   0xDB07             BLT.N    ??getNextEventTime_1
   \   0000001E   0xDC01             BGT.N    ??getNextEventTime_2
   \   00000020   0x4542             CMP      R2,R8
   \   00000022   0xD304             BCC.N    ??getNextEventTime_1
     87          			/**
     88          			 * We are here if action timestamp is in the past
     89          			 *
     90          			 * looks like we end up here after 'writeconfig' (which freezes the firmware) - we are late
     91          			 * for the next scheduled event
     92          			 */
     93          			efitime_t aBitInTheFuture = nowX + lateDelay;
   \                     ??getNextEventTime_2:
   \   00000024   0xE9D4 0x0102      LDRD     R0,R1,[R4, #+8]
   \   00000028   0x1810             ADDS     R0,R2,R0
   \   0000002A   0x4159             ADCS     R1,R3,R1
     94          			return aBitInTheFuture;
   \   0000002C   0xE007             B.N      ??getNextEventTime_3
     95          		} else {
     96          			return head->momentX;
   \                     ??getNextEventTime_1:
   \   0000002E   0x6824             LDR      R4,[R4, #+0]
   \   00000030   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   00000034   0xE003             B.N      ??getNextEventTime_3
     97          		}
     98          	}
     99          	return EMPTY_QUEUE;
   \                     ??getNextEventTime_0:
   \   00000036   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003A   0xF07F 0x4170      MVNS     R1,#-268435456
   \                     ??getNextEventTime_3:
   \   0000003E   0xE8BD 0x03D0      POP      {R4,R6-R9}
   \   00000042   0x4770             BX       LR               ;; return
    100          }
    101          

   \                                 In section .bss, align 4
    102          static scheduling_s * longScheduling;
   \                     longScheduling:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    103          uint32_t maxEventQueueTime = 0;
   \                     maxEventQueueTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    104          uint32_t lastEventQueueTime;
   \                     lastEventQueueTime:
   \   00000000                      DS8 4
    105          
    106          /**
    107           * Invoke all pending actions prior to specified timestamp
    108           * @return number of executed actions
    109           */

   \                                 In section .text, align 2, keep-with-next
    110          int EventQueue::executeAll(efitime_t now) {
   \                     _ZN10EventQueue10executeAllEx:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4682             MOV      R10,R0
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    111          	scheduling_s * current, *tmp;
    112          
    113          	scheduling_s * executionList = NULL;
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    114          
    115          	int listIterationCounter = 0;
   \   00000010   0x2700             MOVS     R7,#+0
    116          	int executionCounter = 0;
   \   00000012   0xF05F 0x0800      MOVS     R8,#+0
    117          	// we need safe iteration because we are removing elements inside the loop
    118          	LL_FOREACH_SAFE(head, current, tmp)
   \   00000016   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000001A   0x0006             MOVS     R6,R0
   \                     ??executeAll_0:
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD02A             BEQ.N    ??executeAll_1
   \   00000020   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD125             BNE.N    ??executeAll_1
    119          	{
    120          		if (++listIterationCounter > QUEUE_LENGTH_LIMIT) {
   \   0000002A   0x1C7F             ADDS     R7,R7,#+1
   \   0000002C   0xF5B7 0x7F7A      CMP      R7,#+1000
   \   00000030   0xDD04             BLE.N    ??executeAll_2
    121          			firmwareError("Is this list looped?");
   \   00000032   0x....             LDR.N    R0,??DataTable1_1
   \   00000034   0x.... 0x....      BL       firmwareError
    122          			return false;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE056             B.N      ??executeAll_3
    123          		}
    124          		if (current->momentX <= now) {
   \                     ??executeAll_2:
   \   0000003C   0xE9D6 0x0100      LDRD     R0,R1,[R6, #+0]
   \   00000040   0x428D             CMP      R5,R1
   \   00000042   0xDB18             BLT.N    ??executeAll_4
   \   00000044   0xDC01             BGT.N    ??executeAll_5
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD315             BCC.N    ??executeAll_4
    125          			executionCounter++;
   \                     ??executeAll_5:
   \   0000004A   0xF118 0x0801      ADDS     R8,R8,#+1
    126          			efiAssert(head == current, "removing from head", -1);
   \   0000004E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000052   0x42B0             CMP      R0,R6
   \   00000054   0xD005             BEQ.N    ??executeAll_6
   \   00000056   0x....             LDR.N    R0,??DataTable1_2
   \   00000058   0x.... 0x....      BL       firmwareError
   \   0000005C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000060   0xE043             B.N      ??executeAll_3
    127          			//LL_DELETE(head, current);
    128          			head = head->next;
   \                     ??executeAll_6:
   \   00000062   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000066   0x6900             LDR      R0,[R0, #+16]
   \   00000068   0xF8CA 0x0000      STR      R0,[R10, #+0]
    129          			LL_PREPEND(executionList, current);
   \   0000006C   0xF8C6 0xB010      STR      R11,[R6, #+16]
   \   00000070   0x46B3             MOV      R11,R6
    130          		} else {
   \   00000072   0x464E             MOV      R6,R9
   \   00000074   0xE7D2             B.N      ??executeAll_0
    131          			/**
    132          			 * The list is sorted. Once we find one action in the future, all the remaining ones
    133          			 * are also in the future.
    134          			 */
    135          			break;
    136          		}
    137          	}
    138          #if EFI_UNIT_TEST
    139          	assertListIsSorted();
    140          #endif
    141          
    142          	/*
    143          	 * we need safe iteration here because 'callback' might change change 'current->next'
    144          	 * while re-inserting it into the queue from within the callback
    145          	 */
    146          	LL_FOREACH_SAFE(executionList, current, tmp)
   \                     ??executeAll_4:
   \                     ??executeAll_1:
   \   00000076   0x465E             MOV      R6,R11
   \                     ??executeAll_7:
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD035             BEQ.N    ??executeAll_8
   \   0000007C   0xF8D6 0x9010      LDR      R9,[R6, #+16]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD130             BNE.N    ??executeAll_8
    147          	{
    148          		uint32_t before = GET_TIMESTAMP();
   \   00000086   0x....             LDR.N    R0,??DataTable1_3  ;; 0xe0001004
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x9001             STR      R0,[SP, #+4]
    149          		current->isScheduled = false;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x7530             STRB     R0,[R6, #+20]
    150          		int howFarOff = now - current->momentX;
   \   00000090   0xE9D6 0x0100      LDRD     R0,R1,[R6, #+0]
   \   00000094   0x1A20             SUBS     R0,R4,R0
   \   00000096   0x9000             STR      R0,[SP, #+0]
    151          		maxHowFarOff = maxI(maxHowFarOff, howFarOff);
   \   00000098   0x9900             LDR      R1,[SP, #+0]
   \   0000009A   0x....             LDR.N    R0,??DataTable1_4
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x.... 0x....      BL       maxI
   \   000000A2   0x....             LDR.N    R1,??DataTable1_4
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    152          		current->callback(current->param);
   \   000000A6   0x68F0             LDR      R0,[R6, #+12]
   \   000000A8   0x68B1             LDR      R1,[R6, #+8]
   \   000000AA   0x4788             BLX      R1
    153          		// even with overflow it's safe to subtract here
    154          		lastEventQueueTime = GET_TIMESTAMP() - before;
   \   000000AC   0x....             LDR.N    R0,??DataTable1_3  ;; 0xe0001004
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x9901             LDR      R1,[SP, #+4]
   \   000000B2   0x1A40             SUBS     R0,R0,R1
   \   000000B4   0x....             LDR.N    R1,??DataTable1_5
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    155          		if (lastEventQueueTime > maxEventQueueTime)
   \   000000B8   0x....             LDR.N    R0,??DataTable1_6
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x....             LDR.N    R1,??DataTable1_5
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD203             BCS.N    ??executeAll_9
    156          			maxEventQueueTime = lastEventQueueTime;
   \   000000C4   0x....             LDR.N    R0,??DataTable1_6
   \   000000C6   0x....             LDR.N    R1,??DataTable1_5
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0x6001             STR      R1,[R0, #+0]
    157          		if (lastEventQueueTime > 2000) {
   \                     ??executeAll_9:
   \   000000CC   0x....             LDR.N    R0,??DataTable1_5
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   000000D4   0xD906             BLS.N    ??executeAll_10
    158          			longScheduling = current;
   \   000000D6   0x....             LDR.N    R0,??DataTable1_7
   \   000000D8   0x6006             STR      R6,[R0, #+0]
    159          			lastEventQueueTime++;
   \   000000DA   0x....             LDR.N    R0,??DataTable1_5
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x....             LDR.N    R1,??DataTable1_5
   \   000000E2   0x6008             STR      R0,[R1, #+0]
    160          		}
    161          	}
   \                     ??executeAll_10:
   \   000000E4   0x464E             MOV      R6,R9
   \   000000E6   0xE7C7             B.N      ??executeAll_7
    162          	return executionCounter;
   \                     ??executeAll_8:
   \   000000E8   0x4640             MOV      R0,R8
   \                     ??executeAll_3:
   \   000000EA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    163          }
    164          

   \                                 In section .text, align 2, keep-with-next
    165          int EventQueue::size(void) {
   \                     _ZN10EventQueue4sizeEv:
   \   00000000   0x0001             MOVS     R1,R0
    166          	scheduling_s *tmp;
    167          	int result;
    168          	LL_COUNT(head, tmp, result);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x0018             MOVS     R0,R3
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x001A             MOVS     R2,R3
   \                     ??size_0:
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD002             BEQ.N    ??size_1
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x6912             LDR      R2,[R2, #+16]
   \   00000012   0xE7FA             B.N      ??size_0
    169          	return result;
   \                     ??size_1:
   \   00000014   0x4770             BX       LR               ;; return
    170          }
    171          
    172          #if EFI_UNIT_TEST
    173          void EventQueue::assertListIsSorted() {
    174          	scheduling_s *current = head;
    175          	while (current != NULL && current->next != NULL) {
    176          		efiAssertVoid(current->momentX <= current->next->momentX, "list order");
    177          		current = current->next;
    178          	}
    179          }
    180          #endif
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void EventQueue::setLateDelay(int value) {
    183          	lateDelay = value;
   \                     _ZN10EventQueue12setLateDelayEi:
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x17CB             ASRS     R3,R1,#+31
   \   00000004   0xE9C0 0x2302      STRD     R2,R3,[R0, #+8]
    184          }
   \   00000008   0x4770             BX       LR               ;; return
    185          

   \                                 In section .text, align 2, keep-with-next
    186          scheduling_s * EventQueue::getHead() {
    187          	return head;
   \                     _ZN10EventQueue7getHeadEv:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
    188          }
    189          

   \                                 In section .text, align 2, keep-with-next
    190          scheduling_s *EventQueue::getForUnitText(int index) {
   \                     _ZN10EventQueue14getForUnitTextEi:
   \   00000000   0x0002             MOVS     R2,R0
    191          	scheduling_s * current;
    192          
    193          	LL_FOREACH(head, current)
   \   00000002   0x6810             LDR      R0,[R2, #+0]
   \   00000004   0x0003             MOVS     R3,R0
   \                     ??getForUnitText_0:
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD006             BEQ.N    ??getForUnitText_1
    194          	{
    195          		if (index == 0)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??getForUnitText_2
    196          			return current;
   \   0000000E   0x0018             MOVS     R0,R3
   \   00000010   0xE003             B.N      ??getForUnitText_3
    197          		index--;
   \                     ??getForUnitText_2:
   \   00000012   0x1E49             SUBS     R1,R1,#+1
    198          	}
   \   00000014   0x691B             LDR      R3,[R3, #+16]
   \   00000016   0xE7F6             B.N      ??getForUnitText_0
    199          	return NULL;
   \                     ??getForUnitText_1:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??getForUnitText_3:
   \   0000001A   0x4770             BX       LR               ;; return
    200          }
    201          

   \                                 In section .text, align 2, keep-with-next
    202          void EventQueue::clear(void) {
    203          	head = NULL;
   \                     _ZN10EventQueue5clearEv:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    204          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     `?<Constant "NULL callback">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     `?<Constant "Is this list looped?">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     `?<Constant "removing from head">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     maxHowFarOff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x........         DC32     lastEventQueueTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x........         DC32     maxEventQueueTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x........         DC32     longScheduling

   \                                 In section .rodata, align 4
   \                     `?<Constant "NULL callback">`:
   \   00000000   0x4E 0x55          DC8 "NULL callback"
   \              0x4C 0x4C    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x6C 0x62    
   \              0x61 0x63    
   \              0x6B 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Is this list looped?">`:
   \   00000000   0x49 0x73          DC8 "Is this list looped?"
   \              0x20 0x74    
   \              0x68 0x69    
   \              0x73 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x20 0x6C    
   \              0x6F 0x6F    
   \              0x70 0x65    
   \              0x64 0x3F    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "removing from head">`:
   \   00000000   0x72 0x65          DC8 "removing from head"
   \              0x6D 0x6F    
   \              0x76 0x69    
   \              0x6E 0x67    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x68 0x65    
   \              0x61 0x64    
   \              0x00         
   \   00000013   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   EventQueue::EventQueue()
         8   -> EventQueue::setLateDelay(int)
      16   EventQueue::checkIfPending(scheduling_s *)
        16   -> assertNotInList<scheduling_s>(scheduling_s *, scheduling_s *)
       0   EventQueue::clear()
      48   EventQueue::executeAll(int64_t)
        48   -- Indirect call
        48   -> firmwareError
        48   -> maxI
       0   EventQueue::getForUnitText(int)
       0   EventQueue::getHead()
      20   EventQueue::getNextEventTime(int64_t)
      32   EventQueue::insertTask(scheduling_s *, int64_t, schfunc_t, void *)
        32   -> firmwareError
       0   EventQueue::setLateDelay(int)
       0   EventQueue::size()
       8   EventQueue::subobject EventQueue()
         8   -> EventQueue::EventQueue()
      24   assertNotInList<scheduling_s>(scheduling_s *, scheduling_s *)
        24   -> firmwareError
        24   -> warning
       0   scheduling_s::scheduling_s()
       8   scheduling_s::subobject scheduling_s()
         8   -> scheduling_s::scheduling_s()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "Is this list looped?">
      16  ?<Constant "NULL callback">
      20  ?<Constant "removing from head">
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
      20  EventQueue::EventQueue()
      16  EventQueue::checkIfPending(scheduling_s *)
       6  EventQueue::clear()
     238  EventQueue::executeAll(int64_t)
      28  EventQueue::getForUnitText(int)
       4  EventQueue::getHead()
      68  EventQueue::getNextEventTime(int64_t)
     134  EventQueue::insertTask(scheduling_s *, int64_t, schfunc_t, void *)
      10  EventQueue::setLateDelay(int)
      22  EventQueue::size()
      12  EventQueue::subobject EventQueue()
      68  assertNotInList<scheduling_s>(scheduling_s *, scheduling_s *)
       4  lastEventQueueTime
       4  longScheduling
       4  maxEventQueueTime
       4  maxHowFarOff
      26  scheduling_s::scheduling_s()
      12  scheduling_s::subobject scheduling_s()
      52  -- Other

 
  16 bytes in section .bss
 112 bytes in section .rodata
 696 bytes in section .text
 
 628 bytes of CODE  memory (+ 68 bytes shared)
  60 bytes of CONST memory (+ 52 bytes shared)
  16 bytes of DATA  memory

Errors: none
Warnings: 3
