###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:49 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\vario #
#                       us\fatfs_bindings\fatfs_diskio.c                      #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\vario #
#                       us\fatfs_bindings\fatfs_diskio.c -lCN                 #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\f #
#                       atfs_diskio.lst                                       #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\fa #
#                       tfs_diskio.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\various\fatfs_bindings\fatfs_diskio.c
      1          /*-----------------------------------------------------------------------*/
      2          /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
      3          /*-----------------------------------------------------------------------*/
      4          /* This is a stub disk I/O module that acts as front end of the existing */
      5          /* disk I/O modules and attach it to FatFs module with common interface. */
      6          /*-----------------------------------------------------------------------*/
      7          
      8          #include "main.h"
      9          #include "ffconf.h"
     10          #include "diskio.h"
     11          
     12          #if EFI_FILE_LOGGING || defined(__DOXYGEN__)
     13          
     14          #if HAL_USE_MMC_SPI && HAL_USE_SDC
     15          #error "cannot specify both MMC_SPI and SDC drivers"
     16          #endif
     17          
     18          #if HAL_USE_MMC_SPI
     19          extern MMCDriver MMCD1;
     20          #elif HAL_USE_SDC
     21          extern SDCDriver SDCD1;
     22          #else
     23          #error "MMC_SPI or SDC driver must be specified"
     24          #endif
     25          
     26          #if HAL_USE_RTC
     27          #include "chrtclib.h"
     28          extern RTCDriver RTCD1;
     29          #endif
     30          
     31          /*-----------------------------------------------------------------------*/
     32          /* Correspondence between physical drive number and physical drive.      */
     33          
     34          #define MMC     0
     35          #define SDC     0
     36          
     37          
     38          
     39          /*-----------------------------------------------------------------------*/
     40          /* Inidialize a Drive                                                    */
     41          

   \                                 In section .text, align 2, keep-with-next
     42          DSTATUS disk_initialize (
     43              BYTE drv                /* Physical drive nmuber (0..) */
     44          )
     45          {
   \                     disk_initialize:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     46            DSTATUS stat;
     47          
     48            switch (drv) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD111             BNE.N    ??disk_initialize_0
     49          #if HAL_USE_MMC_SPI
     50            case MMC:
     51              stat = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
     52              /* It is initialized externally, just reads the status.*/
     53              if (blkGetDriverState(&MMCD1) != BLK_READY)
   \   0000000E   0x....             LDR.N    R0,??DataTable4
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD001             BEQ.N    ??disk_initialize_1
     54                stat |= STA_NOINIT;
   \   00000016   0xF055 0x0501      ORRS     R5,R5,#0x1
     55              if (mmcIsWriteProtected(&MMCD1))
   \                     ??disk_initialize_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable4
   \   0000001C   0x.... 0x....      BL       mmc_lld_is_write_protected
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??disk_initialize_2
     56                stat |=  STA_PROTECT;
   \   00000024   0xF055 0x0504      ORRS     R5,R5,#0x4
     57              return stat;
   \                     ??disk_initialize_2:
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xE000             B.N      ??disk_initialize_3
     58          #else
     59            case SDC:
     60              stat = 0;
     61              /* It is initialized externally, just reads the status.*/
     62              if (blkGetDriverState(&SDCD1) != BLK_READY)
     63                stat |= STA_NOINIT;
     64              if (sdcIsWriteProtected(&SDCD1))
     65                stat |=  STA_PROTECT;
     66              return stat;
     67          #endif
     68            }
     69            return STA_NODISK;
   \                     ??disk_initialize_0:
   \   0000002E   0x2002             MOVS     R0,#+2
   \                     ??disk_initialize_3:
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     70          }
     71          
     72          
     73          
     74          /*-----------------------------------------------------------------------*/
     75          /* Return Disk Status                                                    */
     76          

   \                                 In section .text, align 2, keep-with-next
     77          DSTATUS disk_status (
     78              BYTE drv        /* Physical drive nmuber (0..) */
     79          )
     80          {
   \                     disk_status:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     81            DSTATUS stat;
     82          
     83            switch (drv) {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD111             BNE.N    ??disk_status_0
     84          #if HAL_USE_MMC_SPI
     85            case MMC:
     86              stat = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
     87              /* It is initialized externally, just reads the status.*/
     88              if (blkGetDriverState(&MMCD1) != BLK_READY)
   \   0000000E   0x....             LDR.N    R0,??DataTable4
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD001             BEQ.N    ??disk_status_1
     89                stat |= STA_NOINIT;
   \   00000016   0xF055 0x0501      ORRS     R5,R5,#0x1
     90              if (mmcIsWriteProtected(&MMCD1))
   \                     ??disk_status_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable4
   \   0000001C   0x.... 0x....      BL       mmc_lld_is_write_protected
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??disk_status_2
     91                stat |= STA_PROTECT;
   \   00000024   0xF055 0x0504      ORRS     R5,R5,#0x4
     92              return stat;
   \                     ??disk_status_2:
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xE000             B.N      ??disk_status_3
     93          #else
     94            case SDC:
     95              stat = 0;
     96              /* It is initialized externally, just reads the status.*/
     97              if (blkGetDriverState(&SDCD1) != BLK_READY)
     98                stat |= STA_NOINIT;
     99              if (sdcIsWriteProtected(&SDCD1))
    100                stat |= STA_PROTECT;
    101              return stat;
    102          #endif
    103            }
    104            return STA_NODISK;
   \                     ??disk_status_0:
   \   0000002E   0x2002             MOVS     R0,#+2
   \                     ??disk_status_3:
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          
    108          
    109          /*-----------------------------------------------------------------------*/
    110          /* Read Sector(s)                                                        */
    111          

   \                                 In section .text, align 2, keep-with-next
    112          DRESULT disk_read (
    113              BYTE drv,        /* Physical drive nmuber (0..) */
    114              BYTE *buff,        /* Data buffer to store read data */
    115              DWORD sector,    /* Sector address (LBA) */
    116              BYTE count        /* Number of sectors to read (1..255) */
    117          )
    118          {
   \                     disk_read:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    119            switch (drv) {
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD125             BNE.N    ??disk_read_0
    120          #if HAL_USE_MMC_SPI
    121            case MMC:
    122              if (blkGetDriverState(&MMCD1) != BLK_READY)
   \   00000010   0x....             LDR.N    R0,??DataTable4
   \   00000012   0x7900             LDRB     R0,[R0, #+4]
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD001             BEQ.N    ??disk_read_1
    123                return RES_NOTRDY;
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xE020             B.N      ??disk_read_2
    124              if (mmcStartSequentialRead(&MMCD1, sector))
   \                     ??disk_read_1:
   \   0000001C   0x0031             MOVS     R1,R6
   \   0000001E   0x....             LDR.N    R0,??DataTable4
   \   00000020   0x.... 0x....      BL       mmcStartSequentialRead
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??disk_read_3
    125                return RES_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE018             B.N      ??disk_read_2
    126              while (count > 0) {
   \                     ??disk_read_3:
   \   0000002C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   0x2F00             CMP      R7,#+0
   \   00000030   0xD00B             BEQ.N    ??disk_read_4
    127                if (mmcSequentialRead(&MMCD1, buff))
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x....             LDR.N    R0,??DataTable4
   \   00000036   0x.... 0x....      BL       mmcSequentialRead
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??disk_read_5
    128                  return RES_ERROR;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE00D             B.N      ??disk_read_2
    129                buff += MMCSD_BLOCK_SIZE;
   \                     ??disk_read_5:
   \   00000042   0xF515 0x7500      ADDS     R5,R5,#+512
    130                count--;
   \   00000046   0x1E7F             SUBS     R7,R7,#+1
   \   00000048   0xE7F0             B.N      ??disk_read_3
    131              }
    132              if (mmcStopSequentialRead(&MMCD1))
   \                     ??disk_read_4:
   \   0000004A   0x....             LDR.N    R0,??DataTable4
   \   0000004C   0x.... 0x....      BL       mmcStopSequentialRead
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD001             BEQ.N    ??disk_read_6
    133                  return RES_ERROR;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xE002             B.N      ??disk_read_2
    134              return RES_OK;
   \                     ??disk_read_6:
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE000             B.N      ??disk_read_2
    135          #else
    136            case SDC:
    137              if (blkGetDriverState(&SDCD1) != BLK_READY)
    138                return RES_NOTRDY;
    139              if (sdcRead(&SDCD1, sector, buff, count))
    140                return RES_ERROR;
    141              return RES_OK;
    142          #endif
    143            }
    144            return RES_PARERR;
   \                     ??disk_read_0:
   \   0000005C   0x2004             MOVS     R0,#+4
   \                     ??disk_read_2:
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    145          }
    146          
    147          
    148          
    149          /*-----------------------------------------------------------------------*/
    150          /* Write Sector(s)                                                       */
    151          
    152          #if _READONLY == 0

   \                                 In section .text, align 2, keep-with-next
    153          DRESULT disk_write (
    154              BYTE drv,            /* Physical drive nmuber (0..) */
    155              const BYTE *buff,    /* Data to be written */
    156              DWORD sector,        /* Sector address (LBA) */
    157              BYTE count            /* Number of sectors to write (1..255) */
    158          )
    159          {
   \                     disk_write:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    160            switch (drv) {
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD12C             BNE.N    ??disk_write_0
    161          #if HAL_USE_MMC_SPI
    162            case MMC:
    163              if (blkGetDriverState(&MMCD1) != BLK_READY)
   \   00000010   0x....             LDR.N    R0,??DataTable4
   \   00000012   0x7900             LDRB     R0,[R0, #+4]
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD001             BEQ.N    ??disk_write_1
    164                  return RES_NOTRDY;
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xE027             B.N      ??disk_write_2
    165              if (mmcIsWriteProtected(&MMCD1))
   \                     ??disk_write_1:
   \   0000001C   0x....             LDR.N    R0,??DataTable4
   \   0000001E   0x.... 0x....      BL       mmc_lld_is_write_protected
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??disk_write_3
    166                  return RES_WRPRT;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xE020             B.N      ??disk_write_2
    167              if (mmcStartSequentialWrite(&MMCD1, sector))
   \                     ??disk_write_3:
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0x....             LDR.N    R0,??DataTable4
   \   0000002E   0x.... 0x....      BL       mmcStartSequentialWrite
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD001             BEQ.N    ??disk_write_4
    168                  return RES_ERROR;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE018             B.N      ??disk_write_2
    169              while (count > 0) {
   \                     ??disk_write_4:
   \   0000003A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD00B             BEQ.N    ??disk_write_5
    170                  if (mmcSequentialWrite(&MMCD1, buff))
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0x....             LDR.N    R0,??DataTable4
   \   00000044   0x.... 0x....      BL       mmcSequentialWrite
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD001             BEQ.N    ??disk_write_6
    171                      return RES_ERROR;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE00D             B.N      ??disk_write_2
    172                  buff += MMCSD_BLOCK_SIZE;
   \                     ??disk_write_6:
   \   00000050   0xF515 0x7500      ADDS     R5,R5,#+512
    173                  count--;
   \   00000054   0x1E7F             SUBS     R7,R7,#+1
   \   00000056   0xE7F0             B.N      ??disk_write_4
    174              }
    175              if (mmcStopSequentialWrite(&MMCD1))
   \                     ??disk_write_5:
   \   00000058   0x....             LDR.N    R0,??DataTable4
   \   0000005A   0x.... 0x....      BL       mmcStopSequentialWrite
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ.N    ??disk_write_7
    176                  return RES_ERROR;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xE002             B.N      ??disk_write_2
    177              return RES_OK;
   \                     ??disk_write_7:
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE000             B.N      ??disk_write_2
    178          #else
    179            case SDC:
    180              if (blkGetDriverState(&SDCD1) != BLK_READY)
    181                return RES_NOTRDY;
    182              if (sdcWrite(&SDCD1, sector, buff, count))
    183                return RES_ERROR;
    184              return RES_OK;
    185          #endif
    186            }
    187            return RES_PARERR;
   \                     ??disk_write_0:
   \   0000006A   0x2004             MOVS     R0,#+4
   \                     ??disk_write_2:
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    188          }
    189          #endif /* _READONLY */
    190          
    191          
    192          
    193          /*-----------------------------------------------------------------------*/
    194          /* Miscellaneous Functions                                               */
    195          

   \                                 In section .text, align 2, keep-with-next
    196          DRESULT disk_ioctl (
    197              BYTE drv,        /* Physical drive nmuber (0..) */
    198              BYTE ctrl,        /* Control code */
    199              void *buff        /* Buffer to send/receive control data */
    200          )
    201          {
   \                     disk_ioctl:
   \   00000000   0x0003             MOVS     R3,R0
    202            switch (drv) {
   \   00000002   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD10F             BNE.N    ??disk_ioctl_0
    203          #if HAL_USE_MMC_SPI
    204            case MMC:
    205              switch (ctrl) {
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0008             MOVS     R0,R1
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ.N    ??disk_ioctl_1
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD002             BEQ.N    ??disk_ioctl_2
   \   00000014   0xE006             B.N      ??disk_ioctl_3
    206              case CTRL_SYNC:
    207                  return RES_OK;
   \                     ??disk_ioctl_1:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE007             B.N      ??disk_ioctl_4
    208              case GET_SECTOR_SIZE:
    209                  *((WORD *)buff) = MMCSD_BLOCK_SIZE;
   \                     ??disk_ioctl_2:
   \   0000001A   0xF44F 0x7000      MOV      R0,#+512
   \   0000001E   0x8010             STRH     R0,[R2, #+0]
    210                  return RES_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE002             B.N      ??disk_ioctl_4
    211          #if _USE_ERASE
    212              case CTRL_ERASE_SECTOR:
    213                  mmcErase(&MMCD1, *((DWORD *)buff), *((DWORD *)buff + 1));
    214                  return RES_OK;
    215          #endif
    216              default:
    217                  return RES_PARERR;
   \                     ??disk_ioctl_3:
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xE000             B.N      ??disk_ioctl_4
    218              }
    219          #else
    220            case SDC:
    221              switch (ctrl) {
    222              case CTRL_SYNC:
    223                  return RES_OK;
    224              case GET_SECTOR_COUNT:
    225                  *((DWORD *)buff) = mmcsdGetCardCapacity(&SDCD1);
    226                  return RES_OK;
    227              case GET_SECTOR_SIZE:
    228                  *((WORD *)buff) = MMCSD_BLOCK_SIZE;
    229                  return RES_OK;
    230              case GET_BLOCK_SIZE:
    231                  *((DWORD *)buff) = 256; /* 512b blocks in one erase block */
    232                  return RES_OK;
    233          #if _USE_ERASE
    234              case CTRL_ERASE_SECTOR:
    235                  sdcErase(&SDCD1, *((DWORD *)buff), *((DWORD *)buff + 1));
    236                  return RES_OK;
    237          #endif
    238              default:
    239                  return RES_PARERR;
    240              }
    241          #endif
    242            }
    243            return RES_PARERR;
   \                     ??disk_ioctl_0:
   \   00000028   0x2004             MOVS     R0,#+4
   \                     ??disk_ioctl_4:
   \   0000002A   0x4770             BX       LR               ;; return
    244          }
    245          

   \                                 In section .text, align 2, keep-with-next
    246          DWORD get_fattime(void) {
   \                     get_fattime:
   \   00000000   0xB580             PUSH     {R7,LR}
    247          #if HAL_USE_RTC
    248              return rtcGetTimeFat(&RTCD1);
   \   00000002   0x....             LDR.N    R0,??DataTable4_1
   \   00000004   0x.... 0x....      BL       rtcGetTimeFat
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    249          #else
    250              return ((uint32_t)0 | (1 << 16)) | (1 << 21); /* wrong but valid time */
    251          #endif
    252          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     MMCD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     RTCD1
    253          
    254          #endif
    255          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   disk_initialize
        16   -> mmc_lld_is_write_protected
       0   disk_ioctl
      24   disk_read
        24   -> mmcSequentialRead
        24   -> mmcStartSequentialRead
        24   -> mmcStopSequentialRead
      16   disk_status
        16   -> mmc_lld_is_write_protected
      24   disk_write
        24   -> mmcSequentialWrite
        24   -> mmcStartSequentialWrite
        24   -> mmcStopSequentialWrite
        24   -> mmc_lld_is_write_protected
       8   get_fattime
         8   -> rtcGetTimeFat


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
      50  disk_initialize
      44  disk_ioctl
      96  disk_read
      50  disk_status
     110  disk_write
      10  get_fattime

 
 368 bytes in section .text
 
 368 bytes of CODE memory

Errors: none
Warnings: none
