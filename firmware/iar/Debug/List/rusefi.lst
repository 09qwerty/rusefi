###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:00 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\rusefi.cpp       #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\rusefi.cpp -lCN  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\r #
#                       usefi.lst                                             #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ru #
#                       sefi.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\rusefi.cpp
      1          /**
      2           * @file	rusefi.cpp
      3           * @brief Initialization code and main status reporting look
      4           *
      5           * @date Dec 25, 2013
      6           * @author Andrey Belomutskiy, (c) 2012-2015
      7           */
      8          
      9          /**
     10           * @mainpage
     11           *
     12           * @section sec_into
     13           *
     14           * rusEfi is implemented based on the idea that with modern 100+ MHz microprocessors the relatively
     15           * undemanding task of internal combustion engine control could be implemented in a high-level, processor-independent
     16           * (to some extent) manner. Thus the key concepts of rusEfi: dependency on high-level hardware abstraction layer, software-based PWM etc.
     17           *
     18           * @section sec_main Brief overview
     19           *
     20           * rusEfi runs on crankshaft or camshaft ('trigger') position sensor events.
     21           * Once per crankshaft revolution we evaluate the amount of needed fuel and
     22           * the spark timing. Once we have decided on the parameters for this revolution
     23           * we schedule all the actions to be triggered by the closest trigger event.
     24           *
     25           * We also have some utility threads like idle control thread and communication threads.
     26           *
     27           *
     28           *
     29           * @section sec_trigger Trigger Decoding
     30           *
     31           * Our primary trigger decoder is based on the idea of synchronizing the primary shaft signal and simply counting events on
     32           * the secondary signal. A typical scenario would be when camshaft positions sensor is the primary signal and crankshaft is secondary,
     33           * but sometimes there would be two signals generated by two camshaft sensors.
     34           * Another scenario is when we only have crankshaft position sensor, this would make it the primary signal and there would be no secondary signal.
     35           *
     36           * There is no software filtering so the signals are expected to be valid. TODO: in reality we are still catching engine stop noise as unrealisticly high RPM.
     37           *
     38           * The decoder is configured to act either on the primary signal rise or on the primary signal fall. It then compares the duration
     39           * of time from the previous signal to the duration of time from the signal before previous, and if the ratio falls into the configurable
     40           * range between 'syncRatioFrom' and 'syncRatioTo' this is assumed to be the synchronizing event.
     41           *
     42           * For instance, for a 36/1 skipped tooth wheel the ratio range for synchronization is from 1.5 to 3
     43           *
     44           * Some triggers do not require synchronization, this case we just count signals.
     45           * A single tooth primary signal would be a typical example when synchronization is not needed.
     46           *
     47           *
     48           *
     49           *
     50           *
     51           * @section sec_scheduler Event Scheduler
     52           *
     53           * It is a general agreement to measure all angles in crankshaft angles. In a four stroke
     54           * engine, a full cycle consists of two revolutions of the crankshaft, so all the angles are
     55           * running between 0 and 720 degrees.
     56           *
     57           * Ignition timing is a great example of a process which highlights the need of a hybrid
     58           * approach to event scheduling.
     59           * The most important part of controlling ignition
     60           * is firing up the spark at the right moment - so, for this job we need 'angle-based' timing,
     61           * for example we would need to fire up the spark at 700 degrees. Before we can fire up the spark
     62           * at 700 degrees, we need to charge the ignition coil, for example this dwell time is 4ms - that
     63           * means we need to turn on the coil at '4 ms before 700 degrees'. Let's  assume that the engine is
     64           * current at 600 RPM - that means 360 degrees would take 100ms so 4ms is 14.4 degrees at current RPM which
     65           * means we need to start charting the coil at 685.6 degrees.
     66           *
     67           * The position sensors at our disposal are not providing us the current position at any moment of time -
     68           * all we've got is a set of events which are happening at the knows positions. For instance, let's assume that
     69           * our sensor sends as an event at 0 degrees, at 90 degrees, at 600 degrees and and 690 degrees.
     70           *
     71           * So, for this particular sensor the most precise scheduling would be possible if we schedule coil charting
     72           * as '85.6 degrees after the 600 degrees position sensor event', and spark firing as
     73           * '10 degrees after the 690 position sensor event'. Considering current RPM, we calculate that '10 degress after' is
     74           * 2.777ms, so we schedule spark firing at '2.777ms after the 690 position sensor event', thus combining trigger events
     75           * with time-based offset.
     76           *
     77           * @section config Persistent Configuration
     78           * engine_configuration_s structure is kept in the internal flash memory, it has all the settings. Currently rusefi.ini has a direct mapping of this structure.
     79           *
     80           * Please note that due to TunerStudio protocol it's important to have the total structure size in synch between the firmware and TS .ini file -
     81           * just to make sure that this is not forgotten the size of the structure is hard-coded as PAGE_0_SIZE constant. There is always some 'unused' fields added in advance so that
     82           * one can add some fields without the pain of increasing the total config page size.
     83           * <br>See flash_main.cpp
     84           *
     85           *
     86           * @section sec_fuel_injection Fuel Injection
     87           *
     88           *
     89           * @sectuion sec_misc Misc
     90           *
     91           * <BR>See main_trigger_callback.cpp for main trigger event handler
     92           * <BR>See fuel_math.cpp for details on fuel amount logic
     93           * <BR>See rpm_calculator.cpp for details on how getRpm() is calculated
     94           *
     95           */
     96          
     97          #include "main.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SystemReset()
   \                     _Z16NVIC_SystemResetv:
   \   00000000   0xF3BF 0x8F4F      DSB      
   \   00000004   0x....             LDR.N    R0,??DataTable8_2  ;; 0xe000ed0c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \   0000000C   0x....             LDR.N    R1,??DataTable8_3  ;; 0x5fa0004
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0x....             LDR.N    R1,??DataTable8_2  ;; 0xe000ed0c
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0xF3BF 0x8F4F      DSB      
   \                     ??NVIC_SystemReset_0:
   \   00000018   0xE7FE             B.N      ??NVIC_SystemReset_0

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     98          #include "trigger_structure.h"
     99          #include "hardware.h"
    100          #include "engine_controller.h"
    101          #include "efiGpio.h"
    102          
    103          #include "global.h"
    104          #include "rfi_perftest.h"
    105          #include "rusefi.h"
    106          #include "memstreams.h"
    107          
    108          #include "eficonsole.h"
    109          #include "status_loop.h"
    110          #include "pin_repository.h"
    111          
    112          #if EFI_HD44780_LCD
    113          #include "lcd_HD44780.h"
    114          #endif /* EFI_HD44780_LCD */
    115          
    116          #if EFI_ENGINE_EMULATOR || defined(__DOXYGEN__)
    117          #include "engine_emulator.h"
    118          #endif /* EFI_ENGINE_EMULATOR */
    119          

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine:
   \   00000000   0xB580             PUSH     {R7,LR}
    120          static LoggingWithStorage sharedLogger("main");
   \   00000002   0x....             LDR.N    R1,??DataTable8
   \   00000004   0x....             LDR.N    R0,??DataTable8_1
   \   00000006   0x.... 0x....      BL       _ZN18LoggingWithStorageC1EPKc
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     sharedLogger:
   \   00000000                      DS8 260
    121          

   \                                 In section .bss, align 1
    122          bool_t main_loop_started = false;
   \                     main_loop_started:
   \   00000000                      DS8 1
    123          

   \                                 In section .bss, align 4
    124          static MemoryStream firmwareErrorMessageStream;
   \                     firmwareErrorMessageStream:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
    125          static char panicMessage[200];
   \                     panicMessage:
   \   00000000                      DS8 200
    126          

   \                                 In section .bss, align 4
    127          uint8_t errorMessageBuffer[200];
   \                     errorMessageBuffer:
   \   00000000                      DS8 200

   \                                 In section .bss, align 1
    128          bool hasFirmwareErrorFlag = false;
   \                     hasFirmwareErrorFlag:
   \   00000000                      DS8 1
    129          

   \                                 In section .bss, align 4
    130          static virtual_timer_t resetTimer;
   \                     resetTimer:
   \   00000000                      DS8 20
    131          
    132          EXTERN_ENGINE
    133          ;
    134          

   \                                 In section .text, align 2, keep-with-next
    135          char *getFirmwareError(void) {
    136          	return (char*) errorMessageBuffer;
   \                     getFirmwareError:
   \   00000000   0x....             LDR.N    R0,??DataTable8_4
   \   00000002   0x4770             BX       LR               ;; return
    137          }
    138          
    139          // todo: move this into a hw-specific file

   \                                 In section .text, align 2, keep-with-next
    140          static void rebootNow(void) {
   \                     _Z9rebootNowv:
   \   00000000   0xB580             PUSH     {R7,LR}
    141          	NVIC_SystemReset();
   \   00000002   0x.... 0x....      BL       _Z16NVIC_SystemResetv
    142          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    143          
    144          /**
    145           * Some configuration changes require full firmware reset.
    146           * Once day we will write graceful shutdown, but that would be one day.
    147           */

   \                                 In section .text, align 2, keep-with-next
    148          static void scheduleReboot(void) {
   \                     _Z14scheduleRebootv:
   \   00000000   0xB580             PUSH     {R7,LR}
    149          	scheduleMsg(&sharedLogger, "Rebooting in 5 seconds...");
   \   00000002   0x....             LDR.N    R1,??DataTable8_5
   \   00000004   0x....             LDR.N    R0,??DataTable8_1
   \   00000006   0x.... 0x....      BL       scheduleMsg
    150          	lockAnyContext();
   \   0000000A   0x.... 0x....      BL       lockAnyContext
    151          	chVTSetI(&resetTimer, 5 * CH_FREQUENCY, (vtfunc_t) rebootNow, NULL);
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x....             LDR.N    R2,??DataTable8_6
   \   00000012   0xF241 0x3188      MOVW     R1,#+5000
   \   00000016   0x....             LDR.N    R0,??DataTable8_7
   \   00000018   0x.... 0x....      BL       chVTSetI
    152          	unlockAnyContext();
   \   0000001C   0x.... 0x....      BL       unlockAnyContext
    153          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    154          

   \                                 In section .text, align 2, keep-with-next
    155          void swo_init() {
    156          	// todo: make SWO work
    157          //     uint32_t SWOSpeed = 2000000; //2000kbps, default for ST-LINK
    158          //     // todo: use a macro to access clock speed
    159          //     uint32_t SWOPrescaler = (168000000 / SWOSpeed) - 1; // SWOSpeed in Hz, note that F_CPU is expected to be 96000000 in this case
    160          //     CoreDebug->DEMCR = CoreDebug_DEMCR_TRCENA_Msk;
    161          //     *((volatile unsigned *)(ITM_BASE + 0x400F0)) = 0x00000002; // "Selected PIN Protocol Register": Select which protocol to use for trace output (2: SWO)
    162          //     *((volatile unsigned *)(ITM_BASE + 0x40010)) = SWOPrescaler; // "Async Clock Prescaler Register". Scale the baud rate of the asynchronous output
    163          //     *((volatile unsigned *)(ITM_BASE + 0x00FB0)) = 0xC5ACCE55; // ITM Lock Access Register, C5ACCE55 enables more write access to Control Register 0xE00 :: 0xFFC
    164          //     ITM->TCR = ITM_TCR_TraceBusID_Msk | ITM_TCR_SWOENA_Msk | ITM_TCR_SYNCENA_Msk | ITM_TCR_ITMENA_Msk; // ITM Trace Control Register
    165          //     ITM->TPR = ITM_TPR_PRIVMASK_Msk; // ITM Trace Privilege Register
    166          //     ITM->TER = 0x00000001; // ITM Trace Enable Register. Enabled tracing on stimulus ports. One bit per stimulus port.
    167          //     *((volatile unsigned *)(ITM_BASE + 0x01000)) = 0x400003FE; // DWT_CTRL
    168          //     *((volatile unsigned *)(ITM_BASE + 0x40304)) = 0x00000100; // Formatter and Flush Control Register
    169          }
   \                     _Z8swo_initv:
   \   00000000   0x4770             BX       LR               ;; return
    170          

   \                                 In section .bss, align 4
    171          engine_configuration_s activeConfiguration;
   \                     activeConfiguration:
   \   00000000                      DS8 2216
    172          

   \                                 In section .text, align 2, keep-with-next
    173          static void rememberCurrentConfiguration(void) {
   \                     _Z28rememberCurrentConfigurationv:
   \   00000000   0xB580             PUSH     {R7,LR}
    174          	memcpy(&activeConfiguration, engineConfiguration, sizeof(engine_configuration_s));
   \   00000002   0xF640 0x02A8      MOVW     R2,#+2216
   \   00000006   0x....             LDR.N    R0,??DataTable8_8
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable8_9
   \   0000000C   0x.... 0x....      BL       memcpy
    175          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void applyNewConfiguration(void) {
   \                     applyNewConfiguration:
   \   00000000   0xB580             PUSH     {R7,LR}
    178          	applyNewHardwareSettings();
   \   00000002   0x.... 0x....      BL       _Z24applyNewHardwareSettingsv
    179          	rememberCurrentConfiguration();
   \   00000006   0x.... 0x....      BL       _Z28rememberCurrentConfigurationv
    180          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void runRusEfi(void) {
   \                     runRusEfi:
   \   00000000   0xB580             PUSH     {R7,LR}
    183          	msObjectInit(&firmwareErrorMessageStream, errorMessageBuffer, sizeof(errorMessageBuffer), 0);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x22C8             MOVS     R2,#+200
   \   00000006   0x....             LDR.N    R1,??DataTable8_4
   \   00000008   0x....             LDR.N    R0,??DataTable8_10
   \   0000000A   0x.... 0x....      BL       msObjectInit
    184          
    185          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
    186          	engine->engineConfiguration2 = engineConfiguration2;
   \   0000000E   0x....             LDR.N    R0,??DataTable8_11
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x....             LDR.N    R1,??DataTable8_12
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x6281             STR      R1,[R0, #+40]
    187          #endif
    188          
    189          	initErrorHandling();
   \   00000018   0x.... 0x....      BL       initErrorHandling
    190          
    191          	swo_init();
   \   0000001C   0x.... 0x....      BL       _Z8swo_initv
    192          
    193          	prepareVoidConfiguration(&activeConfiguration);
   \   00000020   0x....             LDR.N    R0,??DataTable8_9
   \   00000022   0x.... 0x....      BL       _Z24prepareVoidConfigurationP22engine_configuration_s
    194          
    195          	/**
    196          	 * First data structure keeps track of which hardware I/O pins are used by whom
    197          	 */
    198          	initPinRepository();
   \   00000026   0x.... 0x....      BL       _Z17initPinRepositoryv
    199          
    200          	/**
    201          	 * Next we should initialize serial port console, it's important to know what's going on
    202          	 */
    203          	initializeConsole(&sharedLogger);
   \   0000002A   0x....             LDR.N    R0,??DataTable8_1
   \   0000002C   0x.... 0x....      BL       initializeConsole
    204          
    205          	engine->init();
   \   00000030   0x....             LDR.N    R0,??DataTable8_11
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x.... 0x....      BL       _ZN6Engine4initEv
    206          
    207          	addConsoleAction("reboot", scheduleReboot);
   \   00000038   0x....             LDR.N    R1,??DataTable8_13
   \   0000003A   0x....             LDR.N    R0,??DataTable8_14
   \   0000003C   0x.... 0x....      BL       addConsoleAction
    208          
    209          	/**
    210          	 * Initialize hardware drivers
    211          	 */
    212          	initHardware(&sharedLogger);
   \   00000040   0x....             LDR.N    R0,??DataTable8_1
   \   00000042   0x.... 0x....      BL       _Z12initHardwareP7Logging
    213          
    214          	initStatusLoop(engine);
   \   00000046   0x....             LDR.N    R0,??DataTable8_11
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x.... 0x....      BL       _Z14initStatusLoopP6Engine
    215          	/**
    216          	 * Now let's initialize actual engine control logic
    217          	 * todo: should we initialize some? most? controllers before hardware?
    218          	 */
    219          	initEngineContoller(&sharedLogger PASS_ENGINE_PARAMETER_F);
   \   0000004E   0x....             LDR.N    R0,??DataTable8_1
   \   00000050   0x.... 0x....      BL       _Z19initEngineContollerP7Logging
    220          
    221          #if EFI_PERF_METRICS || defined(__DOXYGEN__)
    222          	initTimePerfActions(&sharedLogger);
    223          #endif
    224          
    225          #if EFI_ENGINE_EMULATOR || defined(__DOXYGEN__)
    226          	initEngineEmulator(&sharedLogger, engine);
   \   00000054   0x....             LDR.N    R0,??DataTable8_11
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x....             LDR.N    R0,??DataTable8_1
   \   0000005A   0x.... 0x....      BL       _Z18initEngineEmulatorP7LoggingP6Engine
    227          #endif
    228          	startStatusThreads(engine);
   \   0000005E   0x....             LDR.N    R0,??DataTable8_11
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      BL       _Z18startStatusThreadsP6Engine
    229          
    230          	rememberCurrentConfiguration();
   \   00000066   0x.... 0x....      BL       _Z28rememberCurrentConfigurationv
    231          
    232          	print("Running main loop\r\n");
   \   0000006A   0x....             LDR.N    R0,??DataTable8_15
   \   0000006C   0x.... 0x....      BL       print
    233          	main_loop_started = true;
   \   00000070   0x....             LDR.N    R0,??DataTable8_16
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x7001             STRB     R1,[R0, #+0]
    234          	/**
    235          	 * This loop is the closes we have to 'main loop' - but here we only publish the status. The main logic of engine
    236          	 * control is around main_trigger_callback
    237          	 */
    238          	while (true) {
    239          		efiAssertVoid(getRemainingStack(chThdSelf()) > 128, "stack#1");
   \                     ??runRusEfi_0:
   \   00000076   0x....             LDR.N    R0,??DataTable8_17
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0x.... 0x....      BL       getRemainingStack
   \   0000007E   0x2881             CMP      R0,#+129
   \   00000080   0xDA03             BGE.N    ??runRusEfi_1
   \   00000082   0x....             LDR.N    R0,??DataTable8_18
   \   00000084   0x.... 0x....      BL       firmwareError
   \   00000088   0xE013             B.N      ??runRusEfi_2
    240          
    241          #if (EFI_CLI_SUPPORT && !EFI_UART_ECHO_TEST_MODE) || defined(__DOXYGEN__)
    242          		// sensor state + all pending messages for our own dev console
    243          		updateDevConsoleState(engine);
   \                     ??runRusEfi_1:
   \   0000008A   0x....             LDR.N    R0,??DataTable8_11
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x.... 0x....      BL       _Z21updateDevConsoleStateP6Engine
    244          #endif /* EFI_CLI_SUPPORT */
    245          
    246          		chThdSleepMilliseconds(boardConfiguration->consoleLoopPeriod);
   \   00000092   0x....             LDR.N    R0,??DataTable8_19
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF8D0 0x013C      LDR      R0,[R0, #+316]
   \   0000009A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000009E   0x4348             MULS     R0,R1,R0
   \   000000A0   0x1E40             SUBS     R0,R0,#+1
   \   000000A2   0xF44F 0x717A      MOV      R1,#+1000
   \   000000A6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0x.... 0x....      BL       chThdSleep
   \   000000B0   0xE7E1             B.N      ??runRusEfi_0
    247          	}
   \                     ??runRusEfi_2:
   \   000000B2   0xBD01             POP      {R0,PC}          ;; return
    248          }
    249          

   \                                 In section .text, align 2, keep-with-next
    250          void chDbgStackOverflowPanic(Thread *otp) {
   \                     _Z23chDbgStackOverflowPanicP6Thread:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    251          	strcpy(panicMessage, "stack overflow: ");
   \   00000004   0x....             LDR.N    R1,??DataTable8_20
   \   00000006   0x....             LDR.N    R0,??DataTable8_21
   \   00000008   0x.... 0x....      BL       strcpy
    252          #ifdef CH_USE_REGISTRY
    253          	strcat(panicMessage, otp->p_name);
   \   0000000C   0x69A1             LDR      R1,[R4, #+24]
   \   0000000E   0x.... 0x....      BL       strcat
    254          #endif
    255          	chDbgPanic3(panicMessage, __FILE__, __LINE__);
   \   00000012   0x22FF             MOVS     R2,#+255
   \   00000014   0x....             LDR.N    R1,??DataTable8_22
   \   00000016   0x....             LDR.N    R0,??DataTable8_21
   \   00000018   0x.... 0x....      BL       chDbgPanic3
    256          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    257          
    258          extern engine_pins_s enginePins;
    259          
    260          // todo: why is this method here and not in error_handling.cpp ?

   \                                 In section .text, align 2, keep-with-next
    261          void firmwareError(const char *errorMsg, ...) {
   \                     firmwareError:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0x0004             MOVS     R4,R0
    262          	if (hasFirmwareErrorFlag)
   \   00000006   0x....             LDR.N    R0,??DataTable8_23
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD129             BNE.N    ??firmwareError_0
    263          		return;
    264          	ON_FATAL_ERROR()
   \                     ??firmwareError_1:
   \   0000000E   0x....             LDR.N    R0,??DataTable8_24  ;; 0x40020c18
   \   00000010   0xF44F 0x4180      MOV      R1,#+16384
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0x.... 0x....      BL       _Z14turnAllPinsOffv
    265          	;
    266          	hasFirmwareErrorFlag = true;
   \   0000001A   0x....             LDR.N    R0,??DataTable8_23
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    267          	if (indexOf(errorMsg, '%') == -1) {
   \   00000020   0x2125             MOVS     R1,#+37
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       indexOf
   \   00000028   0xF110 0x0F01      CMN      R0,#+1
   \   0000002C   0xD109             BNE.N    ??firmwareError_2
    268          		/**
    269          		 * in case of simple error message let's reduce stack usage
    270          		 * because chvprintf might be causing an error
    271          		 */
    272          		strncpy((char*) errorMessageBuffer, errorMsg, sizeof(errorMessageBuffer) - 1);
   \   0000002E   0x22C7             MOVS     R2,#+199
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x....             LDR.N    R0,??DataTable8_4
   \   00000034   0x.... 0x....      BL       strncpy
    273          		errorMessageBuffer[sizeof(errorMessageBuffer) - 1] = 0; // just to be sure
   \   00000038   0x....             LDR.N    R0,??DataTable8_4
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xF880 0x10C7      STRB     R1,[R0, #+199]
   \   00000040   0xE00F             B.N      ??firmwareError_3
    274          	} else {
    275          		firmwareErrorMessageStream.eos = 0; // reset
   \                     ??firmwareError_2:
   \   00000042   0x....             LDR.N    R0,??DataTable8_10
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x60C1             STR      R1,[R0, #+12]
    276          		va_list ap;
    277          		va_start(ap, errorMsg);
   \   00000048   0xA803             ADD      R0,SP,#+12
   \   0000004A   0x0005             MOVS     R5,R0
    278          		chvprintf((BaseSequentialStream *) &firmwareErrorMessageStream, errorMsg, ap);
   \   0000004C   0x002A             MOVS     R2,R5
   \   0000004E   0x0021             MOVS     R1,R4
   \   00000050   0x....             LDR.N    R0,??DataTable8_10
   \   00000052   0x.... 0x....      BL       chvprintf
    279          		va_end(ap);
    280          
    281          		firmwareErrorMessageStream.buffer[firmwareErrorMessageStream.eos] = 0; // need to terminate explicitly
   \   00000056   0x....             LDR.N    R0,??DataTable8_10
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0x....             LDR.N    R1,??DataTable8_10
   \   0000005C   0x6849             LDR      R1,[R1, #+4]
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x5442             STRB     R2,[R0, R1]
    282          	}
    283          }
   \                     ??firmwareError_3:
   \                     ??firmwareError_0:
   \   00000062   0xBC30             POP      {R4,R5}
   \   00000064   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    284          

   \                                 In section .bss, align 4
    285          static char UNUSED_RAM_SIZE[200];
   \                     UNUSED_RAM_SIZE:
   \   00000000                      DS8 200
    286          

   \                                 In section .ccm, align 4
    287          static char UNUSED_CCM_SIZE[3600] CCM_OPTIONAL;
   \                     UNUSED_CCM_SIZE:
   \   00000000                      DS8 3600
    288          

   \                                 In section .text, align 2, keep-with-next
    289          int getRusEfiVersion(void) {
    290          	if (UNUSED_RAM_SIZE[0] != 0)
   \                     getRusEfiVersion:
   \   00000000   0x....             LDR.N    R0,??DataTable8_25
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??getRusEfiVersion_0
    291          		return 123; // this is here to make the compiler happy about the unused array
   \   00000008   0x207B             MOVS     R0,#+123
   \   0000000A   0xE009             B.N      ??getRusEfiVersion_1
    292          	if (UNUSED_CCM_SIZE[0] * 0 != 0)
   \                     ??getRusEfiVersion_0:
   \   0000000C   0x....             LDR.N    R0,??DataTable8_26
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??getRusEfiVersion_2
    293          		return 3211; // this is here to make the compiler happy about the unused array
   \   00000018   0xF640 0x408B      MOVW     R0,#+3211
   \   0000001C   0xE000             B.N      ??getRusEfiVersion_1
    294          	return 20150629;
   \                     ??getRusEfiVersion_2:
   \   0000001E   0x....             LDR.N    R0,??DataTable8_27  ;; 0x1337965
   \                     ??getRusEfiVersion_1:
   \   00000020   0x4770             BX       LR               ;; return
    295          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     `?<Constant "main">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     sharedLogger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     errorMessageBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     `?<Constant "Rebooting in 5 second...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     _Z9rebootNowv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     resetTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     activeConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     firmwareErrorMessageStream

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     engineConfiguration2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     _Z14scheduleRebootv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x........         DC32     `?<Constant "reboot">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x........         DC32     `?<Constant "Running main loop\\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     main_loop_started

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x........         DC32     `?<Constant "stack#1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x........         DC32     boardConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_20:
   \   00000000   0x........         DC32     `?<Constant "stack overflow: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_21:
   \   00000000   0x........         DC32     panicMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_22:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_23:
   \   00000000   0x........         DC32     hasFirmwareErrorFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_24:
   \   00000000   0x40020C18         DC32     0x40020c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_25:
   \   00000000   0x........         DC32     UNUSED_RAM_SIZE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_26:
   \   00000000   0x........         DC32     UNUSED_CCM_SIZE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_27:
   \   00000000   0x01337965         DC32     0x1337965

   \                                 In section .init_array, align 4, keep-with-next, root
   \   00000000   0x........         DC32    RELOC_ARM_TARGET1 __sti__routine

   \                                 In section .rodata, align 4
   \                     `?<Constant "Rebooting in 5 second...">`:
   \   00000000   0x52 0x65          DC8 "Rebooting in 5 seconds..."
   \              0x62 0x6F    
   \              0x6F 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x69 0x6E    
   \              0x20 0x35    
   \              0x20 0x73    
   \              0x65 0x63    
   \              0x6F 0x6E    
   \              0x64 0x73    
   \              0x2E 0x2E    
   \              0x2E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "reboot">`:
   \   00000000   0x72 0x65          DC8 "reboot"
   \              0x62 0x6F    
   \              0x6F 0x74    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Running main loop\\r\\n">`:
   \   00000000   0x52 0x75          DC8 "Running main loop\015\012"
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x6D 0x61    
   \              0x69 0x6E    
   \              0x20 0x6C    
   \              0x6F 0x6F    
   \              0x70 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "stack#1">`:
   \   00000000   0x73 0x74          DC8 "stack#1"
   \              0x61 0x63    
   \              0x6B 0x23    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "stack overflow: ">`:
   \   00000000   0x73 0x74          DC8 "stack overflow: "
   \              0x61 0x63    
   \              0x6B 0x20    
   \              0x6F 0x76    
   \              0x65 0x72    
   \              0x66 0x6C    
   \              0x6F 0x77    
   \              0x3A 0x20    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 "F:\\stuff\\rusefi_sourceforge\\firmware\\rusefi.cpp"
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \              0x5C 0x72    
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \              0x72 0x67    
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x5C 0x72    
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x2E    
   \              0x63 0x70    
   \              0x70 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "main">`:
   \   00000000   0x6D 0x61          DC8 "main"
   \              0x69 0x6E    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_SystemReset()
       8   __sti__routine()
         8   -> LoggingWithStorage::LoggingWithStorage(char const *)
       8   applyNewConfiguration
         8   -> applyNewHardwareSettings()
         8   -> rememberCurrentConfiguration()
       8   chDbgStackOverflowPanic(Thread *)
         8   -> chDbgPanic3
         8   -> strcat
         8   -> strcpy
      24   firmwareError
        24   -> chvprintf
        24   -> indexOf
        24   -> strncpy
        24   -> turnAllPinsOff()
       0   getFirmwareError
       0   getRusEfiVersion
      16   memcpy
        16   -> __aeabi_memcpy
       8   rebootNow()
         8   -> NVIC_SystemReset()
       8   rememberCurrentConfiguration()
         8   -> memcpy
       8   runRusEfi
         8   -> Engine::init()
         8   -> addConsoleAction
         8   -> chThdSleep
         8   -> firmwareError
         8   -> getRemainingStack
         8   -> initEngineContoller(Logging *)
         8   -> initEngineEmulator(Logging *, Engine *)
         8   -> initErrorHandling
         8   -> initHardware(Logging *)
         8   -> initPinRepository()
         8   -> initStatusLoop(Engine *)
         8   -> initializeConsole
         8   -> msObjectInit
         8   -> prepareVoidConfiguration(engine_configuration_s *)
         8   -> print
         8   -> rememberCurrentConfiguration()
         8   -> startStatusThreads(Engine *)
         8   -> swo_init()
         8   -> updateDevConsoleState(Engine *)
       8   scheduleReboot()
         8   -> chVTSetI
         8   -> lockAnyContext
         8   -> scheduleMsg
         8   -> unlockAnyContext
       0   swo_init()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      48  ?<Constant "F:\\stuff\\rusefi_sourc...">
      28  ?<Constant "Rebooting in 5 second...">
      20  ?<Constant "Running main loop\r\n">
       8  ?<Constant "main">
       8  ?<Constant "reboot">
      20  ?<Constant "stack overflow: ">
       8  ?<Constant "stack#1">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_20
       4  ??DataTable8_21
       4  ??DataTable8_22
       4  ??DataTable8_23
       4  ??DataTable8_24
       4  ??DataTable8_25
       4  ??DataTable8_26
       4  ??DataTable8_27
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      26  NVIC_SystemReset()
    3600  UNUSED_CCM_SIZE
     200  UNUSED_RAM_SIZE
      12  __sti__routine()
    2216  activeConfiguration
      12  applyNewConfiguration
      30  chDbgStackOverflowPanic(Thread *)
     200  errorMessageBuffer
     104  firmwareError
      20  firmwareErrorMessageStream
       4  getFirmwareError
      34  getRusEfiVersion
       1  hasFirmwareErrorFlag
       1  main_loop_started
      22  memcpy
     200  panicMessage
       8  rebootNow()
      18  rememberCurrentConfiguration()
      20  resetTimer
     180  runRusEfi
      34  scheduleReboot()
     260  sharedLogger
       2  swo_init()
       4  -- Other

 
 3 118 bytes in section .bss
 3 600 bytes in section .ccm
     4 bytes in section .init_array
   140 bytes in section .rodata
   598 bytes in section .text
 
   580 bytes of CODE  memory (+ 22 bytes shared)
   140 bytes of CONST memory
 6 718 bytes of DATA  memory

Errors: none
Warnings: 1
