###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:42 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\vario #
#                       us\chrtclib.c                                         #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\vario #
#                       us\chrtclib.c -lCN F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\Debug\List\ -lA F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -o                             #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\   #
#                       --no_cse --no_unroll --no_inline --no_code_motion     #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hrtclib.lst                                           #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       rtclib.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\various\chrtclib.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          /*
     17             Concepts and parts of this file have been contributed by Uladzimir Pylinsky
     18             aka barthess.
     19           */
     20          
     21          /**
     22           * @file    chrtclib.c
     23           * @brief   RTC time conversion utilities code.
     24           *
     25           * @addtogroup chrtclib
     26           * @{
     27           */
     28          
     29          #include <time.h>
     30          
     31          #include "ch.h"
     32          #include "hal.h"
     33          
     34          #include "chrtclib.h"
     35          
     36          #if HAL_USE_RTC || defined(__DOXYGEN__)
     37          
     38          #if (defined(STM32F4XX) || defined(STM32F2XX) || defined(STM32L1XX) ||        \
     39               defined(STM32F30X) || defined(STM32F37X) ||                              \
     40               defined(STM32F1XX) || defined(STM32F10X_MD) || defined(STM32F10X_LD) ||  \
     41               defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F0XX) ||  \
     42               defined(LPC122X) || defined(__DOXYGEN__))
     43          #if STM32_RTC_IS_CALENDAR
     44          /**
     45           * @brief   Converts from STM32 BCD to canonicalized time format.
     46           *
     47           * @param[out] timp     pointer to a @p tm structure as defined in time.h
     48           * @param[in] timespec  pointer to a @p RTCTime structure
     49           *
     50           * @notapi
     51           */

   \                                 In section .text, align 2, keep-with-next
     52          static void stm32_rtc_bcd2tm(struct tm *timp, RTCTime *timespec) {
   \                     stm32_rtc_bcd2tm:
   \   00000000   0xB470             PUSH     {R4-R6}
     53            uint32_t tv_time = timespec->tv_time;
   \   00000002   0x684A             LDR      R2,[R1, #+4]
     54            uint32_t tv_date = timespec->tv_date;
   \   00000004   0x680B             LDR      R3,[R1, #+0]
     55          
     56          #if CH_DBG_ENABLE_CHECKS
     57            timp->tm_isdst = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x6204             STR      R4,[R0, #+32]
     58            timp->tm_wday  = 0;
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x6184             STR      R4,[R0, #+24]
     59            timp->tm_mday  = 0;
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x60C4             STR      R4,[R0, #+12]
     60            timp->tm_yday  = 0;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x61C4             STR      R4,[R0, #+28]
     61            timp->tm_mon   = 0;
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0x6104             STR      R4,[R0, #+16]
     62            timp->tm_year  = 0;
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x6144             STR      R4,[R0, #+20]
     63            timp->tm_sec   = 0;
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x6004             STR      R4,[R0, #+0]
     64            timp->tm_min   = 0;
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0x6044             STR      R4,[R0, #+4]
     65            timp->tm_hour  = 0;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x6084             STR      R4,[R0, #+8]
     66          #endif
     67          
     68            timp->tm_isdst = -1;
   \   0000002A   0xF05F 0x34FF      MOVS     R4,#-1
   \   0000002E   0x6204             STR      R4,[R0, #+32]
     69          
     70            timp->tm_wday = (tv_date & RTC_DR_WDU) >> RTC_DR_WDU_OFFSET;
   \   00000030   0xF3C3 0x3442      UBFX     R4,R3,#+13,#+3
   \   00000034   0x6184             STR      R4,[R0, #+24]
     71            if (timp->tm_wday == 7)
   \   00000036   0x6984             LDR      R4,[R0, #+24]
   \   00000038   0x2C07             CMP      R4,#+7
   \   0000003A   0xD101             BNE.N    ??stm32_rtc_bcd2tm_0
     72              timp->tm_wday = 0;
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0x6184             STR      R4,[R0, #+24]
     73          
     74            timp->tm_mday =  (tv_date & RTC_DR_DU) >> RTC_DR_DU_OFFSET;
   \                     ??stm32_rtc_bcd2tm_0:
   \   00000040   0xF013 0x040F      ANDS     R4,R3,#0xF
   \   00000044   0x60C4             STR      R4,[R0, #+12]
     75            timp->tm_mday += ((tv_date & RTC_DR_DT) >> RTC_DR_DT_OFFSET) * 10;
   \   00000046   0x68C4             LDR      R4,[R0, #+12]
   \   00000048   0xF3C3 0x1501      UBFX     R5,R3,#+4,#+2
   \   0000004C   0x260A             MOVS     R6,#+10
   \   0000004E   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   00000052   0x60C4             STR      R4,[R0, #+12]
     76          
     77            timp->tm_mon  =  (tv_date & RTC_DR_MU) >> RTC_DR_MU_OFFSET;
   \   00000054   0xF3C3 0x2403      UBFX     R4,R3,#+8,#+4
   \   00000058   0x6104             STR      R4,[R0, #+16]
     78            timp->tm_mon  += ((tv_date & RTC_DR_MT) >> RTC_DR_MT_OFFSET) * 10;
   \   0000005A   0x6904             LDR      R4,[R0, #+16]
   \   0000005C   0xF3C3 0x3500      UBFX     R5,R3,#+12,#+1
   \   00000060   0x260A             MOVS     R6,#+10
   \   00000062   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   00000066   0x6104             STR      R4,[R0, #+16]
     79            timp->tm_mon  -= 1;
   \   00000068   0x6904             LDR      R4,[R0, #+16]
   \   0000006A   0x1E64             SUBS     R4,R4,#+1
   \   0000006C   0x6104             STR      R4,[R0, #+16]
     80          
     81            timp->tm_year =  (tv_date & RTC_DR_YU) >> RTC_DR_YU_OFFSET;
   \   0000006E   0xF3C3 0x4403      UBFX     R4,R3,#+16,#+4
   \   00000072   0x6144             STR      R4,[R0, #+20]
     82            timp->tm_year += ((tv_date & RTC_DR_YT) >> RTC_DR_YT_OFFSET) * 10;
   \   00000074   0x6944             LDR      R4,[R0, #+20]
   \   00000076   0xF3C3 0x5503      UBFX     R5,R3,#+20,#+4
   \   0000007A   0x260A             MOVS     R6,#+10
   \   0000007C   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   00000080   0x6144             STR      R4,[R0, #+20]
     83            timp->tm_year += 2000 - 1900;
   \   00000082   0x6944             LDR      R4,[R0, #+20]
   \   00000084   0x3464             ADDS     R4,R4,#+100
   \   00000086   0x6144             STR      R4,[R0, #+20]
     84          
     85            timp->tm_sec  =  (tv_time & RTC_TR_SU) >> RTC_TR_SU_OFFSET;
   \   00000088   0xF012 0x040F      ANDS     R4,R2,#0xF
   \   0000008C   0x6004             STR      R4,[R0, #+0]
     86            timp->tm_sec  += ((tv_time & RTC_TR_ST) >> RTC_TR_ST_OFFSET) * 10;
   \   0000008E   0x6804             LDR      R4,[R0, #+0]
   \   00000090   0xF3C2 0x1502      UBFX     R5,R2,#+4,#+3
   \   00000094   0x260A             MOVS     R6,#+10
   \   00000096   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   0000009A   0x6004             STR      R4,[R0, #+0]
     87          
     88            timp->tm_min  =  (tv_time & RTC_TR_MNU) >> RTC_TR_MNU_OFFSET;
   \   0000009C   0xF3C2 0x2403      UBFX     R4,R2,#+8,#+4
   \   000000A0   0x6044             STR      R4,[R0, #+4]
     89            timp->tm_min  += ((tv_time & RTC_TR_MNT) >> RTC_TR_MNT_OFFSET) * 10;
   \   000000A2   0x6844             LDR      R4,[R0, #+4]
   \   000000A4   0xF3C2 0x3502      UBFX     R5,R2,#+12,#+3
   \   000000A8   0x260A             MOVS     R6,#+10
   \   000000AA   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   000000AE   0x6044             STR      R4,[R0, #+4]
     90          
     91            timp->tm_hour =  (tv_time & RTC_TR_HU) >> RTC_TR_HU_OFFSET;
   \   000000B0   0xF3C2 0x4403      UBFX     R4,R2,#+16,#+4
   \   000000B4   0x6084             STR      R4,[R0, #+8]
     92            timp->tm_hour += ((tv_time & RTC_TR_HT) >> RTC_TR_HT_OFFSET) * 10;
   \   000000B6   0x6884             LDR      R4,[R0, #+8]
   \   000000B8   0xF3C2 0x5501      UBFX     R5,R2,#+20,#+2
   \   000000BC   0x260A             MOVS     R6,#+10
   \   000000BE   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   000000C2   0x6084             STR      R4,[R0, #+8]
     93            timp->tm_hour += 12 * ((tv_time & RTC_TR_PM) >> RTC_TR_PM_OFFSET);
   \   000000C4   0x6884             LDR      R4,[R0, #+8]
   \   000000C6   0xF3C2 0x5580      UBFX     R5,R2,#+22,#+1
   \   000000CA   0x260C             MOVS     R6,#+12
   \   000000CC   0xFB06 0x4405      MLA      R4,R6,R5,R4
   \   000000D0   0x6084             STR      R4,[R0, #+8]
     94          }
   \   000000D2   0xBC70             POP      {R4-R6}
   \   000000D4   0x4770             BX       LR               ;; return
     95          
     96          /**
     97           * @brief   Converts from canonicalized to STM32 BCD time format.
     98           *
     99           * @param[in] timp      pointer to a @p tm structure as defined in time.h
    100           * @param[out] timespec pointer to a @p RTCTime structure
    101           *
    102           * @notapi
    103           */

   \                                 In section .text, align 2, keep-with-next
    104          static void stm32_rtc_tm2bcd(struct tm *timp, RTCTime *timespec) {
   \                     stm32_rtc_tm2bcd:
   \   00000000   0xB430             PUSH     {R4,R5}
    105            uint32_t v = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    106          
    107            timespec->tv_date = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x600B             STR      R3,[R1, #+0]
    108            timespec->tv_time = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x604B             STR      R3,[R1, #+4]
    109          
    110            v = timp->tm_year - 100;
   \   0000000C   0x6943             LDR      R3,[R0, #+20]
   \   0000000E   0x3B64             SUBS     R3,R3,#+100
   \   00000010   0x001A             MOVS     R2,R3
    111            timespec->tv_date |= ((v / 10) << RTC_DR_YT_OFFSET) & RTC_DR_YT;
   \   00000012   0x680B             LDR      R3,[R1, #+0]
   \   00000014   0x240A             MOVS     R4,#+10
   \   00000016   0xFBB2 0xF4F4      UDIV     R4,R2,R4
   \   0000001A   0x0524             LSLS     R4,R4,#+20
   \   0000001C   0xF414 0x0470      ANDS     R4,R4,#0xF00000
   \   00000020   0x4323             ORRS     R3,R4,R3
   \   00000022   0x600B             STR      R3,[R1, #+0]
    112            timespec->tv_date |= (v % 10) << RTC_DR_YU_OFFSET;
   \   00000024   0x230A             MOVS     R3,#+10
   \   00000026   0x680C             LDR      R4,[R1, #+0]
   \   00000028   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   0000002C   0xFB03 0x2315      MLS      R3,R3,R5,R2
   \   00000030   0xEA54 0x4303      ORRS     R3,R4,R3, LSL #+16
   \   00000034   0x600B             STR      R3,[R1, #+0]
    113          
    114            if (timp->tm_wday == 0)
   \   00000036   0x6983             LDR      R3,[R0, #+24]
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD102             BNE.N    ??stm32_rtc_tm2bcd_0
    115              v = 7;
   \   0000003C   0x2307             MOVS     R3,#+7
   \   0000003E   0x001A             MOVS     R2,R3
   \   00000040   0xE001             B.N      ??stm32_rtc_tm2bcd_1
    116            else
    117              v = timp->tm_wday;
   \                     ??stm32_rtc_tm2bcd_0:
   \   00000042   0x6983             LDR      R3,[R0, #+24]
   \   00000044   0x001A             MOVS     R2,R3
    118            timespec->tv_date |= (v << RTC_DR_WDU_OFFSET) & RTC_DR_WDU;
   \                     ??stm32_rtc_tm2bcd_1:
   \   00000046   0x680B             LDR      R3,[R1, #+0]
   \   00000048   0x0354             LSLS     R4,R2,#+13
   \   0000004A   0xF414 0x4460      ANDS     R4,R4,#0xE000
   \   0000004E   0x4323             ORRS     R3,R4,R3
   \   00000050   0x600B             STR      R3,[R1, #+0]
    119          
    120            v = timp->tm_mon + 1;
   \   00000052   0x6903             LDR      R3,[R0, #+16]
   \   00000054   0x1C5B             ADDS     R3,R3,#+1
   \   00000056   0x001A             MOVS     R2,R3
    121            timespec->tv_date |= ((v / 10) << RTC_DR_MT_OFFSET) & RTC_DR_MT;
   \   00000058   0x680B             LDR      R3,[R1, #+0]
   \   0000005A   0x240A             MOVS     R4,#+10
   \   0000005C   0xFBB2 0xF4F4      UDIV     R4,R2,R4
   \   00000060   0x0324             LSLS     R4,R4,#+12
   \   00000062   0xF414 0x5480      ANDS     R4,R4,#0x1000
   \   00000066   0x4323             ORRS     R3,R4,R3
   \   00000068   0x600B             STR      R3,[R1, #+0]
    122            timespec->tv_date |= (v % 10) << RTC_DR_MU_OFFSET;
   \   0000006A   0x230A             MOVS     R3,#+10
   \   0000006C   0x680C             LDR      R4,[R1, #+0]
   \   0000006E   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   00000072   0xFB03 0x2315      MLS      R3,R3,R5,R2
   \   00000076   0xEA54 0x2303      ORRS     R3,R4,R3, LSL #+8
   \   0000007A   0x600B             STR      R3,[R1, #+0]
    123          
    124            v = timp->tm_mday;
   \   0000007C   0x68C3             LDR      R3,[R0, #+12]
   \   0000007E   0x001A             MOVS     R2,R3
    125            timespec->tv_date |= ((v / 10) << RTC_DR_DT_OFFSET) & RTC_DR_DT;
   \   00000080   0x680B             LDR      R3,[R1, #+0]
   \   00000082   0x240A             MOVS     R4,#+10
   \   00000084   0xFBB2 0xF4F4      UDIV     R4,R2,R4
   \   00000088   0x0124             LSLS     R4,R4,#+4
   \   0000008A   0xF014 0x0430      ANDS     R4,R4,#0x30
   \   0000008E   0x4323             ORRS     R3,R4,R3
   \   00000090   0x600B             STR      R3,[R1, #+0]
    126            timespec->tv_date |= (v % 10) << RTC_DR_DU_OFFSET;
   \   00000092   0x230A             MOVS     R3,#+10
   \   00000094   0x680C             LDR      R4,[R1, #+0]
   \   00000096   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   0000009A   0xFB03 0x2315      MLS      R3,R3,R5,R2
   \   0000009E   0x4323             ORRS     R3,R3,R4
   \   000000A0   0x600B             STR      R3,[R1, #+0]
    127          
    128            v = timp->tm_hour;
   \   000000A2   0x6883             LDR      R3,[R0, #+8]
   \   000000A4   0x001A             MOVS     R2,R3
    129            timespec->tv_time |= ((v / 10) << RTC_TR_HT_OFFSET) & RTC_TR_HT;
   \   000000A6   0x684B             LDR      R3,[R1, #+4]
   \   000000A8   0x240A             MOVS     R4,#+10
   \   000000AA   0xFBB2 0xF4F4      UDIV     R4,R2,R4
   \   000000AE   0x0524             LSLS     R4,R4,#+20
   \   000000B0   0xF414 0x1440      ANDS     R4,R4,#0x300000
   \   000000B4   0x4323             ORRS     R3,R4,R3
   \   000000B6   0x604B             STR      R3,[R1, #+4]
    130            timespec->tv_time |= (v % 10) << RTC_TR_HU_OFFSET;
   \   000000B8   0x230A             MOVS     R3,#+10
   \   000000BA   0x684C             LDR      R4,[R1, #+4]
   \   000000BC   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   000000C0   0xFB03 0x2315      MLS      R3,R3,R5,R2
   \   000000C4   0xEA54 0x4303      ORRS     R3,R4,R3, LSL #+16
   \   000000C8   0x604B             STR      R3,[R1, #+4]
    131          
    132            v = timp->tm_min;
   \   000000CA   0x6843             LDR      R3,[R0, #+4]
   \   000000CC   0x001A             MOVS     R2,R3
    133            timespec->tv_time |= ((v / 10) << RTC_TR_MNT_OFFSET) & RTC_TR_MNT;
   \   000000CE   0x684B             LDR      R3,[R1, #+4]
   \   000000D0   0x240A             MOVS     R4,#+10
   \   000000D2   0xFBB2 0xF4F4      UDIV     R4,R2,R4
   \   000000D6   0x0324             LSLS     R4,R4,#+12
   \   000000D8   0xF414 0x44E0      ANDS     R4,R4,#0x7000
   \   000000DC   0x4323             ORRS     R3,R4,R3
   \   000000DE   0x604B             STR      R3,[R1, #+4]
    134            timespec->tv_time |= (v % 10) << RTC_TR_MNU_OFFSET;
   \   000000E0   0x230A             MOVS     R3,#+10
   \   000000E2   0x684C             LDR      R4,[R1, #+4]
   \   000000E4   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   000000E8   0xFB03 0x2315      MLS      R3,R3,R5,R2
   \   000000EC   0xEA54 0x2303      ORRS     R3,R4,R3, LSL #+8
   \   000000F0   0x604B             STR      R3,[R1, #+4]
    135          
    136            v = timp->tm_sec;
   \   000000F2   0x6803             LDR      R3,[R0, #+0]
   \   000000F4   0x001A             MOVS     R2,R3
    137            timespec->tv_time |= ((v / 10) << RTC_TR_ST_OFFSET) & RTC_TR_ST;
   \   000000F6   0x684B             LDR      R3,[R1, #+4]
   \   000000F8   0x240A             MOVS     R4,#+10
   \   000000FA   0xFBB2 0xF4F4      UDIV     R4,R2,R4
   \   000000FE   0x0124             LSLS     R4,R4,#+4
   \   00000100   0xF014 0x0470      ANDS     R4,R4,#0x70
   \   00000104   0x4323             ORRS     R3,R4,R3
   \   00000106   0x604B             STR      R3,[R1, #+4]
    138            timespec->tv_time |= (v % 10) << RTC_TR_SU_OFFSET;
   \   00000108   0x230A             MOVS     R3,#+10
   \   0000010A   0x684C             LDR      R4,[R1, #+4]
   \   0000010C   0xFBB2 0xF5F3      UDIV     R5,R2,R3
   \   00000110   0xFB03 0x2315      MLS      R3,R3,R5,R2
   \   00000114   0x4323             ORRS     R3,R3,R4
   \   00000116   0x604B             STR      R3,[R1, #+4]
    139          }
   \   00000118   0xBC30             POP      {R4,R5}
   \   0000011A   0x4770             BX       LR               ;; return
    140          
    141          /**
    142           * @brief   Gets raw time from RTC and converts it to canonicalized format.
    143           *
    144           * @param[in] rtcp      pointer to RTC driver structure
    145           * @param[out] timp     pointer to a @p tm structure as defined in time.h
    146           *
    147           * @api
    148           */

   \                                 In section .text, align 2, keep-with-next
    149          void rtcGetTimeTm(RTCDriver *rtcp, struct tm *timp) {
   \                     rtcGetTimeTm:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    150          #if STM32_RTC_HAS_SUBSECONDS
    151            RTCTime timespec = {0,0,FALSE,0};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
    152          #else
    153            RTCTime timespec = {0,0,FALSE};
    154          #endif
    155          
    156            rtcGetTime(rtcp, &timespec);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       rtcGetTime
    157            stm32_rtc_bcd2tm(timp, &timespec);
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       stm32_rtc_bcd2tm
    158          }
   \   00000020   0xB005             ADD      SP,SP,#+20
   \   00000022   0xBD30             POP      {R4,R5,PC}       ;; return
    159          
    160          /**
    161           * @brief   Sets RTC time.
    162           *
    163           * @param[in] rtcp      pointer to RTC driver structure
    164           * @param[out] timp     pointer to a @p tm structure as defined in time.h
    165           *
    166           * @api
    167           */

   \                                 In section .text, align 2, keep-with-next
    168          void rtcSetTimeTm(RTCDriver *rtcp, struct tm *timp) {
   \                     rtcSetTimeTm:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    169          #if STM32_RTC_HAS_SUBSECONDS
    170            RTCTime timespec = {0,0,FALSE,0};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
    171          #else
    172            RTCTime timespec = {0,0,FALSE};
    173          #endif
    174          
    175            stm32_rtc_tm2bcd(timp, &timespec);
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       stm32_rtc_tm2bcd
    176            rtcSetTime(rtcp, &timespec);
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       rtcSetTime
    177          }
   \   00000020   0xB005             ADD      SP,SP,#+20
   \   00000022   0xBD30             POP      {R4,R5,PC}       ;; return
    178          
    179          /**
    180           * @brief   Gets raw time from RTC and converts it to unix format.
    181           *
    182           * @param[in] rtcp      pointer to RTC driver structure
    183           * @return              Unix time value in seconds.
    184           *
    185           * @api
    186           */

   \                                 In section .text, align 2, keep-with-next
    187          time_t rtcGetTimeUnixSec(RTCDriver *rtcp) {
   \                     rtcGetTimeUnixSec:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x0004             MOVS     R4,R0
    188          #if STM32_RTC_HAS_SUBSECONDS
    189            RTCTime timespec = {0,0,FALSE,0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    190          #else
    191            RTCTime timespec = {0,0,FALSE};
    192          #endif
    193            struct tm timp;
    194          
    195            rtcGetTime(rtcp, &timespec);
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       rtcGetTime
    196            stm32_rtc_bcd2tm(&timp, &timespec);
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0xA804             ADD      R0,SP,#+16
   \   0000001A   0x.... 0x....      BL       stm32_rtc_bcd2tm
    197          
    198            return mktime(&timp);
   \   0000001E   0xAD04             ADD      R5,SP,#+16
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       __mktime32
   \   00000026   0xB00F             ADD      SP,SP,#+60
   \   00000028   0xBD30             POP      {R4,R5,PC}       ;; return
    199          }
    200          
    201          /**
    202           * @brief   Sets RTC time.
    203           *
    204           * @param[in] rtcp      pointer to RTC driver structure
    205           * @param[in] tv_sec    time specification
    206           * @return              Unix time value in seconds.
    207           *
    208           * @api
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          void rtcSetTimeUnixSec(RTCDriver *rtcp, time_t tv_sec) {
   \                     rtcSetTimeUnixSec:
   \   00000000   0xB572             PUSH     {R1,R4-R6,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x0004             MOVS     R4,R0
    211          #if STM32_RTC_HAS_SUBSECONDS
    212            RTCTime timespec = {0,0,FALSE,0};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    213          #else
    214            RTCTime timespec = {0,0,FALSE};
    215          #endif
    216            struct tm timp;
    217          
    218          #if defined __GNUC__
    219            localtime_r(&tv_sec, &timp);
    220          #else
    221            struct tm *t = localtime(&tv_sec);
   \   0000000E   0xAE0F             ADD      R6,SP,#+60
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x.... 0x....      BL       __localtime32
   \   00000016   0x0005             MOVS     R5,R0
    222            memcpy(&timp, t, sizeof(struct tm));
   \   00000018   0x222C             MOVS     R2,#+44
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0xA804             ADD      R0,SP,#+16
   \   0000001E   0x.... 0x....      BL       memcpy
    223          #endif
    224            stm32_rtc_tm2bcd(&timp, &timespec);
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0xA804             ADD      R0,SP,#+16
   \   00000026   0x.... 0x....      BL       stm32_rtc_tm2bcd
    225            rtcSetTime(rtcp, &timespec);
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       rtcSetTime
    226          }
   \   00000032   0xB010             ADD      SP,SP,#+64
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    227          
    228          /**
    229           * @brief   Gets raw time from RTC and converts it to unix format.
    230           *
    231           * @param[in] rtcp      pointer to RTC driver structure
    232           * @return              Unix time value in microseconds.
    233           *
    234           * @api
    235           */

   \                                 In section .text, align 2, keep-with-next
    236          uint64_t rtcGetTimeUnixUsec(RTCDriver *rtcp) {
   \                     rtcGetTimeUnixUsec:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x0006             MOVS     R6,R0
    237          #if STM32_RTC_HAS_SUBSECONDS
    238            uint64_t result = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
    239            RTCTime timespec = {0,0,FALSE,0};
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    240            struct tm timp;
    241          
    242            rtcGetTime(rtcp, &timespec);
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       rtcGetTime
    243            stm32_rtc_bcd2tm(&timp, &timespec);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0xA804             ADD      R0,SP,#+16
   \   0000001E   0x.... 0x....      BL       stm32_rtc_bcd2tm
    244          
    245            result = (uint64_t)mktime(&timp) * 1000000;
   \   00000022   0xAF04             ADD      R7,SP,#+16
   \   00000024   0x0038             MOVS     R0,R7
   \   00000026   0x.... 0x....      BL       __mktime32
   \   0000002A   0x....             LDR.N    R1,??DataTable0  ;; 0xf4240
   \   0000002C   0xFBA1 0x0100      UMULL    R0,R1,R1,R0
   \   00000030   0x0004             MOVS     R4,R0
   \   00000032   0x000D             MOVS     R5,R1
    246            return result + timespec.tv_msec * 1000;
   \   00000034   0x9803             LDR      R0,[SP, #+12]
   \   00000036   0xF44F 0x717A      MOV      R1,#+1000
   \   0000003A   0x4348             MULS     R0,R1,R0
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x1820             ADDS     R0,R4,R0
   \   00000040   0x4169             ADCS     R1,R5,R1
   \   00000042   0xB00F             ADD      SP,SP,#+60
   \   00000044   0xBDF0             POP      {R4-R7,PC}       ;; return
    247          #else
    248            return (uint64_t)rtcGetTimeUnixSec(rtcp) * 1000000;
    249          #endif
    250          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000000         DC32 0

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000000         DC32 0

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000000         DC32 0

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000000         DC32 0

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000000         DC32 0
    251          
    252          #else /* STM32_RTC_IS_CALENDAR */
    253          /**
    254           * @brief   Gets raw time from RTC and converts it to canonicalized format.
    255           *
    256           * @param[in] rtcp      pointer to RTC driver structure
    257           * @param[out] timp     pointer to a @p tm structure as defined in time.h
    258           *
    259           * @api
    260           */
    261          void rtcGetTimeTm(RTCDriver *rtcp, struct tm *timp) {
    262            RTCTime timespec = {0};
    263          
    264            rtcGetTime(rtcp, &timespec);
    265          #if defined __GNUC__
    266            localtime_r((time_t *)&(timespec.tv_sec), timp);
    267          #else
    268            struct tm *t = localtime((time_t *)&(timespec.tv_sec));
    269            memcpy(&timp, t, sizeof(struct tm));
    270          #endif
    271          
    272          }
    273          
    274          /**
    275           * @brief   Sets RTC time.
    276           *
    277           * @param[in] rtcp      pointer to RTC driver structure
    278           * @param[out] timp     pointer to a @p tm structure as defined in time.h
    279           *
    280           * @api
    281           */
    282          void rtcSetTimeTm(RTCDriver *rtcp, struct tm *timp) {
    283            RTCTime timespec = {0};
    284          
    285            timespec.tv_sec = mktime(timp);
    286          #if !defined(LPC122X)
    287            timespec.tv_msec = 0;
    288          #endif
    289            rtcSetTime(rtcp, &timespec);
    290          }
    291          
    292          /**
    293           * @brief   Gets raw time from RTC and converts it to unix format.
    294           *
    295           * @param[in] rtcp      pointer to RTC driver structure
    296           * @return              Unix time value in seconds.
    297           *
    298           * @api
    299           */
    300          time_t rtcGetTimeUnixSec(RTCDriver *rtcp) {
    301            RTCTime timespec = {0};
    302          
    303            rtcGetTime(rtcp, &timespec);
    304            return timespec.tv_sec;
    305          }
    306          
    307          /**
    308           * @brief   Sets RTC time.
    309           *
    310           * @param[in] rtcp      pointer to RTC driver structure
    311           * @param[in] tv_sec    time specification
    312           * @return              Unix time value in seconds.
    313           *
    314           * @api
    315           */
    316          void rtcSetTimeUnixSec(RTCDriver *rtcp, time_t tv_sec) {
    317            RTCTime timespec = {0};
    318          
    319            timespec.tv_sec = tv_sec;
    320          #if !defined(LPC122X)
    321            timespec.tv_msec = 0;
    322          #endif
    323            rtcSetTime(rtcp, &timespec);
    324          }
    325          
    326          /**
    327           * @brief   Gets raw time from RTC and converts it to unix format.
    328           *
    329           * @param[in] rtcp      pointer to RTC driver structure
    330           * @return              Unix time value in microseconds.
    331           *
    332           * @api
    333           */
    334          uint64_t rtcGetTimeUnixUsec(RTCDriver *rtcp) {
    335          #if STM32_RTC_HAS_SUBSECONDS
    336            uint64_t result = 0;
    337            RTCTime timespec = {0,0};
    338          
    339            rtcGetTime(rtcp, &timespec);
    340            result = (uint64_t)timespec.tv_sec * 1000000;
    341            return result + timespec.tv_msec * 1000;
    342          #else
    343            return (uint64_t)rtcGetTimeUnixSec(rtcp) * 1000000;
    344          #endif
    345          }
    346          
    347          /**
    348           * @brief   Get current time in format suitable for usage in FatFS.
    349           *
    350           * @param[in] rtcp      pointer to RTC driver structure
    351           * @return              FAT time value.
    352           *
    353           * @api
    354           */
    355          uint32_t rtcGetTimeFatFromCounter(RTCDriver *rtcp) {
    356            uint32_t fattime;
    357            struct tm timp;
    358          
    359            rtcGetTimeTm(rtcp, &timp);
    360          
    361            fattime  = (timp.tm_sec)       >> 1;
    362            fattime |= (timp.tm_min)       << 5;
    363            fattime |= (timp.tm_hour)      << 11;
    364            fattime |= (timp.tm_mday)      << 16;
    365            fattime |= (timp.tm_mon + 1)   << 21;
    366            fattime |= (timp.tm_year - 80) << 25;
    367          
    368            return fattime;
    369          }
    370          #endif /* STM32_RTC_IS_CALENDAR */
    371          #endif /* (defined(STM32F4XX) || defined(STM32F2XX) || defined(STM32L1XX) || defined(STM32F1XX)) */
    372          
    373          #endif /* HAL_USE_RTC */
    374          
    375          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   rtcGetTimeTm
        32   -> __aeabi_memclr4
        32   -> rtcGetTime
        32   -> stm32_rtc_bcd2tm
      72   rtcGetTimeUnixSec
        72   -> __aeabi_memclr4
        72   -> __mktime32
        72   -> rtcGetTime
        72   -> stm32_rtc_bcd2tm
      80   rtcGetTimeUnixUsec
        80   -> __aeabi_memclr4
        80   -> __mktime32
        80   -> rtcGetTime
        80   -> stm32_rtc_bcd2tm
      32   rtcSetTimeTm
        32   -> __aeabi_memclr4
        32   -> rtcSetTime
        32   -> stm32_rtc_tm2bcd
      80   rtcSetTimeUnixSec
        80   -> __aeabi_memclr4
        80   -> __localtime32
        80   -> memcpy
        80   -> rtcSetTime
        80   -> stm32_rtc_tm2bcd
      12   stm32_rtc_bcd2tm
       8   stm32_rtc_tm2bcd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant {0, 0, 0, 0}>
      16  ?<Constant {0, 0, 0, 0}>_1
      16  ?<Constant {0, 0, 0, 0}>_2
      16  ?<Constant {0, 0, 0, 0}>_3
      16  ?<Constant {0, 0, 0, 0}>_4
       4  ??DataTable0
      36  rtcGetTimeTm
      42  rtcGetTimeUnixSec
      70  rtcGetTimeUnixUsec
      36  rtcSetTimeTm
      54  rtcSetTimeUnixSec
     214  stm32_rtc_bcd2tm
     284  stm32_rtc_tm2bcd

 
  80 bytes in section .rodata
 740 bytes in section .text
 
 740 bytes of CODE  memory
  80 bytes of CONST memory

Errors: none
Warnings: 1
