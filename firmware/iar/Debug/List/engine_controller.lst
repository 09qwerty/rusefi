###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:18 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\engi #
#                       ne_controller.cpp                                     #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\engi #
#                       ne_controller.cpp -lCN F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\Debug\List\ -lA                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\e #
#                       ngine_controller.lst                                  #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\en #
#                       gine_controller.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\engine_controller.cpp
      1          /**
      2           * @file    engine_controller.cpp
      3           * @brief   Controllers package entry point code
      4           *
      5           *
      6           *
      7           * @date Feb 7, 2013
      8           * @author Andrey Belomutskiy, (c) 2012-2015
      9           *
     10           * This file is part of rusEfi - see http://rusefi.com
     11           *
     12           * rusEfi is free software; you can redistribute it and/or modify it under the terms of
     13           * the GNU General Public License as published by the Free Software Foundation; either
     14           * version 3 of the License, or (at your option) any later version.
     15           *
     16           * rusEfi is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
     17           * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     18           * GNU General Public License for more details.
     19           *
     20           * You should have received a copy of the GNU General Public License along with this program.
     21           * If not, see <http://www.gnu.org/licenses/>.
     22           */
     23          
     24          #include <sensor_chart.h>
     25          #include "main.h"
     26          #include "engine_configuration.h"
     27          #include "trigger_central.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp cyclic_buffer<float>::~cyclic_buffer()
   \                     _ZN13cyclic_bufferIfED1Ev:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp AccelEnrichmemnt::~AccelEnrichmemnt()
   \                     _ZN16AccelEnrichmemntD1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x1D20             ADDS     R0,R4,#+4
   \   00000006   0x.... 0x....      BL       _ZN13cyclic_bufferIfED1Ev
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp Engine::~Engine()
   \                     _ZN6EngineD1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xF514 0x70A6      ADDS     R0,R4,#+332
   \   00000008   0x.... 0x....      BL       _ZN16AccelEnrichmemntD1Ev
   \   0000000C   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000010   0x.... 0x....      BL       _ZN16AccelEnrichmemntD1Ev
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
     28          #include "engine_controller.h"
     29          #include "fsio_core.h"
     30          #include "fsio_impl.h"
     31          #include "idle_thread.h"
     32          #include "rpm_calculator.h"
     33          #include "signal_executor.h"
     34          #include "main_trigger_callback.h"
     35          #include "io_pins.h"
     36          #include "flash_main.h"
     37          #include "tunerstudio.h"
     38          #include "injector_central.h"
     39          #include "rfiutil.h"
     40          #include "engine_math.h"
     41          #include "wave_analyzer.h"
     42          #include "allsensors.h"
     43          #include "electronic_throttle.h"
     44          #include "map_averaging.h"
     45          #include "malfunction_central.h"
     46          #include "malfunction_indicator.h"
     47          #include "engine.h"
     48          #include "algo.h"
     49          #include "LocalVersionHolder.h"
     50          #include "alternatorController.h"
     51          #include "fuel_math.h"
     52          #include "settings.h"
     53          
     54          #if HAL_USE_ADC || defined(__DOXYGEN__)
     55          #include "AdcConfiguration.h"
     56          #endif
     57          
     58          #if EFI_PROD_CODE
     59          #include "pwm_generator.h"
     60          #include "adc_inputs.h"
     61          #include "efilib2.h"
     62          #include "PwmTester.h"
     63          #include "pwm_generator.h"
     64          #include "lcd_controller.h"
     65          #include "pin_repository.h"
     66          #endif
     67          
     68          extern bool hasFirmwareErrorFlag;
     69          

   \                                 In section .ccm, align 4
     70          persistent_config_container_s persistentState CCM_OPTIONAL;
   \                     persistentState:
   \   00000000                      DS8 15300
     71          

   \                                 In section .data, align 4
     72          persistent_config_s *config = &persistentState.persistentConfiguration;
   \                     config:
   \   00000000   0x........         DC32 persistentState + 8H
     73          
     74          /**
     75           * todo: it really looks like these fields should become 'static', i.e. private
     76           * the whole 'extern ...' pattern is less then perfect, I guess the 'God object' Engine
     77           * would be a smaller evil. Whatever is needed should be passed into methods/modules/files as an explicit parameter.
     78           */

   \                                 In section .data, align 4
     79          engine_configuration_s *engineConfiguration = &persistentState.persistentConfiguration.engineConfiguration;
   \                     engineConfiguration:
   \   00000000   0x........         DC32 persistentState + 8H

   \                                 In section .data, align 4
     80          board_configuration_s *boardConfiguration = &persistentState.persistentConfiguration.engineConfiguration.bc;
   \                     boardConfiguration:
   \   00000000   0x........         DC32 persistentState + 278H
     81          
     82          /**
     83           * CH_FREQUENCY is the number of system ticks in a second
     84           */
     85          

   \                                 In section .bss, align 4
     86          static VirtualTimer periodicSlowTimer;
   \                     periodicSlowTimer:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     87          static VirtualTimer periodicFastTimer;
   \                     periodicFastTimer:
   \   00000000                      DS8 20
     88          

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine:
   \   00000000   0xB580             PUSH     {R7,LR}
     89          static LoggingWithStorage logger("Engine Controller");
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable23
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   0000000A   0x.... 0x....      BL       _ZN18LoggingWithStorageC1EPKc
     90          
     91          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
     92          static engine_configuration2_s ec2 CCM_OPTIONAL;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_2
   \   00000012   0x.... 0x....      BL       _ZN23engine_configuration2_sC1Ev
     93          engine_configuration2_s * engineConfiguration2 = &ec2;
     94          #endif
     95          
     96          #if (EFI_PROD_CODE || EFI_SIMULATOR) || defined(__DOXYGEN__)
     97          
     98          /**
     99           * todo: this should probably become 'static', i.e. private, and propagated around explicitly?
    100           */
    101          Engine _engine(&persistentState.persistentConfiguration);
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable23_3
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable23_4
   \   0000001E   0x.... 0x....      BL       _ZN6EngineC1EP19persistent_config_s
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable23_5
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable23_6
   \   0000002A   0x.... 0x....      BL       __aeabi_atexit
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23_7
   \   00000032   0x.... 0x....      BL       _ZN17Overflow64CounterC1Ev
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable23_8
   \   0000003A   0x.... 0x....      BL       _ZN18LocalVersionHolderC1Ev
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     logger:
   \   00000000                      DS8 260

   \                                 In section .ccm, align 8
   \                     ec2:
   \   00000000                      DS8 27488

   \                                 In section .data, align 4
   \                     engineConfiguration2:
   \   00000000   0x........         DC32 ec2

   \                                 In section .bss, align 8
   \                     _engine:
   \   00000000                      DS8 9240

   \                                 In section .data, align 4
    102          Engine * engine = &_engine;
   \                     engine:
   \   00000000   0x........         DC32 _engine
    103          #endif
    104          
    105          /**
    106           * I am not sure if this needs to be configurable.
    107           *
    108           * Also technically the whole feature might be implemented as cranking fuel coefficient curve by TPS.
    109           */
    110          #define CLEANUP_MODE_TPS 95
    111          
    112          extern OutputPin runningPin;
    113          

   \                                 In section .text, align 2, keep-with-next
    114          static msg_t csThread(void) {
   \                     _Z8csThreadv:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    115          	chRegSetThreadName("status");
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_9
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable23_10
   \   0000000C   0x6181             STR      R1,[R0, #+24]
    116          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    117          	while (true) {
    118          		int rpm = getRpm();
   \                     ??csThread_0:
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      BL       _ZN13RpmCalculator3rpmEv
   \   00000018   0x0004             MOVS     R4,R0
    119          		int is_cranking = isCrankingR(rpm);
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xDB07             BLT.N    ??csThread_1
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable23_12
   \   00000022   0xF9B0 0x0068      LDRSH    R0,[R0, #+104]
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xDA01             BGE.N    ??csThread_1
   \   0000002A   0x2501             MOVS     R5,#+1
   \   0000002C   0xE000             B.N      ??csThread_2
   \                     ??csThread_1:
   \   0000002E   0x2500             MOVS     R5,#+0
   \                     ??csThread_2:
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
    120          		int is_running = rpm > 0 && !is_cranking;
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xDB03             BLT.N    ??csThread_3
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD101             BNE.N    ??csThread_3
   \   0000003A   0x2601             MOVS     R6,#+1
   \   0000003C   0xE000             B.N      ??csThread_4
   \                     ??csThread_3:
   \   0000003E   0x2600             MOVS     R6,#+0
   \                     ??csThread_4:
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
    121          		if (is_running) {
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD010             BEQ.N    ??csThread_5
    122          			// blinking while running
    123          			runningPin.setValue(0);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable23_13
   \   0000004C   0x.... 0x....      BL       _ZN9OutputPin8setValueEi
    124          			chThdSleepMilliseconds(50);
   \   00000050   0x2032             MOVS     R0,#+50
   \   00000052   0x.... 0x....      BL       chThdSleep
    125          			runningPin.setValue(1);
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable23_13
   \   0000005C   0x.... 0x....      BL       _ZN9OutputPin8setValueEi
    126          			chThdSleepMilliseconds(50);
   \   00000060   0x2032             MOVS     R0,#+50
   \   00000062   0x.... 0x....      BL       chThdSleep
   \   00000066   0xE7D2             B.N      ??csThread_0
    127          		} else {
    128          			// constant on while cranking and off if engine is stopped
    129          			runningPin.setValue(is_cranking);
   \                     ??csThread_5:
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable23_13
   \   0000006E   0x.... 0x....      BL       _ZN9OutputPin8setValueEi
    130          			chThdSleepMilliseconds(100);
   \   00000072   0x2064             MOVS     R0,#+100
   \   00000074   0x.... 0x....      BL       chThdSleep
   \   00000078   0xE7C9             B.N      ??csThread_0
    131          		}
    132          	}
    133          #endif /* EFI_SHAFT_POSITION_INPUT */
    134          	return -1;
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          static void updateErrorCodes(void) {
   \                     _Z16updateErrorCodesv:
   \   00000000   0xB580             PUSH     {R7,LR}
    138          	/**
    139          	 * technically we can set error codes right inside the getMethods, but I a bit on a fence about it
    140          	 */
    141          	setError(!isValidIntakeAirTemperature(getIntakeAirTemperature(PASS_ENGINE_PARAMETER_F)),
    142          			OBD_Intake_Air_Temperature_Circuit_Malfunction);
   \   00000002   0x.... 0x....      BL       _Z23getIntakeAirTemperaturev
   \   00000006   0x.... 0x....      BL       _Z27isValidIntakeAirTemperaturef
   \   0000000A   0x216E             MOVS     R1,#+110
   \   0000000C   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       setError
    143          	setError(!isValidCoolantTemperature(getCoolantTemperature(PASS_ENGINE_PARAMETER_F)),
    144          			OBD_Engine_Coolant_Temperature_Circuit_Malfunction);
   \   00000016   0x.... 0x....      BL       _Z21getCoolantTemperaturev
   \   0000001A   0x.... 0x....      BL       _Z25isValidCoolantTemperaturef
   \   0000001E   0x2173             MOVS     R1,#+115
   \   00000020   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       setError
    145          }
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    146          
    147          #if EFI_PROD_CODE || defined(__DOXYGEN__)

   \                                 In section .bss, align 8
    148          Overflow64Counter halTime;
   \                     halTime:
   \   00000000                      DS8 16
    149          
    150          //todo: macro to save method invocation

   \                                 In section .text, align 2, keep-with-next
    151          efitimeus_t getTimeNowUs(void) {
   \                     getTimeNowUs:
   \   00000000   0xB580             PUSH     {R7,LR}
    152          	return getTimeNowNt() / (CORE_CLOCK / 1000000);
   \   00000002   0x.... 0x....      BL       getTimeNowNt
   \   00000006   0x22A8             MOVS     R2,#+168
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x.... 0x....      BL       __aeabi_ldivmod
   \   0000000E   0xBD04             POP      {R2,PC}          ;; return
    153          }
    154          
    155          //todo: macro to save method invocation

   \                                 In section .text, align 2, keep-with-next
    156          efitick_t getTimeNowNt(void) {
   \                     getTimeNowNt:
   \   00000000   0xB580             PUSH     {R7,LR}
    157          	return halTime.get();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_7
   \   00000006   0x.... 0x....      BL       _ZN17Overflow64Counter3getEv
   \   0000000A   0xBD04             POP      {R2,PC}          ;; return
    158          }
    159          

   \                                 In section .text, align 2, keep-with-next
    160          efitimems_t currentTimeMillis(void) {
    161          	// todo: migrate to getTimeNowUs? or not?
    162          	return chTimeNow() / TICKS_IN_MS;
   \                     currentTimeMillis:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable23_14
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0x4770             BX       LR               ;; return
    163          }
    164          

   \                                 In section .text, align 2, keep-with-next
    165          int getTimeNowSeconds(void) {
    166          	return chTimeNow() / CH_FREQUENCY;
   \                     getTimeNowSeconds:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable23_14
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0xF44F 0x717A      MOV      R1,#+1000
   \   0000000A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    167          }
    168          
    169          #endif /* EFI_PROD_CODE */
    170          

   \                                 In section .text, align 4, keep-with-next
    171          static void cylinderCleanupControl(Engine *engine) {
   \                     _Z22cylinderCleanupControlP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    172          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
    173          	bool newValue;
    174          	if (engineConfiguration->isCylinderCleanupEnabled) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF890 0x05E4      LDRB     R0,[R0, #+1508]
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x0880             LSRS     R0,R0,#+2
   \   00000012   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD011             BEQ.N    ??cylinderCleanupControl_0
    175          		newValue = isCrankingE(engine) && getTPS(PASS_ENGINE_PARAMETER_F) > CLEANUP_MODE_TPS;
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       _Z11isCrankingEP6Engine
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD00A             BEQ.N    ??cylinderCleanupControl_1
   \   00000024   0x.... 0x....      BL       _Z6getTPSv
   \   00000028   0xEDDF 0x....      VLDR.W   S1,??DataTable10  ;; 0x42be0001
   \   0000002C   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000030   0xEEF1 0xFA10      FMSTAT   
   \   00000034   0xDB01             BLT.N    ??cylinderCleanupControl_1
   \   00000036   0x2501             MOVS     R5,#+1
   \   00000038   0xE000             B.N      ??cylinderCleanupControl_2
   \                     ??cylinderCleanupControl_1:
   \   0000003A   0x2500             MOVS     R5,#+0
   \                     ??cylinderCleanupControl_2:
   \   0000003C   0xE001             B.N      ??cylinderCleanupControl_3
    176          	} else {
    177          		newValue = false;
   \                     ??cylinderCleanupControl_0:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0005             MOVS     R5,R0
    178          	}
    179          	if (newValue != engine->isCylinderCleanupMode) {
   \                     ??cylinderCleanupControl_3:
   \   00000042   0xF641 0x60F8      MOVW     R0,#+7928
   \   00000046   0x5D00             LDRB     R0,[R0, R4]
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD00D             BEQ.N    ??cylinderCleanupControl_4
    180          		engine->isCylinderCleanupMode = newValue;
   \   0000004E   0xF641 0x60F8      MOVW     R0,#+7928
   \   00000052   0x5505             STRB     R5,[R0, R4]
    181          		scheduleMsg(&logger, "isCylinderCleanupMode %s", boolToString(newValue));
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x.... 0x....      BL       _Z12boolToStringb
   \   0000005C   0x0002             MOVS     R2,R0
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable23_16
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000066   0x.... 0x....      BL       scheduleMsg
    182          	}
    183          #endif
    184          }
   \                     ??cylinderCleanupControl_4:
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    185          

   \                                 In section .bss, align 4
    186          static LocalVersionHolder versionForConfigurationListeners;
   \                     versionForConfigurationListeners:
   \   00000000                      DS8 4
    187          
    188          static void periodicSlowCallback(Engine *engine);
    189          

   \                                 In section .text, align 2, keep-with-next
    190          static void scheduleNextSlowInvocation(void) {
   \                     _Z26scheduleNextSlowInvocationv:
   \   00000000   0xB510             PUSH     {R4,LR}
    191          	// schedule next invocation
    192          	int period = boardConfiguration->generalPeriodicThreadPeriod;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_17
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF8D0 0x4148      LDR      R4,[R0, #+328]
    193          	if (period == 0)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??scheduleNextSlowInvocation_0
    194          		period = 50; // this might happen while resetting config
   \   00000010   0x2032             MOVS     R0,#+50
   \   00000012   0x0004             MOVS     R4,R0
    195          	chVTSetAny(&periodicSlowTimer, period * TICKS_IN_MS, (vtfunc_t) &periodicSlowCallback, engine);
   \                     ??scheduleNextSlowInvocation_0:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   00000018   0x6803             LDR      R3,[R0, #+0]
   \   0000001A   0x.... 0x....      ADR.W    R2,_Z20periodicSlowCallbackP6Engine
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_18
   \   00000024   0x.... 0x....      BL       chVTSetAny
    196          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    197          

   \                                 In section .text, align 2, keep-with-next
    198          static void periodicFastCallback(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z20periodicFastCallbackv:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    199          	int rpm = engine->rpmCalculator.rpmValue;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6804             LDR      R4,[R0, #+0]
    200          
    201          	if (isValidRpm(rpm)) {
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xDB2E             BLT.N    ??periodicFastCallback_0
   \   0000000E   0xF247 0x5030      MOVW     R0,#+30000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xDA2A             BGE.N    ??periodicFastCallback_0
    202          		MAP_sensor_config_s * c = &engineConfiguration->map;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF110 0x0570      ADDS     R5,R0,#+112
    203          		engine->engineState.mapAveragingStart = interpolate2d(rpm, c->samplingAngleBins, c->samplingAngle, MAP_ANGLE_SIZE);
   \   00000020   0x2208             MOVS     R2,#+8
   \   00000022   0xF115 0x0120      ADDS     R1,R5,#+32
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xEE00 0x4A10      VMOV     S0,R4
   \   0000002C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000030   0x.... 0x....      BL       _Z13interpolate2dfPfS_i
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF500 0x50F0      ADD      R0,R0,#+7680
   \   0000003E   0x30AC             ADDS     R0,R0,#+172
   \   00000040   0xED80 0x0A00      VSTR     S0,[R0, #0]
    204          		engine->engineState.mapAveragingDuration = interpolate2d(rpm, c->samplingWindowBins, c->samplingWindow, MAP_WINDOW_SIZE);
   \   00000044   0x2208             MOVS     R2,#+8
   \   00000046   0xF115 0x0160      ADDS     R1,R5,#+96
   \   0000004A   0xF115 0x0040      ADDS     R0,R5,#+64
   \   0000004E   0xEE00 0x4A10      VMOV     S0,R4
   \   00000052   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000056   0x.... 0x....      BL       _Z13interpolate2dfPfS_i
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF500 0x50F0      ADD      R0,R0,#+7680
   \   00000064   0x30B0             ADDS     R0,R0,#+176
   \   00000066   0xED80 0x0A00      VSTR     S0,[R0, #0]
   \   0000006A   0xE00F             B.N      ??periodicFastCallback_1
    205          	} else {
    206          		engine->engineState.mapAveragingStart = NAN;
   \                     ??periodicFastCallback_0:
   \   0000006C   0xF641 0x60AC      MOVW     R0,#+7852
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable23_11
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0xF07F 0x4200      MVNS     R2,#-2147483648
   \   0000007A   0x5042             STR      R2,[R0, R1]
    207          		engine->engineState.mapAveragingDuration = NAN;
   \   0000007C   0xF641 0x60B0      MOVW     R0,#+7856
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable23_11
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0xF07F 0x4200      MVNS     R2,#-2147483648
   \   0000008A   0x5042             STR      R2,[R0, R1]
    208          	}
    209          
    210          	engine->periodicFastCallback();
   \                     ??periodicFastCallback_1:
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       _ZN6Engine20periodicFastCallbackEv
    211          
    212          	chVTSetAny(&periodicFastTimer, 20 * TICKS_IN_MS, (vtfunc_t) &periodicFastCallback, engine);
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable23_11
   \   0000009A   0x6803             LDR      R3,[R0, #+0]
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable23_19
   \   000000A0   0x2114             MOVS     R1,#+20
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable23_20
   \   000000A6   0x.... 0x....      BL       chVTSetAny
    213          }
   \   000000AA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    214          

   \                                 In section .text, align 4, keep-with-next
    215          static void periodicSlowCallback(Engine *engine) {
   \                     _Z20periodicSlowCallbackP6Engine:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    216          	efiAssertVoid(getRemainingStack(chThdSelf()) > 64, "lowStckOnEv");
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_9
   \   00000008   0x6980             LDR      R0,[R0, #+24]
   \   0000000A   0x.... 0x....      BL       getRemainingStack
   \   0000000E   0x2841             CMP      R0,#+65
   \   00000010   0xDA04             BGE.N    ??periodicSlowCallback_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable23_21
   \   00000016   0x.... 0x....      BL       firmwareError
   \   0000001A   0xE02F             B.N      ??periodicSlowCallback_1
    217          #if EFI_PROD_CODE
    218          	/**
    219          	 * We need to push current value into the 64 bit counter often enough so that we do not miss an overflow
    220          	 */
    221          	bool alreadyLocked = lockAnyContext();
   \                     ??periodicSlowCallback_0:
   \   0000001C   0x.... 0x....      BL       lockAnyContext
   \   00000020   0x0005             MOVS     R5,R0
    222          	updateAndSet(&halTime.state, hal_lld_get_counter_value());
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23_22  ;; 0xe0001004
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable23_7
   \   0000002C   0x.... 0x....      BL       _Z12updateAndSetP7State64j
    223          	if (!alreadyLocked) {
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD101             BNE.N    ??periodicSlowCallback_2
    224          		unlockAnyContext();
   \   00000036   0x.... 0x....      BL       unlockAnyContext
    225          	}
    226          #endif
    227          
    228          #if (EFI_PROD_CODE && EFI_ENGINE_CONTROL && EFI_INTERNAL_FLASH) || defined(__DOXYGEN__)
    229          	if (!engine->rpmCalculator.isRunning()) {
   \                     ??periodicSlowCallback_2:
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       _ZN13RpmCalculator9isRunningEv
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD101             BNE.N    ??periodicSlowCallback_3
    230          		writeToFlashIfPending();
   \   00000044   0x.... 0x....      BL       _Z21writeToFlashIfPendingv
    231          	}
    232          #endif
    233          
    234          	if (versionForConfigurationListeners.isOld()) {
   \                     ??periodicSlowCallback_3:
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable23_8
   \   0000004C   0x.... 0x....      BL       _ZN18LocalVersionHolder5isOldEv
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD004             BEQ.N    ??periodicSlowCallback_4
    235          		/**
    236          		 * version change could happen for multiple reason and on different threads
    237          		 * in order to be sure which thread (and which stack) invokes the potentially heavy
    238          		 * listeners we invoke them from here.
    239          		 */
    240          		engine->configurationListeners.invokeJustArgCallbacks();
   \   00000054   0xF504 0x500C      ADD      R0,R4,#+8960
   \   00000058   0x3044             ADDS     R0,R0,#+68
   \   0000005A   0x.... 0x....      BL       _ZN16IntListenerArray22invokeJustArgCallbacksEv
    241          	}
    242          
    243          	engine->watchdog();
   \                     ??periodicSlowCallback_4:
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       _ZN6Engine8watchdogEv
    244          	engine->updateSlowSensors();
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       _ZN6Engine17updateSlowSensorsEv
    245          
    246          #if (EFI_PROD_CODE && EFI_FSIO) || defined(__DOXYGEN__)
    247          	runFsio();
   \   0000006A   0x.... 0x....      BL       _Z7runFsiov
    248          #endif
    249          
    250          	updateErrorCodes();
   \   0000006E   0x.... 0x....      BL       _Z16updateErrorCodesv
    251          
    252          	cylinderCleanupControl(engine);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       _Z22cylinderCleanupControlP6Engine
    253          
    254          	scheduleNextSlowInvocation();
   \   00000078   0x.... 0x....      BL       _Z26scheduleNextSlowInvocationv
    255          }
   \                     ??periodicSlowCallback_1:
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    256          

   \                                 In section .text, align 2, keep-with-next
    257          void initPeriodicEvents(DECLARE_ENGINE_PARAMETER_F) {
   \                     _Z18initPeriodicEventsv:
   \   00000000   0xB580             PUSH     {R7,LR}
    258          	scheduleNextSlowInvocation();
   \   00000002   0x.... 0x....      BL       _Z26scheduleNextSlowInvocationv
    259          	periodicFastCallback(PASS_ENGINE_PARAMETER_F);
   \   00000006   0x.... 0x....      BL       _Z20periodicFastCallbackv
    260          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    261          

   \                                 In section .text, align 2, keep-with-next
    262          char * getPinNameByAdcChannel(adc_channel_e hwChannel, char *buffer) {
   \                     _Z22getPinNameByAdcChannel13adc_channel_ePc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    263          #if HAL_USE_ADC || defined(__DOXYGEN__)
    264          	strcpy((char*) buffer, portname(getAdcChannelPort(hwChannel)));
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       _Z17getAdcChannelPort13adc_channel_e
   \   0000000C   0x.... 0x....      BL       _Z8portnameP12GPIO_TypeDef
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       strcpy
    265          	itoa10(&buffer[2], getAdcChannelPin(hwChannel));
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       _Z16getAdcChannelPin13adc_channel_e
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0x1CA8             ADDS     R0,R5,#+2
   \   00000022   0x.... 0x....      BL       itoa10
    266          #else
    267          	strcpy(buffer, "NONE");
    268          #endif
    269          	return (char*) buffer;
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    270          }
    271          

   \                                 In section .bss, align 4
    272          static char pinNameBuffer[16];
   \                     pinNameBuffer:
   \   00000000                      DS8 16
    273          
    274          #if HAL_USE_ADC || defined(__DOXYGEN__)
    275          extern AdcDevice fastAdc;
    276          #endif
    277          

   \                                 In section .text, align 2, keep-with-next
    278          static void printAnalogChannelInfoExt(const char *name, adc_channel_e hwChannel, float adcVoltage,
    279          		float dividerCoeff) {
   \                     _Z25printAnalogChannelInfoExtPKc13adc_channel_eff:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0xB088             SUB      SP,SP,#+32
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
   \   0000000C   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   00000010   0xEEF0 0x8A60      VMOV.F32 S17,S1
    280          #if HAL_USE_ADC || defined(__DOXYGEN__)
    281          	if (hwChannel == EFI_ADC_NONE) {
   \   00000014   0x2D10             CMP      R5,#+16
   \   00000016   0xD107             BNE.N    ??printAnalogChannelInfoExt_0
    282          		scheduleMsg(&logger, "ADC is not assigned for %s", name);
   \   00000018   0x0022             MOVS     R2,R4
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable23_23
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000022   0x.... 0x....      BL       scheduleMsg
    283          		return;
   \   00000026   0xE040             B.N      ??printAnalogChannelInfoExt_1
    284          	}
    285          
    286          	if (fastAdc.isHwUsed(hwChannel)) {
   \                     ??printAnalogChannelInfoExt_0:
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable23_24
   \   0000002E   0x.... 0x....      BL       _ZN9AdcDevice8isHwUsedE13adc_channel_e
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD011             BEQ.N    ??printAnalogChannelInfoExt_2
    287          		scheduleMsg(&logger, "fast enabled=%s", boolToString(boardConfiguration->isFastAdcEnabled));
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable23_17
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF890 0x0180      LDRB     R0,[R0, #+384]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x0900             LSRS     R0,R0,#+4
   \   00000044   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000048   0x.... 0x....      BL       _Z12boolToStringb
   \   0000004C   0x0002             MOVS     R2,R0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable23_25
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000056   0x.... 0x....      BL       scheduleMsg
    288          	}
    289          
    290          	float voltage = adcVoltage * dividerCoeff;
   \                     ??printAnalogChannelInfoExt_2:
   \   0000005A   0xEE28 0x9A28      VMUL.F32 S18,S16,S17
    291          	scheduleMsg(&logger, "%s ADC%d %s %s rawValue=%f/divided=%fv/divider=%f", name, hwChannel, getAdcMode(hwChannel),
    292          			getPinNameByAdcChannel(hwChannel, pinNameBuffer), adcVoltage, voltage, dividerCoeff);
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable23_26
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       _Z22getPinNameByAdcChannel13adc_channel_ePc
   \   00000068   0x0006             MOVS     R6,R0
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0x.... 0x....      BL       _Z10getAdcMode13adc_channel_e
   \   00000070   0x0007             MOVS     R7,R0
   \   00000072   0xEE18 0x0A90      VMOV     R0,S17
   \   00000076   0x.... 0x....      BL       __aeabi_f2d
   \   0000007A   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
   \   0000007E   0xEE19 0x0A10      VMOV     R0,S18
   \   00000082   0x.... 0x....      BL       __aeabi_f2d
   \   00000086   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
   \   0000008A   0xEE18 0x0A10      VMOV     R0,S16
   \   0000008E   0x.... 0x....      BL       __aeabi_f2d
   \   00000092   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
   \   00000096   0x9601             STR      R6,[SP, #+4]
   \   00000098   0x9700             STR      R7,[SP, #+0]
   \   0000009A   0x002B             MOVS     R3,R5
   \   0000009C   0x0022             MOVS     R2,R4
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable23_27
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   000000A6   0x.... 0x....      BL       scheduleMsg
    293          #endif
    294          }
   \                     ??printAnalogChannelInfoExt_1:
   \   000000AA   0xB008             ADD      SP,SP,#+32
   \   000000AC   0xECBD 0x8B04      VPOP     {D8-D9}
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    295          

   \                                 In section .text, align 4, keep-with-next
    296          static void printAnalogChannelInfo(const char *name, adc_channel_e hwChannel) {
   \                     _Z22printAnalogChannelInfoPKc13adc_channel_e:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    297          #if HAL_USE_ADC || defined(__DOXYGEN__)
    298          	printAnalogChannelInfoExt(name, hwChannel, getVoltage("print", hwChannel), engineConfiguration->analogInputDividerCoefficient);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable23_28
   \   0000000C   0x.... 0x....      BL       _Z19getInternalAdcValuePKc13adc_channel_e
   \   00000010   0xEE00 0x0A10      VMOV     S0,R0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xEDD0 0x0A74      VLDR     S1,[R0, #+464]
   \   0000001E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000022   0xED9F 0x....      VLDR.W   S2,??DataTable16  ;; 0x3a400c01
   \   00000026   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       _Z25printAnalogChannelInfoExtPKc13adc_channel_eff
    299          #endif
    300          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    301          

   \                                 In section .text, align 4, keep-with-next
    302          static void printAnalogInfo(void) {
   \                     _Z15printAnalogInfov:
   \   00000000   0xB580             PUSH     {R7,LR}
    303          	scheduleMsg(&logger, "analogInputDividerCoefficient: %f", engineConfiguration->analogInputDividerCoefficient);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF8D0 0x01D0      LDR      R0,[R0, #+464]
   \   0000000C   0x.... 0x....      BL       __aeabi_f2d
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x000B             MOVS     R3,R1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable23_29
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   0000001C   0x.... 0x....      BL       scheduleMsg
    304          
    305          	printAnalogChannelInfo("hip9011", engineConfiguration->hipOutputChannel);
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF8D0 0x15DC      LDR      R1,[R0, #+1500]
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable23_30
   \   0000002E   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    306          	printAnalogChannelInfo("fuel gauge", engineConfiguration->fuelLevelSensor);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF8D0 0x11E4      LDR      R1,[R0, #+484]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable23_31
   \   00000040   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    307          	printAnalogChannelInfo("TPS", engineConfiguration->tpsAdcChannel);
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF8D0 0x120C      LDR      R1,[R0, #+524]
   \   0000004E   0x....             ADR.N    R0,??DataTable15  ;; "TPS"
   \   00000050   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    308          	printAnalogChannelInfo("pPS", engineConfiguration->pedalPositionChannel);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF8D0 0x125C      LDR      R1,[R0, #+604]
   \   0000005E   0x....             ADR.N    R0,??DataTable15_1  ;; "pPS"
   \   00000060   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    309          	printAnalogChannelInfo("CLT", engineConfiguration->clt.adcChannel);
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF8D0 0x111C      LDR      R1,[R0, #+284]
   \   0000006E   0x....             ADR.N    R0,??DataTable15_2  ;; "CLT"
   \   00000070   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    310          	if (engineConfiguration->hasIatSensor) {
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0xF890 0x05D8      LDRB     R0,[R0, #+1496]
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x0840             LSRS     R0,R0,#+1
   \   00000082   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD007             BEQ.N    ??printAnalogInfo_0
    311          		printAnalogChannelInfo("IAT", engineConfiguration->iat.adcChannel);
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF8D0 0x113C      LDR      R1,[R0, #+316]
   \   00000094   0x....             ADR.N    R0,??DataTable16_1  ;; "IAT"
   \   00000096   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    312          	}
    313          	if (hasMafSensor()) {
   \                     ??printAnalogInfo_0:
   \   0000009A   0x.... 0x....      BL       _Z12hasMafSensorv
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD007             BEQ.N    ??printAnalogInfo_1
    314          		printAnalogChannelInfo("MAF", engineConfiguration->mafAdcChannel);
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0xF8D0 0x1244      LDR      R1,[R0, #+580]
   \   000000AC   0x....             ADR.N    R0,??DataTable17  ;; "MAF"
   \   000000AE   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    315          	}
    316          	printAnalogChannelInfo("AFR", engineConfiguration->afr.hwChannel);
   \                     ??printAnalogInfo_1:
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF8D0 0x1248      LDR      R1,[R0, #+584]
   \   000000BC   0x....             ADR.N    R0,??DataTable17_1  ;; "AFR"
   \   000000BE   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    317          	if (engineConfiguration->hasMapSensor) {
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF890 0x05D8      LDRB     R0,[R0, #+1496]
   \   000000CC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD007             BEQ.N    ??printAnalogInfo_2
    318          		printAnalogChannelInfo("MAP", engineConfiguration->map.sensor.hwChannel);
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0xF8D0 0x10FC      LDR      R1,[R0, #+252]
   \   000000DE   0x....             ADR.N    R0,??DataTable17_2  ;; "MAP"
   \   000000E0   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    319          	}
    320          	if (hasBaroSensor()) {
   \                     ??printAnalogInfo_2:
   \   000000E4   0x.... 0x....      BL       _Z13hasBaroSensorv
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD008             BEQ.N    ??printAnalogInfo_3
    321          		printAnalogChannelInfo("BARO", engineConfiguration->baroSensor.hwChannel);
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF8D0 0x126C      LDR      R1,[R0, #+620]
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable23_32
   \   000000FA   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    322          	}
    323          	if (engineConfiguration->externalKnockSenseAdc != EFI_ADC_NONE) {
   \                     ??printAnalogInfo_3:
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF8D0 0x0654      LDR      R0,[R0, #+1620]
   \   00000108   0x2810             CMP      R0,#+16
   \   0000010A   0xD008             BEQ.N    ??printAnalogInfo_4
    324          		printAnalogChannelInfo("extKno", engineConfiguration->externalKnockSenseAdc);
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF8D0 0x1654      LDR      R1,[R0, #+1620]
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable23_33
   \   0000011A   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    325          	}
    326          
    327          	printAnalogChannelInfo("A/C sw", engineConfiguration->acSwitchAdc);
   \                     ??printAnalogInfo_4:
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000122   0x6800             LDR      R0,[R0, #+0]
   \   00000124   0xF8D0 0x15F0      LDR      R1,[R0, #+1520]
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable23_34
   \   0000012C   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    328          	printAnalogChannelInfo("HIP9011", engineConfiguration->hipOutputChannel);
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0xF8D0 0x15DC      LDR      R1,[R0, #+1500]
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable23_35
   \   0000013E   0x.... 0x....      BL       _Z22printAnalogChannelInfoPKc13adc_channel_e
    329          	printAnalogChannelInfoExt("Vbatt", engineConfiguration->vbattAdcChannel, getVoltage("vbatt", engineConfiguration->vbattAdcChannel),
    330          			engineConfiguration->vbattDividerCoeff);
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000146   0x6800             LDR      R0,[R0, #+0]
   \   00000148   0xF8D0 0x11D8      LDR      R1,[R0, #+472]
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable23_36
   \   00000150   0x.... 0x....      BL       _Z19getInternalAdcValuePKc13adc_channel_e
   \   00000154   0xEE00 0x0A10      VMOV     S0,R0
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0xEDD0 0x0A75      VLDR     S1,[R0, #+468]
   \   00000162   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000166   0xED9F 0x....      VLDR.W   S2,??DataTable16  ;; 0x3a400c01
   \   0000016A   0xEE20 0x0A01      VMUL.F32 S0,S0,S2
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000172   0x6800             LDR      R0,[R0, #+0]
   \   00000174   0xF8D0 0x11D8      LDR      R1,[R0, #+472]
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable23_37
   \   0000017C   0x.... 0x....      BL       _Z25printAnalogChannelInfoExtPKc13adc_channel_eff
    331          }
   \   00000180   0xBD01             POP      {R0,PC}          ;; return
    332          

   \                                 In section .bss, align 8
    333          static THD_WORKING_AREA(csThreadStack, UTILITY_THREAD_STACK_SIZE);	// declare thread stack
   \                     csThreadStack:
   \   00000000                      DS8 712
    334          
    335          #define isOutOfBounds(offset) ((offset<0) || (offset) >= (int) sizeof(engine_configuration_s))
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static void getShort(int offset) {
   \                     _Z8getShorti:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    338          	if (isOutOfBounds(offset))
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD403             BMI.N    ??getShort_0
   \   00000008   0xF640 0x00A8      MOVW     R0,#+2216
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xDB00             BLT.N    ??getShort_1
    339          		return;
   \                     ??getShort_0:
   \   00000010   0xE00D             B.N      ??getShort_2
    340          	uint16_t *ptr = (uint16_t *) (&((char *) engineConfiguration)[offset]);
   \                     ??getShort_1:
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1825             ADDS     R5,R4,R0
    341          	uint16_t value = *ptr;
   \   0000001A   0x882E             LDRH     R6,[R5, #+0]
    342          	/**
    343          	 * this response is part of dev console API
    344          	 */
    345          	scheduleMsg(&logger, "short @%d is %d", offset, value);
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x0033             MOVS     R3,R6
   \   00000020   0x0022             MOVS     R2,R4
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable23_38
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   0000002A   0x.... 0x....      BL       scheduleMsg
    346          }
   \                     ??getShort_2:
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    347          

   \                                 In section .text, align 2, keep-with-next
    348          static void setBit(const char *offsetStr, const char *bitStr, const char *valueStr) {
   \                     _Z6setBitPKcS0_S0_:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    349          	int offset = atoi(offsetStr);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       atoi
   \   00000012   0x0007             MOVS     R7,R0
    350          	if (absI(offset) == absI(ERROR_CODE)) {
   \   00000014   0x0038             MOVS     R0,R7
   \   00000016   0x.... 0x....      BL       absI
   \   0000001A   0x4680             MOV      R8,R0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable23_39  ;; 0x128ce430
   \   00000020   0x.... 0x....      BL       absI
   \   00000024   0x4580             CMP      R8,R0
   \   00000026   0xD107             BNE.N    ??setBit_0
    351          		scheduleMsg(&logger, "invalid offset [%s]", offsetStr);
   \   00000028   0x0022             MOVS     R2,R4
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable23_40
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000032   0x.... 0x....      BL       scheduleMsg
    352          		return;
   \   00000036   0xE051             B.N      ??setBit_1
    353          	}
    354          	if (isOutOfBounds(offset)) {
   \                     ??setBit_0:
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD403             BMI.N    ??setBit_2
   \   0000003C   0xF640 0x00A8      MOVW     R0,#+2216
   \   00000040   0x4287             CMP      R7,R0
   \   00000042   0xDB00             BLT.N    ??setBit_3
    355          		return;
   \                     ??setBit_2:
   \   00000044   0xE04A             B.N      ??setBit_1
    356          	}
    357          	int bit = atoi(bitStr);
   \                     ??setBit_3:
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       atoi
   \   0000004C   0x4680             MOV      R8,R0
    358          	if (absI(bit) == absI(ERROR_CODE)) {
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x.... 0x....      BL       absI
   \   00000054   0x4681             MOV      R9,R0
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable23_39  ;; 0x128ce430
   \   0000005A   0x.... 0x....      BL       absI
   \   0000005E   0x4581             CMP      R9,R0
   \   00000060   0xD107             BNE.N    ??setBit_4
    359          		scheduleMsg(&logger, "invalid bit [%s]", bitStr);
   \   00000062   0x002A             MOVS     R2,R5
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable23_41
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   0000006C   0x.... 0x....      BL       scheduleMsg
    360          		return;
   \   00000070   0xE034             B.N      ??setBit_1
    361          	}
    362          	int value = atoi(valueStr);
   \                     ??setBit_4:
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       atoi
   \   00000078   0x4681             MOV      R9,R0
    363          	if (absI(value) == absI(ERROR_CODE)) {
   \   0000007A   0x4648             MOV      R0,R9
   \   0000007C   0x.... 0x....      BL       absI
   \   00000080   0x4682             MOV      R10,R0
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable23_39  ;; 0x128ce430
   \   00000086   0x.... 0x....      BL       absI
   \   0000008A   0x4582             CMP      R10,R0
   \   0000008C   0xD107             BNE.N    ??setBit_5
    364          		scheduleMsg(&logger, "invalid value [%s]", valueStr);
   \   0000008E   0x0032             MOVS     R2,R6
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable23_42
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000098   0x.... 0x....      BL       scheduleMsg
    365          		return;
   \   0000009C   0xE01E             B.N      ??setBit_1
    366          	}
    367          	int *ptr = (int *) (&((char *) engineConfiguration)[offset]);
   \                     ??setBit_5:
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xEB17 0x0A00      ADDS     R10,R7,R0
    368          	*ptr ^= (-value ^ *ptr) & (1 << bit);
   \   000000A8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000AC   0xF1D9 0x0100      RSBS     R1,R9,#+0
   \   000000B0   0xF8DA 0x2000      LDR      R2,[R10, #+0]
   \   000000B4   0x4051             EORS     R1,R2,R1
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0xFA12 0xF208      LSLS     R2,R2,R8
   \   000000BC   0x4011             ANDS     R1,R2,R1
   \   000000BE   0x4048             EORS     R0,R1,R0
   \   000000C0   0xF8CA 0x0000      STR      R0,[R10, #+0]
    369          	/**
    370          	 * this response is part of dev console API
    371          	 */
    372          	scheduleMsg(&logger, "bit @%d/%d is %d", offset, bit, value);
   \   000000C4   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000C8   0x4643             MOV      R3,R8
   \   000000CA   0x003A             MOVS     R2,R7
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable23_43
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   000000D4   0x.... 0x....      BL       scheduleMsg
    373          	applyNewConfiguration();
   \   000000D8   0x.... 0x....      BL       applyNewConfiguration
    374          }
   \                     ??setBit_1:
   \   000000DC   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    375          

   \                                 In section .text, align 2, keep-with-next
    376          static void setShort(const int offset, const int value) {
   \                     _Z8setShortii:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    377          	if (isOutOfBounds(offset))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD403             BMI.N    ??setShort_0
   \   0000000A   0xF640 0x00A8      MOVW     R0,#+2216
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xDB00             BLT.N    ??setShort_1
    378          		return;
   \                     ??setShort_0:
   \   00000012   0xE009             B.N      ??setShort_2
    379          	uint16_t *ptr = (uint16_t *) (&((char *) engineConfiguration)[offset]);
   \                     ??setShort_1:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x1826             ADDS     R6,R4,R0
    380          	*ptr = (uint16_t) value;
   \   0000001C   0x8035             STRH     R5,[R6, #+0]
    381          	getShort(offset);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       _Z8getShorti
    382          	applyNewConfiguration();
   \   00000024   0x.... 0x....      BL       applyNewConfiguration
    383          }
   \                     ??setShort_2:
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    384          

   \                                 In section .text, align 2, keep-with-next
    385          static void getBit(int offset, int bit) {
   \                     _Z6getBitii:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    386          	if (isOutOfBounds(offset))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD403             BMI.N    ??getBit_0
   \   0000000A   0xF640 0x00A8      MOVW     R0,#+2216
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xDB00             BLT.N    ??getBit_1
    387          		return;
   \                     ??getBit_0:
   \   00000012   0xE00F             B.N      ??getBit_2
    388          	int *ptr = (int *) (&((char *) engineConfiguration)[offset]);
   \                     ??getBit_1:
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_15
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x1826             ADDS     R6,R4,R0
    389          	int value = (*ptr >> bit) & 1;
   \   0000001C   0x6830             LDR      R0,[R6, #+0]
   \   0000001E   0x4128             ASRS     R0,R0,R5
   \   00000020   0xF010 0x0701      ANDS     R7,R0,#0x1
    390          	/**
    391          	 * this response is part of dev console API
    392          	 */
    393          	scheduleMsg(&logger, "bit @%d/%d is %d", offset, bit, value);
   \   00000024   0x9700             STR      R7,[SP, #+0]
   \   00000026   0x002B             MOVS     R3,R5
   \   00000028   0x0022             MOVS     R2,R4
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable23_43
   \   0000002E   0x....             LDR.N    R0,??DataTable23_1
   \   00000030   0x.... 0x....      BL       scheduleMsg
    394          }
   \                     ??getBit_2:
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    395          

   \                                 In section .text, align 2, keep-with-next
    396          static void getInt(int offset) {
   \                     _Z6getInti:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    397          	if (isOutOfBounds(offset))
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD403             BMI.N    ??getInt_0
   \   00000008   0xF640 0x00A8      MOVW     R0,#+2216
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xDB00             BLT.N    ??getInt_1
    398          		return;
   \                     ??getInt_0:
   \   00000010   0xE00A             B.N      ??getInt_2
    399          	int *ptr = (int *) (&((char *) engineConfiguration)[offset]);
   \                     ??getInt_1:
   \   00000012   0x....             LDR.N    R0,??DataTable23_15
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1825             ADDS     R5,R4,R0
    400          	int value = *ptr;
   \   00000018   0x682E             LDR      R6,[R5, #+0]
    401          	/**
    402          	 * this response is part of dev console API
    403          	 */
    404          	scheduleMsg(&logger, "int @%d is %d", offset, value);
   \   0000001A   0x0033             MOVS     R3,R6
   \   0000001C   0x0022             MOVS     R2,R4
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable23_44
   \   00000022   0x....             LDR.N    R0,??DataTable23_1
   \   00000024   0x.... 0x....      BL       scheduleMsg
    405          }
   \                     ??getInt_2:
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    406          

   \                                 In section .text, align 2, keep-with-next
    407          static void setInt(const int offset, const int value) {
   \                     _Z6setIntii:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    408          	if (isOutOfBounds(offset))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD403             BMI.N    ??setInt_0
   \   0000000A   0xF640 0x00A8      MOVW     R0,#+2216
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xDB00             BLT.N    ??setInt_1
    409          		return;
   \                     ??setInt_0:
   \   00000012   0xE008             B.N      ??setInt_2
    410          	int *ptr = (int *) (&((char *) engineConfiguration)[offset]);
   \                     ??setInt_1:
   \   00000014   0x....             LDR.N    R0,??DataTable23_15
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1826             ADDS     R6,R4,R0
    411          	*ptr = value;
   \   0000001A   0x6035             STR      R5,[R6, #+0]
    412          	getInt(offset);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       _Z6getInti
    413          	applyNewConfiguration();
   \   00000022   0x.... 0x....      BL       applyNewConfiguration
    414          }
   \                     ??setInt_2:
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    415          

   \                                 In section .text, align 2, keep-with-next
    416          static void getFloat(int offset) {
   \                     _Z8getFloati:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x0004             MOVS     R4,R0
    417          	if (isOutOfBounds(offset))
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD403             BMI.N    ??getFloat_0
   \   0000000E   0xF640 0x00A8      MOVW     R0,#+2216
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xDB00             BLT.N    ??getFloat_1
    418          		return;
   \                     ??getFloat_0:
   \   00000016   0xE00F             B.N      ??getFloat_2
    419          	float *ptr = (float *) (&((char *) engineConfiguration)[offset]);
   \                     ??getFloat_1:
   \   00000018   0x....             LDR.N    R0,??DataTable23_15
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1825             ADDS     R5,R4,R0
    420          	float value = *ptr;
   \   0000001E   0xED95 0x8A00      VLDR     S16,[R5, #0]
    421          	/**
    422          	 * this response is part of dev console API
    423          	 */
    424          	scheduleMsg(&logger, "float @%d is %..100000f", offset, value);
   \   00000022   0xEE18 0x0A10      VMOV     R0,S16
   \   00000026   0x.... 0x....      BL       __aeabi_f2d
   \   0000002A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000002E   0x0022             MOVS     R2,R4
   \   00000030   0x....             LDR.N    R1,??DataTable23_45
   \   00000032   0x....             LDR.N    R0,??DataTable23_1
   \   00000034   0x.... 0x....      BL       scheduleMsg
    425          }
   \                     ??getFloat_2:
   \   00000038   0xB002             ADD      SP,SP,#+8
   \   0000003A   0xECBD 0x8B02      VPOP     {D8}
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    426          

   \                                 In section .text, align 2, keep-with-next
    427          static void setFloat(const char *offsetStr, const char *valueStr) {
   \                     _Z8setFloatPKcS0_:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    428          	int offset = atoi(offsetStr);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       atoi
   \   00000010   0x0006             MOVS     R6,R0
    429          	if (absI(offset) == absI(ERROR_CODE)) {
   \   00000012   0x0030             MOVS     R0,R6
   \   00000014   0x.... 0x....      BL       absI
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0x....             LDR.N    R0,??DataTable23_39  ;; 0x128ce430
   \   0000001C   0x.... 0x....      BL       absI
   \   00000020   0x4287             CMP      R7,R0
   \   00000022   0xD105             BNE.N    ??setFloat_0
    430          		scheduleMsg(&logger, "invalid offset [%s]", offsetStr);
   \   00000024   0x0022             MOVS     R2,R4
   \   00000026   0x....             LDR.N    R1,??DataTable23_40
   \   00000028   0x....             LDR.N    R0,??DataTable23_1
   \   0000002A   0x.... 0x....      BL       scheduleMsg
    431          		return;
   \   0000002E   0xE020             B.N      ??setFloat_1
    432          	}
    433          	if (isOutOfBounds(offset))
   \                     ??setFloat_0:
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD403             BMI.N    ??setFloat_2
   \   00000034   0xF640 0x00A8      MOVW     R0,#+2216
   \   00000038   0x4286             CMP      R6,R0
   \   0000003A   0xDB00             BLT.N    ??setFloat_3
    434          		return;
   \                     ??setFloat_2:
   \   0000003C   0xE019             B.N      ??setFloat_1
    435          	float value = atoff(valueStr);
   \                     ??setFloat_3:
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x.... 0x....      BL       atoff
   \   00000044   0xEEB0 0x8A40      VMOV.F32 S16,S0
    436          	if (cisnan(value)) {
   \   00000048   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000004C   0x.... 0x....      BL       __iar_FDtest
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD105             BNE.N    ??setFloat_4
    437          		scheduleMsg(&logger, "invalid value [%s]", valueStr);
   \   00000054   0x002A             MOVS     R2,R5
   \   00000056   0x....             LDR.N    R1,??DataTable23_42
   \   00000058   0x....             LDR.N    R0,??DataTable23_1
   \   0000005A   0x.... 0x....      BL       scheduleMsg
    438          		return;
   \   0000005E   0xE008             B.N      ??setFloat_1
    439          	}
    440          	float *ptr = (float *) (&((char *) engine->engineConfiguration)[offset]);
   \                     ??setFloat_4:
   \   00000060   0x....             LDR.N    R0,??DataTable23_11
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6A40             LDR      R0,[R0, #+36]
   \   00000066   0x1837             ADDS     R7,R6,R0
    441          	*ptr = value;
   \   00000068   0xED87 0x8A00      VSTR     S16,[R7, #0]
    442          	getFloat(offset);
   \   0000006C   0x0030             MOVS     R0,R6
   \   0000006E   0x.... 0x....      BL       _Z8getFloati
    443          }
   \                     ??setFloat_1:
   \   00000072   0xECBD 0x8B02      VPOP     {D8}
   \   00000076   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    444          
    445          #if EFI_PROD_CODE || defined(__DOXYGEN__)

   \                                 In section .text, align 2, keep-with-next
    446          static void resetAccel(void) {
   \                     _Z10resetAccelv:
   \   00000000   0xB580             PUSH     {R7,LR}
    447          	engine->mapAccelEnrichment.reset();
   \   00000002   0x....             LDR.N    R0,??DataTable23_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x3038             ADDS     R0,R0,#+56
   \   00000008   0x.... 0x....      BL       _ZN16AccelEnrichmemnt5resetEv
    448          	engine->tpsAccelEnrichment.reset();
   \   0000000C   0x....             LDR.N    R0,??DataTable23_11
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF510 0x70A6      ADDS     R0,R0,#+332
   \   00000014   0x.... 0x....      BL       _ZN16AccelEnrichmemnt5resetEv
    449          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    450          #endif
    451          

   \                                 In section .text, align 2, keep-with-next
    452          void initConfigActions(void) {
   \                     _Z17initConfigActionsv:
   \   00000000   0xB580             PUSH     {R7,LR}
    453          	addConsoleActionSS("set_float", (VoidCharPtrCharPtr) setFloat);
   \   00000002   0x....             LDR.N    R1,??DataTable23_46
   \   00000004   0x....             LDR.N    R0,??DataTable23_47
   \   00000006   0x.... 0x....      BL       addConsoleActionSS
    454          	addConsoleActionII("set_int", (VoidIntInt) setInt);
   \   0000000A   0x....             LDR.N    R1,??DataTable23_48
   \   0000000C   0x....             LDR.N    R0,??DataTable23_49
   \   0000000E   0x.... 0x....      BL       addConsoleActionII
    455          	addConsoleActionII("set_short", (VoidIntInt) setShort);
   \   00000012   0x....             LDR.N    R1,??DataTable23_50
   \   00000014   0x....             LDR.N    R0,??DataTable23_51
   \   00000016   0x.... 0x....      BL       addConsoleActionII
    456          	addConsoleActionSSS("set_bit", setBit);
   \   0000001A   0x....             LDR.N    R1,??DataTable23_52
   \   0000001C   0x....             LDR.N    R0,??DataTable23_53
   \   0000001E   0x.... 0x....      BL       addConsoleActionSSS
    457          	addConsoleActionI("get_float", getFloat);
   \   00000022   0x....             LDR.N    R1,??DataTable23_54
   \   00000024   0x....             LDR.N    R0,??DataTable23_55
   \   00000026   0x.... 0x....      BL       addConsoleActionI
    458          	addConsoleActionI("get_int", getInt);
   \   0000002A   0x....             LDR.N    R1,??DataTable23_56
   \   0000002C   0x....             LDR.N    R0,??DataTable23_57
   \   0000002E   0x.... 0x....      BL       addConsoleActionI
    459          	addConsoleActionI("get_short", getShort);
   \   00000032   0x....             LDR.N    R1,??DataTable23_58
   \   00000034   0x....             LDR.N    R0,??DataTable23_59
   \   00000036   0x.... 0x....      BL       addConsoleActionI
    460          	addConsoleActionII("get_bit", getBit);
   \   0000003A   0x....             LDR.N    R1,??DataTable23_60
   \   0000003C   0x....             LDR.N    R0,??DataTable23_61
   \   0000003E   0x.... 0x....      BL       addConsoleActionII
    461          }
   \   00000042   0xBD01             POP      {R0,PC}          ;; return
    462          
    463          // todo: move this logic somewhere else?

   \                                 In section .text, align 2, keep-with-next
    464          static void getKnockInfo(void) {
   \                     _Z12getKnockInfov:
   \   00000000   0xB510             PUSH     {R4,LR}
    465          	adc_channel_e hwChannel = engineConfiguration->externalKnockSenseAdc;
   \   00000002   0x....             LDR.N    R0,??DataTable23_15
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF8D0 0x4654      LDR      R4,[R0, #+1620]
    466          	scheduleMsg(&logger, "externalKnockSenseAdc on ADC", getPinNameByAdcChannel(hwChannel, pinNameBuffer));
   \   0000000A   0x....             LDR.N    R1,??DataTable23_26
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       _Z22getPinNameByAdcChannel13adc_channel_ePc
   \   00000012   0x0002             MOVS     R2,R0
   \   00000014   0x....             LDR.N    R1,??DataTable23_62
   \   00000016   0x....             LDR.N    R0,??DataTable23_1
   \   00000018   0x.... 0x....      BL       scheduleMsg
    467          
    468          	engine->printKnockState();
   \   0000001C   0x....             LDR.N    R0,??DataTable23_11
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       _ZN6Engine15printKnockStateEv
    469          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    470          

   \                                 In section .text, align 2, keep-with-next
    471          void initEngineContoller(Logging *sharedLogger DECLARE_ENGINE_PARAMETER_S) {
   \                     _Z19initEngineContollerP7Logging:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    472          	addConsoleAction("analoginfo", printAnalogInfo);
   \   00000006   0x....             LDR.N    R1,??DataTable23_63
   \   00000008   0x....             LDR.N    R0,??DataTable23_64
   \   0000000A   0x.... 0x....      BL       addConsoleAction
    473          	initConfigActions();
   \   0000000E   0x.... 0x....      BL       _Z17initConfigActionsv
    474          #if EFI_PROD_CODE
    475          	// todo: this is a mess, remove code duplication with simulator
    476          	initSettings(engineConfiguration);
   \   00000012   0x....             LDR.N    R0,??DataTable23_15
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       _Z12initSettingsP22engine_configuration_s
    477          #endif
    478          
    479          #if EFI_TUNER_STUDIO || defined(__DOXYGEN__)
    480          	if (engineConfiguration->isTunerStudioEnabled) {
   \   0000001A   0x....             LDR.N    R0,??DataTable23_15
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF890 0x05E5      LDRB     R0,[R0, #+1509]
   \   00000022   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD001             BEQ.N    ??initEngineContoller_0
    481          		startTunerStudioConnectivity();
   \   0000002A   0x.... 0x....      BL       _Z28startTunerStudioConnectivityv
    482          	}
    483          #endif
    484          
    485          	if (hasFirmwareError()) {
   \                     ??initEngineContoller_0:
   \   0000002E   0x....             LDR.N    R0,??DataTable23_65
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xF040 0x8087      BNE.W    ??initEngineContoller_1
    486          		return;
    487          	}
    488          
    489          	initSensors(sharedLogger PASS_ENGINE_PARAMETER_F);
   \                     ??initEngineContoller_2:
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       _Z11initSensorsP7Logging
    490          
    491          #if EFI_PROD_CODE || defined(__DOXYGEN__)
    492          	initPwmGenerator();
   \   0000003E   0x.... 0x....      BL       _Z16initPwmGeneratorv
    493          #endif
    494          
    495          #if EFI_ANALOG_CHART || defined(__DOXYGEN__)
    496          	initSensorChart();
   \   00000042   0x.... 0x....      BL       _Z15initSensorChartv
    497          #endif /* EFI_ANALOG_CHART */
    498          
    499          	initAlgo(sharedLogger, engineConfiguration);
   \   00000046   0x....             LDR.N    R0,??DataTable23_15
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       _Z8initAlgoP7LoggingP22engine_configuration_s
    500          
    501          #if EFI_WAVE_ANALYZER || defined(__DOXYGEN__)
    502          	if (engineConfiguration->isWaveAnalyzerEnabled) {
   \   00000050   0x....             LDR.N    R0,??DataTable23_15
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF890 0x05E5      LDRB     R0,[R0, #+1509]
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x0840             LSRS     R0,R0,#+1
   \   0000005C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD002             BEQ.N    ??initEngineContoller_3
    503          		initWaveAnalyzer(sharedLogger);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       _Z16initWaveAnalyzerP7Logging
    504          	}
    505          #endif /* EFI_WAVE_ANALYZER */
    506          
    507          #if EFI_SHAFT_POSITION_INPUT || defined(__DOXYGEN__)
    508          	/**
    509          	 * there is an implicit dependency on the fact that 'tachometer' listener is the 1st listener - this case
    510          	 * other listeners can access current RPM value
    511          	 */
    512          	initRpmCalculator(sharedLogger, engine);
   \                     ??initEngineContoller_3:
   \   0000006A   0x....             LDR.N    R0,??DataTable23_11
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       _Z17initRpmCalculatorP7LoggingP6Engine
    513          #endif /* EFI_SHAFT_POSITION_INPUT */
    514          
    515          // multiple issues with this	initMapAdjusterThread();
    516          	initPeriodicEvents(PASS_ENGINE_PARAMETER_F);
   \   00000074   0x.... 0x....      BL       _Z18initPeriodicEventsv
    517          
    518          	chThdCreateStatic(csThreadStack, sizeof(csThreadStack), LOWPRIO, (tfunc_t) csThread, NULL);
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0x....             LDR.N    R3,??DataTable23_66
   \   0000007E   0x2202             MOVS     R2,#+2
   \   00000080   0xF44F 0x7132      MOV      R1,#+712
   \   00000084   0x....             LDR.N    R0,??DataTable23_67
   \   00000086   0x.... 0x....      BL       chThdCreateStatic
    519          
    520          #if (EFI_PROD_CODE && EFI_ENGINE_CONTROL) || defined(__DOXYGEN__)
    521          	initInjectorCentral();
   \   0000008A   0x.... 0x....      BL       _Z19initInjectorCentralv
    522          	/**
    523          	 * This has to go after 'initInjectorCentral' and 'initInjectorCentral' in order to
    524          	 * properly detect un-assigned output pins
    525          	 */
    526          	prepareShapes(PASS_ENGINE_PARAMETER_F);
   \   0000008E   0x.... 0x....      BL       _Z13prepareShapesv
    527          #endif
    528          
    529          #if EFI_PWM_TESTER || defined(__DOXYGEN__)
    530          	initPwmTester();
    531          #endif
    532          
    533          	initMalfunctionCentral();
   \   00000092   0x.... 0x....      BL       initMalfunctionCentral
    534          
    535          #if EFI_ALTERNATOR_CONTROL || defined(__DOXYGEN__)
    536          	initAlternatorCtrl(sharedLogger);
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       _Z18initAlternatorCtrlP7Logging
    537          #endif
    538          
    539          #if EFI_ELECTRONIC_THROTTLE_BODY || defined(__DOXYGEN__)
    540          	initElectronicThrottle();
   \   0000009C   0x.... 0x....      BL       _Z22initElectronicThrottlev
    541          #endif /* EFI_ELECTRONIC_THROTTLE_BODY */
    542          
    543          #if EFI_MALFUNCTION_INDICATOR || defined(__DOXYGEN__)
    544          	if (engineConfiguration->isMilEnabled) {
   \   000000A0   0x....             LDR.N    R0,??DataTable23_15
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF890 0x05E4      LDRB     R0,[R0, #+1508]
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x0980             LSRS     R0,R0,#+6
   \   000000AC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??initEngineContoller_4
    545          		initMalfunctionIndicator();
   \   000000B4   0x.... 0x....      BL       _Z24initMalfunctionIndicatorv
    546          	}
    547          #endif /* EFI_MALFUNCTION_INDICATOR */
    548          
    549          #if EFI_MAP_AVERAGING || defined(__DOXYGEN__)
    550          	if (engineConfiguration->isMapAveragingEnabled) {
   \                     ??initEngineContoller_4:
   \   000000B8   0x....             LDR.N    R0,??DataTable23_15
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF890 0x05E4      LDRB     R0,[R0, #+1508]
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x0940             LSRS     R0,R0,#+5
   \   000000C4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD004             BEQ.N    ??initEngineContoller_5
    551          		initMapAveraging(sharedLogger, engine);
   \   000000CC   0x....             LDR.N    R0,??DataTable23_11
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       _Z16initMapAveragingP7LoggingP6Engine
    552          	}
    553          #endif /* EFI_MAP_AVERAGING */
    554          
    555          #if EFI_ENGINE_CONTROL || defined(__DOXYGEN__)
    556          	if (boardConfiguration->isEngineControlEnabled) {
   \                     ??initEngineContoller_5:
   \   000000D6   0x....             LDR.N    R0,??DataTable23_17
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0xF890 0x0180      LDRB     R0,[R0, #+384]
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x0940             LSRS     R0,R0,#+5
   \   000000E2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD004             BEQ.N    ??initEngineContoller_6
    557          		/**
    558          		 * This method initialized the main listener which actually runs injectors & ignition
    559          		 */
    560          		initMainEventListener(sharedLogger, engine);
   \   000000EA   0x....             LDR.N    R0,??DataTable23_11
   \   000000EC   0x6801             LDR      R1,[R0, #+0]
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x.... 0x....      BL       _Z21initMainEventListenerP7LoggingP6Engine
    561          	}
    562          #endif /* EFI_ENGINE_CONTROL */
    563          
    564          #if EFI_IDLE_CONTROL || defined(__DOXYGEN__)
    565          	if (engineConfiguration->isIdleThreadEnabled) {
   \                     ??initEngineContoller_6:
   \   000000F4   0x....             LDR.N    R0,??DataTable23_15
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0xF890 0x05E5      LDRB     R0,[R0, #+1509]
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FE   0x0880             LSRS     R0,R0,#+2
   \   00000100   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD004             BEQ.N    ??initEngineContoller_7
    566          		startIdleThread(sharedLogger, engine);
   \   00000108   0x....             LDR.N    R0,??DataTable23_11
   \   0000010A   0x6801             LDR      R1,[R0, #+0]
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0x.... 0x....      BL       _Z15startIdleThreadP7LoggingP6Engine
    567          	}
    568          #endif
    569          
    570          	if (engineConfiguration->externalKnockSenseAdc != EFI_ADC_NONE) {
   \                     ??initEngineContoller_7:
   \   00000112   0x....             LDR.N    R0,??DataTable23_15
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0xF8D0 0x0654      LDR      R0,[R0, #+1620]
   \   0000011A   0x2810             CMP      R0,#+16
   \   0000011C   0xD003             BEQ.N    ??initEngineContoller_8
    571          		addConsoleAction("knockinfo", getKnockInfo);
   \   0000011E   0x....             LDR.N    R1,??DataTable23_68
   \   00000120   0x....             LDR.N    R0,??DataTable23_69
   \   00000122   0x.... 0x....      BL       addConsoleAction
    572          	}
    573          
    574          	initAccelEnrichment(sharedLogger);
   \                     ??initEngineContoller_8:
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       _Z19initAccelEnrichmentP7Logging
    575          
    576          	initConfigActions();
   \   0000012C   0x.... 0x....      BL       _Z17initConfigActionsv
    577          #if EFI_PROD_CODE
    578          	addConsoleAction("reset_accel", resetAccel);
   \   00000130   0x....             LDR.N    R1,??DataTable23_70
   \   00000132   0x....             LDR.N    R0,??DataTable23_71
   \   00000134   0x.... 0x....      BL       addConsoleAction
    579          #endif
    580          
    581          #if (EFI_PROD_CODE && EFI_FSIO) || defined(__DOXYGEN__)
    582          	initFsioImpl(sharedLogger, engine);
   \   00000138   0x....             LDR.N    R0,??DataTable23_11
   \   0000013A   0x6801             LDR      R1,[R0, #+0]
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0x.... 0x....      BL       _Z12initFsioImplP7LoggingP6Engine
    583          #endif
    584          
    585          #if EFI_HD44780_LCD || defined(__DOXYGEN__)
    586          	initLcdController();
   \   00000142   0x.... 0x....      BL       _Z17initLcdControllerv
    587          #endif
    588          }
   \                     ??initEngineContoller_1:
   \   00000146   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x42BE0001         DC32     0x42be0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x54 0x50          DC8      "TPS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x70 0x50          DC8      "pPS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x43 0x4C          DC8      "CLT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x3A400C01         DC32     0x3a400c01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x49 0x41          DC8      "IAT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x4D 0x41          DC8      "MAF"
   \              0x46 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x41 0x46          DC8      "AFR"
   \              0x52 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x4D 0x41          DC8      "MAP"
   \              0x50 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     `?<Constant "Engine Controller">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     logger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     ec2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x........         DC32     persistentState+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x........         DC32     _engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x........         DC32     __dso_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x........         DC32     _ZN6EngineD1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x........         DC32     halTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x........         DC32     versionForConfigurationListeners

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x........         DC32     `?<Constant "status">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x........         DC32     engine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x........         DC32     persistentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x........         DC32     runningPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x........         DC32     vtlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_15:
   \   00000000   0x........         DC32     engineConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_16:
   \   00000000   0x........         DC32     `?<Constant "isCylinderCleanupMode %s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_17:
   \   00000000   0x........         DC32     boardConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_18:
   \   00000000   0x........         DC32     periodicSlowTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_19:
   \   00000000   0x........         DC32     _Z20periodicFastCallbackv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_20:
   \   00000000   0x........         DC32     periodicFastTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_21:
   \   00000000   0x........         DC32     `?<Constant "lowStckOnEv">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_22:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_23:
   \   00000000   0x........         DC32     `?<Constant "ADC is not assigned f...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_24:
   \   00000000   0x........         DC32     fastAdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_25:
   \   00000000   0x........         DC32     `?<Constant "fast enabled=%s">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_26:
   \   00000000   0x........         DC32     pinNameBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_27:
   \   00000000   0x........         DC32     `?<Constant "%s ADC%d %s %s rawVal...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_28:
   \   00000000   0x........         DC32     `?<Constant "print">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_29:
   \   00000000   0x........         DC32     `?<Constant "analogInputDividerCoe...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_30:
   \   00000000   0x........         DC32     `?<Constant "hip9011">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_31:
   \   00000000   0x........         DC32     `?<Constant "fuel gauge">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_32:
   \   00000000   0x........         DC32     `?<Constant "BARO">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_33:
   \   00000000   0x........         DC32     `?<Constant "extKno">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_34:
   \   00000000   0x........         DC32     `?<Constant "A/C sw">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_35:
   \   00000000   0x........         DC32     `?<Constant "HIP9011">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_36:
   \   00000000   0x........         DC32     `?<Constant "vbatt">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_37:
   \   00000000   0x........         DC32     `?<Constant "Vbatt">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_38:
   \   00000000   0x........         DC32     `?<Constant "short @%d is %d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_39:
   \   00000000   0x128CE430         DC32     0x128ce430

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_40:
   \   00000000   0x........         DC32     `?<Constant "invalid offset [%s]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_41:
   \   00000000   0x........         DC32     `?<Constant "invalid bit [%s]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_42:
   \   00000000   0x........         DC32     `?<Constant "invalid value [%s]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_43:
   \   00000000   0x........         DC32     `?<Constant "bit @%d/%d is %d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_44:
   \   00000000   0x........         DC32     `?<Constant "int @%d is %d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_45:
   \   00000000   0x........         DC32     `?<Constant "float @%d is %..100000f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_46:
   \   00000000   0x........         DC32     _Z8setFloatPKcS0_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_47:
   \   00000000   0x........         DC32     `?<Constant "set_float">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_48:
   \   00000000   0x........         DC32     _Z6setIntii

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_49:
   \   00000000   0x........         DC32     `?<Constant "set_int">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_50:
   \   00000000   0x........         DC32     _Z8setShortii

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_51:
   \   00000000   0x........         DC32     `?<Constant "set_short">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_52:
   \   00000000   0x........         DC32     _Z6setBitPKcS0_S0_

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_53:
   \   00000000   0x........         DC32     `?<Constant "set_bit">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_54:
   \   00000000   0x........         DC32     _Z8getFloati

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_55:
   \   00000000   0x........         DC32     `?<Constant "get_float">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_56:
   \   00000000   0x........         DC32     _Z6getInti

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_57:
   \   00000000   0x........         DC32     `?<Constant "get_int">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_58:
   \   00000000   0x........         DC32     _Z8getShorti

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_59:
   \   00000000   0x........         DC32     `?<Constant "get_short">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_60:
   \   00000000   0x........         DC32     _Z6getBitii

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_61:
   \   00000000   0x........         DC32     `?<Constant "get_bit">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_62:
   \   00000000   0x........         DC32     `?<Constant "externalKnockSenseAdc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_63:
   \   00000000   0x........         DC32     _Z15printAnalogInfov

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_64:
   \   00000000   0x........         DC32     `?<Constant "analoginfo">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_65:
   \   00000000   0x........         DC32     hasFirmwareErrorFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_66:
   \   00000000   0x........         DC32     _Z8csThreadv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_67:
   \   00000000   0x........         DC32     csThreadStack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_68:
   \   00000000   0x........         DC32     _Z12getKnockInfov

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_69:
   \   00000000   0x........         DC32     `?<Constant "knockinfo">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_70:
   \   00000000   0x........         DC32     _Z10resetAccelv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_71:
   \   00000000   0x........         DC32     `?<Constant "reset_accel">`

   \                                 In section .init_array, align 4, keep-with-next, root
   \   00000000   0x........         DC32    RELOC_ARM_TARGET1 __sti__routine

   \                                 In section .rodata, align 4
   \                     `?<Constant "status">`:
   \   00000000   0x73 0x74          DC8 "status"
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "isCylinderCleanupMode %s">`:
   \   00000000   0x69 0x73          DC8 "isCylinderCleanupMode %s"
   \              0x43 0x79    
   \              0x6C 0x69    
   \              0x6E 0x64    
   \              0x65 0x72    
   \              0x43 0x6C    
   \              0x65 0x61    
   \              0x6E 0x75    
   \              0x70 0x4D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x25 0x73    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "lowStckOnEv">`:
   \   00000000   0x6C 0x6F          DC8 "lowStckOnEv"
   \              0x77 0x53    
   \              0x74 0x63    
   \              0x6B 0x4F    
   \              0x6E 0x45    
   \              0x76 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "ADC is not assigned f...">`:
   \   00000000   0x41 0x44          DC8 "ADC is not assigned for %s"
   \              0x43 0x20    
   \              0x69 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x61    
   \              0x73 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x25 0x73    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "fast enabled=%s">`:
   \   00000000   0x66 0x61          DC8 "fast enabled=%s"
   \              0x73 0x74    
   \              0x20 0x65    
   \              0x6E 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x3D 0x25    
   \              0x73 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "%s ADC%d %s %s rawVal...">`:
   \   00000000   0x25 0x73          DC8 "%s ADC%d %s %s rawValue=%f/divided=%fv/divider=%f"
   \              0x20 0x41    
   \              0x44 0x43    
   \              0x25 0x64    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x20 0x72    
   \              0x61 0x77    
   \              0x56 0x61    
   \              0x6C 0x75    
   \              0x65 0x3D    
   \              0x25 0x66    
   \              0x2F 0x64    
   \              0x69 0x76    
   \              0x69 0x64    
   \              0x65 0x64    
   \              0x3D 0x25    
   \              0x66 0x76    
   \              0x2F 0x64    
   \              0x69 0x76    
   \              0x69 0x64    
   \              0x65 0x72    
   \              0x3D 0x25    
   \              0x66 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "print">`:
   \   00000000   0x70 0x72          DC8 "print"
   \              0x69 0x6E    
   \              0x74 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "analogInputDividerCoe...">`:
   \   00000000   0x61 0x6E          DC8 "analogInputDividerCoefficient: %f"
   \              0x61 0x6C    
   \              0x6F 0x67    
   \              0x49 0x6E    
   \              0x70 0x75    
   \              0x74 0x44    
   \              0x69 0x76    
   \              0x69 0x64    
   \              0x65 0x72    
   \              0x43 0x6F    
   \              0x65 0x66    
   \              0x66 0x69    
   \              0x63 0x69    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x66 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "hip9011">`:
   \   00000000   0x68 0x69          DC8 "hip9011"
   \              0x70 0x39    
   \              0x30 0x31    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "fuel gauge">`:
   \   00000000   0x66 0x75          DC8 "fuel gauge"
   \              0x65 0x6C    
   \              0x20 0x67    
   \              0x61 0x75    
   \              0x67 0x65    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x54 0x50          DC8 "TPS"
   \              0x53 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x70 0x50          DC8 "pPS"
   \              0x53 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x43 0x4C          DC8 "CLT"
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x49 0x41          DC8 "IAT"
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x4D 0x41          DC8 "MAF"
   \              0x46 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x41 0x46          DC8 "AFR"
   \              0x52 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x4D 0x41          DC8 "MAP"
   \              0x50 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "BARO">`:
   \   00000000   0x42 0x41          DC8 "BARO"
   \              0x52 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "extKno">`:
   \   00000000   0x65 0x78          DC8 "extKno"
   \              0x74 0x4B    
   \              0x6E 0x6F    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "A/C sw">`:
   \   00000000   0x41 0x2F          DC8 "A/C sw"
   \              0x43 0x20    
   \              0x73 0x77    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "HIP9011">`:
   \   00000000   0x48 0x49          DC8 "HIP9011"
   \              0x50 0x39    
   \              0x30 0x31    
   \              0x31 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Vbatt">`:
   \   00000000   0x56 0x62          DC8 "Vbatt"
   \              0x61 0x74    
   \              0x74 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "vbatt">`:
   \   00000000   0x76 0x62          DC8 "vbatt"
   \              0x61 0x74    
   \              0x74 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "short @%d is %d">`:
   \   00000000   0x73 0x68          DC8 "short @%d is %d"
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x40 0x25    
   \              0x64 0x20    
   \              0x69 0x73    
   \              0x20 0x25    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid offset [%s]">`:
   \   00000000   0x69 0x6E          DC8 "invalid offset [%s]"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x6F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid bit [%s]">`:
   \   00000000   0x69 0x6E          DC8 "invalid bit [%s]"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x62 0x69    
   \              0x74 0x20    
   \              0x5B 0x25    
   \              0x73 0x5D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "invalid value [%s]">`:
   \   00000000   0x69 0x6E          DC8 "invalid value [%s]"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x76 0x61    
   \              0x6C 0x75    
   \              0x65 0x20    
   \              0x5B 0x25    
   \              0x73 0x5D    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "bit @%d/%d is %d">`:
   \   00000000   0x62 0x69          DC8 "bit @%d/%d is %d"
   \              0x74 0x20    
   \              0x40 0x25    
   \              0x64 0x2F    
   \              0x25 0x64    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x25 0x64    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "int @%d is %d">`:
   \   00000000   0x69 0x6E          DC8 "int @%d is %d"
   \              0x74 0x20    
   \              0x40 0x25    
   \              0x64 0x20    
   \              0x69 0x73    
   \              0x20 0x25    
   \              0x64 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "float @%d is %..100000f">`:
   \   00000000   0x66 0x6C          DC8 "float @%d is %..100000f"
   \              0x6F 0x61    
   \              0x74 0x20    
   \              0x40 0x25    
   \              0x64 0x20    
   \              0x69 0x73    
   \              0x20 0x25    
   \              0x2E 0x2E    
   \              0x31 0x30    
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "set_float">`:
   \   00000000   0x73 0x65          DC8 "set_float"
   \              0x74 0x5F    
   \              0x66 0x6C    
   \              0x6F 0x61    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "set_int">`:
   \   00000000   0x73 0x65          DC8 "set_int"
   \              0x74 0x5F    
   \              0x69 0x6E    
   \              0x74 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "set_short">`:
   \   00000000   0x73 0x65          DC8 "set_short"
   \              0x74 0x5F    
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "set_bit">`:
   \   00000000   0x73 0x65          DC8 "set_bit"
   \              0x74 0x5F    
   \              0x62 0x69    
   \              0x74 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "get_float">`:
   \   00000000   0x67 0x65          DC8 "get_float"
   \              0x74 0x5F    
   \              0x66 0x6C    
   \              0x6F 0x61    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "get_int">`:
   \   00000000   0x67 0x65          DC8 "get_int"
   \              0x74 0x5F    
   \              0x69 0x6E    
   \              0x74 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "get_short">`:
   \   00000000   0x67 0x65          DC8 "get_short"
   \              0x74 0x5F    
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "get_bit">`:
   \   00000000   0x67 0x65          DC8 "get_bit"
   \              0x74 0x5F    
   \              0x62 0x69    
   \              0x74 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "externalKnockSenseAdc...">`:
   \   00000000   0x65 0x78          DC8 "externalKnockSenseAdc on ADC"
   \              0x74 0x65    
   \              0x72 0x6E    
   \              0x61 0x6C    
   \              0x4B 0x6E    
   \              0x6F 0x63    
   \              0x6B 0x53    
   \              0x65 0x6E    
   \              0x73 0x65    
   \              0x41 0x64    
   \              0x63 0x20    
   \              0x6F 0x6E    
   \              0x20 0x41    
   \              0x44 0x43    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "analoginfo">`:
   \   00000000   0x61 0x6E          DC8 "analoginfo"
   \              0x61 0x6C    
   \              0x6F 0x67    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "knockinfo">`:
   \   00000000   0x6B 0x6E          DC8 "knockinfo"
   \              0x6F 0x63    
   \              0x6B 0x69    
   \              0x6E 0x66    
   \              0x6F 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "reset_accel">`:
   \   00000000   0x72 0x65          DC8 "reset_accel"
   \              0x73 0x65    
   \              0x74 0x5F    
   \              0x61 0x63    
   \              0x63 0x65    
   \              0x6C 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "Engine Controller">`:
   \   00000000   0x45 0x6E          DC8 "Engine Controller"
   \              0x67 0x69    
   \              0x6E 0x65    
   \              0x20 0x43    
   \              0x6F 0x6E    
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x6C 0x65    
   \              0x72 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 2
   \   __code __interwork __softfp cyclic_buffer<float>::subobject ~cyclic_buffer()
   \                     _ZN13cyclic_bufferIfED2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN13cyclic_bufferIfED1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AccelEnrichmemnt::~AccelEnrichmemnt()
         8   -> cyclic_buffer<float>::~cyclic_buffer()
       8   Engine::~Engine()
         8   -> AccelEnrichmemnt::~AccelEnrichmemnt()
       8   __sti__routine()
         8   -> Engine::Engine(persistent_config_s *)
         8   -> LocalVersionHolder::LocalVersionHolder()
         8   -> LoggingWithStorage::LoggingWithStorage(char const *)
         8   -> Overflow64Counter::Overflow64Counter()
         8   -> __aeabi_atexit
         8   -> engine_configuration2_s::engine_configuration2_s()
      16   csThread()
        16   -> OutputPin::setValue(int)
        16   -> RpmCalculator::rpm()
        16   -> chThdSleep
       0   currentTimeMillis
       8   cyclic_buffer<float>::subobject ~cyclic_buffer()
         8   -> cyclic_buffer<float>::~cyclic_buffer()
       0   cyclic_buffer<float>::~cyclic_buffer()
      16   cylinderCleanupControl(Engine *)
        16   -> boolToString(bool)
        16   -> getTPS()
        16   -> isCrankingE(Engine *)
        16   -> scheduleMsg
      24   getBit(int, int)
        24   -> scheduleMsg
      32   getFloat(int)
        32   -> __aeabi_f2d
        32   -> scheduleMsg
      16   getInt(int)
        16   -> scheduleMsg
       8   getKnockInfo()
         8   -> Engine::printKnockState()
         8   -> getPinNameByAdcChannel(adc_channel_e, char *)
         8   -> scheduleMsg
      16   getPinNameByAdcChannel(adc_channel_e, char *)
        16   -> getAdcChannelPin(adc_channel_e)
        16   -> getAdcChannelPort(adc_channel_e)
        16   -> itoa10
        16   -> portname(GPIO_TypeDef *)
        16   -> strcpy
      16   getShort(int)
        16   -> scheduleMsg
       8   getTimeNowNt
         8   -> Overflow64Counter::get()
       0   getTimeNowSeconds
       8   getTimeNowUs
         8   -> __aeabi_ldivmod
         8   -> getTimeNowNt
       8   initConfigActions()
         8   -> addConsoleActionI
         8   -> addConsoleActionII
         8   -> addConsoleActionSS
         8   -> addConsoleActionSSS
      16   initEngineContoller(Logging *)
        16   -> addConsoleAction
        16   -> chThdCreateStatic
        16   -> initAccelEnrichment(Logging *)
        16   -> initAlgo(Logging *, engine_configuration_s *)
        16   -> initAlternatorCtrl(Logging *)
        16   -> initConfigActions()
        16   -> initElectronicThrottle()
        16   -> initFsioImpl(Logging *, Engine *)
        16   -> initInjectorCentral()
        16   -> initLcdController()
        16   -> initMainEventListener(Logging *, Engine *)
        16   -> initMalfunctionCentral
        16   -> initMalfunctionIndicator()
        16   -> initMapAveraging(Logging *, Engine *)
        16   -> initPeriodicEvents()
        16   -> initPwmGenerator()
        16   -> initRpmCalculator(Logging *, Engine *)
        16   -> initSensorChart()
        16   -> initSensors(Logging *)
        16   -> initSettings(engine_configuration_s *)
        16   -> initWaveAnalyzer(Logging *)
        16   -> prepareShapes()
        16   -> startIdleThread(Logging *, Engine *)
        16   -> startTunerStudioConnectivity()
       8   initPeriodicEvents()
         8   -> periodicFastCallback()
         8   -> scheduleNextSlowInvocation()
      16   periodicFastCallback()
        16   -> Engine::periodicFastCallback()
        16   -> chVTSetAny
        16   -> interpolate2d(float, float *, float *, int)
      16   periodicSlowCallback(Engine *)
        16   -> Engine::updateSlowSensors()
        16   -> Engine::watchdog()
        16   -> IntListenerArray::invokeJustArgCallbacks()
        16   -> LocalVersionHolder::isOld()
        16   -> RpmCalculator::isRunning()
        16   -> cylinderCleanupControl(Engine *)
        16   -> firmwareError
        16   -> getRemainingStack
        16   -> lockAnyContext
        16   -> runFsio()
        16   -> scheduleNextSlowInvocation()
        16   -> unlockAnyContext
        16   -> updateAndSet(State64 *, uint32_t)
        16   -> updateErrorCodes()
        16   -> writeToFlashIfPending()
      16   printAnalogChannelInfo(char const *, adc_channel_e)
        16   -> getInternalAdcValue(char const *, adc_channel_e)
        16   -> printAnalogChannelInfoExt(char const *, adc_channel_e, float, float)
      72   printAnalogChannelInfoExt(char const *, adc_channel_e, float, float)
        72   -> AdcDevice::isHwUsed(adc_channel_e)
        72   -> __aeabi_f2d
        72   -> boolToString(bool)
        72   -> getAdcMode(adc_channel_e)
        72   -> getPinNameByAdcChannel(adc_channel_e, char *)
        72   -> scheduleMsg
       8   printAnalogInfo()
         8   -> __aeabi_f2d
         8   -> getInternalAdcValue(char const *, adc_channel_e)
         8   -> hasBaroSensor()
         8   -> hasMafSensor()
         8   -> printAnalogChannelInfo(char const *, adc_channel_e)
         8   -> printAnalogChannelInfoExt(char const *, adc_channel_e, float, float)
         8   -> scheduleMsg
       8   resetAccel()
         8   -> AccelEnrichmemnt::reset()
       8   scheduleNextSlowInvocation()
         8   -> chVTSetAny
      40   setBit(char const *, char const *, char const *)
        40   -> absI
        40   -> applyNewConfiguration
        40   -> atoi
        40   -> scheduleMsg
      32   setFloat(char const *, char const *)
        32   -> __iar_FDtest
        32   -> absI
        32   -> atoff
        32   -> atoi
        32   -> getFloat(int)
        32   -> scheduleMsg
      16   setInt(int, int)
        16   -> applyNewConfiguration
        16   -> getInt(int)
      16   setShort(int, int)
        16   -> applyNewConfiguration
        16   -> getShort(int)
       8   updateErrorCodes()
         8   -> getCoolantTemperature()
         8   -> getIntakeAirTemperature()
         8   -> isValidCoolantTemperature(float)
         8   -> isValidIntakeAirTemperature(float)
         8   -> setError


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      52  ?<Constant "%s ADC%d %s %s rawVal...">
       8  ?<Constant "A/C sw">
      28  ?<Constant "ADC is not assigned f...">
       4  ?<Constant "AFR">
       8  ?<Constant "BARO">
       4  ?<Constant "CLT">
      20  ?<Constant "Engine Controller">
       8  ?<Constant "HIP9011">
       4  ?<Constant "IAT">
       4  ?<Constant "MAF">
       4  ?<Constant "MAP">
       4  ?<Constant "TPS">
       8  ?<Constant "Vbatt">
      36  ?<Constant "analogInputDividerCoe...">
      12  ?<Constant "analoginfo">
      20  ?<Constant "bit @%d/%d is %d">
       8  ?<Constant "extKno">
      32  ?<Constant "externalKnockSenseAdc...">
      16  ?<Constant "fast enabled=%s">
      24  ?<Constant "float @%d is %..100000f">
      12  ?<Constant "fuel gauge">
       8  ?<Constant "get_bit">
      12  ?<Constant "get_float">
       8  ?<Constant "get_int">
      12  ?<Constant "get_short">
       8  ?<Constant "hip9011">
      16  ?<Constant "int @%d is %d">
      20  ?<Constant "invalid bit [%s]">
      20  ?<Constant "invalid offset [%s]">
      20  ?<Constant "invalid value [%s]">
      28  ?<Constant "isCylinderCleanupMode %s">
      12  ?<Constant "knockinfo">
      12  ?<Constant "lowStckOnEv">
       4  ?<Constant "pPS">
       8  ?<Constant "print">
      12  ?<Constant "reset_accel">
       8  ?<Constant "set_bit">
      12  ?<Constant "set_float">
       8  ?<Constant "set_int">
      12  ?<Constant "set_short">
      16  ?<Constant "short @%d is %d">
       8  ?<Constant "status">
       8  ?<Constant "vbatt">
       4  ??DataTable10
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_16
       4  ??DataTable23_17
       4  ??DataTable23_18
       4  ??DataTable23_19
       4  ??DataTable23_2
       4  ??DataTable23_20
       4  ??DataTable23_21
       4  ??DataTable23_22
       4  ??DataTable23_23
       4  ??DataTable23_24
       4  ??DataTable23_25
       4  ??DataTable23_26
       4  ??DataTable23_27
       4  ??DataTable23_28
       4  ??DataTable23_29
       4  ??DataTable23_3
       4  ??DataTable23_30
       4  ??DataTable23_31
       4  ??DataTable23_32
       4  ??DataTable23_33
       4  ??DataTable23_34
       4  ??DataTable23_35
       4  ??DataTable23_36
       4  ??DataTable23_37
       4  ??DataTable23_38
       4  ??DataTable23_39
       4  ??DataTable23_4
       4  ??DataTable23_40
       4  ??DataTable23_41
       4  ??DataTable23_42
       4  ??DataTable23_43
       4  ??DataTable23_44
       4  ??DataTable23_45
       4  ??DataTable23_46
       4  ??DataTable23_47
       4  ??DataTable23_48
       4  ??DataTable23_49
       4  ??DataTable23_5
       4  ??DataTable23_50
       4  ??DataTable23_51
       4  ??DataTable23_52
       4  ??DataTable23_53
       4  ??DataTable23_54
       4  ??DataTable23_55
       4  ??DataTable23_56
       4  ??DataTable23_57
       4  ??DataTable23_58
       4  ??DataTable23_59
       4  ??DataTable23_6
       4  ??DataTable23_60
       4  ??DataTable23_61
       4  ??DataTable23_62
       4  ??DataTable23_63
       4  ??DataTable23_64
       4  ??DataTable23_65
       4  ??DataTable23_66
       4  ??DataTable23_67
       4  ??DataTable23_68
       4  ??DataTable23_69
       4  ??DataTable23_7
       4  ??DataTable23_70
       4  ??DataTable23_71
       4  ??DataTable23_8
       4  ??DataTable23_9
      14  AccelEnrichmemnt::~AccelEnrichmemnt()
      24  Engine::~Engine()
      64  __sti__routine()
    9240  _engine
       4  boardConfiguration
       4  config
     122  csThread()
     712  csThreadStack
      14  currentTimeMillis
      12  cyclic_buffer<float>::subobject ~cyclic_buffer()
       2  cyclic_buffer<float>::~cyclic_buffer()
     108  cylinderCleanupControl(Engine *)
   27488  ec2
       4  engine
       4  engineConfiguration
       4  engineConfiguration2
      54  getBit(int, int)
      64  getFloat(int)
      42  getInt(int)
      38  getKnockInfo()
      42  getPinNameByAdcChannel(adc_channel_e, char *)
      48  getShort(int)
      12  getTimeNowNt
      16  getTimeNowSeconds
      16  getTimeNowUs
      16  halTime
      68  initConfigActions()
     328  initEngineContoller(Logging *)
      12  initPeriodicEvents()
     260  logger
     172  periodicFastCallback()
      20  periodicFastTimer
     126  periodicSlowCallback(Engine *)
      20  periodicSlowTimer
   15300  persistentState
      16  pinNameBuffer
      52  printAnalogChannelInfo(char const *, adc_channel_e)
     178  printAnalogChannelInfoExt(char const *, adc_channel_e, float, float)
     386  printAnalogInfo()
      26  resetAccel()
      42  scheduleNextSlowInvocation()
     224  setBit(char const *, char const *, char const *)
     120  setFloat(char const *, char const *)
      40  setInt(int, int)
      42  setShort(int, int)
      44  updateErrorCodes()
       4  versionForConfigurationListeners
       4  -- Other

 
 10 288 bytes in section .bss
 42 788 bytes in section .ccm
     20 bytes in section .data
      4 bytes in section .init_array
    588 bytes in section .rodata
  2 876 bytes in section .text
 
  2 828 bytes of CODE  memory (+ 52 bytes shared)
    588 bytes of CONST memory
 53 096 bytes of DATA  memory

Errors: none
Warnings: 3
