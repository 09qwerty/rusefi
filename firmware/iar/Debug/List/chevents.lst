###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:17 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chevents.c                                      #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\kerne #
#                       l\src\chevents.c -lCN F:\stuff\rusefi_sourceforge\fir #
#                       mware\iar\Debug\List\ -lA                             #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\c #
#                       hevents.lst                                           #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\ch #
#                       events.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\kernel\src\chevents.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
      3                           2011,2012,2013 Giovanni Di Sirio.
      4          
      5              This file is part of ChibiOS/RT.
      6          
      7              ChibiOS/RT is free software; you can redistribute it and/or modify
      8              it under the terms of the GNU General Public License as published by
      9              the Free Software Foundation; either version 3 of the License, or
     10              (at your option) any later version.
     11          
     12              ChibiOS/RT is distributed in the hope that it will be useful,
     13              but WITHOUT ANY WARRANTY; without even the implied warranty of
     14              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15              GNU General Public License for more details.
     16          
     17              You should have received a copy of the GNU General Public License
     18              along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19          
     20                                                ---
     21          
     22              A special exception to the GPL can be applied should you wish to distribute
     23              a combined work that includes ChibiOS/RT, without being obliged to provide
     24              the source code for any proprietary components. See the file exception.txt
     25              for full details of how and when the exception can be applied.
     26          */
     27          /*
     28             Concepts and parts of this file have been contributed by Scott (skute).
     29           */
     30          
     31          /**
     32           * @file    chevents.c
     33           * @brief   Events code.
     34           *
     35           * @addtogroup events
     36           * @details Event Flags, Event Sources and Event Listeners.
     37           *          <h2>Operation mode</h2>
     38           *          Each thread has a mask of pending event flags inside its @p Thread
     39           *          structure.
     40           *          Operations defined for event flags:
     41           *          - <b>Wait</b>, the invoking thread goes to sleep until a certain
     42           *            AND/OR combination of event flags becomes pending.
     43           *          - <b>Clear</b>, a mask of event flags is cleared from the pending
     44           *            events mask, the cleared event flags mask is returned (only the
     45           *            flags that were actually pending and then cleared).
     46           *          - <b>Signal</b>, an event mask is directly ORed to the mask of the
     47           *            signaled thread.
     48           *          - <b>Broadcast</b>, each thread registered on an Event Source is
     49           *            signaled with the event flags specified in its Event Listener.
     50           *          - <b>Dispatch</b>, an events mask is scanned and for each bit set
     51           *            to one an associated handler function is invoked. Bit masks are
     52           *            scanned from bit zero upward.
     53           *          .
     54           *          An Event Source is a special object that can be "broadcasted" by
     55           *          a thread or an interrupt service routine. Broadcasting an Event
     56           *          Source has the effect that all the threads registered on the
     57           *          Event Source will be signaled with an events mask.<br>
     58           *          An unlimited number of Event Sources can exists in a system and
     59           *          each thread can be listening on an unlimited number of
     60           *          them.
     61           * @pre     In order to use the Events APIs the @p CH_USE_EVENTS option must be
     62           *          enabled in @p chconf.h.
     63           * @post    Enabling events requires 1-4 (depending on the architecture)
     64           *          extra bytes in the @p Thread structure.
     65           * @{
     66           */
     67          
     68          #include "ch.h"
     69          
     70          #if CH_USE_EVENTS || defined(__DOXYGEN__)
     71          /**
     72           * @brief   Registers an Event Listener on an Event Source.
     73           * @details Once a thread has registered as listener on an event source it
     74           *          will be notified of all events broadcasted there.
     75           * @note    Multiple Event Listeners can specify the same bits to be ORed to
     76           *          different threads.
     77           *
     78           * @param[in] esp       pointer to the  @p EventSource structure
     79           * @param[out] elp      pointer to the @p EventListener structure
     80           * @param[in] mask      the mask of event flags to be ORed to the thread when
     81           *                      the event source is broadcasted
     82           *
     83           * @api
     84           */

   \                                 In section .text, align 2, keep-with-next
     85          void chEvtRegisterMask(EventSource *esp, EventListener *elp, eventmask_t mask) {
   \                     chEvtRegisterMask:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     86          
     87            chDbgCheck((esp != NULL) && (elp != NULL), "chEvtRegisterMask");
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD001             BEQ.N    ??chEvtRegisterMask_0
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD106             BNE.N    ??chEvtRegisterMask_1
   \                     ??chEvtRegisterMask_0:
   \   00000010   0x2257             MOVS     R2,#+87
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000001A   0x.... 0x....      BL       chDbgPanic3
     88          
     89            chSysLock();
   \                     ??chEvtRegisterMask_1:
   \   0000001E   0x2020             MOVS     R0,#+32
   \   00000020   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000024   0x.... 0x....      BL       dbg_check_lock
     90            elp->el_next     = esp->es_next;
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6028             STR      R0,[R5, #+0]
     91            esp->es_next     = elp;
   \   0000002C   0x6025             STR      R5,[R4, #+0]
     92            elp->el_listener = currp;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000032   0x6980             LDR      R0,[R0, #+24]
   \   00000034   0x6068             STR      R0,[R5, #+4]
     93            elp->el_mask     = mask;
   \   00000036   0x60AE             STR      R6,[R5, #+8]
     94            elp->el_flags    = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x60E8             STR      R0,[R5, #+12]
     95            chSysUnlock();
   \   0000003C   0x.... 0x....      BL       dbg_check_unlock
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF380 0x8811      MSR      BASEPRI,R0
     96          }
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
     97          
     98          /**
     99           * @brief   Unregisters an Event Listener from its Event Source.
    100           * @note    If the event listener is not registered on the specified event
    101           *          source then the function does nothing.
    102           * @note    For optimal performance it is better to perform the unregister
    103           *          operations in inverse order of the register operations (elements
    104           *          are found on top of the list).
    105           *
    106           * @param[in] esp       pointer to the  @p EventSource structure
    107           * @param[in] elp       pointer to the @p EventListener structure
    108           *
    109           * @api
    110           */

   \                                 In section .text, align 2, keep-with-next
    111          void chEvtUnregister(EventSource *esp, EventListener *elp) {
   \                     chEvtUnregister:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    112            EventListener *p;
    113          
    114            chDbgCheck((esp != NULL) && (elp != NULL), "chEvtUnregister");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ.N    ??chEvtUnregister_0
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD106             BNE.N    ??chEvtUnregister_1
   \                     ??chEvtUnregister_0:
   \   0000000E   0x2272             MOVS     R2,#+114
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000018   0x.... 0x....      BL       chDbgPanic3
    115          
    116            p = (EventListener *)esp;
   \                     ??chEvtUnregister_1:
   \   0000001C   0x0026             MOVS     R6,R4
    117            chSysLock();
   \   0000001E   0x2020             MOVS     R0,#+32
   \   00000020   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000024   0x.... 0x....      BL       dbg_check_lock
    118            while (p->el_next != (EventListener *)esp) {
   \                     ??chEvtUnregister_2:
   \   00000028   0x6830             LDR      R0,[R6, #+0]
   \   0000002A   0x42A0             CMP      R0,R4
   \   0000002C   0xD007             BEQ.N    ??chEvtUnregister_3
    119              if (p->el_next == elp) {
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x42A8             CMP      R0,R5
   \   00000032   0xD102             BNE.N    ??chEvtUnregister_4
    120                p->el_next = elp->el_next;
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x6030             STR      R0,[R6, #+0]
    121                break;
   \   00000038   0xE001             B.N      ??chEvtUnregister_3
    122              }
    123              p = p->el_next;
   \                     ??chEvtUnregister_4:
   \   0000003A   0x6836             LDR      R6,[R6, #+0]
   \   0000003C   0xE7F4             B.N      ??chEvtUnregister_2
    124            }
    125            chSysUnlock();
   \                     ??chEvtUnregister_3:
   \   0000003E   0x.... 0x....      BL       dbg_check_unlock
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF380 0x8811      MSR      BASEPRI,R0
    126          }
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    127          
    128          /**
    129           * @brief   Clears the pending events specified in the mask.
    130           *
    131           * @param[in] mask      the events to be cleared
    132           * @return              The pending events that were cleared.
    133           *
    134           * @api
    135           */

   \                                 In section .text, align 2, keep-with-next
    136          eventmask_t chEvtGetAndClearEvents(eventmask_t mask) {
   \                     chEvtGetAndClearEvents:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    137            eventmask_t m;
    138          
    139            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    140          
    141            m = currp->p_epending & mask;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000012   0x6980             LDR      R0,[R0, #+24]
   \   00000014   0x6B80             LDR      R0,[R0, #+56]
   \   00000016   0x4020             ANDS     R0,R4,R0
   \   00000018   0x0005             MOVS     R5,R0
    142            currp->p_epending &= ~mask;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x6B80             LDR      R0,[R0, #+56]
   \   00000022   0x43A0             BICS     R0,R0,R4
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000028   0x6989             LDR      R1,[R1, #+24]
   \   0000002A   0x6388             STR      R0,[R1, #+56]
    143          
    144            chSysUnlock();
   \   0000002C   0x.... 0x....      BL       dbg_check_unlock
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF380 0x8811      MSR      BASEPRI,R0
    145            return m;
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    146          }
    147          
    148          /**
    149           * @brief   Adds (OR) a set of event flags on the current thread, this is
    150           *          @b much faster than using @p chEvtBroadcast() or @p chEvtSignal().
    151           *
    152           * @param[in] mask      the event flags to be added
    153           * @return              The current pending events mask.
    154           *
    155           * @api
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          eventmask_t chEvtAddEvents(eventmask_t mask) {
   \                     chEvtAddEvents:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    158          
    159            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    160          
    161            mask = (currp->p_epending |= mask);
   \   0000000E   0x....             LDR.N    R0,??DataTable13_2
   \   00000010   0x6980             LDR      R0,[R0, #+24]
   \   00000012   0x6B80             LDR      R0,[R0, #+56]
   \   00000014   0x4304             ORRS     R4,R4,R0
   \   00000016   0x....             LDR.N    R0,??DataTable13_2
   \   00000018   0x6980             LDR      R0,[R0, #+24]
   \   0000001A   0x6384             STR      R4,[R0, #+56]
    162          
    163            chSysUnlock();
   \   0000001C   0x.... 0x....      BL       dbg_check_unlock
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF380 0x8811      MSR      BASEPRI,R0
    164            return mask;
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    165          }
    166          
    167          /**
    168           * @brief   Signals all the Event Listeners registered on the specified Event
    169           *          Source.
    170           * @details This function variants ORs the specified event flags to all the
    171           *          threads registered on the @p EventSource in addition to the event
    172           *          flags specified by the threads themselves in the
    173           *          @p EventListener objects.
    174           * @post    This function does not reschedule so a call to a rescheduling
    175           *          function must be performed before unlocking the kernel. Note that
    176           *          interrupt handlers always reschedule on exit so an explicit
    177           *          reschedule must not be performed in ISRs.
    178           *
    179           * @param[in] esp       pointer to the @p EventSource structure
    180           * @param[in] flags     the flags set to be added to the listener flags mask
    181           *
    182           * @iclass
    183           */

   \                                 In section .text, align 2, keep-with-next
    184          void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
   \                     chEvtBroadcastFlagsI:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    185            EventListener *elp;
    186          
    187            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    188            chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??chEvtBroadcastFlagsI_0
   \   0000000E   0x22BC             MOVS     R2,#+188
   \   00000010   0x....             LDR.N    R1,??DataTable13
   \   00000012   0x....             LDR.N    R0,??DataTable13_4
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    189          
    190            elp = esp->es_next;
   \                     ??chEvtBroadcastFlagsI_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x0006             MOVS     R6,R0
    191            while (elp != (EventListener *)esp) {
   \                     ??chEvtBroadcastFlagsI_1:
   \   0000001C   0x42A6             CMP      R6,R4
   \   0000001E   0xD008             BEQ.N    ??chEvtBroadcastFlagsI_2
    192              elp->el_flags |= flags;
   \   00000020   0x68F0             LDR      R0,[R6, #+12]
   \   00000022   0x4328             ORRS     R0,R5,R0
   \   00000024   0x60F0             STR      R0,[R6, #+12]
    193              chEvtSignalI(elp->el_listener, elp->el_mask);
   \   00000026   0x68B1             LDR      R1,[R6, #+8]
   \   00000028   0x6870             LDR      R0,[R6, #+4]
   \   0000002A   0x.... 0x....      BL       chEvtSignalI
    194              elp = elp->el_next;
   \   0000002E   0x6836             LDR      R6,[R6, #+0]
   \   00000030   0xE7F4             B.N      ??chEvtBroadcastFlagsI_1
    195            }
    196          }
   \                     ??chEvtBroadcastFlagsI_2:
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    197          
    198          /**
    199           * @brief   Returns the flags associated to an @p EventListener.
    200           * @details The flags are returned and the @p EventListener flags mask is
    201           *          cleared.
    202           *
    203           * @param[in] elp       pointer to the @p EventListener structure
    204           * @return              The flags added to the listener by the associated
    205           *                      event source.
    206           *
    207           * @api
    208           */

   \                                 In section .text, align 2, keep-with-next
    209          flagsmask_t chEvtGetAndClearFlags(EventListener *elp) {
   \                     chEvtGetAndClearFlags:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    210            flagsmask_t flags;
    211          
    212            chSysLock();
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000A   0x.... 0x....      BL       dbg_check_lock
    213          
    214            flags = elp->el_flags;
   \   0000000E   0x68E0             LDR      R0,[R4, #+12]
   \   00000010   0x0005             MOVS     R5,R0
    215            elp->el_flags = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60E0             STR      R0,[R4, #+12]
    216          
    217            chSysUnlock();
   \   00000016   0x.... 0x....      BL       dbg_check_unlock
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF380 0x8811      MSR      BASEPRI,R0
    218            return flags;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    219          }
    220          
    221          /**
    222           * @brief   Adds a set of event flags directly to specified @p Thread.
    223           *
    224           * @param[in] tp        the thread to be signaled
    225           * @param[in] mask      the event flags set to be ORed
    226           *
    227           * @api
    228           */

   \                                 In section .text, align 2, keep-with-next
    229          void chEvtSignal(Thread *tp, eventmask_t mask) {
   \                     chEvtSignal:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    230          
    231            chDbgCheck(tp != NULL, "chEvtSignal");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD104             BNE.N    ??chEvtSignal_0
   \   0000000A   0x22E7             MOVS     R2,#+231
   \   0000000C   0x....             LDR.N    R1,??DataTable13
   \   0000000E   0x....             LDR.N    R0,??DataTable13_5
   \   00000010   0x.... 0x....      BL       chDbgPanic3
    232          
    233            chSysLock();
   \                     ??chEvtSignal_0:
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001A   0x.... 0x....      BL       dbg_check_lock
    234            chEvtSignalI(tp, mask);
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       chEvtSignalI
    235            chSchRescheduleS();
   \   00000026   0x.... 0x....      BL       chSchRescheduleS
    236            chSysUnlock();
   \   0000002A   0x.... 0x....      BL       dbg_check_unlock
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF380 0x8811      MSR      BASEPRI,R0
    237          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    238          
    239          /**
    240           * @brief   Adds a set of event flags directly to specified @p Thread.
    241           * @post    This function does not reschedule so a call to a rescheduling
    242           *          function must be performed before unlocking the kernel. Note that
    243           *          interrupt handlers always reschedule on exit so an explicit
    244           *          reschedule must not be performed in ISRs.
    245           *
    246           * @param[in] tp        the thread to be signaled
    247           * @param[in] mask      the event flags set to be ORed
    248           *
    249           * @iclass
    250           */

   \                                 In section .text, align 2, keep-with-next
    251          void chEvtSignalI(Thread *tp, eventmask_t mask) {
   \                     chEvtSignalI:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    252          
    253            chDbgCheckClassI();
   \   00000006   0x.... 0x....      BL       chDbgCheckClassI
    254            chDbgCheck(tp != NULL, "chEvtSignalI");
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??chEvtSignalI_0
   \   0000000E   0x22FE             MOVS     R2,#+254
   \   00000010   0x....             LDR.N    R1,??DataTable13
   \   00000012   0x....             LDR.N    R0,??DataTable13_6
   \   00000014   0x.... 0x....      BL       chDbgPanic3
    255          
    256            tp->p_epending |= mask;
   \                     ??chEvtSignalI_0:
   \   00000018   0x6BA0             LDR      R0,[R4, #+56]
   \   0000001A   0x4328             ORRS     R0,R5,R0
   \   0000001C   0x63A0             STR      R0,[R4, #+56]
    257            /* Test on the AND/OR conditions wait states.*/
    258            if (((tp->p_state == THD_STATE_WTOREVT) &&
    259                 ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
    260                ((tp->p_state == THD_STATE_WTANDEVT) &&
    261                 ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
   \   0000001E   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000022   0x2808             CMP      R0,#+8
   \   00000024   0xD103             BNE.N    ??chEvtSignalI_1
   \   00000026   0x6BA0             LDR      R0,[R4, #+56]
   \   00000028   0x6AA1             LDR      R1,[R4, #+40]
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD109             BNE.N    ??chEvtSignalI_2
   \                     ??chEvtSignalI_1:
   \   0000002E   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD10A             BNE.N    ??chEvtSignalI_3
   \   00000036   0x6BA0             LDR      R0,[R4, #+56]
   \   00000038   0x6AA1             LDR      R1,[R4, #+40]
   \   0000003A   0x4008             ANDS     R0,R1,R0
   \   0000003C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD104             BNE.N    ??chEvtSignalI_3
    262              chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
   \                     ??chEvtSignalI_2:
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       chSchReadyI
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x6281             STR      R1,[R0, #+40]
    263          }
   \                     ??chEvtSignalI_3:
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    264          
    265          /**
    266           * @brief   Signals all the Event Listeners registered on the specified Event
    267           *          Source.
    268           * @details This function variants ORs the specified event flags to all the
    269           *          threads registered on the @p EventSource in addition to the event
    270           *          flags specified by the threads themselves in the
    271           *          @p EventListener objects.
    272           *
    273           * @param[in] esp       pointer to the @p EventSource structure
    274           * @param[in] flags     the flags set to be added to the listener flags mask
    275           *
    276           * @api
    277           */

   \                                 In section .text, align 2, keep-with-next
    278          void chEvtBroadcastFlags(EventSource *esp, flagsmask_t flags) {
   \                     chEvtBroadcastFlags:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    279          
    280            chSysLock();
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000C   0x.... 0x....      BL       dbg_check_lock
    281            chEvtBroadcastFlagsI(esp, flags);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       chEvtBroadcastFlagsI
    282            chSchRescheduleS();
   \   00000018   0x.... 0x....      BL       chSchRescheduleS
    283            chSysUnlock();
   \   0000001C   0x.... 0x....      BL       dbg_check_unlock
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF380 0x8811      MSR      BASEPRI,R0
    284          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    285          
    286          /**
    287           * @brief   Returns the flags associated to an @p EventListener.
    288           * @details The flags are returned and the @p EventListener flags mask is
    289           *          cleared.
    290           *
    291           * @param[in] elp       pointer to the @p EventListener structure
    292           * @return              The flags added to the listener by the associated
    293           *                      event source.
    294           *
    295           * @iclass
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          flagsmask_t chEvtGetAndClearFlagsI(EventListener *elp) {
   \                     chEvtGetAndClearFlagsI:
   \   00000000   0x0001             MOVS     R1,R0
    298            flagsmask_t flags;
    299          
    300            flags = elp->el_flags;
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0x0010             MOVS     R0,R2
    301            elp->el_flags = 0;
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    302          
    303            return flags;
   \   0000000A   0x4770             BX       LR               ;; return
    304          }
    305          
    306          /**
    307           * @brief   Invokes the event handlers associated to an event flags mask.
    308           *
    309           * @param[in] mask      mask of the event flags to be dispatched
    310           * @param[in] handlers  an array of @p evhandler_t. The array must have size
    311           *                      equal to the number of bits in eventmask_t.
    312           *
    313           * @api
    314           */

   \                                 In section .text, align 2, keep-with-next
    315          void chEvtDispatch(const evhandler_t *handlers, eventmask_t mask) {
   \                     chEvtDispatch:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    316            eventid_t eid;
    317          
    318            chDbgCheck(handlers != NULL, "chEvtDispatch");
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD105             BNE.N    ??chEvtDispatch_0
   \   0000000A   0xF44F 0x729F      MOV      R2,#+318
   \   0000000E   0x....             LDR.N    R1,??DataTable13
   \   00000010   0x....             LDR.N    R0,??DataTable13_7
   \   00000012   0x.... 0x....      BL       chDbgPanic3
    319          
    320            eid = 0;
   \                     ??chEvtDispatch_0:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
    321            while (mask) {
   \                     ??chEvtDispatch_1:
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD013             BEQ.N    ??chEvtDispatch_2
    322              if (mask & EVENT_MASK(eid)) {
   \   0000001E   0xFA36 0xF005      LSRS     R0,R6,R5
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD50D             BPL.N    ??chEvtDispatch_3
    323                chDbgAssert(handlers[eid] != NULL,
    324                            "chEvtDispatch(), #1",
    325                            "null handler");
   \   00000026   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD102             BNE.N    ??chEvtDispatch_4
   \   0000002E   0x....             LDR.N    R0,??DataTable13_8
   \   00000030   0x.... 0x....      BL       chDbgPanic
    326                mask &= ~EVENT_MASK(eid);
   \                     ??chEvtDispatch_4:
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x40A8             LSLS     R0,R0,R5
   \   00000038   0x4386             BICS     R6,R6,R0
    327                handlers[eid](eid);
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xF854 0x1025      LDR      R1,[R4, R5, LSL #+2]
   \   00000040   0x4788             BLX      R1
    328              }
    329              eid++;
   \                     ??chEvtDispatch_3:
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0xE7E9             B.N      ??chEvtDispatch_1
    330            }
    331          }
   \                     ??chEvtDispatch_2:
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    332          
    333          #if CH_OPTIMIZE_SPEED || !CH_USE_EVENTS_TIMEOUT || defined(__DOXYGEN__)
    334          /**
    335           * @brief   Waits for exactly one of the specified events.
    336           * @details The function waits for one event among those specified in
    337           *          @p mask to become pending then the event is cleared and returned.
    338           * @note    One and only one event is served in the function, the one with the
    339           *          lowest event id. The function is meant to be invoked into a loop in
    340           *          order to serve all the pending events.<br>
    341           *          This means that Event Listeners with a lower event identifier have
    342           *          an higher priority.
    343           *
    344           * @param[in] mask      mask of the event flags that the function should wait
    345           *                      for, @p ALL_EVENTS enables all the events
    346           * @return              The mask of the lowest id served and cleared event.
    347           *
    348           * @api
    349           */

   \                                 In section .text, align 2, keep-with-next
    350          eventmask_t chEvtWaitOne(eventmask_t mask) {
   \                     chEvtWaitOne:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    351            Thread *ctp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable13_2
   \   00000006   0x6985             LDR      R5,[R0, #+24]
    352            eventmask_t m;
    353          
    354            chSysLock();
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000E   0x.... 0x....      BL       dbg_check_lock
    355          
    356            if ((m = (ctp->p_epending & mask)) == 0) {
   \   00000012   0x6BA8             LDR      R0,[R5, #+56]
   \   00000014   0x4020             ANDS     R0,R4,R0
   \   00000016   0x0006             MOVS     R6,R0
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD106             BNE.N    ??chEvtWaitOne_0
    357              ctp->p_u.ewmask = mask;
   \   0000001C   0x62AC             STR      R4,[R5, #+40]
    358              chSchGoSleepS(THD_STATE_WTOREVT);
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0x.... 0x....      BL       chSchGoSleepS
    359              m = ctp->p_epending & mask;
   \   00000024   0x6BA8             LDR      R0,[R5, #+56]
   \   00000026   0x4020             ANDS     R0,R4,R0
   \   00000028   0x0006             MOVS     R6,R0
    360            }
    361            m ^= m & (m - 1);
   \                     ??chEvtWaitOne_0:
   \   0000002A   0x1E70             SUBS     R0,R6,#+1
   \   0000002C   0x4030             ANDS     R0,R0,R6
   \   0000002E   0x4046             EORS     R6,R0,R6
    362            ctp->p_epending &= ~m;
   \   00000030   0x6BA8             LDR      R0,[R5, #+56]
   \   00000032   0x43B0             BICS     R0,R0,R6
   \   00000034   0x63A8             STR      R0,[R5, #+56]
    363          
    364            chSysUnlock();
   \   00000036   0x.... 0x....      BL       dbg_check_unlock
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF380 0x8811      MSR      BASEPRI,R0
    365            return m;
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    366          }
    367          
    368          /**
    369           * @brief   Waits for any of the specified events.
    370           * @details The function waits for any event among those specified in
    371           *          @p mask to become pending then the events are cleared and returned.
    372           *
    373           * @param[in] mask      mask of the event flags that the function should wait
    374           *                      for, @p ALL_EVENTS enables all the events
    375           * @return              The mask of the served and cleared events.
    376           *
    377           * @api
    378           */

   \                                 In section .text, align 2, keep-with-next
    379          eventmask_t chEvtWaitAny(eventmask_t mask) {
   \                     chEvtWaitAny:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    380            Thread *ctp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable13_2
   \   00000006   0x6985             LDR      R5,[R0, #+24]
    381            eventmask_t m;
    382          
    383            chSysLock();
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000E   0x.... 0x....      BL       dbg_check_lock
    384          
    385            if ((m = (ctp->p_epending & mask)) == 0) {
   \   00000012   0x6BA8             LDR      R0,[R5, #+56]
   \   00000014   0x4020             ANDS     R0,R4,R0
   \   00000016   0x0006             MOVS     R6,R0
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD106             BNE.N    ??chEvtWaitAny_0
    386              ctp->p_u.ewmask = mask;
   \   0000001C   0x62AC             STR      R4,[R5, #+40]
    387              chSchGoSleepS(THD_STATE_WTOREVT);
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0x.... 0x....      BL       chSchGoSleepS
    388              m = ctp->p_epending & mask;
   \   00000024   0x6BA8             LDR      R0,[R5, #+56]
   \   00000026   0x4020             ANDS     R0,R4,R0
   \   00000028   0x0006             MOVS     R6,R0
    389            }
    390            ctp->p_epending &= ~m;
   \                     ??chEvtWaitAny_0:
   \   0000002A   0x6BA8             LDR      R0,[R5, #+56]
   \   0000002C   0x43B0             BICS     R0,R0,R6
   \   0000002E   0x63A8             STR      R0,[R5, #+56]
    391          
    392            chSysUnlock();
   \   00000030   0x.... 0x....      BL       dbg_check_unlock
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF380 0x8811      MSR      BASEPRI,R0
    393            return m;
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    394          }
    395          
    396          /**
    397           * @brief   Waits for all the specified events.
    398           * @details The function waits for all the events specified in @p mask to
    399           *          become pending then the events are cleared and returned.
    400           *
    401           * @param[in] mask      mask of the event flags that the function should wait
    402           *                      for, @p ALL_EVENTS requires all the events
    403           * @return              The mask of the served and cleared events.
    404           *
    405           * @api
    406           */

   \                                 In section .text, align 2, keep-with-next
    407          eventmask_t chEvtWaitAll(eventmask_t mask) {
   \                     chEvtWaitAll:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    408            Thread *ctp = currp;
   \   00000004   0x....             LDR.N    R0,??DataTable13_2
   \   00000006   0x6985             LDR      R5,[R0, #+24]
    409          
    410            chSysLock();
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000000E   0x.... 0x....      BL       dbg_check_lock
    411          
    412            if ((ctp->p_epending & mask) != mask) {
   \   00000012   0x6BA8             LDR      R0,[R5, #+56]
   \   00000014   0x4020             ANDS     R0,R4,R0
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD003             BEQ.N    ??chEvtWaitAll_0
    413              ctp->p_u.ewmask = mask;
   \   0000001A   0x62AC             STR      R4,[R5, #+40]
    414              chSchGoSleepS(THD_STATE_WTANDEVT);
   \   0000001C   0x2009             MOVS     R0,#+9
   \   0000001E   0x.... 0x....      BL       chSchGoSleepS
    415            }
    416            ctp->p_epending &= ~mask;
   \                     ??chEvtWaitAll_0:
   \   00000022   0x6BA8             LDR      R0,[R5, #+56]
   \   00000024   0x43A0             BICS     R0,R0,R4
   \   00000026   0x63A8             STR      R0,[R5, #+56]
    417          
    418            chSysUnlock();
   \   00000028   0x.... 0x....      BL       dbg_check_unlock
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF380 0x8811      MSR      BASEPRI,R0
    419            return mask;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    420          }
    421          #endif /* CH_OPTIMIZE_SPEED || !CH_USE_EVENTS_TIMEOUT */
    422          
    423          #if CH_USE_EVENTS_TIMEOUT || defined(__DOXYGEN__)
    424          /**
    425           * @brief   Waits for exactly one of the specified events.
    426           * @details The function waits for one event among those specified in
    427           *          @p mask to become pending then the event is cleared and returned.
    428           * @note    One and only one event is served in the function, the one with the
    429           *          lowest event id. The function is meant to be invoked into a loop in
    430           *          order to serve all the pending events.<br>
    431           *          This means that Event Listeners with a lower event identifier have
    432           *          an higher priority.
    433           *
    434           * @param[in] mask      mask of the event flags that the function should wait
    435           *                      for, @p ALL_EVENTS enables all the events
    436           * @param[in] time      the number of ticks before the operation timeouts,
    437           *                      the following special values are allowed:
    438           *                      - @a TIME_IMMEDIATE immediate timeout.
    439           *                      - @a TIME_INFINITE no timeout.
    440           *                      .
    441           * @return              The mask of the lowest id served and cleared event.
    442           * @retval 0            if the operation has timed out.
    443           *
    444           * @api
    445           */

   \                                 In section .text, align 2, keep-with-next
    446          eventmask_t chEvtWaitOneTimeout(eventmask_t mask, systime_t time) {
   \                     chEvtWaitOneTimeout:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    447            Thread *ctp = currp;
   \   00000006   0x....             LDR.N    R0,??DataTable13_2
   \   00000008   0x6986             LDR      R6,[R0, #+24]
    448            eventmask_t m;
    449          
    450            chSysLock();
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000010   0x.... 0x....      BL       dbg_check_lock
    451          
    452            if ((m = (ctp->p_epending & mask)) == 0) {
   \   00000014   0x6BB0             LDR      R0,[R6, #+56]
   \   00000016   0x4020             ANDS     R0,R4,R0
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD119             BNE.N    ??chEvtWaitOneTimeout_0
    453              if (TIME_IMMEDIATE == time) {
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD106             BNE.N    ??chEvtWaitOneTimeout_1
    454                chSysUnlock();
   \   00000022   0x.... 0x....      BL       dbg_check_unlock
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF380 0x8811      MSR      BASEPRI,R0
    455                return (eventmask_t)0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE01C             B.N      ??chEvtWaitOneTimeout_2
    456              }
    457              ctp->p_u.ewmask = mask;
   \                     ??chEvtWaitOneTimeout_1:
   \   00000030   0x62B4             STR      R4,[R6, #+40]
    458              if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD506             BPL.N    ??chEvtWaitOneTimeout_3
    459                chSysUnlock();
   \   0000003E   0x.... 0x....      BL       dbg_check_unlock
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF380 0x8811      MSR      BASEPRI,R0
    460                return (eventmask_t)0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE00E             B.N      ??chEvtWaitOneTimeout_2
    461              }
    462              m = ctp->p_epending & mask;
   \                     ??chEvtWaitOneTimeout_3:
   \   0000004C   0x6BB0             LDR      R0,[R6, #+56]
   \   0000004E   0x4020             ANDS     R0,R4,R0
   \   00000050   0x0007             MOVS     R7,R0
    463            }
    464            m ^= m & (m - 1);
   \                     ??chEvtWaitOneTimeout_0:
   \   00000052   0x1E78             SUBS     R0,R7,#+1
   \   00000054   0x4038             ANDS     R0,R0,R7
   \   00000056   0x4047             EORS     R7,R0,R7
    465            ctp->p_epending &= ~m;
   \   00000058   0x6BB0             LDR      R0,[R6, #+56]
   \   0000005A   0x43B8             BICS     R0,R0,R7
   \   0000005C   0x63B0             STR      R0,[R6, #+56]
    466          
    467            chSysUnlock();
   \   0000005E   0x.... 0x....      BL       dbg_check_unlock
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF380 0x8811      MSR      BASEPRI,R0
    468            return m;
   \   00000068   0x0038             MOVS     R0,R7
   \                     ??chEvtWaitOneTimeout_2:
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    469          }
    470          
    471          /**
    472           * @brief   Waits for any of the specified events.
    473           * @details The function waits for any event among those specified in
    474           *          @p mask to become pending then the events are cleared and
    475           *          returned.
    476           *
    477           * @param[in] mask      mask of the event flags that the function should wait
    478           *                      for, @p ALL_EVENTS enables all the events
    479           * @param[in] time      the number of ticks before the operation timeouts,
    480           *                      the following special values are allowed:
    481           *                      - @a TIME_IMMEDIATE immediate timeout.
    482           *                      - @a TIME_INFINITE no timeout.
    483           *                      .
    484           * @return              The mask of the served and cleared events.
    485           * @retval 0            if the operation has timed out.
    486           *
    487           * @api
    488           */

   \                                 In section .text, align 2, keep-with-next
    489          eventmask_t chEvtWaitAnyTimeout(eventmask_t mask, systime_t time) {
   \                     chEvtWaitAnyTimeout:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    490            Thread *ctp = currp;
   \   00000006   0x....             LDR.N    R0,??DataTable13_2
   \   00000008   0x6986             LDR      R6,[R0, #+24]
    491            eventmask_t m;
    492          
    493            chSysLock();
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000010   0x.... 0x....      BL       dbg_check_lock
    494          
    495            if ((m = (ctp->p_epending & mask)) == 0) {
   \   00000014   0x6BB0             LDR      R0,[R6, #+56]
   \   00000016   0x4020             ANDS     R0,R4,R0
   \   00000018   0x0007             MOVS     R7,R0
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD119             BNE.N    ??chEvtWaitAnyTimeout_0
    496              if (TIME_IMMEDIATE == time) {
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD106             BNE.N    ??chEvtWaitAnyTimeout_1
    497                chSysUnlock();
   \   00000022   0x.... 0x....      BL       dbg_check_unlock
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF380 0x8811      MSR      BASEPRI,R0
    498                return (eventmask_t)0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE019             B.N      ??chEvtWaitAnyTimeout_2
    499              }
    500              ctp->p_u.ewmask = mask;
   \                     ??chEvtWaitAnyTimeout_1:
   \   00000030   0x62B4             STR      R4,[R6, #+40]
    501              if (chSchGoSleepTimeoutS(THD_STATE_WTOREVT, time) < RDY_OK) {
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD506             BPL.N    ??chEvtWaitAnyTimeout_3
    502                chSysUnlock();
   \   0000003E   0x.... 0x....      BL       dbg_check_unlock
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF380 0x8811      MSR      BASEPRI,R0
    503                return (eventmask_t)0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE00B             B.N      ??chEvtWaitAnyTimeout_2
    504              }
    505              m = ctp->p_epending & mask;
   \                     ??chEvtWaitAnyTimeout_3:
   \   0000004C   0x6BB0             LDR      R0,[R6, #+56]
   \   0000004E   0x4020             ANDS     R0,R4,R0
   \   00000050   0x0007             MOVS     R7,R0
    506            }
    507            ctp->p_epending &= ~m;
   \                     ??chEvtWaitAnyTimeout_0:
   \   00000052   0x6BB0             LDR      R0,[R6, #+56]
   \   00000054   0x43B8             BICS     R0,R0,R7
   \   00000056   0x63B0             STR      R0,[R6, #+56]
    508          
    509            chSysUnlock();
   \   00000058   0x.... 0x....      BL       dbg_check_unlock
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF380 0x8811      MSR      BASEPRI,R0
    510            return m;
   \   00000062   0x0038             MOVS     R0,R7
   \                     ??chEvtWaitAnyTimeout_2:
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    511          }
    512          
    513          /**
    514           * @brief   Waits for all the specified events.
    515           * @details The function waits for all the events specified in @p mask to
    516           *          become pending then the events are cleared and returned.
    517           *
    518           * @param[in] mask      mask of the event flags that the function should wait
    519           *                      for, @p ALL_EVENTS requires all the events
    520           * @param[in] time      the number of ticks before the operation timeouts,
    521           *                      the following special values are allowed:
    522           *                      - @a TIME_IMMEDIATE immediate timeout.
    523           *                      - @a TIME_INFINITE no timeout.
    524           *                      .
    525           * @return              The mask of the served and cleared events.
    526           * @retval 0            if the operation has timed out.
    527           *
    528           * @api
    529           */

   \                                 In section .text, align 2, keep-with-next
    530          eventmask_t chEvtWaitAllTimeout(eventmask_t mask, systime_t time) {
   \                     chEvtWaitAllTimeout:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    531            Thread *ctp = currp;
   \   00000006   0x....             LDR.N    R0,??DataTable13_2
   \   00000008   0x6986             LDR      R6,[R0, #+24]
    532          
    533            chSysLock();
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000010   0x.... 0x....      BL       dbg_check_lock
    534          
    535            if ((ctp->p_epending & mask) != mask) {
   \   00000014   0x6BB0             LDR      R0,[R6, #+56]
   \   00000016   0x4020             ANDS     R0,R4,R0
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD016             BEQ.N    ??chEvtWaitAllTimeout_0
    536              if (TIME_IMMEDIATE == time) {
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD106             BNE.N    ??chEvtWaitAllTimeout_1
    537                chSysUnlock();
   \   00000020   0x.... 0x....      BL       dbg_check_unlock
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF380 0x8811      MSR      BASEPRI,R0
    538                return (eventmask_t)0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE016             B.N      ??chEvtWaitAllTimeout_2
    539              }
    540              ctp->p_u.ewmask = mask;
   \                     ??chEvtWaitAllTimeout_1:
   \   0000002E   0x62B4             STR      R4,[R6, #+40]
    541              if (chSchGoSleepTimeoutS(THD_STATE_WTANDEVT, time) < RDY_OK) {
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x2009             MOVS     R0,#+9
   \   00000034   0x.... 0x....      BL       chSchGoSleepTimeoutS
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD506             BPL.N    ??chEvtWaitAllTimeout_0
    542                chSysUnlock();
   \   0000003C   0x.... 0x....      BL       dbg_check_unlock
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF380 0x8811      MSR      BASEPRI,R0
    543                return (eventmask_t)0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE008             B.N      ??chEvtWaitAllTimeout_2
    544              }
    545            }
    546            ctp->p_epending &= ~mask;
   \                     ??chEvtWaitAllTimeout_0:
   \   0000004A   0x6BB0             LDR      R0,[R6, #+56]
   \   0000004C   0x43A0             BICS     R0,R0,R4
   \   0000004E   0x63B0             STR      R0,[R6, #+56]
    547          
    548            chSysUnlock();
   \   00000050   0x.... 0x....      BL       dbg_check_unlock
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF380 0x8811      MSR      BASEPRI,R0
    549            return mask;
   \   0000005A   0x0020             MOVS     R0,R4
   \                     ??chEvtWaitAllTimeout_2:
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    550          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     `?<Constant "\\"chEvtRegisterMask\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     `?<Constant "\\"chEvtUnregister\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     `?<Constant "\\"chEvtBroadcastMaskI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     `?<Constant "\\"chEvtSignal\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     `?<Constant "\\"chEvtSignalI\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     `?<Constant "\\"chEvtDispatch\\"()">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     `?<Constant "chEvtDispatch(), #1">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chEvtRegisterMask\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chEvtRegisterMask\"()"
   \              0x68 0x45    
   \              0x76 0x74    
   \              0x52 0x65    
   \              0x67 0x69    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x4D 0x61    
   \              0x73 0x6B    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "F:\\\\stuff\\\\rusefi_sourc...">`:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 73H, 74H, 75H, 66H, 66H
   \              0x5C 0x73    
   \              0x74 0x75    
   \              0x66 0x66    
   \   00000008   0x5C 0x72          DC8 5CH, 72H, 75H, 73H, 65H, 66H, 69H, 5FH
   \              0x75 0x73    
   \              0x65 0x66    
   \              0x69 0x5F    
   \   00000010   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 66H, 6FH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x66 0x6F    
   \   00000018   0x72 0x67          DC8 72H, 67H, 65H, 5CH, 66H, 69H, 72H, 6DH
   \              0x65 0x5C    
   \              0x66 0x69    
   \              0x72 0x6D    
   \   00000020   0x77 0x61          DC8 77H, 61H, 72H, 65H, 5CH, 63H, 68H, 69H
   \              0x72 0x65    
   \              0x5C 0x63    
   \              0x68 0x69    
   \   00000028   0x62 0x69          DC8 62H, 69H, 6FH, 73H, 5CH, 6FH, 73H, 5CH
   \              0x6F 0x73    
   \              0x5C 0x6F    
   \              0x73 0x5C    
   \   00000030   0x6B 0x65          DC8 6BH, 65H, 72H, 6EH, 65H, 6CH, 5CH, 73H
   \              0x72 0x6E    
   \              0x65 0x6C    
   \              0x5C 0x73    
   \   00000038   0x72 0x63          DC8 72H, 63H, 5CH, 63H, 68H, 65H, 76H, 65H
   \              0x5C 0x63    
   \              0x68 0x65    
   \              0x76 0x65    
   \   00000040   0x6E 0x74          DC8 6EH, 74H, 73H, 2EH, 63H, 0
   \              0x73 0x2E    
   \              0x63 0x00    
   \   00000046   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chEvtUnregister\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chEvtUnregister\"()"
   \              0x68 0x45    
   \              0x76 0x74    
   \              0x55 0x6E    
   \              0x72 0x65    
   \              0x67 0x69    
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chEvtBroadcastMaskI\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chEvtBroadcastMaskI\"()"
   \              0x68 0x45    
   \              0x76 0x74    
   \              0x42 0x72    
   \              0x6F 0x61    
   \              0x64 0x63    
   \              0x61 0x73    
   \              0x74 0x4D    
   \              0x61 0x73    
   \              0x6B 0x49    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chEvtSignal\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chEvtSignal\"()"
   \              0x68 0x45    
   \              0x76 0x74    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x22 0x28    
   \              0x29 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chEvtSignalI\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chEvtSignalI\"()"
   \              0x68 0x45    
   \              0x76 0x74    
   \              0x53 0x69    
   \              0x67 0x6E    
   \              0x61 0x6C    
   \              0x49 0x22    
   \              0x28 0x29    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"chEvtDispatch\\"()">`:
   \   00000000   0x22 0x63          DC8 "\"chEvtDispatch\"()"
   \              0x68 0x45    
   \              0x76 0x74    
   \              0x44 0x69    
   \              0x73 0x70    
   \              0x61 0x74    
   \              0x63 0x68    
   \              0x22 0x28    
   \              0x29 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "chEvtDispatch(), #1">`:
   \   00000000   0x63 0x68          DC8 "chEvtDispatch(), #1"
   \              0x45 0x76    
   \              0x74 0x44    
   \              0x69 0x73    
   \              0x70 0x61    
   \              0x74 0x63    
   \              0x68 0x28    
   \              0x29 0x2C    
   \              0x20 0x23    
   \              0x31 0x00    
    551          #endif /* CH_USE_EVENTS_TIMEOUT */
    552          
    553          #endif /* CH_USE_EVENTS */
    554          
    555          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   chEvtAddEvents
         8   -> dbg_check_lock
         8   -> dbg_check_unlock
      16   chEvtBroadcastFlags
        16   -> chEvtBroadcastFlagsI
        16   -> chSchRescheduleS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtBroadcastFlagsI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> chEvtSignalI
      16   chEvtDispatch
        16   -- Indirect call
        16   -> chDbgPanic
        16   -> chDbgPanic3
      16   chEvtGetAndClearEvents
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtGetAndClearFlags
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
       0   chEvtGetAndClearFlagsI
      16   chEvtRegisterMask
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtSignal
        16   -> chDbgPanic3
        16   -> chEvtSignalI
        16   -> chSchRescheduleS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtSignalI
        16   -> chDbgCheckClassI
        16   -> chDbgPanic3
        16   -> chSchReadyI
      16   chEvtUnregister
        16   -> chDbgPanic3
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtWaitAll
        16   -> chSchGoSleepS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtWaitAllTimeout
        16   -> chSchGoSleepTimeoutS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      16   chEvtWaitAny
        16   -> chSchGoSleepS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      24   chEvtWaitAnyTimeout
        24   -> chSchGoSleepTimeoutS
        24   -> dbg_check_lock
        24   -> dbg_check_unlock
      16   chEvtWaitOne
        16   -> chSchGoSleepS
        16   -> dbg_check_lock
        16   -> dbg_check_unlock
      24   chEvtWaitOneTimeout
        24   -> chSchGoSleepTimeoutS
        24   -> dbg_check_lock
        24   -> dbg_check_unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  ?<Constant "F:\\stuff\\rusefi_sourc...">
      24  ?<Constant "\"chEvtBroadcastMaskI\"()">
      20  ?<Constant "\"chEvtDispatch\"()">
      24  ?<Constant "\"chEvtRegisterMask\"()">
      20  ?<Constant "\"chEvtSignalI\"()">
      16  ?<Constant "\"chEvtSignal\"()">
      20  ?<Constant "\"chEvtUnregister\"()">
      20  ?<Constant "chEvtDispatch(), #1">
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
      42  chEvtAddEvents
      40  chEvtBroadcastFlags
      52  chEvtBroadcastFlagsI
      72  chEvtDispatch
      58  chEvtGetAndClearEvents
      36  chEvtGetAndClearFlags
      12  chEvtGetAndClearFlagsI
      72  chEvtRegisterMask
      54  chEvtSignal
      78  chEvtSignalI
      74  chEvtUnregister
      54  chEvtWaitAll
      94  chEvtWaitAllTimeout
      62  chEvtWaitAny
     102  chEvtWaitAnyTimeout
      68  chEvtWaitOne
     108  chEvtWaitOneTimeout

 
   216 bytes in section .rodata
 1 114 bytes in section .text
 
 1 114 bytes of CODE  memory
   216 bytes of CONST memory

Errors: none
Warnings: none
