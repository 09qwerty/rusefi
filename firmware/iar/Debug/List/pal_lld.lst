###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:57 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\GPIOv2\pal_lld.c                       #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\GPIOv2\pal_lld.c -lCN                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\p #
#                       al_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\pa #
#                       l_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\GPIOv2\pal_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/GPIOv2/pal_lld.c
     19           * @brief   STM32L1xx/STM32F2xx/STM32F4xx GPIO low level driver code.
     20           *
     21           * @addtogroup PAL
     22           * @{
     23           */
     24          
     25          #include "ch.h"
     26          #include "hal.h"
     27          
     28          #if HAL_USE_PAL || defined(__DOXYGEN__)
     29          
     30          /*===========================================================================*/
     31          /* Driver local definitions.                                                 */
     32          /*===========================================================================*/
     33          
     34          #if defined(STM32L1XX)
     35          #define AHB_EN_MASK     (RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN |          \
     36                                   RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIODEN |          \
     37                                   RCC_AHBENR_GPIOEEN | RCC_AHBENR_GPIOHEN)
     38          #define AHB_LPEN_MASK   AHB_EN_MASK
     39          
     40          #elif defined(STM32F030) || defined(STM32F0XX_MD)
     41          #define AHB_EN_MASK     (RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN |          \
     42                                   RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIODEN |          \
     43                                   RCC_AHBENR_GPIOFEN)
     44          
     45          #elif defined(STM32F0XX_LD)
     46          #define AHB_EN_MASK     (RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN |          \
     47                                   RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOFEN)
     48          
     49          #elif defined(STM32F2XX)
     50          #define AHB1_EN_MASK    (RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN |        \
     51                                   RCC_AHB1ENR_GPIOCEN | RCC_AHB1ENR_GPIODEN |        \
     52                                   RCC_AHB1ENR_GPIOEEN | RCC_AHB1ENR_GPIOFEN |        \
     53                                   RCC_AHB1ENR_GPIOGEN | RCC_AHB1ENR_GPIOHEN |        \
     54                                   RCC_AHB1ENR_GPIOIEN)
     55          #define AHB1_LPEN_MASK  AHB1_EN_MASK
     56          
     57          #elif defined(STM32F30X) || defined(STM32F37X)
     58          #define AHB_EN_MASK     (RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN |          \
     59                                   RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIODEN |          \
     60                                   RCC_AHBENR_GPIOEEN | RCC_AHBENR_GPIOFEN)
     61          
     62          #elif defined(STM32F4XX)
     63          #if STM32_HAS_GPIOF && STM32_HAS_GPIOG && STM32_HAS_GPIOI
     64          #define AHB1_EN_MASK    (RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN |        \
     65                                   RCC_AHB1ENR_GPIOCEN | RCC_AHB1ENR_GPIODEN |        \
     66                                   RCC_AHB1ENR_GPIOEEN | RCC_AHB1ENR_GPIOFEN |        \
     67                                   RCC_AHB1ENR_GPIOGEN | RCC_AHB1ENR_GPIOHEN |        \
     68                                   RCC_AHB1ENR_GPIOIEN)
     69          #else
     70          #define AHB1_EN_MASK    (RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN |        \
     71                                   RCC_AHB1ENR_GPIOCEN | RCC_AHB1ENR_GPIODEN |        \
     72                                   RCC_AHB1ENR_GPIOEEN)
     73          #endif /* STM32_HAS_GPIOF && STM32_HAS_GPIOG && STM32_HAS_GPIOI */
     74          #define AHB1_LPEN_MASK  AHB1_EN_MASK
     75          
     76          #else
     77          #error "missing or unsupported platform for GPIOv2 PAL driver"
     78          #endif
     79          
     80          /*===========================================================================*/
     81          /* Driver exported variables.                                                */
     82          /*===========================================================================*/
     83          
     84          /*===========================================================================*/
     85          /* Driver local variables and types.                                         */
     86          /*===========================================================================*/
     87          
     88          /*===========================================================================*/
     89          /* Driver local functions.                                                   */
     90          /*===========================================================================*/
     91          

   \                                 In section .text, align 2, keep-with-next
     92          static void initgpio(GPIO_TypeDef *gpiop, const stm32_gpio_setup_t *config) {
     93          
     94            gpiop->OTYPER  = config->otyper;
   \                     initgpio:
   \   00000000   0x684A             LDR      R2,[R1, #+4]
   \   00000002   0x6042             STR      R2,[R0, #+4]
     95            gpiop->OSPEEDR = config->ospeedr;
   \   00000004   0x688A             LDR      R2,[R1, #+8]
   \   00000006   0x6082             STR      R2,[R0, #+8]
     96            gpiop->PUPDR   = config->pupdr;
   \   00000008   0x68CA             LDR      R2,[R1, #+12]
   \   0000000A   0x60C2             STR      R2,[R0, #+12]
     97            gpiop->ODR     = config->odr;
   \   0000000C   0x690A             LDR      R2,[R1, #+16]
   \   0000000E   0x6142             STR      R2,[R0, #+20]
     98            gpiop->AFRL    = config->afrl;
   \   00000010   0x694A             LDR      R2,[R1, #+20]
   \   00000012   0x6202             STR      R2,[R0, #+32]
     99            gpiop->AFRH    = config->afrh;
   \   00000014   0x698A             LDR      R2,[R1, #+24]
   \   00000016   0x6242             STR      R2,[R0, #+36]
    100            gpiop->MODER   = config->moder;
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    101          }
   \   0000001C   0x4770             BX       LR               ;; return
    102          
    103          /*===========================================================================*/
    104          /* Driver interrupt handlers.                                                */
    105          /*===========================================================================*/
    106          
    107          /*===========================================================================*/
    108          /* Driver exported functions.                                                */
    109          /*===========================================================================*/
    110          
    111          /**
    112           * @brief   STM32 I/O ports configuration.
    113           * @details Ports A-D(E, F, G, H) clocks enabled.
    114           *
    115           * @param[in] config    the STM32 ports configuration
    116           *
    117           * @notapi
    118           */

   \                                 In section .text, align 2, keep-with-next
    119          void _pal_lld_init(const PALConfig *config) {
   \                     _pal_lld_init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    120          
    121            /*
    122             * Enables the GPIO related clocks.
    123             */
    124          #if defined(STM32L1XX)
    125            rccEnableAHB(AHB_EN_MASK, TRUE);
    126            RCC->AHBLPENR |= AHB_LPEN_MASK;
    127          #elif defined(STM32F0XX)
    128            rccEnableAHB(AHB_EN_MASK, TRUE);
    129          #elif defined(STM32F30X) || defined(STM32F37X)
    130            rccEnableAHB(AHB_EN_MASK, TRUE);
    131          #elif defined(STM32F2XX) || defined(STM32F4XX)
    132            RCC->AHB1ENR   |= AHB1_EN_MASK;
   \   00000004   0x....             LDR.N    R0,??DataTable0  ;; 0x40023830
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF240 0x11FF      MOVW     R1,#+511
   \   0000000C   0x4308             ORRS     R0,R1,R0
   \   0000000E   0x....             LDR.N    R1,??DataTable0  ;; 0x40023830
   \   00000010   0x6008             STR      R0,[R1, #+0]
    133            RCC->AHB1LPENR |= AHB1_LPEN_MASK;
   \   00000012   0x....             LDR.N    R0,??DataTable0_1  ;; 0x40023850
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF240 0x11FF      MOVW     R1,#+511
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40023850
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    134          #endif
    135          
    136            /*
    137             * Initial GPIO setup.
    138             */
    139          #if STM32_HAS_GPIOA
    140            initgpio(GPIOA, &config->PAData);
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable0_2  ;; 0x40020000
   \   00000024   0x.... 0x....      BL       initgpio
    141          #endif
    142          #if STM32_HAS_GPIOB
    143            initgpio(GPIOB, &config->PBData);
   \   00000028   0xF114 0x011C      ADDS     R1,R4,#+28
   \   0000002C   0x....             LDR.N    R0,??DataTable0_3  ;; 0x40020400
   \   0000002E   0x.... 0x....      BL       initgpio
    144          #endif
    145          #if STM32_HAS_GPIOC
    146            initgpio(GPIOC, &config->PCData);
   \   00000032   0xF114 0x0138      ADDS     R1,R4,#+56
   \   00000036   0x....             LDR.N    R0,??DataTable0_4  ;; 0x40020800
   \   00000038   0x.... 0x....      BL       initgpio
    147          #endif
    148          #if STM32_HAS_GPIOD
    149            initgpio(GPIOD, &config->PDData);
   \   0000003C   0xF114 0x0154      ADDS     R1,R4,#+84
   \   00000040   0x....             LDR.N    R0,??DataTable0_5  ;; 0x40020c00
   \   00000042   0x.... 0x....      BL       initgpio
    150          #endif
    151          #if STM32_HAS_GPIOE
    152            initgpio(GPIOE, &config->PEData);
   \   00000046   0xF114 0x0170      ADDS     R1,R4,#+112
   \   0000004A   0x....             LDR.N    R0,??DataTable0_6  ;; 0x40021000
   \   0000004C   0x.... 0x....      BL       initgpio
    153          #endif
    154          #if STM32_HAS_GPIOF
    155            initgpio(GPIOF, &config->PFData);
   \   00000050   0xF114 0x018C      ADDS     R1,R4,#+140
   \   00000054   0x....             LDR.N    R0,??DataTable0_7  ;; 0x40021400
   \   00000056   0x.... 0x....      BL       initgpio
    156          #endif
    157          #if STM32_HAS_GPIOG
    158            initgpio(GPIOG, &config->PGData);
   \   0000005A   0xF114 0x01A8      ADDS     R1,R4,#+168
   \   0000005E   0x....             LDR.N    R0,??DataTable0_8  ;; 0x40021800
   \   00000060   0x.... 0x....      BL       initgpio
    159          #endif
    160          #if STM32_HAS_GPIOH
    161            initgpio(GPIOH, &config->PHData);
   \   00000064   0xF114 0x01C4      ADDS     R1,R4,#+196
   \   00000068   0x....             LDR.N    R0,??DataTable0_9  ;; 0x40021c00
   \   0000006A   0x.... 0x....      BL       initgpio
    162          #endif
    163          #if STM32_HAS_GPIOI
    164            initgpio(GPIOI, &config->PIData);
   \   0000006E   0xF114 0x01E0      ADDS     R1,R4,#+224
   \   00000072   0x....             LDR.N    R0,??DataTable0_10  ;; 0x40022000
   \   00000074   0x.... 0x....      BL       initgpio
    165          #endif
    166          }
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    167          
    168          /**
    169           * @brief   Pads mode setup.
    170           * @details This function programs a pads group belonging to the same port
    171           *          with the specified mode.
    172           * @note    @p PAL_MODE_UNCONNECTED is implemented as push pull at minimum
    173           *          speed.
    174           *
    175           * @param[in] port      the port identifier
    176           * @param[in] mask      the group mask
    177           * @param[in] mode      the mode
    178           *
    179           * @notapi
    180           */
    181          #if 1

   \                                 In section .text, align 2, keep-with-next
    182          void _pal_lld_setgroupmode(ioportid_t port,
    183                                     ioportmask_t mask,
    184                                     iomode_t mode) {
   \                     _pal_lld_setgroupmode:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    185          
    186            uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
   \   00000004   0xF012 0x0303      ANDS     R3,R2,#0x3
    187            uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
   \   00000008   0xF3C2 0x0480      UBFX     R4,R2,#+2,#+1
    188            uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
   \   0000000C   0xF3C2 0x05C1      UBFX     R5,R2,#+3,#+2
    189            uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
   \   00000010   0xF3C2 0x1641      UBFX     R6,R2,#+5,#+2
    190            uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
   \   00000014   0xF3C2 0x17C3      UBFX     R7,R2,#+7,#+4
   \   00000018   0x9700             STR      R7,[SP, #+0]
    191            uint32_t bit     = 0;
   \   0000001A   0x2700             MOVS     R7,#+0
    192            while (TRUE) {
    193              if ((mask & 1) != 0) {
   \                     ??_pal_lld_setgroupmode_0:
   \   0000001C   0xEA5F 0x7CC1      LSLS     R12,R1,#+31
   \   00000020   0xD557             BPL.N    ??_pal_lld_setgroupmode_1
    194                uint32_t altrmask, m1, m2, m4;
    195          
    196                altrmask = altr << ((bit & 7) * 4);
   \   00000022   0xF8DD 0xA000      LDR      R10,[SP, #+0]
   \   00000026   0xF017 0x0B07      ANDS     R11,R7,#0x7
   \   0000002A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000002E   0xEA5F 0x0B8B      LSLS     R11,R11,#+2
   \   00000032   0xFA1A 0xFA0B      LSLS     R10,R10,R11
   \   00000036   0x46D4             MOV      R12,R10
    197                m4 = 15 << ((bit & 7) * 4);
   \   00000038   0xF05F 0x0A0F      MOVS     R10,#+15
   \   0000003C   0xF017 0x0B07      ANDS     R11,R7,#0x7
   \   00000040   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000044   0xEA5F 0x0B8B      LSLS     R11,R11,#+2
   \   00000048   0xFA1A 0xFA0B      LSLS     R10,R10,R11
   \   0000004C   0x46D1             MOV      R9,R10
    198                if (bit < 8)
   \   0000004E   0x2F08             CMP      R7,#+8
   \   00000050   0xD208             BCS.N    ??_pal_lld_setgroupmode_2
    199                  port->AFRL = (port->AFRL & ~m4) | altrmask;
   \   00000052   0xF8D0 0xA020      LDR      R10,[R0, #+32]
   \   00000056   0xEA3A 0x0A09      BICS     R10,R10,R9
   \   0000005A   0xEA5C 0x0A0A      ORRS     R10,R12,R10
   \   0000005E   0xF8C0 0xA020      STR      R10,[R0, #+32]
   \   00000062   0xE007             B.N      ??_pal_lld_setgroupmode_3
    200                else
    201                  port->AFRH = (port->AFRH & ~m4) | altrmask;
   \                     ??_pal_lld_setgroupmode_2:
   \   00000064   0xF8D0 0xA024      LDR      R10,[R0, #+36]
   \   00000068   0xEA3A 0x0A09      BICS     R10,R10,R9
   \   0000006C   0xEA5C 0x0A0A      ORRS     R10,R12,R10
   \   00000070   0xF8C0 0xA024      STR      R10,[R0, #+36]
    202                m1 = 1 << bit;
   \                     ??_pal_lld_setgroupmode_3:
   \   00000074   0xF05F 0x0A01      MOVS     R10,#+1
   \   00000078   0xFA1A 0xFA07      LSLS     R10,R10,R7
   \   0000007C   0x46D6             MOV      LR,R10
    203                port->OTYPER  = (port->OTYPER & ~m1) | otyper;
   \   0000007E   0xF8D0 0xA004      LDR      R10,[R0, #+4]
   \   00000082   0xEA3A 0x0A0E      BICS     R10,R10,LR
   \   00000086   0xEA54 0x0A0A      ORRS     R10,R4,R10
   \   0000008A   0xF8C0 0xA004      STR      R10,[R0, #+4]
    204                m2 = 3 << (bit * 2);
   \   0000008E   0xF05F 0x0A03      MOVS     R10,#+3
   \   00000092   0x46BB             MOV      R11,R7
   \   00000094   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000098   0xEA5F 0x0B4B      LSLS     R11,R11,#+1
   \   0000009C   0xFA1A 0xFA0B      LSLS     R10,R10,R11
   \   000000A0   0x46D0             MOV      R8,R10
    205                port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
   \   000000A2   0xF8D0 0xA008      LDR      R10,[R0, #+8]
   \   000000A6   0xEA3A 0x0A08      BICS     R10,R10,R8
   \   000000AA   0xEA55 0x0A0A      ORRS     R10,R5,R10
   \   000000AE   0xF8C0 0xA008      STR      R10,[R0, #+8]
    206                port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
   \   000000B2   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
   \   000000B6   0xEA3A 0x0A08      BICS     R10,R10,R8
   \   000000BA   0xEA56 0x0A0A      ORRS     R10,R6,R10
   \   000000BE   0xF8C0 0xA00C      STR      R10,[R0, #+12]
    207                port->MODER   = (port->MODER & ~m2) | moder;
   \   000000C2   0xF8D0 0xA000      LDR      R10,[R0, #+0]
   \   000000C6   0xEA3A 0x0808      BICS     R8,R10,R8
   \   000000CA   0xEA53 0x0808      ORRS     R8,R3,R8
   \   000000CE   0xF8C0 0x8000      STR      R8,[R0, #+0]
    208              }
    209              mask >>= 1;
   \                     ??_pal_lld_setgroupmode_1:
   \   000000D2   0x0849             LSRS     R1,R1,#+1
    210              if (!mask)
   \   000000D4   0x2900             CMP      R1,#+0
   \   000000D6   0xD005             BEQ.N    ??_pal_lld_setgroupmode_4
    211                return;
    212              otyper <<= 1;
   \                     ??_pal_lld_setgroupmode_5:
   \   000000D8   0x0064             LSLS     R4,R4,#+1
    213              ospeedr <<= 2;
   \   000000DA   0x00AD             LSLS     R5,R5,#+2
    214              pupdr <<= 2;
   \   000000DC   0x00B6             LSLS     R6,R6,#+2
    215              moder <<= 2;
   \   000000DE   0x009B             LSLS     R3,R3,#+2
    216              bit++;
   \   000000E0   0x1C7F             ADDS     R7,R7,#+1
   \   000000E2   0xE79B             B.N      ??_pal_lld_setgroupmode_0
    217            }
   \                     ??_pal_lld_setgroupmode_4:
   \   000000E4   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    218          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40023850         DC32     0x40023850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_9:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_10:
   \   00000000   0x40022000         DC32     0x40022000
    219          #else
    220          void _pal_lld_setgroupmode(ioportid_t port,
    221                                     ioportmask_t mask,
    222                                     iomode_t mode) {
    223            uint32_t afrm, moderm, pupdrm, otyperm, ospeedrm;
    224            uint32_t m1 = (uint32_t)mask;
    225            uint32_t m2 = 0;
    226            uint32_t m4l = 0;
    227            uint32_t m4h = 0;
    228            uint32_t bit = 0;
    229            do {
    230              if ((mask & 1) != 0) {
    231                m2 |= 3 << bit;
    232                if (bit < 16)
    233                  m4l |= 15 << ((bit & 14) * 2);
    234                else
    235                  m4h |= 15 << ((bit & 14) * 2);
    236              }
    237              bit += 2;
    238              mask >>= 1;
    239            } while (mask);
    240          
    241            afrm = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) * 0x1111;
    242            port->AFRL = (port->AFRL & ~m4l) | (afrm & m4l);
    243            port->AFRH = (port->AFRH & ~m4h) | (afrm & m4h);
    244          
    245            ospeedrm = ((mode & PAL_STM32_OSPEED_MASK) >> 3) * 0x5555;
    246            port->OSPEEDR = (port->OSPEEDR & ~m2) | (ospeedrm & m2);
    247          
    248            otyperm = ((mode & PAL_STM32_OTYPE_MASK) >> 2) * 0xffff;
    249            port->OTYPER = (port->OTYPER & ~m1) | (otyperm & m1);
    250          
    251            pupdrm = ((mode & PAL_STM32_PUDR_MASK) >> 5) * 0x5555;
    252            port->PUPDR = (port->PUPDR & ~m2) | (pupdrm & m2);
    253          
    254            moderm = ((mode & PAL_STM32_MODE_MASK) >> 0) * 0x5555;
    255            port->MODER = (port->MODER & ~m2) | (moderm & m2);
    256          }
    257          #endif
    258          
    259          #endif /* HAL_USE_PAL */
    260          
    261          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   _pal_lld_init
         8   -> initgpio
      40   _pal_lld_setgroupmode
       0   initgpio


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_10
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
       4  ??DataTable0_9
     122  _pal_lld_init
     232  _pal_lld_setgroupmode
      30  initgpio

 
 428 bytes in section .text
 
 428 bytes of CODE memory

Errors: none
Warnings: none
