###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:09:30 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\controllers\core #
#                       \interpolation.cpp                                    #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\controllers\core #
#                       \interpolation.cpp -lCN F:\stuff\rusefi_sourceforge\f #
#                       irmware\iar\Debug\List\ -lA                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj #
#                       \ --no_cse --no_unroll --no_inline --no_code_motion   #
#                       --no_tbaa --no_clustering --no_scheduling --debug     #
#                       --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp     #
#                       --dlib_config "C:\Program Files (x86)\IAR             #
#                       Systems\Embedded Workbench                            #
#                       6.5\arm\INC\c\DLib_Config_Normal.h"                   #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\     #
#                       -On --eec++                                           #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\i #
#                       nterpolation.lst                                      #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\in #
#                       terpolation.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\controllers\core\interpolation.cpp
      1          /**
      2           * @file    interpolation.cpp
      3           * @brief	Linear interpolation algorithms
      4           *
      5           * @date Oct 17, 2013
      6           * @author Andrey Belomutskiy, (c) 2012-2015
      7           * @author Dmitry Sidin, (c) 2015
      8           */
      9          
     10          #if DEBUG_FUEL
     11          #include <stdio.h>
     12          #endif
     13          
     14          #include <math.h>
     15          
     16          #include "main.h"
     17          #include "efilib2.h"
     18          #include "interpolation.h"
     19          

   \                                 In section .data, align 4
     20          int needInterpolationLogging = true;
   \                     needInterpolationLogging:
   \   00000000   0x00000001         DC32 1
     21          
     22          #define BINARY_PERF true
     23          

   \                                 In section .bss, align 4
     24          Logging * logger;
   \                     logger:
   \   00000000                      DS8 4
     25          
     26          #if BINARY_PERF
     27          
     28          #define COUNT 10000
     29          

   \                                 In section .data, align 4
     30          float array16[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
   \                     array16:
   \   00000000   0x3F800000         DC32 3F800000H, 40000000H, 40400000H, 40800000H, 40A00000H, 40C00000H
   \              0x40000000   
   \              0x40400000   
   \              0x40800000   
   \              0x40A00000   
   \              0x40C00000   
   \   00000018   0x40E00000         DC32 40E00000H, 41000000H, 41100000H, 41200000H, 41300000H, 41400000H
   \              0x41000000   
   \              0x41100000   
   \              0x41200000   
   \              0x41300000   
   \              0x41400000   
   \   00000030   0x41500000         DC32 41500000H, 41600000H, 41700000H, 41800000H
   \              0x41600000   
   \              0x41700000   
   \              0x41800000   
     31          

   \                                 In section .text, align 2, keep-with-next
     32          static void testBinary(void) {
   \                     _Z10testBinaryv:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
     33          	const int size16 = 16;
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x9000             STR      R0,[SP, #+0]
     34          
     35          	uint32_t totalOld = 0;
   \   00000008   0x2400             MOVS     R4,#+0
     36          	uint32_t totalNew = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
     37          
     38          	for (int v = 0; v <= 16; v++) {
   \   0000000C   0x2600             MOVS     R6,#+0
   \                     ??testBinary_0:
   \   0000000E   0x2E11             CMP      R6,#+17
   \   00000010   0xDA56             BGE.N    ??testBinary_1
     39          		uint32_t timeOld;
     40          		{
     41          			uint32_t start = GET_TIMESTAMP();
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0xe0001004
   \   00000016   0xF8D0 0x9000      LDR      R9,[R0, #+0]
     42          			int temp = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
     43          			for (int i = 0; i < COUNT; i++) {
   \   0000001C   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??testBinary_2:
   \   00000020   0xF242 0x7110      MOVW     R1,#+10000
   \   00000024   0x458A             CMP      R10,R1
   \   00000026   0xDA0E             BGE.N    ??testBinary_3
     44          				temp += findIndex(array16, size16, v);
   \   00000028   0x4680             MOV      R8,R0
   \   0000002A   0xEE00 0x6A10      VMOV     S0,R6
   \   0000002E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000032   0x2110             MOVS     R1,#+16
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000038   0x.... 0x....      BL       _Z9findIndexPKfif
   \   0000003C   0xEB10 0x0008      ADDS     R0,R0,R8
     45          			}
   \   00000040   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000044   0xE7EC             B.N      ??testBinary_2
     46          			timeOld = GET_TIMESTAMP() - start;
   \                     ??testBinary_3:
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0xe0001004
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0xEBB1 0x0109      SUBS     R1,R1,R9
   \   00000050   0x000F             MOVS     R7,R1
     47          		}
     48          		uint32_t timeNew;
     49          		{
     50          			uint32_t start = GET_TIMESTAMP();
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0xe0001004
   \   00000056   0xF8D1 0x9000      LDR      R9,[R1, #+0]
     51          			int temp = 0;
   \   0000005A   0xF05F 0x0A00      MOVS     R10,#+0
     52          			for (int i = 0; i < COUNT; i++) {
   \   0000005E   0xF05F 0x0B00      MOVS     R11,#+0
   \                     ??testBinary_4:
   \   00000062   0xF242 0x7010      MOVW     R0,#+10000
   \   00000066   0x4583             CMP      R11,R0
   \   00000068   0xDA0D             BGE.N    ??testBinary_5
     53          				temp += findIndex2(array16, size16, v);
   \   0000006A   0xEE00 0x6A10      VMOV     S0,R6
   \   0000006E   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000072   0x2110             MOVS     R1,#+16
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000078   0x.... 0x....      BL       _Z10findIndex2PKfjf
   \   0000007C   0xEB10 0x0A0A      ADDS     R10,R0,R10
     54          			}
   \   00000080   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000084   0xE7ED             B.N      ??testBinary_4
     55          			timeNew = GET_TIMESTAMP() - start;
   \                     ??testBinary_5:
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0xe0001004
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00000090   0x4680             MOV      R8,R0
     56          		}
     57          		scheduleMsg(logger, "for v=%d old=%d ticks", v, timeOld);
   \   00000092   0x003B             MOVS     R3,R7
   \   00000094   0x0032             MOVS     R2,R6
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x.... 0x....      BL       scheduleMsg
     58          		scheduleMsg(logger, "for v=%d new=%d ticks", v, timeNew);
   \   000000A4   0x4643             MOV      R3,R8
   \   000000A6   0x0032             MOVS     R2,R6
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable7_5
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x.... 0x....      BL       scheduleMsg
     59          
     60          		totalOld += timeOld;
   \   000000B6   0x193C             ADDS     R4,R7,R4
     61          		totalNew += timeNew;
   \   000000B8   0xEB18 0x0505      ADDS     R5,R8,R5
     62          	}
   \   000000BC   0x1C76             ADDS     R6,R6,#+1
   \   000000BE   0xE7A6             B.N      ??testBinary_0
     63          	scheduleMsg(logger, "totalOld=%d ticks", totalOld);
   \                     ??testBinary_1:
   \   000000C0   0x0022             MOVS     R2,R4
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable7_6
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x.... 0x....      BL       scheduleMsg
     64          	scheduleMsg(logger, "totalNew=%d ticks", totalNew);
   \   000000D0   0x002A             MOVS     R2,R5
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable7_7
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x.... 0x....      BL       scheduleMsg
     65          
     66          }
   \   000000E0   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
     67          
     68          #endif
     69          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp FastInterpolation::subobject FastInterpolation()
   \                     _ZN17FastInterpolationC2Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN17FastInterpolationC1Ev
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
     70          FastInterpolation::FastInterpolation() {
   \                     _ZN17FastInterpolationC1Ev:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     71          	init(0, 0, 1, 1);
   \   00000004   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   00000008   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \   0000000C   0xEDDF 0x....      VLDR.W   S1,??DataTable5  ;; 0x0
   \   00000010   0xED9F 0x....      VLDR.W   S0,??DataTable5  ;; 0x0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       _ZN17FastInterpolation4initEffff
     72          }
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     73          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __vfp FastInterpolation::subobject FastInterpolation(float, float, float, float)
   \                     _ZN17FastInterpolationC2Effff:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN17FastInterpolationC1Effff
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
     74          FastInterpolation::FastInterpolation(float x1, float y1, float x2, float y2) {
   \                     _ZN17FastInterpolationC1Effff:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000010   0xEEB0 0x9A41      VMOV.F32 S18,S2
   \   00000014   0xEEF0 0x9A61      VMOV.F32 S19,S3
     75          	init(x1, y1, x2, y2);
   \   00000018   0xEEF0 0x1A69      VMOV.F32 S3,S19
   \   0000001C   0xEEB0 0x1A49      VMOV.F32 S2,S18
   \   00000020   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   00000024   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN17FastInterpolation4initEffff
     76          }
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xECBD 0x8B04      VPOP     {D8-D9}
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
     77          

   \                                 In section .text, align 2, keep-with-next
     78          void FastInterpolation::init(float x1, float y1, float x2, float y2) {
   \                     _ZN17FastInterpolation4initEffff:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B04      VPUSH    {D8-D9}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000E   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000012   0xEEB0 0x9A41      VMOV.F32 S18,S2
   \   00000016   0xEEF0 0x9A61      VMOV.F32 S19,S3
     79          	if (x1 == x2) {
   \   0000001A   0xEEB4 0x8A49      VCMP.F32 S16,S18
   \   0000001E   0xEEF1 0xFA10      FMSTAT   
   \   00000022   0xD110             BNE.N    ??init_0
     80          		firmwareError("init: Same x1 and x2 in interpolate: %f/%f", x1, x2);
   \   00000024   0xEE19 0x0A10      VMOV     R0,S18
   \   00000028   0x.... 0x....      BL       __aeabi_f2d
   \   0000002C   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000030   0xEE18 0x0A10      VMOV     R0,S16
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x0002             MOVS     R2,R0
   \   0000003A   0x000B             MOVS     R3,R1
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable7_8
   \   00000040   0x.... 0x....      BL       firmwareError
     81          		return;
   \   00000044   0xE00F             B.N      ??init_1
     82          	}
     83          	a = INTERPOLATION_A(x1, y1, x2, y2);
   \                     ??init_0:
   \   00000046   0xEE38 0x0AE9      VSUB.F32 S0,S17,S19
   \   0000004A   0xEE78 0x0A49      VSUB.F32 S1,S16,S18
   \   0000004E   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000052   0xED84 0x0A00      VSTR     S0,[R4, #0]
     84          	b = y1 - a * x1;
   \   00000056   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   0000005A   0xEEF0 0x0A68      VMOV.F32 S1,S17
   \   0000005E   0xEE40 0x0A48      VMLS.F32 S1,S0,S16
   \   00000062   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
     85          }
   \                     ??init_1:
   \   00000066   0xB002             ADD      SP,SP,#+8
   \   00000068   0xECBD 0x8B04      VPOP     {D8-D9}
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
     86          

   \                                 In section .text, align 2, keep-with-next
     87          float FastInterpolation::getValue(float x) {
     88          	return a * x + b;
   \                     _ZN17FastInterpolation8getValueEf:
   \   00000000   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000004   0xEDD0 0x0A01      VLDR     S1,[R0, #+4]
   \   00000008   0xEE41 0x0A00      VMLA.F32 S1,S2,S0
   \   0000000C   0xEEB0 0x0A60      VMOV.F32 S0,S1
   \   00000010   0x4770             BX       LR               ;; return
     89          }
     90          
     91          /** @brief	Linear interpolation by two points
     92           *
     93           * @param	x1 key of the first point
     94           * @param	y1 value of the first point
     95           * @param	x2 key of the second point
     96           * @param	y2 value of the second point
     97           * @param	X key to be interpolated
     98           *
     99           * @note	For example, "interpolate(engineConfiguration.tpsMin, 0, engineConfiguration.tpsMax, 100, adc);"
    100           */

   \                                 In section .text, align 4, keep-with-next
    101          float interpolate(float x1, float y1, float x2, float y2, float x) {
   \                     _Z11interpolatefffff:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B06      VPUSH    {D8-D10}
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0xEEB0 0xAA40      VMOV.F32 S20,S0
   \   0000000C   0xEEB0 0x8A60      VMOV.F32 S16,S1
   \   00000010   0xEEF0 0x8A41      VMOV.F32 S17,S2
   \   00000014   0xEEB0 0x9A61      VMOV.F32 S18,S3
   \   00000018   0xEEF0 0x9A42      VMOV.F32 S19,S4
    102          	// todo: double comparison using EPS
    103          	if (x1 == x2) {
   \   0000001C   0xEEB4 0xAA68      VCMP.F32 S20,S17
   \   00000020   0xEEF1 0xFA10      FMSTAT   
   \   00000024   0xD114             BNE.N    ??interpolate_0
    104          		/**
    105          		 * we could end up here for example while resetting bins while changing engine type
    106          		 */
    107          		warning(OBD_PCM_Processor_Fault, "interpolate: Same x1 and x2 in interpolate: %f/%f", x1, x2);
   \   00000026   0xEE18 0x0A90      VMOV     R0,S17
   \   0000002A   0x.... 0x....      BL       __aeabi_f2d
   \   0000002E   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000032   0xEE1A 0x0A10      VMOV     R0,S20
   \   00000036   0x.... 0x....      BL       __aeabi_f2d
   \   0000003A   0x0002             MOVS     R2,R0
   \   0000003C   0x000B             MOVS     R3,R1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable7_9
   \   00000042   0xF240 0x205E      MOVW     R0,#+606
   \   00000046   0x.... 0x....      BL       warning
    108          		return NAN;
   \   0000004A   0xED9F 0x....      VLDR.W   S0,??DataTable5_1  ;; 0x7fffffff
   \   0000004E   0xE00D             B.N      ??interpolate_1
    109          	}
    110          
    111          	// a*x1 + b = y1
    112          	// a*x2 + b = y2
    113          //	efiAssertVoid(x1 != x2, "no way we can interpolate");
    114          	float a = INTERPOLATION_A(x1, y1, x2, y2);
   \                     ??interpolate_0:
   \   00000050   0xEE38 0x0A49      VSUB.F32 S0,S16,S18
   \   00000054   0xEE7A 0x0A68      VSUB.F32 S1,S20,S17
   \   00000058   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
    115          	float b = y1 - a * x1;
   \   0000005C   0xEEB0 0x1A48      VMOV.F32 S2,S16
   \   00000060   0xEE00 0x1ACA      VMLS.F32 S2,S1,S20
    116          	float result = a * x + b;
   \   00000064   0xEEB0 0x0A41      VMOV.F32 S0,S2
   \   00000068   0xEE00 0x0AA9      VMLA.F32 S0,S1,S19
    117          #if	DEBUG_FUEL
    118          	printf("x1=%f y1=%f x2=%f y2=%f\r\n", x1, y1, x2, y2);
    119          	printf("a=%f b=%f result=%f\r\n", a, b, result);
    120          #endif
    121          	return result;
   \                     ??interpolate_1:
   \   0000006C   0xB002             ADD      SP,SP,#+8
   \   0000006E   0xECBD 0x8B06      VPOP     {D8-D10}
   \   00000072   0xBD01             POP      {R0,PC}          ;; return
    122          }
    123          

   \                                 In section .text, align 2, keep-with-next
    124          int findIndex2(const float array[], unsigned size, float value) {
   \                     _Z10findIndex2PKfjf:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
    125          	efiAssert(!cisnan(value), "NaN in findIndex", 0);
   \   0000000E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000012   0x.... 0x....      BL       __iar_FDtest
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD105             BNE.N    ??findIndex2_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable7_10
   \   0000001E   0x.... 0x....      BL       firmwareError
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE030             B.N      ??findIndex2_1
    126          	efiAssert(size > 1, "NaN in findIndex", 0);
   \                     ??findIndex2_0:
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD205             BCS.N    ??findIndex2_2
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable7_10
   \   0000002E   0x.... 0x....      BL       firmwareError
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE028             B.N      ??findIndex2_1
    127          //	if (size <= 1)
    128          //		return size && *array <= value ? 0 : -1;
    129          
    130          	signed i = 0;
   \                     ??findIndex2_2:
   \   00000036   0x2600             MOVS     R6,#+0
    131          	//unsigned b = 1 << int(log(float(size) - 1) / 0.69314718055994530942);
    132          	unsigned b = size >> 1; // in our case size is always a power of 2
   \   00000038   0x086F             LSRS     R7,R5,#+1
    133          	efiAssert(b + b == size, "Size not power of 2", -1);
   \   0000003A   0x19F8             ADDS     R0,R7,R7
   \   0000003C   0x42A8             CMP      R0,R5
   \   0000003E   0xD006             BEQ.N    ??findIndex2_3
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable7_11
   \   00000044   0x.... 0x....      BL       firmwareError
   \   00000048   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004C   0xE01C             B.N      ??findIndex2_1
    134          	for (; b; b >>= 1) {
   \                     ??findIndex2_3:
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD00D             BEQ.N    ??findIndex2_4
    135          		unsigned j = i | b;
   \   00000052   0xEA57 0x0006      ORRS     R0,R7,R6
    136          		/**
    137          		 * it should be
    138          		 * "if (j < size && array[j] <= value)"
    139          		 * but in our case size is always power of 2 thus size is always more then j
    140          		 */
    141          		// efiAssert(j < size, "size", 0);
    142          		if (array[j] <= value)
   \   00000056   0xEB14 0x0180      ADDS     R1,R4,R0, LSL #+2
   \   0000005A   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   0000005E   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000062   0xEEF1 0xFA10      FMSTAT   
   \   00000066   0xDB00             BLT.N    ??findIndex2_5
    143          			i = j;
   \   00000068   0x0006             MOVS     R6,R0
    144          	}
   \                     ??findIndex2_5:
   \   0000006A   0x087F             LSRS     R7,R7,#+1
   \   0000006C   0xE7EF             B.N      ??findIndex2_3
    145          	return i || *array <= value ? i : -1;
   \                     ??findIndex2_4:
   \   0000006E   0x2E00             CMP      R6,#+0
   \   00000070   0xD106             BNE.N    ??findIndex2_6
   \   00000072   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000076   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   0000007A   0xEEF1 0xFA10      FMSTAT   
   \   0000007E   0xDB00             BLT.N    ??findIndex2_7
   \                     ??findIndex2_6:
   \   00000080   0xE001             B.N      ??findIndex2_8
   \                     ??findIndex2_7:
   \   00000082   0xF05F 0x36FF      MOVS     R6,#-1
   \                     ??findIndex2_8:
   \   00000086   0x0030             MOVS     R0,R6
   \                     ??findIndex2_1:
   \   00000088   0xECBD 0x8B02      VPOP     {D8}
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    146          }
    147          
    148          /** @brief	Binary search
    149           * @returns	the highest index within sorted array such that array[i] is greater than or equal to the parameter
    150           * @note If the parameter is smaller than the first element of the array, -1 is returned.
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          int findIndex(const float array[], int size, float value) {
   \                     _Z9findIndexPKfif:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
    153          	efiAssert(!cisnan(value), "NaN in findIndex", 0);
   \   0000000E   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000012   0x.... 0x....      BL       __iar_FDtest
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD104             BNE.N    ??findIndex_0
   \   0000001A   0x....             LDR.N    R0,??DataTable7_10
   \   0000001C   0x.... 0x....      BL       firmwareError
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE028             B.N      ??findIndex_1
    154          
    155          	if (value < array[0])
   \                     ??findIndex_0:
   \   00000024   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000028   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   0000002C   0xEEF1 0xFA10      FMSTAT   
   \   00000030   0xD502             BPL.N    ??findIndex_2
    156          		return -1;
   \   00000032   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000036   0xE01E             B.N      ??findIndex_1
    157          	int middle;
    158          
    159          	int left = 0;
   \                     ??findIndex_2:
   \   00000038   0x2100             MOVS     R1,#+0
    160          	int right = size;
   \   0000003A   0x002A             MOVS     R2,R5
    161          
    162          	// todo: extract binary search as template method?
    163          	while (true) {
    164          #if 0
    165          		// that's an assertion to make sure we do not loop here
    166          		size--;
    167          		efiAssert(size > 0, "Unexpected state in binary search", 0);
    168          #endif
    169          
    170          		// todo: compare current implementation with
    171          		// http://eigenjoy.com/2011/01/21/worlds-fastest-binary-search/
    172          		// ?
    173          		middle = (left + right) / 2;
   \                     ??findIndex_3:
   \   0000003C   0x1853             ADDS     R3,R2,R1
   \   0000003E   0x2602             MOVS     R6,#+2
   \   00000040   0xFB93 0xF3F6      SDIV     R3,R3,R6
   \   00000044   0x0018             MOVS     R0,R3
    174          
    175          //		print("left=%d middle=%d right=%d: %f\r\n", left, middle, right, array[middle]);
    176          
    177          		if (middle == left)
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD015             BEQ.N    ??findIndex_4
    178          			break;
    179          
    180          		if (value < array[middle]) {
   \                     ??findIndex_5:
   \   0000004A   0xEB14 0x0380      ADDS     R3,R4,R0, LSL #+2
   \   0000004E   0xED93 0x0A00      VLDR     S0,[R3, #0]
   \   00000052   0xEEB4 0x8A40      VCMP.F32 S16,S0
   \   00000056   0xEEF1 0xFA10      FMSTAT   
   \   0000005A   0xD501             BPL.N    ??findIndex_6
    181          			right = middle;
   \   0000005C   0x0002             MOVS     R2,R0
   \   0000005E   0xE7ED             B.N      ??findIndex_3
    182          		} else if (value > array[middle]) {
   \                     ??findIndex_6:
   \   00000060   0xEB14 0x0380      ADDS     R3,R4,R0, LSL #+2
   \   00000064   0xED93 0x0A00      VLDR     S0,[R3, #0]
   \   00000068   0xEEB4 0x0A48      VCMP.F32 S0,S16
   \   0000006C   0xEEF1 0xFA10      FMSTAT   
   \   00000070   0xD501             BPL.N    ??findIndex_7
    183          			left = middle;
   \   00000072   0x0001             MOVS     R1,R0
   \   00000074   0xE7E2             B.N      ??findIndex_3
    184          		} else {
    185          			break;
    186          		}
    187          	}
    188          
    189          	return middle;
   \                     ??findIndex_7:
   \                     ??findIndex_4:
   \                     ??findIndex_1:
   \   00000076   0xECBD 0x8B02      VPOP     {D8}
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    190          }
    191          
    192          /**
    193           * @brief	One-dimensional table lookup with linear interpolation
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          float interpolate2d(float value, float bin[], float values[], int size) {
   \                     _Z13interpolate2dfPfS_i:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000A   0x0004             MOVS     R4,R0
   \   0000000C   0x000E             MOVS     R6,R1
   \   0000000E   0x0017             MOVS     R7,R2
    196          	int index = findIndex(bin, size, value);
   \   00000010   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000014   0x0039             MOVS     R1,R7
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _Z9findIndexPKfif
   \   0000001C   0x0005             MOVS     R5,R0
    197          
    198          	if (index == -1)
   \   0000001E   0xF115 0x0F01      CMN      R5,#+1
   \   00000022   0xD102             BNE.N    ??interpolate2d_0
    199          		return values[0];
   \   00000024   0xED96 0x0A00      VLDR     S0,[R6, #0]
   \   00000028   0xE01C             B.N      ??interpolate2d_1
    200          	if (index == size - 1)
   \                     ??interpolate2d_0:
   \   0000002A   0x1E78             SUBS     R0,R7,#+1
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD105             BNE.N    ??interpolate2d_2
    201          		return values[size - 1];
   \   00000030   0xEB16 0x0087      ADDS     R0,R6,R7, LSL #+2
   \   00000034   0x1F00             SUBS     R0,R0,#+4
   \   00000036   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000003A   0xE013             B.N      ??interpolate2d_1
    202          
    203          	return interpolate(bin[index], values[index], bin[index + 1], values[index + 1], value);
   \                     ??interpolate2d_2:
   \   0000003C   0xEEB0 0x2A48      VMOV.F32 S4,S16
   \   00000040   0xEB16 0x0085      ADDS     R0,R6,R5, LSL #+2
   \   00000044   0xEDD0 0x1A01      VLDR     S3,[R0, #+4]
   \   00000048   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000004C   0xED90 0x1A01      VLDR     S2,[R0, #+4]
   \   00000050   0xEB16 0x0085      ADDS     R0,R6,R5, LSL #+2
   \   00000054   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000058   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000005C   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000060   0x.... 0x....      BL       _Z11interpolatefffff
   \                     ??interpolate2d_1:
   \   00000064   0xECBD 0x8B02      VPOP     {D8}
   \   00000068   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    204          }
    205          
    206          /**
    207           * @brief	Two-dimensional table lookup with linear interpolation
    208           */

   \                                 In section .text, align 4, keep-with-next
    209          float interpolate3d(float x, float xBin[], int xBinSize, float y, float yBin[], int yBinSize, float* map[]) {
   \                     _Z13interpolate3dfPfifS_iPS_:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xED2D 0x8B0C      VPUSH    {D8-D13}
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000E   0x4680             MOV      R8,R0
   \   00000010   0x000C             MOVS     R4,R1
   \   00000012   0xEEF0 0x8A60      VMOV.F32 S17,S1
   \   00000016   0x0015             MOVS     R5,R2
   \   00000018   0x001E             MOVS     R6,R3
   \   0000001A   0x9F18             LDR      R7,[SP, #+96]
    210          	if (cisnan(x)) {
   \   0000001C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000020   0x.... 0x....      BL       __iar_FDtest
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD10D             BNE.N    ??interpolate3d_0
    211          		warning(OBD_PCM_Processor_Fault, "%f: x is NaN in interpolate3d", x);
   \   00000028   0xEE18 0x0A10      VMOV     R0,S16
   \   0000002C   0x.... 0x....      BL       __aeabi_f2d
   \   00000030   0x0002             MOVS     R2,R0
   \   00000032   0x000B             MOVS     R3,R1
   \   00000034   0x....             LDR.N    R1,??DataTable7_12
   \   00000036   0xF240 0x205E      MOVW     R0,#+606
   \   0000003A   0x.... 0x....      BL       warning
    212          		return NAN;
   \   0000003E   0xED9F 0x....      VLDR.W   S0,??DataTable7  ;; 0x7fffffff
   \   00000042   0xE0DC             B.N      ??interpolate3d_1
    213          	}
    214          	if (cisnan(y)) {
   \                     ??interpolate3d_0:
   \   00000044   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000048   0x.... 0x....      BL       __iar_FDtest
   \   0000004C   0x2802             CMP      R0,#+2
   \   0000004E   0xD10D             BNE.N    ??interpolate3d_2
    215          		warning(OBD_PCM_Processor_Fault, "%f: y is NaN in interpolate3d", y);
   \   00000050   0xEE18 0x0A90      VMOV     R0,S17
   \   00000054   0x.... 0x....      BL       __aeabi_f2d
   \   00000058   0x0002             MOVS     R2,R0
   \   0000005A   0x000B             MOVS     R3,R1
   \   0000005C   0x....             LDR.N    R1,??DataTable7_13
   \   0000005E   0xF240 0x205E      MOVW     R0,#+606
   \   00000062   0x.... 0x....      BL       warning
    216          		return NAN;
   \   00000066   0xED9F 0x....      VLDR.W   S0,??DataTable7  ;; 0x7fffffff
   \   0000006A   0xE0C8             B.N      ??interpolate3d_1
    217          	}
    218          
    219          	int xIndex = findIndex(xBin, xBinSize, x);
   \                     ??interpolate3d_2:
   \   0000006C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x.... 0x....      BL       _Z9findIndexPKfif
   \   00000078   0x4682             MOV      R10,R0
    220          #if	DEBUG_INTERPOLATION
    221          	if (needInterpolationLogging)
    222          		printf("X index=%d\r\n", xIndex);
    223          #endif
    224          	int yIndex = findIndex(yBin, yBinSize, y);
   \   0000007A   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   0000007E   0x0031             MOVS     R1,R6
   \   00000080   0x0028             MOVS     R0,R5
   \   00000082   0x.... 0x....      BL       _Z9findIndexPKfif
   \   00000086   0x4681             MOV      R9,R0
    225          	if (xIndex < 0 && yIndex < 0) {
   \   00000088   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000008C   0xD506             BPL.N    ??interpolate3d_3
   \   0000008E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000092   0xD503             BPL.N    ??interpolate3d_3
    226          #if	DEBUG_INTERPOLATION
    227          		if (needInterpolationLogging)
    228          			printf("X and Y are smaller than smallest cell in table: %d\r\n", xIndex);
    229          #endif
    230          		return map[0][0];
   \   00000094   0x6838             LDR      R0,[R7, #+0]
   \   00000096   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000009A   0xE0B0             B.N      ??interpolate3d_1
    231          	}
    232          
    233          	if (xIndex < 0) {
   \                     ??interpolate3d_3:
   \   0000009C   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A0   0xD527             BPL.N    ??interpolate3d_4
    234          #if	DEBUG_INTERPOLATION
    235          		if (needInterpolationLogging)
    236          			printf("X is smaller than smallest cell in table: %dr\n", xIndex);
    237          #endif
    238          		if (yIndex == yBinSize - 1)
   \   000000A2   0x1E70             SUBS     R0,R6,#+1
   \   000000A4   0x4581             CMP      R9,R0
   \   000000A6   0xD105             BNE.N    ??interpolate3d_5
    239          			return map[0][yIndex];
   \   000000A8   0x6838             LDR      R0,[R7, #+0]
   \   000000AA   0xEB10 0x0089      ADDS     R0,R0,R9, LSL #+2
   \   000000AE   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000B2   0xE0A4             B.N      ??interpolate3d_1
    240          		float keyMin = yBin[yIndex];
   \                     ??interpolate3d_5:
   \   000000B4   0xF855 0x0029      LDR      R0,[R5, R9, LSL #+2]
   \   000000B8   0xEE09 0x0A10      VMOV     S18,R0
    241          		float keyMax = yBin[yIndex + 1];
   \   000000BC   0xEB15 0x0089      ADDS     R0,R5,R9, LSL #+2
   \   000000C0   0xEDD0 0x9A01      VLDR     S19,[R0, #+4]
    242          		float rpmMinValue = map[0][yIndex];
   \   000000C4   0x6838             LDR      R0,[R7, #+0]
   \   000000C6   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \   000000CA   0xEE0A 0x0A10      VMOV     S20,R0
    243          		float rpmMaxValue = map[0][yIndex + 1];
   \   000000CE   0x6838             LDR      R0,[R7, #+0]
   \   000000D0   0xEB10 0x0089      ADDS     R0,R0,R9, LSL #+2
   \   000000D4   0xEDD0 0xAA01      VLDR     S21,[R0, #+4]
    244          
    245          		return interpolate(keyMin, rpmMinValue, keyMax, rpmMaxValue, y);
   \   000000D8   0xEEB0 0x2A68      VMOV.F32 S4,S17
   \   000000DC   0xEEF0 0x1A6A      VMOV.F32 S3,S21
   \   000000E0   0xEEB0 0x1A69      VMOV.F32 S2,S19
   \   000000E4   0xEEF0 0x0A4A      VMOV.F32 S1,S20
   \   000000E8   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   000000EC   0x.... 0x....      BL       _Z11interpolatefffff
   \   000000F0   0xE085             B.N      ??interpolate3d_1
    246          	}
    247          
    248          	if (yIndex < 0) {
   \                     ??interpolate3d_4:
   \   000000F2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F6   0xD504             BPL.N    ??interpolate3d_6
    249          #if	DEBUG_INTERPOLATION
    250          		if (needInterpolationLogging)
    251          			printf("Y is smaller than smallest cell in table: %d\r\n", yIndex);
    252          #endif
    253          		// no interpolation should be fine here.
    254          		return map[xIndex][0];
   \   000000F8   0xF857 0x002A      LDR      R0,[R7, R10, LSL #+2]
   \   000000FC   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000100   0xE07D             B.N      ??interpolate3d_1
    255          	}
    256          
    257          	if (xIndex == xBinSize - 1 && yIndex == yBinSize - 1) {
   \                     ??interpolate3d_6:
   \   00000102   0x1E60             SUBS     R0,R4,#+1
   \   00000104   0x4582             CMP      R10,R0
   \   00000106   0xD10C             BNE.N    ??interpolate3d_7
   \   00000108   0x1E70             SUBS     R0,R6,#+1
   \   0000010A   0x4581             CMP      R9,R0
   \   0000010C   0xD109             BNE.N    ??interpolate3d_7
    258          #if	DEBUG_INTERPOLATION
    259          		if (needInterpolationLogging)
    260          			printf("X and Y are larger than largest cell in table: %d %d\r\n", xIndex, yIndex);
    261          #endif
    262          		return map[xBinSize - 1][yBinSize - 1];
   \   0000010E   0xEB17 0x0084      ADDS     R0,R7,R4, LSL #+2
   \   00000112   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   00000116   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   0000011A   0x1F00             SUBS     R0,R0,#+4
   \   0000011C   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000120   0xE06D             B.N      ??interpolate3d_1
    263          	}
    264          
    265          	if (xIndex == xBinSize - 1) {
   \                     ??interpolate3d_7:
   \   00000122   0x1E60             SUBS     R0,R4,#+1
   \   00000124   0x4582             CMP      R10,R0
   \   00000126   0xD108             BNE.N    ??interpolate3d_8
    266          #if	DEBUG_INTERPOLATION
    267          		if (needInterpolationLogging)
    268          			printf("TODO BETTER LOGGING x overflow %d\r\n", yIndex);
    269          #endif
    270          		// todo: implement better handling - y interpolation
    271          		return map[xBinSize - 1][yIndex];
   \   00000128   0xEB17 0x0084      ADDS     R0,R7,R4, LSL #+2
   \   0000012C   0xF850 0x0C04      LDR      R0,[R0, #-4]
   \   00000130   0xEB10 0x0089      ADDS     R0,R0,R9, LSL #+2
   \   00000134   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000138   0xE061             B.N      ??interpolate3d_1
    272          	}
    273          
    274          	if (yIndex == yBinSize - 1) {
   \                     ??interpolate3d_8:
   \   0000013A   0x1E70             SUBS     R0,R6,#+1
   \   0000013C   0x4581             CMP      R9,R0
   \   0000013E   0xD107             BNE.N    ??interpolate3d_9
    275          #if	DEBUG_INTERPOLATION
    276          		if (needInterpolationLogging)
    277          			printf("Y is larger than largest cell in table: %d\r\n", yIndex);
    278          #endif
    279          		// todo: implement better handling - x interpolation
    280          		return map[xIndex][yBinSize - 1];
   \   00000140   0xF857 0x002A      LDR      R0,[R7, R10, LSL #+2]
   \   00000144   0xEB10 0x0086      ADDS     R0,R0,R6, LSL #+2
   \   00000148   0x1F00             SUBS     R0,R0,#+4
   \   0000014A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000014E   0xE056             B.N      ??interpolate3d_1
    281          	}
    282          
    283          	/*
    284          	 * first we find the interpolated value for this RPM
    285          	 */
    286          	int rpmMaxIndex = xIndex + 1;
   \                     ??interpolate3d_9:
   \   00000150   0xF11A 0x0001      ADDS     R0,R10,#+1
   \   00000154   0x9000             STR      R0,[SP, #+0]
    287          
    288          	float xMin = xBin[xIndex];
   \   00000156   0xF858 0x002A      LDR      R0,[R8, R10, LSL #+2]
   \   0000015A   0xEE09 0x0A10      VMOV     S18,R0
    289          	float xMax = xBin[xIndex + 1];
   \   0000015E   0xEB18 0x008A      ADDS     R0,R8,R10, LSL #+2
   \   00000162   0xEDD0 0x9A01      VLDR     S19,[R0, #+4]
    290          	float rpmMinKeyMinValue = map[xIndex][yIndex];
   \   00000166   0xF857 0x002A      LDR      R0,[R7, R10, LSL #+2]
   \   0000016A   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \   0000016E   0xEE0D 0x0A90      VMOV     S27,R0
    291          	float rpmMaxKeyMinValue = map[xIndex + 1][yIndex];
   \   00000172   0xEB17 0x008A      ADDS     R0,R7,R10, LSL #+2
   \   00000176   0x6840             LDR      R0,[R0, #+4]
   \   00000178   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \   0000017C   0xEE0A 0x0A10      VMOV     S20,R0
    292          
    293          	float keyMinValue = interpolate(xMin, rpmMinKeyMinValue, xMax, rpmMaxKeyMinValue, x);
   \   00000180   0xEEB0 0x2A48      VMOV.F32 S4,S16
   \   00000184   0xEEF0 0x1A4A      VMOV.F32 S3,S20
   \   00000188   0xEEB0 0x1A69      VMOV.F32 S2,S19
   \   0000018C   0xEEF0 0x0A6D      VMOV.F32 S1,S27
   \   00000190   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   00000194   0x.... 0x....      BL       _Z11interpolatefffff
   \   00000198   0xEEF0 0xAA40      VMOV.F32 S21,S0
    294          
    295          #if	DEBUG_INTERPOLATION
    296          	if (needInterpolationLogging) {
    297          		printf("X=%f:\r\nrange %f - %f\r\n", x, xMin, xMax);
    298          		printf("X interpolation range %f   %f result %f\r\n", rpmMinKeyMinValue, rpmMaxKeyMinValue, keyMinValue);
    299          	}
    300          #endif
    301          
    302          	int keyMaxIndex = yIndex + 1;
   \   0000019C   0xF119 0x0B01      ADDS     R11,R9,#+1
    303          	float keyMin = yBin[yIndex];
   \   000001A0   0xF855 0x0029      LDR      R0,[R5, R9, LSL #+2]
   \   000001A4   0xEE0B 0x0A10      VMOV     S22,R0
    304          	float keyMax = yBin[keyMaxIndex];
   \   000001A8   0xF855 0x002B      LDR      R0,[R5, R11, LSL #+2]
   \   000001AC   0xEE0B 0x0A90      VMOV     S23,R0
    305          	float rpmMinKeyMaxValue = map[xIndex][keyMaxIndex];
   \   000001B0   0xF857 0x002A      LDR      R0,[R7, R10, LSL #+2]
   \   000001B4   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   000001B8   0xEE0C 0x0A10      VMOV     S24,R0
    306          	float rpmMaxKeyMaxValue = map[rpmMaxIndex][keyMaxIndex];
   \   000001BC   0x9800             LDR      R0,[SP, #+0]
   \   000001BE   0xF857 0x0020      LDR      R0,[R7, R0, LSL #+2]
   \   000001C2   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   000001C6   0xEE0C 0x0A90      VMOV     S25,R0
    307          
    308          	float keyMaxValue = interpolate(xMin, rpmMinKeyMaxValue, xMax, rpmMaxKeyMaxValue, x);
   \   000001CA   0xEEB0 0x2A48      VMOV.F32 S4,S16
   \   000001CE   0xEEF0 0x1A6C      VMOV.F32 S3,S25
   \   000001D2   0xEEB0 0x1A69      VMOV.F32 S2,S19
   \   000001D6   0xEEF0 0x0A4C      VMOV.F32 S1,S24
   \   000001DA   0xEEB0 0x0A49      VMOV.F32 S0,S18
   \   000001DE   0x.... 0x....      BL       _Z11interpolatefffff
   \   000001E2   0xEEB0 0xDA40      VMOV.F32 S26,S0
    309          
    310          #if	DEBUG_INTERPOLATION
    311          	if (needInterpolationLogging) {
    312          		printf("key=%f:\r\nrange %f - %f\r\n", y, keyMin, keyMax);
    313          		printf("key interpolation range %f   %f result %f\r\n", rpmMinKeyMaxValue, rpmMaxKeyMaxValue, keyMaxValue);
    314          	}
    315          #endif
    316          
    317          	float result = interpolate(keyMin, keyMinValue, keyMax, keyMaxValue, y);
   \   000001E6   0xEEB0 0x2A68      VMOV.F32 S4,S17
   \   000001EA   0xEEF0 0x1A4D      VMOV.F32 S3,S26
   \   000001EE   0xEEB0 0x1A6B      VMOV.F32 S2,S23
   \   000001F2   0xEEF0 0x0A6A      VMOV.F32 S1,S21
   \   000001F6   0xEEB0 0x0A4B      VMOV.F32 S0,S22
   \   000001FA   0x.... 0x....      BL       _Z11interpolatefffff
    318          	return result;
   \                     ??interpolate3d_1:
   \   000001FE   0xB002             ADD      SP,SP,#+8
   \   00000200   0xECBD 0x8B0C      VPOP     {D8-D13}
   \   00000204   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    319          }
    320          

   \                                 In section .text, align 2, keep-with-next
    321          void setTableValue(float bins[], float values[], int size, float key, float value) {
   \                     _Z13setTableValuePfS_iff:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0xEEF0 0x8A40      VMOV.F32 S17,S0
   \   00000010   0xEEB0 0x8A60      VMOV.F32 S16,S1
    322          	int index = findIndex(bins, size, key);
   \   00000014   0xEEB0 0x0A68      VMOV.F32 S0,S17
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       _Z9findIndexPKfif
    323          	if (index == -1)
   \   00000020   0xF110 0x0F01      CMN      R0,#+1
   \   00000024   0xD101             BNE.N    ??setTableValue_0
    324          		index = 0;
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x0008             MOVS     R0,R1
    325          	values[index] = value;
   \                     ??setTableValue_0:
   \   0000002A   0xEB15 0x0180      ADDS     R1,R5,R0, LSL #+2
   \   0000002E   0xED81 0x8A00      VSTR     S16,[R1, #0]
    326          }
   \   00000032   0xECBD 0x8B02      VPOP     {D8}
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    327          

   \                                 In section .text, align 2, keep-with-next
    328          void initInterpolation(Logging *sharedLogger) {
   \                     _Z17initInterpolationP7Logging:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    329          	logger = sharedLogger;
   \   00000004   0x....             LDR.N    R0,??DataTable7_4
   \   00000006   0x6004             STR      R4,[R0, #+0]
    330          #if BINARY_PERF && ! EFI_UNIT_TEST
    331          	addConsoleAction("binarytest", testBinary);
   \   00000008   0x....             LDR.N    R1,??DataTable7_14
   \   0000000A   0x....             LDR.N    R0,??DataTable7_15
   \   0000000C   0x.... 0x....      BL       addConsoleAction
    332          #endif
    333          
    334          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x00000000         DC32     0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     array16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     `?<Constant "for v=%d old=%d ticks">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     logger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     `?<Constant "for v=%d new=%d ticks">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     `?<Constant "totalOld=%d ticks">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     `?<Constant "totalNew=%d ticks">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     `?<Constant "init: Same x1 and x2 ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     `?<Constant "interpolate: Same x1 ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     `?<Constant "NaN in findIndex">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x........         DC32     `?<Constant "Size not power of 2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     `?<Constant "%f: x is NaN in inter...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     `?<Constant "%f: y is NaN in inter...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     _Z10testBinaryv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     `?<Constant "binarytest">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "for v=%d old=%d ticks">`:
   \   00000000   0x66 0x6F          DC8 "for v=%d old=%d ticks"
   \              0x72 0x20    
   \              0x76 0x3D    
   \              0x25 0x64    
   \              0x20 0x6F    
   \              0x6C 0x64    
   \              0x3D 0x25    
   \              0x64 0x20    
   \              0x74 0x69    
   \              0x63 0x6B    
   \              0x73 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "for v=%d new=%d ticks">`:
   \   00000000   0x66 0x6F          DC8 "for v=%d new=%d ticks"
   \              0x72 0x20    
   \              0x76 0x3D    
   \              0x25 0x64    
   \              0x20 0x6E    
   \              0x65 0x77    
   \              0x3D 0x25    
   \              0x64 0x20    
   \              0x74 0x69    
   \              0x63 0x6B    
   \              0x73 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "totalOld=%d ticks">`:
   \   00000000   0x74 0x6F          DC8 "totalOld=%d ticks"
   \              0x74 0x61    
   \              0x6C 0x4F    
   \              0x6C 0x64    
   \              0x3D 0x25    
   \              0x64 0x20    
   \              0x74 0x69    
   \              0x63 0x6B    
   \              0x73 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "totalNew=%d ticks">`:
   \   00000000   0x74 0x6F          DC8 "totalNew=%d ticks"
   \              0x74 0x61    
   \              0x6C 0x4E    
   \              0x65 0x77    
   \              0x3D 0x25    
   \              0x64 0x20    
   \              0x74 0x69    
   \              0x63 0x6B    
   \              0x73 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "interpolate: Same x1 ...">`:
   \   00000000   0x69 0x6E          DC8 "interpolate: Same x1 and x2 in interpolate: %f/%f"
   \              0x74 0x65    
   \              0x72 0x70    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x53    
   \              0x61 0x6D    
   \              0x65 0x20    
   \              0x78 0x31    
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x78    
   \              0x32 0x20    
   \              0x69 0x6E    
   \              0x20 0x69    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x70 0x6F    
   \              0x6C 0x61    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x25 0x66    
   \              0x2F 0x25    
   \              0x66 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "NaN in findIndex">`:
   \   00000000   0x4E 0x61          DC8 "NaN in findIndex"
   \              0x4E 0x20    
   \              0x69 0x6E    
   \              0x20 0x66    
   \              0x69 0x6E    
   \              0x64 0x49    
   \              0x6E 0x64    
   \              0x65 0x78    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Size not power of 2">`:
   \   00000000   0x53 0x69          DC8 "Size not power of 2"
   \              0x7A 0x65    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x70    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x32 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "%f: x is NaN in inter...">`:
   \   00000000   0x25 0x66          DC8 "%f: x is NaN in interpolate3d"
   \              0x3A 0x20    
   \              0x78 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x61 0x4E    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x70    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x65 0x33    
   \              0x64 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%f: y is NaN in inter...">`:
   \   00000000   0x25 0x66          DC8 "%f: y is NaN in interpolate3d"
   \              0x3A 0x20    
   \              0x79 0x20    
   \              0x69 0x73    
   \              0x20 0x4E    
   \              0x61 0x4E    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x70    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x65 0x33    
   \              0x64 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "binarytest">`:
   \   00000000   0x62 0x69          DC8 "binarytest"
   \              0x6E 0x61    
   \              0x72 0x79    
   \              0x74 0x65    
   \              0x73 0x74    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "init: Same x1 and x2 ...">`:
   \   00000000   0x69 0x6E          DC8 "init: Same x1 and x2 in interpolate: %f/%f"
   \              0x69 0x74    
   \              0x3A 0x20    
   \              0x53 0x61    
   \              0x6D 0x65    
   \              0x20 0x78    
   \              0x31 0x20    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x78 0x32    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x70    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x65 0x3A    
   \              0x20 0x25    
   \              0x66 0x2F    
   \              0x25 0x66    
   \              0x00         
   \   0000002B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FastInterpolation::FastInterpolation()
         8   -> FastInterpolation::init(float, float, float, float)
      24   FastInterpolation::FastInterpolation(float, float, float, float)
        24   -> FastInterpolation::init(float, float, float, float)
       0   FastInterpolation::getValue(float)
      32   FastInterpolation::init(float, float, float, float)
        32   -> __aeabi_f2d
        32   -> firmwareError
       8   FastInterpolation::subobject FastInterpolation()
         8   -> FastInterpolation::FastInterpolation()
       8   FastInterpolation::subobject FastInterpolation(float, float, float, float)
         8   -> FastInterpolation::FastInterpolation(float, float, float, float)
      24   findIndex(float const *, int, float)
        24   -> __iar_FDtest
        24   -> firmwareError
      32   findIndex2(float const *, unsigned int, float)
        32   -> __iar_FDtest
        32   -> firmwareError
       8   initInterpolation(Logging *)
         8   -> addConsoleAction
      40   interpolate(float, float, float, float, float)
        40   -> __aeabi_f2d
        40   -> warning
      32   interpolate2d(float, float *, float *, int)
        32   -> findIndex(float const *, int, float)
        32   -> interpolate(float, float, float, float, float)
      96   interpolate3d(float, float *, int, float, float *, int, float **)
        96   -> __aeabi_f2d
        96   -> __iar_FDtest
        96   -> findIndex(float const *, int, float)
        96   -> interpolate(float, float, float, float, float)
        96   -> warning
      24   setTableValue(float *, float *, int, float, float)
        24   -> findIndex(float const *, int, float)
      40   testBinary()
        40   -> findIndex(float const *, int, float)
        40   -> findIndex2(float const *, unsigned int, float)
        40   -> scheduleMsg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "%f: x is NaN in inter...">
      32  ?<Constant "%f: y is NaN in inter...">
      20  ?<Constant "NaN in findIndex">
      20  ?<Constant "Size not power of 2">
      12  ?<Constant "binarytest">
      24  ?<Constant "for v=%d new=%d ticks">
      24  ?<Constant "for v=%d old=%d ticks">
      44  ?<Constant "init: Same x1 and x2 ...">
      52  ?<Constant "interpolate: Same x1 ...">
      20  ?<Constant "totalNew=%d ticks">
      20  ?<Constant "totalOld=%d ticks">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      30  FastInterpolation::FastInterpolation()
      54  FastInterpolation::FastInterpolation(float, float, float, float)
      18  FastInterpolation::getValue(float)
     110  FastInterpolation::init(float, float, float, float)
      12  FastInterpolation::subobject FastInterpolation()
      12  FastInterpolation::subobject FastInterpolation(float, float, float, float)
      64  array16
     124  findIndex(float const *, int, float)
     142  findIndex2(float const *, unsigned int, float)
      18  initInterpolation(Logging *)
     116  interpolate(float, float, float, float, float)
     106  interpolate2d(float, float *, float *, int)
     520  interpolate3d(float, float *, int, float, float *, int, float **)
       4  logger
       4  needInterpolationLogging
      56  setTableValue(float *, float *, int, float, float)
     228  testBinary()

 
     4 bytes in section .bss
    68 bytes in section .data
   300 bytes in section .rodata
 1 618 bytes in section .text
 
 1 618 bytes of CODE  memory
   300 bytes of CONST memory
    72 bytes of DATA  memory

Errors: none
Warnings: none
