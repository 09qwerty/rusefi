###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      30/Jun/2015  23:10:06 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode        =  thumb                                                 #
#    Endian          =  little                                                #
#    Source file     =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\OTGv1\usb_lld.c                        #
#    Command line    =  F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\p #
#                       latforms\STM32\OTGv1\usb_lld.c -lCN                   #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\  #
#                       -lA F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Li #
#                       st\ -o F:\stuff\rusefi_sourceforge\firmware\iar\Debug #
#                       \Obj\ --no_cse --no_unroll --no_inline                #
#                       --no_code_motion --no_tbaa --no_clustering            #
#                       --no_scheduling --debug --endian=little               #
#                       --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config       #
#                       "C:\Program Files (x86)\IAR Systems\Embedded          #
#                       Workbench 6.5\arm\INC\c\DLib_Config_Normal.h"         #
#                       --misrac2004=1.2-1.4,2.3,3.4,4.2,6.5-7,8.2-8.3,9.3,   #
#                       12.3,13.6-13,15.5,17.3,19.17,20.7-20.9,20.11 -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\ -I       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\kernel\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\ports\common\ARMCMx\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\common\ARMCMx\CMSIS\include\ -I               #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\ports\IAR\ARMCMx\ -I F:\stuff\rusefi_sourceforge\fi #
#                       rmware\iar\..\chibios\os\ports\IAR\ARMCMx\STM32F4xx\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\chibio #
#                       s\os\hal\include\ -I F:\stuff\rusefi_sourceforge\firm #
#                       ware\iar\..\chibios\os\hal\platforms\STM32\ -I        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\DMAv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\GPIOv2\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\I2Cv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\SPIv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\TIMv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\RTCv2\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\USARTv1\ -I                     #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32\OTGv1\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\hal\platforms\STM32F4xx\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\o #
#                       s\various\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\chibios\os\various\devices_lib\accel\ -I         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\chibios\b #
#                       oards\ST_STM32F4_DISCOVERY\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\co #
#                       ntrollers\algo\ -I F:\stuff\rusefi_sourceforge\firmwa #
#                       re\iar\..\controllers\core\ -I                        #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\system\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\controllers\sensors\ -I                          #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\controlle #
#                       rs\math\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\controllers\trigger\ -I                            #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\config #
#                       \ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\conf #
#                       ig\engines\ -I F:\stuff\rusefi_sourceforge\firmware\i #
#                       ar\..\config\stm32f4ems\ -I                           #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\console\b #
#                       inary\ -I F:\stuff\rusefi_sourceforge\firmware\iar\.. #
#                       \console_util\ -I F:\stuff\rusefi_sourceforge\firmwar #
#                       e\iar\..\development\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\development\test\ -I                  #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\developme #
#                       nt\hw_layer\ -I F:\stuff\rusefi_sourceforge\firmware\ #
#                       iar\..\hw_layer\algo\ -I F:\stuff\rusefi_sourceforge\ #
#                       firmware\iar\..\hw_layer\lcd\ -I                      #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                       stm32f4\ -I F:\stuff\rusefi_sourceforge\firmware\iar\ #
#                       ..\hw_layer\serial_over_usb\ -I                       #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\hw_layer\ #
#                        -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext\  #
#                       -I F:\stuff\rusefi_sourceforge\firmware\iar\..\ext_al #
#                       go\ -I F:\stuff\rusefi_sourceforge\firmware\iar\..\de #
#                       velopment\ -I F:\stuff\rusefi_sourceforge\firmware\ia #
#                       r\..\development\hw_layer\ -I                         #
#                       F:\stuff\rusefi_sourceforge\firmware\iar\..\util\ -On #
#    MISRA C version =  2004                                                  #
#      Enabled       =  1.2-1.4 2.3 3.4 4.2 6.5 7 8.2 8.3 9.3 12.3 13.6 13.7  #
#                       15.5 17.3 19.17 20.7-20.9 20.11                       #
#      Checked       =  1.4 2.3 4.2 6.5 7 8.2 8.3 9.3 12.3 13.7 15.5          #
#                       20.7-20.9 20.11                                       #
#      Not checked   =  1.1-1.3 1.5-2.2 2.4-4.1 5-6.4 8.1 8.4-9.2 10-12.2     #
#                       12.4-13.6 14-15.4 16-20.6 20.10 20.12 21              #
#    List file       =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\List\u #
#                       sb_lld.lst                                            #
#    Object file     =  F:\stuff\rusefi_sourceforge\firmware\iar\Debug\Obj\us #
#                       b_lld.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\stuff\rusefi_sourceforge\firmware\chibios\os\hal\platforms\STM32\OTGv1\usb_lld.c
      1          /*
      2              ChibiOS/RT - Copyright (C) 2006-2013 Giovanni Di Sirio
      3          
      4              Licensed under the Apache License, Version 2.0 (the "License");
      5              you may not use this file except in compliance with the License.
      6              You may obtain a copy of the License at
      7          
      8                  http://www.apache.org/licenses/LICENSE-2.0
      9          
     10              Unless required by applicable law or agreed to in writing, software
     11              distributed under the License is distributed on an "AS IS" BASIS,
     12              WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13              See the License for the specific language governing permissions and
     14              limitations under the License.
     15          */
     16          
     17          /**
     18           * @file    STM32/OTGv1/usb_lld.c
     19           * @brief   STM32 USB subsystem low level driver source.
     20           *
     21           * @addtogroup USB
     22           * @{
     23           */
     24          
     25          #include <string.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     26          
     27          #include "ch.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct Thread *fifo_remove(ThreadsQueue *)
   \                     fifo_remove:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   \   00000008   0x6051             STR      R1,[R2, #+4]
   \   0000000A   0x4770             BX       LR               ;; return
     28          #include "hal.h"
     29          
     30          #if HAL_USE_USB || defined(__DOXYGEN__)
     31          
     32          /*===========================================================================*/
     33          /* Driver local definitions.                                                 */
     34          /*===========================================================================*/
     35          
     36          #define TRDT_VALUE              5
     37          
     38          #define EP0_MAX_INSIZE          64
     39          #define EP0_MAX_OUTSIZE         64
     40          
     41          /*===========================================================================*/
     42          /* Driver exported variables.                                                */
     43          /*===========================================================================*/
     44          
     45          /** @brief OTG_FS driver identifier.*/
     46          #if STM32_USB_USE_OTG1 || defined(__DOXYGEN__)

   \                                 In section .bss, align 8
     47          USBDriver USBD1;
   \                     USBD1:
   \   00000000                      DS8 1440
     48          #endif
     49          
     50          /** @brief OTG_HS driver identifier.*/
     51          #if STM32_USB_USE_OTG2 || defined(__DOXYGEN__)
     52          USBDriver USBD2;
     53          #endif
     54          
     55          /*===========================================================================*/
     56          /* Driver local variables and types.                                         */
     57          /*===========================================================================*/
     58          
     59          /**
     60           * @brief   EP0 state.
     61           * @note    It is an union because IN and OUT endpoints are never used at the
     62           *          same time for EP0.
     63           */
     64          static union {
     65            /**
     66             * @brief   IN EP0 state.
     67             */
     68            USBInEndpointState in;
     69            /**
     70             * @brief   OUT EP0 state.
     71             */
     72            USBOutEndpointState out;

   \                                 In section .bss, align 4
     73          } ep0_state;
   \                     ep0_state:
   \   00000000                      DS8 20
     74          
     75          /**
     76           * @brief   Buffer for the EP0 setup packets.
     77           */

   \                                 In section .bss, align 4
     78          static uint8_t ep0setup_buffer[8];
   \                     ep0setup_buffer:
   \   00000000                      DS8 8
     79          
     80          /**
     81           * @brief   EP0 initialization structure.
     82           */

   \                                 In section .rodata, align 4
     83          static const USBEndpointConfig ep0config = {
   \                     ep0config:
   \   00000000   0x00000000         DC32 0, _usb_ep0setup, _usb_ep0in, _usb_ep0out
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x0040 0x0040      DC16 64, 64
   \   00000014   0x........         DC32 ep0_state, ep0_state
   \              0x........   
   \   0000001C   0x0001             DC16 1
   \   0000001E   0x00 0x00          DC8 0, 0
   \   00000020   0x........         DC32 ep0setup_buffer
     84            USB_EP_MODE_TYPE_CTRL,
     85            _usb_ep0setup,
     86            _usb_ep0in,
     87            _usb_ep0out,
     88            0x40,
     89            0x40,
     90            &ep0_state.in,
     91            &ep0_state.out,
     92            1,
     93            ep0setup_buffer
     94          };
     95          
     96          #if STM32_USB_USE_OTG1

   \                                 In section .rodata, align 4
     97          static const stm32_otg_params_t fsparams = {
   \                     fsparams:
   \   00000000   0x00000080         DC32 128, 320, 3
   \              0x00000140   
   \              0x00000003   
     98            STM32_USB_OTG1_RX_FIFO_SIZE / 4,
     99            STM32_OTG1_FIFO_MEM_SIZE,
    100            STM32_OTG1_ENDOPOINTS_NUMBER
    101          };
    102          #endif
    103          
    104          #if STM32_USB_USE_OTG2
    105          static const stm32_otg_params_t hsparams = {
    106            STM32_USB_OTG2_RX_FIFO_SIZE / 4,
    107            STM32_OTG2_FIFO_MEM_SIZE,
    108            STM32_OTG2_ENDOPOINTS_NUMBER
    109          };
    110          #endif
    111          
    112          /*===========================================================================*/
    113          /* Driver local functions.                                                   */
    114          /*===========================================================================*/
    115          
    116          /**
    117           * @brief   Wakes up the pump thread.
    118           *
    119           * @param[in] usbp      pointer to the @p USBDriver object
    120           *
    121           * @notapi
    122           */

   \                                 In section .text, align 2, keep-with-next
    123          static void usb_lld_wakeup_pump(USBDriver *usbp) {
   \                     usb_lld_wakeup_pump:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    124          
    125            if (usbp->thd_wait != NULL) {
   \   00000004   0x6E60             LDR      R0,[R4, #+100]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??usb_lld_wakeup_pump_0
    126              chThdResumeI(usbp->thd_wait);
   \   0000000A   0x6E60             LDR      R0,[R4, #+100]
   \   0000000C   0x.... 0x....      BL       chSchReadyI
    127              usbp->thd_wait = NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6660             STR      R0,[R4, #+100]
    128            }
    129          }
   \                     ??usb_lld_wakeup_pump_0:
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    130          

   \                                 In section .text, align 2, keep-with-next
    131          static void otg_core_reset(USBDriver *usbp) {
   \                     otg_core_reset:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    132            stm32_otg_t *otgp = usbp->otg;
   \   00000004   0x6D25             LDR      R5,[R4, #+80]
    133          
    134            halPolledDelay(32);
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0x.... 0x....      BL       halPolledDelay
    135          
    136            /* Core reset and delay of at least 3 PHY cycles.*/
    137            otgp->GRSTCTL = GRSTCTL_CSRST;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x6128             STR      R0,[R5, #+16]
    138            while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
   \                     ??otg_core_reset_0:
   \   00000010   0x6928             LDR      R0,[R5, #+16]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD4FC             BMI.N    ??otg_core_reset_0
    139              ;
    140          
    141            halPolledDelay(12);
   \   00000016   0x200C             MOVS     R0,#+12
   \   00000018   0x.... 0x....      BL       halPolledDelay
    142          
    143            /* Wait AHB idle condition.*/
    144            while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
   \                     ??otg_core_reset_1:
   \   0000001C   0x6928             LDR      R0,[R5, #+16]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD5FC             BPL.N    ??otg_core_reset_1
    145              ;
    146          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    147          

   \                                 In section .text, align 2, keep-with-next
    148          static void otg_disable_ep(USBDriver *usbp) {
   \                     otg_disable_ep:
   \   00000000   0xB410             PUSH     {R4}
    149            stm32_otg_t *otgp = usbp->otg;
   \   00000002   0x6D01             LDR      R1,[R0, #+80]
    150            unsigned i;
    151          
    152            for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x001A             MOVS     R2,R3
   \                     ??otg_disable_ep_0:
   \   00000008   0x6D43             LDR      R3,[R0, #+84]
   \   0000000A   0x689B             LDR      R3,[R3, #+8]
   \   0000000C   0x4293             CMP      R3,R2
   \   0000000E   0xD347             BCC.N    ??otg_disable_ep_1
    153              /* Disable only if enabled because this sentence in the manual:
    154                 "The application must set this bit only if Endpoint Enable is
    155                  already set for this endpoint".*/
    156              if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0) {
   \   00000010   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000014   0xF8D3 0x3900      LDR      R3,[R3, #+2304]
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xD50C             BPL.N    ??otg_disable_ep_2
    157                otgp->ie[i].DIEPCTL = DIEPCTL_EPDIS;
   \   0000001C   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000020   0xF05F 0x4480      MOVS     R4,#+1073741824
   \   00000024   0xF8C3 0x4900      STR      R4,[R3, #+2304]
    158                /* Wait for endpoint disable.*/
    159                while (!(otgp->ie[i].DIEPINT & DIEPINT_EPDISD))
   \                     ??otg_disable_ep_3:
   \   00000028   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   0000002C   0xF8D3 0x3908      LDR      R3,[R3, #+2312]
   \   00000030   0x079B             LSLS     R3,R3,#+30
   \   00000032   0xD405             BMI.N    ??otg_disable_ep_4
   \   00000034   0xE7F8             B.N      ??otg_disable_ep_3
    160                  ;
    161              }
    162              else
    163                otgp->ie[i].DIEPCTL = 0;
   \                     ??otg_disable_ep_2:
   \   00000036   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0xF8C3 0x4900      STR      R4,[R3, #+2304]
    164              otgp->ie[i].DIEPTSIZ = 0;
   \                     ??otg_disable_ep_4:
   \   00000040   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000044   0x2400             MOVS     R4,#+0
   \   00000046   0xF8C3 0x4910      STR      R4,[R3, #+2320]
    165              otgp->ie[i].DIEPINT = 0xFFFFFFFF;
   \   0000004A   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   0000004E   0xF05F 0x34FF      MOVS     R4,#-1
   \   00000052   0xF8C3 0x4908      STR      R4,[R3, #+2312]
    166              /* Disable only if enabled because this sentence in the manual:
    167                 "The application must set this bit only if Endpoint Enable is
    168                  already set for this endpoint".
    169                 Note that the attempt to disable the OUT EP0 is ignored by the
    170                 hardware but the code is simpler this way.*/
    171              if ((otgp->oe[i].DOEPCTL & DOEPCTL_EPENA) != 0) {
   \   00000056   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   0000005A   0xF8D3 0x3B00      LDR      R3,[R3, #+2816]
   \   0000005E   0x2B00             CMP      R3,#+0
   \   00000060   0xD50C             BPL.N    ??otg_disable_ep_5
    172                otgp->oe[i].DOEPCTL = DOEPCTL_EPDIS;
   \   00000062   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000066   0xF05F 0x4480      MOVS     R4,#+1073741824
   \   0000006A   0xF8C3 0x4B00      STR      R4,[R3, #+2816]
    173                /* Wait for endpoint disable.*/
    174                while (!(otgp->oe[i].DOEPINT & DOEPINT_OTEPDIS))
   \                     ??otg_disable_ep_6:
   \   0000006E   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000072   0xF8D3 0x3B08      LDR      R3,[R3, #+2824]
   \   00000076   0x06DB             LSLS     R3,R3,#+27
   \   00000078   0xD405             BMI.N    ??otg_disable_ep_7
   \   0000007A   0xE7F8             B.N      ??otg_disable_ep_6
    175                  ;
    176              }
    177              else
    178                otgp->oe[i].DOEPCTL = 0;
   \                     ??otg_disable_ep_5:
   \   0000007C   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000080   0x2400             MOVS     R4,#+0
   \   00000082   0xF8C3 0x4B00      STR      R4,[R3, #+2816]
    179              otgp->oe[i].DOEPTSIZ = 0;
   \                     ??otg_disable_ep_7:
   \   00000086   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   0000008A   0x2400             MOVS     R4,#+0
   \   0000008C   0xF8C3 0x4B10      STR      R4,[R3, #+2832]
    180              otgp->oe[i].DOEPINT = 0xFFFFFFFF;
   \   00000090   0xEB11 0x1342      ADDS     R3,R1,R2, LSL #+5
   \   00000094   0xF05F 0x34FF      MOVS     R4,#-1
   \   00000098   0xF8C3 0x4B08      STR      R4,[R3, #+2824]
    181            }
   \   0000009C   0x1C52             ADDS     R2,R2,#+1
   \   0000009E   0xE7B3             B.N      ??otg_disable_ep_0
    182            otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
   \                     ??otg_disable_ep_1:
   \   000000A0   0xF05F 0x1301      MOVS     R3,#+65537
   \   000000A4   0xF8C1 0x381C      STR      R3,[R1, #+2076]
    183          }
   \   000000A8   0xBC10             POP      {R4}
   \   000000AA   0x4770             BX       LR               ;; return
    184          

   \                                 In section .text, align 2, keep-with-next
    185          static void otg_rxfifo_flush(USBDriver *usbp) {
   \                     otg_rxfifo_flush:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    186            stm32_otg_t *otgp = usbp->otg;
   \   00000004   0x6D25             LDR      R5,[R4, #+80]
    187          
    188            otgp->GRSTCTL = GRSTCTL_RXFFLSH;
   \   00000006   0x2010             MOVS     R0,#+16
   \   00000008   0x6128             STR      R0,[R5, #+16]
    189            while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
   \                     ??otg_rxfifo_flush_0:
   \   0000000A   0x6928             LDR      R0,[R5, #+16]
   \   0000000C   0x06C0             LSLS     R0,R0,#+27
   \   0000000E   0xD4FC             BMI.N    ??otg_rxfifo_flush_0
    190              ;
    191            /* Wait for 3 PHY Clocks.*/
    192            halPolledDelay(12);
   \   00000010   0x200C             MOVS     R0,#+12
   \   00000012   0x.... 0x....      BL       halPolledDelay
    193          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    194          

   \                                 In section .text, align 2, keep-with-next
    195          static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
   \                     otg_txfifo_flush:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    196            stm32_otg_t *otgp = usbp->otg;
   \   00000006   0x6D26             LDR      R6,[R4, #+80]
    197          
    198            otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
   \   00000008   0x01A8             LSLS     R0,R5,#+6
   \   0000000A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000000E   0x6130             STR      R0,[R6, #+16]
    199            while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
   \                     ??otg_txfifo_flush_0:
   \   00000010   0x6930             LDR      R0,[R6, #+16]
   \   00000012   0x0680             LSLS     R0,R0,#+26
   \   00000014   0xD4FC             BMI.N    ??otg_txfifo_flush_0
    200              ;
    201            /* Wait for 3 PHY Clocks.*/
    202            halPolledDelay(12);
   \   00000016   0x200C             MOVS     R0,#+12
   \   00000018   0x.... 0x....      BL       halPolledDelay
    203          }
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    204          
    205          /**
    206           * @brief   Resets the FIFO RAM memory allocator.
    207           *
    208           * @param[in] usbp      pointer to the @p USBDriver object
    209           *
    210           * @notapi
    211           */

   \                                 In section .text, align 2, keep-with-next
    212          static void otg_ram_reset(USBDriver *usbp) {
    213          
    214            usbp->pmnext = usbp->otgparams->rx_fifo_size;
   \                     otg_ram_reset:
   \   00000000   0x6D41             LDR      R1,[R0, #+84]
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6581             STR      R1,[R0, #+88]
    215          }
   \   00000006   0x4770             BX       LR               ;; return
    216          
    217          /**
    218           * @brief   Allocates a block from the FIFO RAM memory.
    219           *
    220           * @param[in] usbp      pointer to the @p USBDriver object
    221           * @param[in] size      size of the packet buffer to allocate in words
    222           *
    223           * @notapi
    224           */

   \                                 In section .text, align 2, keep-with-next
    225          static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
   \                     otg_ram_alloc:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    226            uint32_t next;
    227          
    228            next = usbp->pmnext;
   \   00000006   0x6DA0             LDR      R0,[R4, #+88]
   \   00000008   0x0006             MOVS     R6,R0
    229            usbp->pmnext += size;
   \   0000000A   0x6DA0             LDR      R0,[R4, #+88]
   \   0000000C   0x1828             ADDS     R0,R5,R0
   \   0000000E   0x65A0             STR      R0,[R4, #+88]
    230            chDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
    231                        "otg_fifo_alloc(), #1", "OTG FIFO memory overflow");
   \   00000010   0x6D60             LDR      R0,[R4, #+84]
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x6DA1             LDR      R1,[R4, #+88]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD203             BCS.N    ??otg_ram_alloc_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000001E   0x.... 0x....      BL       chDbgPanic
    232            return next;
   \                     ??otg_ram_alloc_0:
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    233          }
    234          
    235          /**
    236           * @brief   Pushes a series of words into a FIFO.
    237           *
    238           * @param[in] fifop     pointer to the FIFO register
    239           * @param[in] buf       pointer to the words buffer, not necessarily word
    240           *                      aligned
    241           * @param[in] n         number of words to push
    242           *
    243           * @return              A pointer after the last word pushed.
    244           *
    245           * @notapi
    246           */

   \                                 In section .text, align 2, keep-with-next
    247          static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {
   \                     otg_do_push:
   \   00000000   0x0003             MOVS     R3,R0
   \   00000002   0x0008             MOVS     R0,R1
    248          
    249            while (n > 0) {
   \                     ??otg_do_push_0:
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD004             BEQ.N    ??otg_do_push_1
    250              /* Note, this line relies on the Cortex-M3/M4 ability to perform
    251                 unaligned word accesses and on the LSB-first memory organization.*/
    252              *fifop = *((PACKED_VAR uint32_t *)buf);
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6019             STR      R1,[R3, #+0]
    253              buf += 4;
   \   0000000C   0x1D00             ADDS     R0,R0,#+4
    254              n--;
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0xE7F8             B.N      ??otg_do_push_0
    255            }
    256            return buf;
   \                     ??otg_do_push_1:
   \   00000012   0x4770             BX       LR               ;; return
    257          }
    258          
    259          /**
    260           * @brief   Writes to a TX FIFO.
    261           *
    262           * @param[in] fifop     pointer to the FIFO register
    263           * @param[in] buf       buffer where to copy the endpoint data
    264           * @param[in] n         maximum number of bytes to copy
    265           *
    266           * @notapi
    267           */

   \                                 In section .text, align 2, keep-with-next
    268          static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
    269                                                 const uint8_t *buf,
    270                                                 size_t n) {
   \                     otg_fifo_write_from_buffer:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    271          
    272            otg_do_push(fifop, (uint8_t *)buf, (n + 3) / 4);
   \   00000008   0x1CF0             ADDS     R0,R6,#+3
   \   0000000A   0x0882             LSRS     R2,R0,#+2
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       otg_do_push
    273          }
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
    274          
    275          /**
    276           * @brief   Writes to a TX FIFO fetching data from a queue.
    277           *
    278           * @param[in] fifop     pointer to the FIFO register
    279           * @param[in] oqp       pointer to an @p OutputQueue object
    280           * @param[in] n         maximum number of bytes to copy
    281           *
    282           * @notapi
    283           */

   \                                 In section .text, align 2, keep-with-next
    284          static void otg_fifo_write_from_queue(volatile uint32_t *fifop,
    285                                                OutputQueue *oqp,
    286                                                size_t n) {
   \                     otg_fifo_write_from_queue:
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    287            size_t ntogo;
    288          
    289            ntogo = n;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0x4681             MOV      R9,R0
    290            while (ntogo > 0) {
   \                     ??otg_fifo_write_from_queue_0:
   \   0000000C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000010   0xD03F             BEQ.N    ??otg_fifo_write_from_queue_1
    291              uint32_t w, i;
    292              size_t nw = ntogo / 4;
   \   00000012   0xEA5F 0x0899      LSRS     R8,R9,#+2
    293          
    294              if (nw > 0) {
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xD019             BEQ.N    ??otg_fifo_write_from_queue_2
    295                size_t streak;
    296                uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
   \   0000001C   0x6928             LDR      R0,[R5, #+16]
   \   0000001E   0x69A9             LDR      R1,[R5, #+24]
   \   00000020   0x1A40             SUBS     R0,R0,R1
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0xFB90 0xFBF1      SDIV     R11,R0,R1
    297          
    298                ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
   \   00000028   0x45C3             CMP      R11,R8
   \   0000002A   0xD301             BCC.N    ??otg_fifo_write_from_queue_3
   \   0000002C   0x46C2             MOV      R10,R8
   \   0000002E   0xE000             B.N      ??otg_fifo_write_from_queue_4
   \                     ??otg_fifo_write_from_queue_3:
   \   00000030   0x46DA             MOV      R10,R11
   \                     ??otg_fifo_write_from_queue_4:
   \   00000032   0xEBB9 0x098A      SUBS     R9,R9,R10, LSL #+2
    299                oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
   \   00000036   0x4652             MOV      R2,R10
   \   00000038   0x69A9             LDR      R1,[R5, #+24]
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       otg_do_push
   \   00000040   0x61A8             STR      R0,[R5, #+24]
    300                if (oqp->q_rdptr >= oqp->q_top) {
   \   00000042   0x69A8             LDR      R0,[R5, #+24]
   \   00000044   0x6929             LDR      R1,[R5, #+16]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD302             BCC.N    ??otg_fifo_write_from_queue_2
    301                  oqp->q_rdptr = oqp->q_buffer;
   \   0000004A   0x68E8             LDR      R0,[R5, #+12]
   \   0000004C   0x61A8             STR      R0,[R5, #+24]
    302                  continue;
   \   0000004E   0xE7DD             B.N      ??otg_fifo_write_from_queue_0
    303                }
    304              }
    305          
    306              /* If this condition is not satisfied then there is a word lying across
    307                 queue circular buffer boundary or there are some remaining bytes.*/
    308              if (ntogo <= 0)
   \                     ??otg_fifo_write_from_queue_2:
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD01D             BEQ.N    ??otg_fifo_write_from_queue_1
    309                break;
    310          
    311              /* One byte at time.*/
    312              w = 0;
   \                     ??otg_fifo_write_from_queue_5:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0006             MOVS     R6,R0
    313              i = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0007             MOVS     R7,R0
    314              while ((ntogo > 0) && (i < 4)) {
   \                     ??otg_fifo_write_from_queue_6:
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD014             BEQ.N    ??otg_fifo_write_from_queue_7
   \   00000064   0x2F04             CMP      R7,#+4
   \   00000066   0xD212             BCS.N    ??otg_fifo_write_from_queue_7
    315                w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
   \   00000068   0x69A8             LDR      R0,[R5, #+24]
   \   0000006A   0x1C41             ADDS     R1,R0,#+1
   \   0000006C   0x61A9             STR      R1,[R5, #+24]
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x0039             MOVS     R1,R7
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x00C9             LSLS     R1,R1,#+3
   \   00000076   0x4088             LSLS     R0,R0,R1
   \   00000078   0x4306             ORRS     R6,R0,R6
    316                if (oqp->q_rdptr >= oqp->q_top)
   \   0000007A   0x69A8             LDR      R0,[R5, #+24]
   \   0000007C   0x6929             LDR      R1,[R5, #+16]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD301             BCC.N    ??otg_fifo_write_from_queue_8
    317                  oqp->q_rdptr = oqp->q_buffer;
   \   00000082   0x68E8             LDR      R0,[R5, #+12]
   \   00000084   0x61A8             STR      R0,[R5, #+24]
    318                ntogo--;
   \                     ??otg_fifo_write_from_queue_8:
   \   00000086   0xF1B9 0x0901      SUBS     R9,R9,#+1
    319                i++;
   \   0000008A   0x1C7F             ADDS     R7,R7,#+1
   \   0000008C   0xE7E7             B.N      ??otg_fifo_write_from_queue_6
    320              }
    321              *fifop = w;
   \                     ??otg_fifo_write_from_queue_7:
   \   0000008E   0x6026             STR      R6,[R4, #+0]
   \   00000090   0xE7BC             B.N      ??otg_fifo_write_from_queue_0
    322            }
    323          
    324            /* Updating queue.*/
    325            chSysLock();
   \                     ??otg_fifo_write_from_queue_1:
   \   00000092   0x2020             MOVS     R0,#+32
   \   00000094   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000098   0x.... 0x....      BL       dbg_check_lock
    326            oqp->q_counter += n;
   \   0000009C   0x68A8             LDR      R0,[R5, #+8]
   \   0000009E   0x9900             LDR      R1,[SP, #+0]
   \   000000A0   0x1808             ADDS     R0,R1,R0
   \   000000A2   0x60A8             STR      R0,[R5, #+8]
    327            while (notempty(&oqp->q_waiting))
   \                     ??otg_fifo_write_from_queue_9:
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x42A8             CMP      R0,R5
   \   000000A8   0xD007             BEQ.N    ??otg_fifo_write_from_queue_10
    328              chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       fifo_remove
   \   000000B0   0x.... 0x....      BL       chSchReadyI
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x6281             STR      R1,[R0, #+40]
   \   000000B8   0xE7F4             B.N      ??otg_fifo_write_from_queue_9
    329            chSchRescheduleS();
   \                     ??otg_fifo_write_from_queue_10:
   \   000000BA   0x.... 0x....      BL       chSchRescheduleS
    330            chSysUnlock();
   \   000000BE   0x.... 0x....      BL       dbg_check_unlock
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF380 0x8811      MSR      BASEPRI,R0
    331          }
   \   000000C8   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    332          
    333          /**
    334           * @brief   Pops a series of words from a FIFO.
    335           *
    336           * @param[in] fifop     pointer to the FIFO register
    337           * @param[in] buf       pointer to the words buffer, not necessarily word
    338           *                      aligned
    339           * @param[in] n         number of words to push
    340           *
    341           * @return              A pointer after the last word pushed.
    342           *
    343           * @notapi
    344           */

   \                                 In section .text, align 2, keep-with-next
    345          static uint8_t *otg_do_pop(volatile uint32_t *fifop, uint8_t *buf, size_t n) {
   \                     otg_do_pop:
   \   00000000   0x0003             MOVS     R3,R0
   \   00000002   0x0008             MOVS     R0,R1
    346          
    347            while (n > 0) {
   \                     ??otg_do_pop_0:
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD004             BEQ.N    ??otg_do_pop_1
    348              uint32_t w = *fifop;
   \   00000008   0x6819             LDR      R1,[R3, #+0]
    349              /* Note, this line relies on the Cortex-M3/M4 ability to perform
    350                 unaligned word accesses and on the LSB-first memory organization.*/
    351              *((PACKED_VAR uint32_t *)buf) = w;
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    352              buf += 4;
   \   0000000C   0x1D00             ADDS     R0,R0,#+4
    353              n--;
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0xE7F8             B.N      ??otg_do_pop_0
    354            }
    355            return buf;
   \                     ??otg_do_pop_1:
   \   00000012   0x4770             BX       LR               ;; return
    356          }
    357          
    358          /**
    359           * @brief   Reads a packet from the RXFIFO.
    360           *
    361           * @param[in] fifop     pointer to the FIFO register
    362           * @param[out] buf      buffer where to copy the endpoint data
    363           * @param[in] n         number of bytes to pull from the FIFO
    364           * @param[in] max       number of bytes to copy into the buffer
    365           *
    366           * @notapi
    367           */

   \                                 In section .text, align 2, keep-with-next
    368          static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
    369                                              uint8_t *buf,
    370                                              size_t n,
    371                                              size_t max) {
   \                     otg_fifo_read_to_buffer:
   \   00000000   0xB410             PUSH     {R4}
    372          
    373            n = (n + 3) / 4;
   \   00000002   0x1CD2             ADDS     R2,R2,#+3
   \   00000004   0x0892             LSRS     R2,R2,#+2
    374            max = (max + 3) / 4;
   \   00000006   0x1CDB             ADDS     R3,R3,#+3
   \   00000008   0x089B             LSRS     R3,R3,#+2
    375            while (n) {
   \                     ??otg_fifo_read_to_buffer_0:
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD007             BEQ.N    ??otg_fifo_read_to_buffer_1
    376              uint32_t w = *fifop;
   \   0000000E   0x6804             LDR      R4,[R0, #+0]
    377              if (max) {
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD002             BEQ.N    ??otg_fifo_read_to_buffer_2
    378                /* Note, this line relies on the Cortex-M3/M4 ability to perform
    379                   unaligned word accesses and on the LSB-first memory organization.*/
    380                *((PACKED_VAR uint32_t *)buf) = w;
   \   00000014   0x600C             STR      R4,[R1, #+0]
    381                buf += 4;
   \   00000016   0x1D09             ADDS     R1,R1,#+4
    382                max--;
   \   00000018   0x1E5B             SUBS     R3,R3,#+1
    383              }
    384              n--;
   \                     ??otg_fifo_read_to_buffer_2:
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0xE7F5             B.N      ??otg_fifo_read_to_buffer_0
    385            }
    386          }
   \                     ??otg_fifo_read_to_buffer_1:
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    387          
    388          /**
    389           * @brief   Reads a packet from the RXFIFO.
    390           *
    391           * @param[in] fifop     pointer to the FIFO register
    392           * @param[in] iqp       pointer to an @p InputQueue object
    393           * @param[in] n         number of bytes to pull from the FIFO
    394           *
    395           * @notapi
    396           */

   \                                 In section .text, align 2, keep-with-next
    397          static void otg_fifo_read_to_queue(volatile uint32_t *fifop,
    398                                             InputQueue *iqp,
    399                                             size_t n) {
   \                     otg_fifo_read_to_queue:
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    400            size_t ntogo;
    401          
    402            ntogo = n;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0x4681             MOV      R9,R0
    403            while (ntogo > 0) {
   \                     ??otg_fifo_read_to_queue_0:
   \   0000000C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000010   0xD03D             BEQ.N    ??otg_fifo_read_to_queue_1
    404              uint32_t w, i;
    405              size_t nw = ntogo / 4;
   \   00000012   0xEA5F 0x0899      LSRS     R8,R9,#+2
    406          
    407              if (nw > 0) {
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xD019             BEQ.N    ??otg_fifo_read_to_queue_2
    408                size_t streak;
    409                uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;
   \   0000001C   0x6968             LDR      R0,[R5, #+20]
   \   0000001E   0x6969             LDR      R1,[R5, #+20]
   \   00000020   0x1A40             SUBS     R0,R0,R1
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0xFB90 0xFBF1      SDIV     R11,R0,R1
    410          
    411                ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
   \   00000028   0x45C3             CMP      R11,R8
   \   0000002A   0xD301             BCC.N    ??otg_fifo_read_to_queue_3
   \   0000002C   0x46C2             MOV      R10,R8
   \   0000002E   0xE000             B.N      ??otg_fifo_read_to_queue_4
   \                     ??otg_fifo_read_to_queue_3:
   \   00000030   0x46DA             MOV      R10,R11
   \                     ??otg_fifo_read_to_queue_4:
   \   00000032   0xEBB9 0x098A      SUBS     R9,R9,R10, LSL #+2
    412                iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
   \   00000036   0x4652             MOV      R2,R10
   \   00000038   0x6969             LDR      R1,[R5, #+20]
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       otg_do_pop
   \   00000040   0x6168             STR      R0,[R5, #+20]
    413                if (iqp->q_wrptr >= iqp->q_top) {
   \   00000042   0x6968             LDR      R0,[R5, #+20]
   \   00000044   0x6929             LDR      R1,[R5, #+16]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD302             BCC.N    ??otg_fifo_read_to_queue_2
    414                  iqp->q_wrptr = iqp->q_buffer;
   \   0000004A   0x68E8             LDR      R0,[R5, #+12]
   \   0000004C   0x6168             STR      R0,[R5, #+20]
    415                  continue;
   \   0000004E   0xE7DD             B.N      ??otg_fifo_read_to_queue_0
    416                }
    417              }
    418          
    419              /* If this condition is not satisfied then there is a word lying across
    420                 queue circular buffer boundary or there are some remaining bytes.*/
    421              if (ntogo <= 0)
   \                     ??otg_fifo_read_to_queue_2:
   \   00000050   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000054   0xD01B             BEQ.N    ??otg_fifo_read_to_queue_1
    422                break;
    423          
    424              /* One byte at time.*/
    425              w = *fifop;
   \                     ??otg_fifo_read_to_queue_5:
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x0006             MOVS     R6,R0
    426              i = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0007             MOVS     R7,R0
    427              while ((ntogo > 0) && (i < 4)) {
   \                     ??otg_fifo_read_to_queue_6:
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD0D3             BEQ.N    ??otg_fifo_read_to_queue_0
   \   00000064   0x2F04             CMP      R7,#+4
   \   00000066   0xD2D1             BCS.N    ??otg_fifo_read_to_queue_0
    428                *iqp->q_wrptr++ = (uint8_t)(w >> (i * 8));
   \   00000068   0x6968             LDR      R0,[R5, #+20]
   \   0000006A   0x1C41             ADDS     R1,R0,#+1
   \   0000006C   0x6169             STR      R1,[R5, #+20]
   \   0000006E   0x0039             MOVS     R1,R7
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0x00C9             LSLS     R1,R1,#+3
   \   00000074   0xFA36 0xF101      LSRS     R1,R6,R1
   \   00000078   0x7001             STRB     R1,[R0, #+0]
    429                if (iqp->q_wrptr >= iqp->q_top)
   \   0000007A   0x6968             LDR      R0,[R5, #+20]
   \   0000007C   0x6929             LDR      R1,[R5, #+16]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD301             BCC.N    ??otg_fifo_read_to_queue_7
    430                  iqp->q_wrptr = iqp->q_buffer;
   \   00000082   0x68E8             LDR      R0,[R5, #+12]
   \   00000084   0x6168             STR      R0,[R5, #+20]
    431                ntogo--;
   \                     ??otg_fifo_read_to_queue_7:
   \   00000086   0xF1B9 0x0901      SUBS     R9,R9,#+1
    432                i++;
   \   0000008A   0x1C7F             ADDS     R7,R7,#+1
   \   0000008C   0xE7E7             B.N      ??otg_fifo_read_to_queue_6
    433              }
    434            }
    435          
    436            /* Updating queue.*/
    437            chSysLock();
   \                     ??otg_fifo_read_to_queue_1:
   \   0000008E   0x2020             MOVS     R0,#+32
   \   00000090   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000094   0x.... 0x....      BL       dbg_check_lock
    438            iqp->q_counter += n;
   \   00000098   0x68A8             LDR      R0,[R5, #+8]
   \   0000009A   0x9900             LDR      R1,[SP, #+0]
   \   0000009C   0x1808             ADDS     R0,R1,R0
   \   0000009E   0x60A8             STR      R0,[R5, #+8]
    439            while (notempty(&iqp->q_waiting))
   \                     ??otg_fifo_read_to_queue_8:
   \   000000A0   0x6828             LDR      R0,[R5, #+0]
   \   000000A2   0x42A8             CMP      R0,R5
   \   000000A4   0xD007             BEQ.N    ??otg_fifo_read_to_queue_9
    440              chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0x.... 0x....      BL       fifo_remove
   \   000000AC   0x.... 0x....      BL       chSchReadyI
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x6281             STR      R1,[R0, #+40]
   \   000000B4   0xE7F4             B.N      ??otg_fifo_read_to_queue_8
    441            chSchRescheduleS();
   \                     ??otg_fifo_read_to_queue_9:
   \   000000B6   0x.... 0x....      BL       chSchRescheduleS
    442            chSysUnlock();
   \   000000BA   0x.... 0x....      BL       dbg_check_unlock
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF380 0x8811      MSR      BASEPRI,R0
    443          }
   \   000000C4   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    444          
    445          /**
    446           * @brief   Incoming packets handler.
    447           *
    448           * @param[in] usbp      pointer to the @p USBDriver object
    449           *
    450           * @notapi
    451           */

   \                                 In section .text, align 2, keep-with-next
    452          static void otg_rxfifo_handler(USBDriver *usbp) {
   \                     otg_rxfifo_handler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    453            uint32_t sts, cnt, ep;
    454          
    455            sts = usbp->otg->GRXSTSP;
   \   00000004   0x6D20             LDR      R0,[R4, #+80]
   \   00000006   0x6A00             LDR      R0,[R0, #+32]
   \   00000008   0x0005             MOVS     R5,R0
    456            switch (sts & GRXSTSP_PKTSTS_MASK) {
   \   0000000A   0xF415 0x10F0      ANDS     R0,R5,#0x1E0000
   \   0000000E   0xF5B0 0x2F80      CMP      R0,#+262144
   \   00000012   0xD019             BEQ.N    ??otg_rxfifo_handler_0
   \   00000014   0xF5B0 0x2F00      CMP      R0,#+524288
   \   00000018   0xD003             BEQ.N    ??otg_rxfifo_handler_1
   \   0000001A   0xF5B0 0x2F40      CMP      R0,#+786432
   \   0000001E   0xD001             BEQ.N    ??otg_rxfifo_handler_2
   \   00000020   0xE057             B.N      ??otg_rxfifo_handler_3
    457            case GRXSTSP_SETUP_COMP:
    458              break;
   \                     ??otg_rxfifo_handler_1:
   \   00000022   0xE056             B.N      ??otg_rxfifo_handler_3
    459            case GRXSTSP_SETUP_DATA:
    460              cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
   \                     ??otg_rxfifo_handler_2:
   \   00000024   0xF3C5 0x100A      UBFX     R0,R5,#+4,#+11
   \   00000028   0x0006             MOVS     R6,R0
    461              ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
   \   0000002A   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   0000002E   0x0007             MOVS     R7,R0
    462              otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
    463                                      cnt, 8);
   \   00000030   0x2308             MOVS     R3,#+8
   \   00000032   0x0032             MOVS     R2,R6
   \   00000034   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0x6A01             LDR      R1,[R0, #+32]
   \   0000003C   0x6D20             LDR      R0,[R4, #+80]
   \   0000003E   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   00000042   0x.... 0x....      BL       otg_fifo_read_to_buffer
    464              break;
   \   00000046   0xE044             B.N      ??otg_rxfifo_handler_3
    465            case GRXSTSP_OUT_DATA:
    466              cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
   \                     ??otg_rxfifo_handler_0:
   \   00000048   0xF3C5 0x100A      UBFX     R0,R5,#+4,#+11
   \   0000004C   0x0006             MOVS     R6,R0
    467              ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
   \   0000004E   0xF015 0x000F      ANDS     R0,R5,#0xF
   \   00000052   0x0007             MOVS     R7,R0
    468              if (usbp->epc[ep]->out_state->rxqueued) {
   \   00000054   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD00B             BEQ.N    ??otg_rxfifo_handler_4
    469                /* Queue associated.*/
    470                otg_fifo_read_to_queue(usbp->otg->FIFO[0],
    471                                       usbp->epc[ep]->out_state->mode.queue.rxqueue,
    472                                       cnt);
   \   00000062   0x0032             MOVS     R2,R6
   \   00000064   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000068   0x68C0             LDR      R0,[R0, #+12]
   \   0000006A   0x6980             LDR      R0,[R0, #+24]
   \   0000006C   0x68C1             LDR      R1,[R0, #+12]
   \   0000006E   0x6D20             LDR      R0,[R4, #+80]
   \   00000070   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   00000074   0x.... 0x....      BL       otg_fifo_read_to_queue
   \   00000078   0xE020             B.N      ??otg_rxfifo_handler_5
    473              }
    474              else {
    475                otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
    476                                        usbp->epc[ep]->out_state->mode.linear.rxbuf,
    477                                        cnt,
    478                                        usbp->epc[ep]->out_state->rxsize -
    479                                        usbp->epc[ep]->out_state->rxcnt);
   \                     ??otg_rxfifo_handler_4:
   \   0000007A   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   0000007E   0x68C0             LDR      R0,[R0, #+12]
   \   00000080   0x6980             LDR      R0,[R0, #+24]
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \   00000084   0xEB14 0x0187      ADDS     R1,R4,R7, LSL #+2
   \   00000088   0x68C9             LDR      R1,[R1, #+12]
   \   0000008A   0x6989             LDR      R1,[R1, #+24]
   \   0000008C   0x6889             LDR      R1,[R1, #+8]
   \   0000008E   0x1A43             SUBS     R3,R0,R1
   \   00000090   0x0032             MOVS     R2,R6
   \   00000092   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   00000096   0x68C0             LDR      R0,[R0, #+12]
   \   00000098   0x6980             LDR      R0,[R0, #+24]
   \   0000009A   0x68C1             LDR      R1,[R0, #+12]
   \   0000009C   0x6D20             LDR      R0,[R4, #+80]
   \   0000009E   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   000000A2   0x.... 0x....      BL       otg_fifo_read_to_buffer
    480                usbp->epc[ep]->out_state->mode.linear.rxbuf += cnt;
   \   000000A6   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0x6980             LDR      R0,[R0, #+24]
   \   000000AE   0xEB14 0x0187      ADDS     R1,R4,R7, LSL #+2
   \   000000B2   0x68C9             LDR      R1,[R1, #+12]
   \   000000B4   0x6989             LDR      R1,[R1, #+24]
   \   000000B6   0x68C9             LDR      R1,[R1, #+12]
   \   000000B8   0x1871             ADDS     R1,R6,R1
   \   000000BA   0x60C1             STR      R1,[R0, #+12]
    481              }
    482              usbp->epc[ep]->out_state->rxcnt += cnt;
   \                     ??otg_rxfifo_handler_5:
   \   000000BC   0xEB14 0x0087      ADDS     R0,R4,R7, LSL #+2
   \   000000C0   0x68C0             LDR      R0,[R0, #+12]
   \   000000C2   0x6980             LDR      R0,[R0, #+24]
   \   000000C4   0xEB14 0x0187      ADDS     R1,R4,R7, LSL #+2
   \   000000C8   0x68C9             LDR      R1,[R1, #+12]
   \   000000CA   0x6989             LDR      R1,[R1, #+24]
   \   000000CC   0x6889             LDR      R1,[R1, #+8]
   \   000000CE   0x1871             ADDS     R1,R6,R1
   \   000000D0   0x6081             STR      R1,[R0, #+8]
    483              break;
    484            case GRXSTSP_OUT_GLOBAL_NAK:
    485            case GRXSTSP_OUT_COMP:
    486            default:
    487              ;
    488            }
    489          }
   \                     ??otg_rxfifo_handler_3:
   \   000000D2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    490          
    491          /**
    492           * @brief   Outgoing packets handler.
    493           *
    494           * @param[in] usbp      pointer to the @p USBDriver object
    495           * @param[in] ep        endpoint number
    496           *
    497           * @notapi
    498           */

   \                                 In section .text, align 2, keep-with-next
    499          static bool_t otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
   \                     otg_txfifo_handler:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    500          
    501            /* The TXFIFO is filled until there is space and data to be transmitted.*/
    502            while (TRUE) {
    503              uint32_t n;
    504          
    505              /* Transaction end condition.*/
    506              if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
   \                     ??otg_txfifo_handler_0:
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000018   0x68C9             LDR      R1,[R1, #+12]
   \   0000001A   0x6949             LDR      R1,[R1, #+20]
   \   0000001C   0x6849             LDR      R1,[R1, #+4]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD301             BCC.N    ??otg_txfifo_handler_1
    507                return TRUE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE06C             B.N      ??otg_txfifo_handler_2
    508          
    509              /* Number of bytes remaining in current transaction.*/
    510              n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
   \                     ??otg_txfifo_handler_1:
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0x6940             LDR      R0,[R0, #+20]
   \   00000030   0x6840             LDR      R0,[R0, #+4]
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000038   0x68C9             LDR      R1,[R1, #+12]
   \   0000003A   0x6949             LDR      R1,[R1, #+20]
   \   0000003C   0x6889             LDR      R1,[R1, #+8]
   \   0000003E   0x1A40             SUBS     R0,R0,R1
   \   00000040   0x0006             MOVS     R6,R0
    511              if (n > usbp->epc[ep]->in_maxsize)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000048   0x68C0             LDR      R0,[R0, #+12]
   \   0000004A   0x8A00             LDRH     R0,[R0, #+16]
   \   0000004C   0x42B0             CMP      R0,R6
   \   0000004E   0xD205             BCS.N    ??otg_txfifo_handler_3
    512                n = usbp->epc[ep]->in_maxsize;
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0x8A00             LDRH     R0,[R0, #+16]
   \   0000005A   0x0006             MOVS     R6,R0
    513          
    514              /* Checks if in the TXFIFO there is enough space to accommodate the
    515                 next packet.*/
    516              if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
   \                     ??otg_txfifo_handler_3:
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x6D20             LDR      R0,[R4, #+80]
   \   00000060   0xEB10 0x1045      ADDS     R0,R0,R5, LSL #+5
   \   00000064   0xF8D0 0x0918      LDR      R0,[R0, #+2328]
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0x0080             LSLS     R0,R0,#+2
   \   0000006C   0x42B0             CMP      R0,R6
   \   0000006E   0xD201             BCS.N    ??otg_txfifo_handler_4
    517                return FALSE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE045             B.N      ??otg_txfifo_handler_2
    518          
    519          #if STM32_USB_OTGFIFO_FILL_BASEPRI
    520              __set_BASEPRI(CORTEX_PRIORITY_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
    521          #endif
    522              /* Handles the two cases: linear buffer or queue.*/
    523              if (usbp->epc[ep]->in_state->txqueued) {
   \                     ??otg_txfifo_handler_4:
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000007A   0x68C0             LDR      R0,[R0, #+12]
   \   0000007C   0x6940             LDR      R0,[R0, #+20]
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD011             BEQ.N    ??otg_txfifo_handler_5
    524                /* Queue associated.*/
    525                otg_fifo_write_from_queue(usbp->otg->FIFO[ep],
    526                                          usbp->epc[ep]->in_state->mode.queue.txqueue,
    527                                          n);
   \   00000084   0x0032             MOVS     R2,R6
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000008C   0x68C0             LDR      R0,[R0, #+12]
   \   0000008E   0x6940             LDR      R0,[R0, #+20]
   \   00000090   0x68C1             LDR      R1,[R0, #+12]
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0xF44F 0x5080      MOV      R0,#+4096
   \   00000098   0x6D23             LDR      R3,[R4, #+80]
   \   0000009A   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   0000009E   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   000000A2   0x.... 0x....      BL       otg_fifo_write_from_queue
   \   000000A6   0xE01D             B.N      ??otg_txfifo_handler_6
    528              }
    529              else {
    530                /* Linear buffer associated.*/
    531                otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
    532                                           usbp->epc[ep]->in_state->mode.linear.txbuf,
    533                                           n);
   \                     ??otg_txfifo_handler_5:
   \   000000A8   0x0032             MOVS     R2,R6
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000B0   0x68C0             LDR      R0,[R0, #+12]
   \   000000B2   0x6940             LDR      R0,[R0, #+20]
   \   000000B4   0x68C1             LDR      R1,[R0, #+12]
   \   000000B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B8   0xF44F 0x5080      MOV      R0,#+4096
   \   000000BC   0x6D23             LDR      R3,[R4, #+80]
   \   000000BE   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   000000C2   0xF510 0x5080      ADDS     R0,R0,#+4096
   \   000000C6   0x.... 0x....      BL       otg_fifo_write_from_buffer
    534                usbp->epc[ep]->in_state->mode.linear.txbuf += n;
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000D0   0x68C0             LDR      R0,[R0, #+12]
   \   000000D2   0x6940             LDR      R0,[R0, #+20]
   \   000000D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D6   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   000000DA   0x68C9             LDR      R1,[R1, #+12]
   \   000000DC   0x6949             LDR      R1,[R1, #+20]
   \   000000DE   0x68C9             LDR      R1,[R1, #+12]
   \   000000E0   0x1871             ADDS     R1,R6,R1
   \   000000E2   0x60C1             STR      R1,[R0, #+12]
    535              }
    536          #if STM32_USB_OTGFIFO_FILL_BASEPRI
    537            __set_BASEPRI(0);
    538          #endif
    539              usbp->epc[ep]->in_state->txcnt += n;
   \                     ??otg_txfifo_handler_6:
   \   000000E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E6   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000EA   0x68C0             LDR      R0,[R0, #+12]
   \   000000EC   0x6940             LDR      R0,[R0, #+20]
   \   000000EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F0   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   000000F4   0x68C9             LDR      R1,[R1, #+12]
   \   000000F6   0x6949             LDR      R1,[R1, #+20]
   \   000000F8   0x6889             LDR      R1,[R1, #+8]
   \   000000FA   0x1871             ADDS     R1,R6,R1
   \   000000FC   0x6081             STR      R1,[R0, #+8]
   \   000000FE   0xE782             B.N      ??otg_txfifo_handler_0
    540            }
   \                     ??otg_txfifo_handler_2:
   \   00000100   0xBD70             POP      {R4-R6,PC}       ;; return
    541          }
    542          
    543          /**
    544           * @brief   Generic endpoint IN handler.
    545           *
    546           * @param[in] usbp      pointer to the @p USBDriver object
    547           * @param[in] ep        endpoint number
    548           *
    549           * @notapi
    550           */

   \                                 In section .text, align 2, keep-with-next
    551          static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
   \                     otg_epin_handler:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    552            stm32_otg_t *otgp = usbp->otg;
   \   00000008   0x6D26             LDR      R6,[R4, #+80]
    553            uint32_t epint = otgp->ie[ep].DIEPINT;
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000010   0xF8D0 0x7908      LDR      R7,[R0, #+2312]
    554          
    555            otgp->ie[ep].DIEPINT = epint;
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000001A   0xF8C0 0x7908      STR      R7,[R0, #+2312]
    556          
    557            if (epint & DIEPINT_TOC) {
    558              /* Timeouts not handled yet, not sure how to handle.*/
    559            }
    560            if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
   \   0000001E   0x07F8             LSLS     R0,R7,#+31
   \   00000020   0xD53C             BPL.N    ??otg_epin_handler_0
   \   00000022   0xF8D6 0x0810      LDR      R0,[R6, #+2064]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD538             BPL.N    ??otg_epin_handler_0
    561              /* Transmit transfer complete.*/
    562              USBInEndpointState *isp = usbp->epc[ep]->in_state;
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0xF8D0 0x8014      LDR      R8,[R0, #+20]
    563          
    564              if (isp->txsize < isp->totsize) {
   \   00000036   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000003A   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD21E             BCS.N    ??otg_epin_handler_1
    565                /* In case the transaction covered only part of the total transfer
    566                   then another transaction is immediately started in order to
    567                   cover the remaining.*/
    568                isp->txsize = isp->totsize - isp->txsize;
   \   00000042   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000046   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   0000004A   0x1A40             SUBS     R0,R0,R1
   \   0000004C   0xF8C8 0x0004      STR      R0,[R8, #+4]
    569                isp->txcnt  = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF8C8 0x0008      STR      R0,[R8, #+8]
    570                usb_lld_prepare_transmit(usbp, ep);
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       usb_lld_prepare_transmit
    571                chSysLockFromIsr();
   \   00000060   0x2020             MOVS     R0,#+32
   \   00000062   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000066   0x.... 0x....      BL       dbg_check_lock_from_isr
    572                usb_lld_start_in(usbp, ep);
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       usb_lld_start_in
    573                chSysUnlockFromIsr();
   \   00000074   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000007E   0xE00D             B.N      ??otg_epin_handler_0
    574              }
    575              else {
    576                /* End on IN transfer.*/
    577                _usb_isr_invoke_in_cb(usbp, ep);
   \                     ??otg_epin_handler_1:
   \   00000080   0x8920             LDRH     R0,[R4, #+8]
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x40A9             LSLS     R1,R1,R5
   \   00000086   0x4388             BICS     R0,R0,R1
   \   00000088   0x8120             STRH     R0,[R4, #+8]
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0xEB14 0x0285      ADDS     R2,R4,R5, LSL #+2
   \   00000096   0x68D2             LDR      R2,[R2, #+12]
   \   00000098   0x6892             LDR      R2,[R2, #+8]
   \   0000009A   0x4790             BLX      R2
    578              }
    579            }
    580            if ((epint & DIEPINT_TXFE) &&
    581                (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
   \                     ??otg_epin_handler_0:
   \   0000009C   0x0638             LSLS     R0,R7,#+24
   \   0000009E   0xD51D             BPL.N    ??otg_epin_handler_2
   \   000000A0   0xF8D6 0x0834      LDR      R0,[R6, #+2100]
   \   000000A4   0x40E8             LSRS     R0,R0,R5
   \   000000A6   0x07C0             LSLS     R0,R0,#+31
   \   000000A8   0xD518             BPL.N    ??otg_epin_handler_2
    582              /* The thread is made ready, it will be scheduled on ISR exit.*/
    583              chSysLockFromIsr();
   \   000000AA   0x2020             MOVS     R0,#+32
   \   000000AC   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000B0   0x.... 0x....      BL       dbg_check_lock_from_isr
    584              usbp->txpending |= (1 << ep);
   \   000000B4   0x6DE0             LDR      R0,[R4, #+92]
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x40A9             LSLS     R1,R1,R5
   \   000000BA   0x4308             ORRS     R0,R1,R0
   \   000000BC   0x65E0             STR      R0,[R4, #+92]
    585              otgp->DIEPEMPMSK &= ~(1 << ep);
   \   000000BE   0xF8D6 0x0834      LDR      R0,[R6, #+2100]
   \   000000C2   0x2101             MOVS     R1,#+1
   \   000000C4   0x40A9             LSLS     R1,R1,R5
   \   000000C6   0x4388             BICS     R0,R0,R1
   \   000000C8   0xF8C6 0x0834      STR      R0,[R6, #+2100]
    586              usb_lld_wakeup_pump(usbp);
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       usb_lld_wakeup_pump
    587              chSysUnlockFromIsr();
   \   000000D2   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF380 0x8811      MSR      BASEPRI,R0
    588            }
    589          }
   \                     ??otg_epin_handler_2:
   \   000000DC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    590          
    591          /**
    592           * @brief   Generic endpoint OUT handler.
    593           *
    594           * @param[in] usbp      pointer to the @p USBDriver object
    595           * @param[in] ep        endpoint number
    596           *
    597           * @notapi
    598           */

   \                                 In section .text, align 2, keep-with-next
    599          static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
   \                     otg_epout_handler:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    600            stm32_otg_t *otgp = usbp->otg;
   \   00000008   0x6D26             LDR      R6,[R4, #+80]
    601            uint32_t epint = otgp->oe[ep].DOEPINT;
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000010   0xF8D0 0x7B08      LDR      R7,[R0, #+2824]
    602          
    603            /* Resets all EP IRQ sources.*/
    604            otgp->oe[ep].DOEPINT = epint;
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000001A   0xF8C0 0x7B08      STR      R7,[R0, #+2824]
    605          
    606            if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
   \   0000001E   0x0738             LSLS     R0,R7,#+28
   \   00000020   0xD50C             BPL.N    ??otg_epout_handler_0
   \   00000022   0xF8D6 0x0814      LDR      R0,[R6, #+2068]
   \   00000026   0x0700             LSLS     R0,R0,#+28
   \   00000028   0xD508             BPL.N    ??otg_epout_handler_0
    607              /* Setup packets handling, setup packets are handled using a
    608                 specific callback.*/
    609              _usb_isr_invoke_setup_cb(usbp, ep);
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xEB14 0x0285      ADDS     R2,R4,R5, LSL #+2
   \   00000036   0x68D2             LDR      R2,[R2, #+12]
   \   00000038   0x6852             LDR      R2,[R2, #+4]
   \   0000003A   0x4790             BLX      R2
    610          
    611            }
    612            if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
   \                     ??otg_epout_handler_0:
   \   0000003C   0x07F8             LSLS     R0,R7,#+31
   \   0000003E   0xD53C             BPL.N    ??otg_epout_handler_1
   \   00000040   0xF8D6 0x0814      LDR      R0,[R6, #+2068]
   \   00000044   0x07C0             LSLS     R0,R0,#+31
   \   00000046   0xD538             BPL.N    ??otg_epout_handler_1
    613              /* Receive transfer complete.*/
    614              USBOutEndpointState *osp = usbp->epc[ep]->out_state;
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0xF8D0 0x8018      LDR      R8,[R0, #+24]
    615          
    616              if (osp->rxsize < osp->totsize) {
   \   00000054   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000058   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD21E             BCS.N    ??otg_epout_handler_2
    617                /* In case the transaction covered only part of the total transfer
    618                   then another transaction is immediately started in order to
    619                   cover the remaining.*/
    620                osp->rxsize = osp->totsize - osp->rxsize;
   \   00000060   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \   00000064   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   00000068   0x1A40             SUBS     R0,R0,R1
   \   0000006A   0xF8C8 0x0004      STR      R0,[R8, #+4]
    621                osp->rxcnt  = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8C8 0x0008      STR      R0,[R8, #+8]
    622                usb_lld_prepare_receive(usbp, ep);
   \   00000074   0x0029             MOVS     R1,R5
   \   00000076   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       usb_lld_prepare_receive
    623                chSysLockFromIsr();
   \   0000007E   0x2020             MOVS     R0,#+32
   \   00000080   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000084   0x.... 0x....      BL       dbg_check_lock_from_isr
    624                usb_lld_start_out(usbp, ep);
   \   00000088   0x0029             MOVS     R1,R5
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       usb_lld_start_out
    625                chSysUnlockFromIsr();
   \   00000092   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000009C   0xE00D             B.N      ??otg_epout_handler_1
    626              }
    627              else {
    628                /* End on OUT transfer.*/
    629                _usb_isr_invoke_out_cb(usbp, ep);
   \                     ??otg_epout_handler_2:
   \   0000009E   0x8960             LDRH     R0,[R4, #+10]
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x40A9             LSLS     R1,R1,R5
   \   000000A4   0x4388             BICS     R0,R0,R1
   \   000000A6   0x8160             STRH     R0,[R4, #+10]
   \   000000A8   0x0029             MOVS     R1,R5
   \   000000AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B0   0xEB14 0x0285      ADDS     R2,R4,R5, LSL #+2
   \   000000B4   0x68D2             LDR      R2,[R2, #+12]
   \   000000B6   0x68D2             LDR      R2,[R2, #+12]
   \   000000B8   0x4790             BLX      R2
    630              }
    631            }
    632          }
   \                     ??otg_epout_handler_1:
   \   000000BA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    633          
    634          /**
    635           * @brief   OTG shared ISR.
    636           *
    637           * @param[in] usbp      pointer to the @p USBDriver object
    638           *
    639           * @notapi
    640           */

   \                                 In section .text, align 2, keep-with-next
    641          static void usb_lld_serve_interrupt(USBDriver *usbp) {
   \                     usb_lld_serve_interrupt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    642            stm32_otg_t *otgp = usbp->otg;
   \   00000004   0x6D25             LDR      R5,[R4, #+80]
    643            uint32_t sts, src;
    644          
    645            sts  = otgp->GINTSTS;
   \   00000006   0x6968             LDR      R0,[R5, #+20]
   \   00000008   0x0007             MOVS     R7,R0
    646            sts &= otgp->GINTMSK;
   \   0000000A   0x69A8             LDR      R0,[R5, #+24]
   \   0000000C   0x4007             ANDS     R7,R0,R7
    647            otgp->GINTSTS = sts;
   \   0000000E   0x616F             STR      R7,[R5, #+20]
    648          
    649            /* Reset interrupt handling.*/
    650            if (sts & GINTSTS_USBRST) {
   \   00000010   0x04F8             LSLS     R0,R7,#+19
   \   00000012   0xD50B             BPL.N    ??usb_lld_serve_interrupt_0
    651              _usb_reset(usbp);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       _usb_reset
    652              _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??usb_lld_serve_interrupt_0
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x6862             LDR      R2,[R4, #+4]
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x4790             BLX      R2
    653            }
    654          
    655            /* Enumeration done.*/
    656            if (sts & GINTSTS_ENUMDNE) {
   \                     ??usb_lld_serve_interrupt_0:
   \   0000002C   0x04B8             LSLS     R0,R7,#+18
   \   0000002E   0xD501             BPL.N    ??usb_lld_serve_interrupt_1
    657              (void)otgp->DSTS;
   \   00000030   0xF8D5 0x0808      LDR      R0,[R5, #+2056]
    658            }
    659          
    660            /* SOF interrupt handling.*/
    661            if (sts & GINTSTS_SOF) {
   \                     ??usb_lld_serve_interrupt_1:
   \   00000034   0x0738             LSLS     R0,R7,#+28
   \   00000036   0xD507             BPL.N    ??usb_lld_serve_interrupt_2
    662              _usb_isr_invoke_sof_cb(usbp);
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x68C0             LDR      R0,[R0, #+12]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??usb_lld_serve_interrupt_2
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x6861             LDR      R1,[R4, #+4]
   \   00000044   0x68C9             LDR      R1,[R1, #+12]
   \   00000046   0x4788             BLX      R1
    663            }
    664          
    665            /* RX FIFO not empty handling.*/
    666            if (sts & GINTSTS_RXFLVL) {
   \                     ??usb_lld_serve_interrupt_2:
   \   00000048   0x06F8             LSLS     R0,R7,#+27
   \   0000004A   0xD510             BPL.N    ??usb_lld_serve_interrupt_3
    667              /* The interrupt is masked while the thread has control or it would
    668                 be triggered again.*/
    669              chSysLockFromIsr();
   \   0000004C   0x2020             MOVS     R0,#+32
   \   0000004E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000052   0x.... 0x....      BL       dbg_check_lock_from_isr
    670              otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
   \   00000056   0x69A8             LDR      R0,[R5, #+24]
   \   00000058   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000005C   0x61A8             STR      R0,[R5, #+24]
    671              usb_lld_wakeup_pump(usbp);
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       usb_lld_wakeup_pump
    672              chSysUnlockFromIsr();
   \   00000064   0x.... 0x....      BL       dbg_check_unlock_from_isr
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF380 0x8811      MSR      BASEPRI,R0
    673            }
    674          
    675            /* IN/OUT endpoints event handling.*/
    676            src = otgp->DAINT;
   \                     ??usb_lld_serve_interrupt_3:
   \   0000006E   0xF8D5 0x0818      LDR      R0,[R5, #+2072]
   \   00000072   0x0006             MOVS     R6,R0
    677            if (sts & GINTSTS_IEPINT) {
   \   00000074   0x0378             LSLS     R0,R7,#+13
   \   00000076   0xD517             BPL.N    ??usb_lld_serve_interrupt_4
    678              if (src & (1 << 0))
   \   00000078   0x07F0             LSLS     R0,R6,#+31
   \   0000007A   0xD503             BPL.N    ??usb_lld_serve_interrupt_5
    679                otg_epin_handler(usbp, 0);
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       otg_epin_handler
    680              if (src & (1 << 1))
   \                     ??usb_lld_serve_interrupt_5:
   \   00000084   0x07B0             LSLS     R0,R6,#+30
   \   00000086   0xD503             BPL.N    ??usb_lld_serve_interrupt_6
    681                otg_epin_handler(usbp, 1);
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       otg_epin_handler
    682              if (src & (1 << 2))
   \                     ??usb_lld_serve_interrupt_6:
   \   00000090   0x0770             LSLS     R0,R6,#+29
   \   00000092   0xD503             BPL.N    ??usb_lld_serve_interrupt_7
    683                otg_epin_handler(usbp, 2);
   \   00000094   0x2102             MOVS     R1,#+2
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       otg_epin_handler
    684              if (src & (1 << 3))
   \                     ??usb_lld_serve_interrupt_7:
   \   0000009C   0x0730             LSLS     R0,R6,#+28
   \   0000009E   0xD503             BPL.N    ??usb_lld_serve_interrupt_4
    685                otg_epin_handler(usbp, 3);
   \   000000A0   0x2103             MOVS     R1,#+3
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       otg_epin_handler
    686          #if STM32_USB_USE_OTG2
    687              if (src & (1 << 4))
    688                otg_epin_handler(usbp, 4);
    689              if (src & (1 << 5))
    690                otg_epin_handler(usbp, 5);
    691          #endif
    692            }
    693            if (sts & GINTSTS_OEPINT) {
   \                     ??usb_lld_serve_interrupt_4:
   \   000000A8   0x0338             LSLS     R0,R7,#+12
   \   000000AA   0xD517             BPL.N    ??usb_lld_serve_interrupt_8
    694              if (src & (1 << 16))
   \   000000AC   0x03F0             LSLS     R0,R6,#+15
   \   000000AE   0xD503             BPL.N    ??usb_lld_serve_interrupt_9
    695                otg_epout_handler(usbp, 0);
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       otg_epout_handler
    696              if (src & (1 << 17))
   \                     ??usb_lld_serve_interrupt_9:
   \   000000B8   0x03B0             LSLS     R0,R6,#+14
   \   000000BA   0xD503             BPL.N    ??usb_lld_serve_interrupt_10
    697                otg_epout_handler(usbp, 1);
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       otg_epout_handler
    698              if (src & (1 << 18))
   \                     ??usb_lld_serve_interrupt_10:
   \   000000C4   0x0370             LSLS     R0,R6,#+13
   \   000000C6   0xD503             BPL.N    ??usb_lld_serve_interrupt_11
    699                otg_epout_handler(usbp, 2);
   \   000000C8   0x2102             MOVS     R1,#+2
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       otg_epout_handler
    700              if (src & (1 << 19))
   \                     ??usb_lld_serve_interrupt_11:
   \   000000D0   0x0330             LSLS     R0,R6,#+12
   \   000000D2   0xD503             BPL.N    ??usb_lld_serve_interrupt_8
    701                otg_epout_handler(usbp, 3);
   \   000000D4   0x2103             MOVS     R1,#+3
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       otg_epout_handler
    702          #if STM32_USB_USE_OTG2
    703              if (src & (1 << 20))
    704                otg_epout_handler(usbp, 4);
    705              if (src & (1 << 21))
    706                otg_epout_handler(usbp, 5);
    707          #endif
    708            }
    709          }
   \                     ??usb_lld_serve_interrupt_8:
   \   000000DC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    710          
    711          /*===========================================================================*/
    712          /* Driver interrupt handlers and threads.                                    */
    713          /*===========================================================================*/
    714          

   \                                 In section .text, align 2, keep-with-next
    715          static msg_t usb_lld_pump(void *p) {
   \                     usb_lld_pump:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    716            USBDriver *usbp = (USBDriver *)p;
   \   00000006   0x0025             MOVS     R5,R4
    717            stm32_otg_t *otgp = usbp->otg;
   \   00000008   0x6D2E             LDR      R6,[R5, #+80]
    718          
    719            chRegSetThreadName("usb_lld_pump");
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \   00000014   0x6181             STR      R1,[R0, #+24]
    720            chSysLock();
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF380 0x8811      MSR      BASEPRI,R0
   \   0000001C   0x.... 0x....      BL       dbg_check_lock
    721            while (TRUE) {
    722              usbep_t ep;
    723              uint32_t epmask;
    724          
    725              /* Nothing to do, going to sleep.*/
    726              if ((usbp->state == USB_STOP) ||
    727                  ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
   \                     ??usb_lld_pump_0:
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD005             BEQ.N    ??usb_lld_pump_1
   \   00000026   0x6DE8             LDR      R0,[R5, #+92]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD10D             BNE.N    ??usb_lld_pump_2
   \   0000002C   0x6970             LDR      R0,[R6, #+20]
   \   0000002E   0x06C0             LSLS     R0,R0,#+27
   \   00000030   0xD40A             BMI.N    ??usb_lld_pump_2
    728                otgp->GINTMSK |= GINTMSK_RXFLVLM;
   \                     ??usb_lld_pump_1:
   \   00000032   0x69B0             LDR      R0,[R6, #+24]
   \   00000034   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000038   0x61B0             STR      R0,[R6, #+24]
    729                usbp->thd_wait = chThdSelf();
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000003E   0x6980             LDR      R0,[R0, #+24]
   \   00000040   0x6668             STR      R0,[R5, #+100]
    730                chSchGoSleepS(THD_STATE_SUSPENDED);
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x.... 0x....      BL       chSchGoSleepS
    731              }
    732              chSysUnlock();
   \                     ??usb_lld_pump_2:
   \   00000048   0x.... 0x....      BL       dbg_check_unlock
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF380 0x8811      MSR      BASEPRI,R0
    733          
    734              /* Checks if there are TXFIFOs to be filled.*/
    735              for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x0007             MOVS     R7,R0
   \                     ??usb_lld_pump_3:
   \   00000056   0x6D68             LDR      R0,[R5, #+84]
   \   00000058   0x6880             LDR      R0,[R0, #+8]
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x42B8             CMP      R0,R7
   \   0000005E   0xD340             BCC.N    ??usb_lld_pump_4
    736          
    737                /* Empties the RX FIFO.*/
    738                while (otgp->GINTSTS & GINTSTS_RXFLVL) {
   \                     ??usb_lld_pump_5:
   \   00000060   0x6970             LDR      R0,[R6, #+20]
   \   00000062   0x06C0             LSLS     R0,R0,#+27
   \   00000064   0xD503             BPL.N    ??usb_lld_pump_6
    739                  otg_rxfifo_handler(usbp);
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0x.... 0x....      BL       otg_rxfifo_handler
   \   0000006C   0xE7F8             B.N      ??usb_lld_pump_5
    740                }
    741          
    742                epmask = (1 << ep);
   \                     ??usb_lld_pump_6:
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x40B8             LSLS     R0,R0,R7
   \   00000072   0x4680             MOV      R8,R0
    743                if (usbp->txpending & epmask) {
   \   00000074   0x6DE8             LDR      R0,[R5, #+92]
   \   00000076   0xEA10 0x0F08      TST      R0,R8
   \   0000007A   0xD030             BEQ.N    ??usb_lld_pump_7
    744                  bool_t done;
    745          
    746                  chSysLock();
   \   0000007C   0x2020             MOVS     R0,#+32
   \   0000007E   0xF380 0x8811      MSR      BASEPRI,R0
   \   00000082   0x.... 0x....      BL       dbg_check_lock
    747                  /* USB interrupts are globally *suspended* because the peripheral
    748                     does not allow any interference during the TX FIFO filling
    749                     operation.
    750                     Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
    751                       "The application has to finish writing one complete packet before
    752                        switching to a different channel/endpoint FIFO. Violating this
    753                        rule results in an error.".*/
    754                  otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
   \   00000086   0x68B0             LDR      R0,[R6, #+8]
   \   00000088   0x0840             LSRS     R0,R0,#+1
   \   0000008A   0x0040             LSLS     R0,R0,#+1
   \   0000008C   0x60B0             STR      R0,[R6, #+8]
    755                  usbp->txpending &= ~epmask;
   \   0000008E   0x6DE8             LDR      R0,[R5, #+92]
   \   00000090   0xEA30 0x0008      BICS     R0,R0,R8
   \   00000094   0x65E8             STR      R0,[R5, #+92]
    756                  chSysUnlock();
   \   00000096   0x.... 0x....      BL       dbg_check_unlock
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF380 0x8811      MSR      BASEPRI,R0
    757          
    758                  done = otg_txfifo_handler(usbp, ep);
   \   000000A0   0x0039             MOVS     R1,R7
   \   000000A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A4   0x0028             MOVS     R0,R5
   \   000000A6   0x.... 0x....      BL       otg_txfifo_handler
   \   000000AA   0x4681             MOV      R9,R0
    759          
    760                  chSysLock();
   \   000000AC   0x2020             MOVS     R0,#+32
   \   000000AE   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000B2   0x.... 0x....      BL       dbg_check_lock
    761                  otgp->GAHBCFG |= GAHBCFG_GINTMSK;
   \   000000B6   0x68B0             LDR      R0,[R6, #+8]
   \   000000B8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000BC   0x60B0             STR      R0,[R6, #+8]
    762                  if (!done)
   \   000000BE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000C6   0xD105             BNE.N    ??usb_lld_pump_8
    763                    otgp->DIEPEMPMSK |= epmask;
   \   000000C8   0xF8D6 0x0834      LDR      R0,[R6, #+2100]
   \   000000CC   0xEA58 0x0000      ORRS     R0,R8,R0
   \   000000D0   0xF8C6 0x0834      STR      R0,[R6, #+2100]
    764                  chSysUnlock();
   \                     ??usb_lld_pump_8:
   \   000000D4   0x.... 0x....      BL       dbg_check_unlock
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF380 0x8811      MSR      BASEPRI,R0
    765                }
    766              }
   \                     ??usb_lld_pump_7:
   \   000000DE   0x1C7F             ADDS     R7,R7,#+1
   \   000000E0   0xE7B9             B.N      ??usb_lld_pump_3
    767              chSysLock();
   \                     ??usb_lld_pump_4:
   \   000000E2   0x2020             MOVS     R0,#+32
   \   000000E4   0xF380 0x8811      MSR      BASEPRI,R0
   \   000000E8   0x.... 0x....      BL       dbg_check_lock
   \   000000EC   0xE798             B.N      ??usb_lld_pump_0
    768            }
    769            // we are never here but GCC cannot figure this out
    770            return 0;
    771          }
    772          
    773          #if STM32_USB_USE_OTG1 || defined(__DOXYGEN__)
    774          #if !defined(STM32_OTG1_HANDLER)
    775          #error "STM32_OTG1_HANDLER not defined"
    776          #endif
    777          /**
    778           * @brief   OTG1 interrupt handler.
    779           *
    780           * @isr
    781           */

   \                                 In section .text, align 2, keep-with-next
    782          CH_IRQ_HANDLER(STM32_OTG1_HANDLER) {
   \                     Vector14C:
   \   00000000   0xB580             PUSH     {R7,LR}
    783          
    784            CH_IRQ_PROLOGUE();
   \   00000002   0x.... 0x....      BL       dbg_check_enter_isr
    785          
    786            usb_lld_serve_interrupt(&USBD1);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000000A   0x.... 0x....      BL       usb_lld_serve_interrupt
    787          
    788            CH_IRQ_EPILOGUE();
   \   0000000E   0x.... 0x....      BL       dbg_check_leave_isr
   \   00000012   0x.... 0x....      BL       _port_irq_epilogue
    789          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    790          #endif
    791          
    792          #if STM32_USB_USE_OTG2 || defined(__DOXYGEN__)
    793          #if !defined(STM32_OTG2_HANDLER)
    794          #error "STM32_OTG2_HANDLER not defined"
    795          #endif
    796          /**
    797           * @brief   OTG2 interrupt handler.
    798           *
    799           * @isr
    800           */
    801          CH_IRQ_HANDLER(STM32_OTG2_HANDLER) {
    802          
    803            CH_IRQ_PROLOGUE();
    804          
    805            usb_lld_serve_interrupt(&USBD2);
    806          
    807            CH_IRQ_EPILOGUE();
    808          }
    809          #endif
    810          
    811          /*===========================================================================*/
    812          /* Driver exported functions.                                                */
    813          /*===========================================================================*/
    814          
    815          /**
    816           * @brief   Low level USB driver initialization.
    817           *
    818           * @notapi
    819           */

   \                                 In section .text, align 2, keep-with-next
    820          void usb_lld_init(void) {
   \                     usb_lld_init:
   \   00000000   0xB510             PUSH     {R4,LR}
    821          
    822            /* Driver initialization.*/
    823          #if STM32_USB_USE_OTG1
    824            usbObjectInit(&USBD1);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000006   0x.... 0x....      BL       usbObjectInit
    825            USBD1.thd_ptr   = NULL;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6601             STR      R1,[R0, #+96]
    826            USBD1.thd_wait  = NULL;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6641             STR      R1,[R0, #+100]
    827            USBD1.otg       = OTG_FS;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000001E   0xF05F 0x41A0      MOVS     R1,#+1342177280
   \   00000022   0x6501             STR      R1,[R0, #+80]
    828            USBD1.otgparams = &fsparams;
   \   00000024   0x....             LDR.N    R0,??DataTable6_3
   \   00000026   0x....             LDR.N    R1,??DataTable6_4
   \   00000028   0x6541             STR      R1,[R0, #+84]
    829          
    830            /* Filling the thread working area here because the function
    831               @p chThdCreateI() does not do it.*/
    832          #if CH_DBG_FILL_THREADS
    833            {
    834              void *wsp = USBD1.wa_pump;
   \   0000002A   0x....             LDR.N    R4,??DataTable6_5
    835              _thread_memfill((uint8_t *)wsp,
    836                              (uint8_t *)wsp + sizeof(Thread),
    837                              CH_THREAD_FILL_VALUE);
   \   0000002C   0x22FF             MOVS     R2,#+255
   \   0000002E   0xF114 0x014C      ADDS     R1,R4,#+76
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       _thread_memfill
    838              _thread_memfill((uint8_t *)wsp + sizeof(Thread),
    839                              (uint8_t *)wsp + sizeof(USBD1.wa_pump),
    840                              CH_STACK_FILL_VALUE);
   \   00000038   0x2255             MOVS     R2,#+85
   \   0000003A   0xF514 0x61A7      ADDS     R1,R4,#+1336
   \   0000003E   0xF114 0x004C      ADDS     R0,R4,#+76
   \   00000042   0x.... 0x....      BL       _thread_memfill
    841            }
    842          #endif
    843          #endif
    844          
    845          #if STM32_USB_USE_OTG2
    846            usbObjectInit(&USBD2);
    847            USBD2.thd_ptr   = NULL;
    848            USBD2.thd_wait  = NULL;
    849            USBD2.otg       = OTG_HS;
    850            USBD2.otgparams = &hsparams;
    851          
    852            /* Filling the thread working area here because the function
    853               @p chThdCreateI() does not do it.*/
    854          #if CH_DBG_FILL_THREADS
    855            {
    856              void *wsp = USBD2.wa_pump;
    857              _thread_memfill((uint8_t *)wsp,
    858                              (uint8_t *)wsp + sizeof(Thread),
    859                              CH_THREAD_FILL_VALUE);
    860              _thread_memfill((uint8_t *)wsp + sizeof(Thread),
    861                              (uint8_t *)wsp + sizeof(USBD2.wa_pump),
    862                              CH_STACK_FILL_VALUE);
    863            }
    864          #endif
    865          #endif
    866          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    867          
    868          /**
    869           * @brief   Configures and activates the USB peripheral.
    870           * @note    Starting the OTG cell can be a slow operation carried out with
    871           *          interrupts disabled, perform it before starting time-critical
    872           *          operations.
    873           *
    874           * @param[in] usbp      pointer to the @p USBDriver object
    875           *
    876           * @notapi
    877           */

   \                                 In section .text, align 2, keep-with-next
    878          void usb_lld_start(USBDriver *usbp) {
   \                     usb_lld_start:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    879            stm32_otg_t *otgp = usbp->otg;
   \   00000004   0x6D25             LDR      R5,[R4, #+80]
    880          
    881            if (usbp->state == USB_STOP) {
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD153             BNE.N    ??usb_lld_start_0
    882              /* Clock activation.*/
    883          #if STM32_USB_USE_OTG1
    884              if (&USBD1 == usbp) {
   \   0000000C   0x....             LDR.N    R0,??DataTable6_3
   \   0000000E   0x42A0             CMP      R0,R4
   \   00000010   0xD112             BNE.N    ??usb_lld_start_1
    885                /* OTG FS clock enable and reset.*/
    886                rccEnableOTG_FS(FALSE);
   \   00000012   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40023834
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001A   0x....             LDR.N    R1,??DataTable6_6  ;; 0x40023834
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    887                rccResetOTG_FS();
   \   0000001E   0x....             LDR.N    R0,??DataTable6_7  ;; 0x40023814
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x....             LDR.N    R1,??DataTable6_7  ;; 0x40023814
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable6_7  ;; 0x40023814
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    888          
    889                /* Enables IRQ vector.*/
    890                nvicEnableVector(STM32_OTG1_NUMBER,
    891                                 CORTEX_PRIORITY_MASK(STM32_USB_OTG1_IRQ_PRIORITY));
   \   00000030   0x21E0             MOVS     R1,#+224
   \   00000032   0x2043             MOVS     R0,#+67
   \   00000034   0x.... 0x....      BL       nvicEnableVector
    892              }
    893          #endif
    894          #if STM32_USB_USE_OTG2
    895              if (&USBD2 == usbp) {
    896                /* OTG HS clock enable and reset.*/
    897                rccEnableOTG_HS(FALSE);
    898                rccResetOTG_HS();
    899          
    900                /* Workaround for the problem described here:
    901                   http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798 */
    902                rccDisableOTG_HSULPI(TRUE);
    903          
    904                /* Enables IRQ vector.*/
    905                nvicEnableVector(STM32_OTG2_NUMBER,
    906                                 CORTEX_PRIORITY_MASK(STM32_USB_OTG2_IRQ_PRIORITY));
    907              }
    908          #endif
    909          
    910              /* Creates the data pump threads in a suspended state. Note, it is
    911                 created only once, the first time @p usbStart() is invoked.*/
    912              usbp->txpending = 0;
   \                     ??usb_lld_start_1:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x65E0             STR      R0,[R4, #+92]
    913              if (usbp->thd_ptr == NULL)
   \   0000003C   0x6E20             LDR      R0,[R4, #+96]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10A             BNE.N    ??usb_lld_start_2
    914                usbp->thd_ptr = usbp->thd_wait = chThdCreateI(usbp->wa_pump,
    915                                                              sizeof usbp->wa_pump,
    916                                                              STM32_USB_OTG_THREAD_PRIO,
    917                                                              usb_lld_pump,
    918                                                              usbp);
   \   00000042   0x9400             STR      R4,[SP, #+0]
   \   00000044   0x....             LDR.N    R3,??DataTable6_8
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0xF44F 0x61A7      MOV      R1,#+1336
   \   0000004C   0xF114 0x0068      ADDS     R0,R4,#+104
   \   00000050   0x.... 0x....      BL       chThdCreateI
   \   00000054   0x6660             STR      R0,[R4, #+100]
   \   00000056   0x6620             STR      R0,[R4, #+96]
    919          
    920              /* - Forced device mode.
    921                 - USB turn-around time = TRDT_VALUE.
    922                 - Full Speed 1.1 PHY.*/
    923              otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
   \                     ??usb_lld_start_2:
   \   00000058   0x....             LDR.N    R0,??DataTable6_9  ;; 0x40001440
   \   0000005A   0x60E8             STR      R0,[R5, #+12]
    924          
    925              /* 48MHz 1.1 PHY.*/
    926              otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
   \   0000005C   0x....             LDR.N    R0,??DataTable6_10  ;; 0x2200003
   \   0000005E   0xF8C5 0x0800      STR      R0,[R5, #+2048]
    927          
    928              /* PHY enabled.*/
    929              otgp->PCGCCTL = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF8C5 0x0E00      STR      R0,[R5, #+3584]
    930          
    931              /* Internal FS PHY activation.*/
    932          #if defined(BOARD_OTG_NOVBUSSENS)
    933              otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
    934                            GCCFG_PWRDWN;
    935          #else
    936              otgp->GCCFG = GCCFG_VBUSASEN | GCCFG_VBUSBSEN | GCCFG_PWRDWN;
   \   00000068   0xF45F 0x2050      MOVS     R0,#+851968
   \   0000006C   0x63A8             STR      R0,[R5, #+56]
    937          #endif
    938          
    939              /* Soft core reset.*/
    940              otg_core_reset(usbp);
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       otg_core_reset
    941          
    942              /* Interrupts on TXFIFOs half empty.*/
    943              otgp->GAHBCFG = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x60A8             STR      R0,[R5, #+8]
    944          
    945              /* Endpoints re-initialization.*/
    946              otg_disable_ep(usbp);
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       otg_disable_ep
    947          
    948              /* Clear all pending Device Interrupts, only the USB Reset interrupt
    949                 is required initially.*/
    950              otgp->DIEPMSK  = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF8C5 0x0810      STR      R0,[R5, #+2064]
    951              otgp->DOEPMSK  = 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF8C5 0x0814      STR      R0,[R5, #+2068]
    952              otgp->DAINTMSK = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF8C5 0x081C      STR      R0,[R5, #+2076]
    953              if (usbp->config->sof_cb == NULL)
   \   00000090   0x6860             LDR      R0,[R4, #+4]
   \   00000092   0x68C0             LDR      R0,[R0, #+12]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD103             BNE.N    ??usb_lld_start_3
    954                otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
    955                                 GINTMSK_ESUSPM  |*/;
   \   00000098   0xF44F 0x5040      MOV      R0,#+12288
   \   0000009C   0x61A8             STR      R0,[R5, #+24]
   \   0000009E   0xE002             B.N      ??usb_lld_start_4
    956              else
    957                otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
    958                                 GINTMSK_ESUSPM */ | GINTMSK_SOFM;
   \                     ??usb_lld_start_3:
   \   000000A0   0xF243 0x0008      MOVW     R0,#+12296
   \   000000A4   0x61A8             STR      R0,[R5, #+24]
    959              otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */
   \                     ??usb_lld_start_4:
   \   000000A6   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000AA   0x6168             STR      R0,[R5, #+20]
    960          
    961              /* Global interrupts enable.*/
    962              otgp->GAHBCFG |= GAHBCFG_GINTMSK;
   \   000000AC   0x68A8             LDR      R0,[R5, #+8]
   \   000000AE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000B2   0x60A8             STR      R0,[R5, #+8]
    963            }
    964          }
   \                     ??usb_lld_start_0:
   \   000000B4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    965          
    966          /**
    967           * @brief   Deactivates the USB peripheral.
    968           *
    969           * @param[in] usbp      pointer to the @p USBDriver object
    970           *
    971           * @notapi
    972           */

   \                                 In section .text, align 2, keep-with-next
    973          void usb_lld_stop(USBDriver *usbp) {
   \                     usb_lld_stop:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    974            stm32_otg_t *otgp = usbp->otg;
   \   00000004   0x6D25             LDR      R5,[R4, #+80]
    975          
    976            /* If in ready state then disables the USB clock.*/
    977            if (usbp->state != USB_STOP) {
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD00B             BEQ.N    ??usb_lld_stop_0
    978          
    979              /* Disabling all endpoints in case the driver has been stopped while
    980                 active.*/
    981              otg_disable_ep(usbp);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       otg_disable_ep
    982          
    983              usbp->txpending = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x65E0             STR      R0,[R4, #+92]
    984          
    985              otgp->DAINTMSK   = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8C5 0x081C      STR      R0,[R5, #+2076]
    986              otgp->GAHBCFG    = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x60A8             STR      R0,[R5, #+8]
    987              otgp->GCCFG      = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63A8             STR      R0,[R5, #+56]
    988          
    989          #if STM32_USB_USE_USB1
    990              if (&USBD1 == usbp) {
    991                nvicDisableVector(STM32_OTG1_NUMBER);
    992                rccDisableOTG1(FALSE);
    993              }
    994          #endif
    995          
    996          #if STM32_USB_USE_USB2
    997              if (&USBD2 == usbp) {
    998                nvicDisableVector(STM32_OTG2_NUMBER);
    999                rccDisableOTG2(FALSE);
   1000              }
   1001          #endif
   1002            }
   1003          }
   \                     ??usb_lld_stop_0:
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1004          
   1005          /**
   1006           * @brief   USB low level reset routine.
   1007           *
   1008           * @param[in] usbp      pointer to the @p USBDriver object
   1009           *
   1010           * @notapi
   1011           */

   \                                 In section .text, align 2, keep-with-next
   1012          void usb_lld_reset(USBDriver *usbp) {
   \                     usb_lld_reset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1013            unsigned i;
   1014            stm32_otg_t *otgp = usbp->otg;
   \   00000004   0x6D26             LDR      R6,[R4, #+80]
   1015          
   1016            /* Flush the Tx FIFO.*/
   1017            otg_txfifo_flush(usbp, 0);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       otg_txfifo_flush
   1018          
   1019            /* All endpoints in NAK mode, interrupts cleared.*/
   1020            for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0005             MOVS     R5,R0
   \                     ??usb_lld_reset_0:
   \   00000012   0x6D60             LDR      R0,[R4, #+84]
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x42A8             CMP      R0,R5
   \   00000018   0xD317             BCC.N    ??usb_lld_reset_1
   1021              otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
   \   0000001A   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000001E   0xF05F 0x6100      MOVS     R1,#+134217728
   \   00000022   0xF8C0 0x1900      STR      R1,[R0, #+2304]
   1022              otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
   \   00000026   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   0000002A   0xF05F 0x6100      MOVS     R1,#+134217728
   \   0000002E   0xF8C0 0x1B00      STR      R1,[R0, #+2816]
   1023              otgp->ie[i].DIEPINT = 0xFF;
   \   00000032   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000036   0x21FF             MOVS     R1,#+255
   \   00000038   0xF8C0 0x1908      STR      R1,[R0, #+2312]
   1024              otgp->oe[i].DOEPINT = 0xFF;
   \   0000003C   0xEB16 0x1045      ADDS     R0,R6,R5, LSL #+5
   \   00000040   0x21FF             MOVS     R1,#+255
   \   00000042   0xF8C0 0x1B08      STR      R1,[R0, #+2824]
   1025            }
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \   00000048   0xE7E3             B.N      ??usb_lld_reset_0
   1026          
   1027            /* Endpoint interrupts all disabled and cleared.*/
   1028            otgp->DAINT = 0xFFFFFFFF;
   \                     ??usb_lld_reset_1:
   \   0000004A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004E   0xF8C6 0x0818      STR      R0,[R6, #+2072]
   1029            otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
   \   00000052   0xF05F 0x1001      MOVS     R0,#+65537
   \   00000056   0xF8C6 0x081C      STR      R0,[R6, #+2076]
   1030          
   1031            /* Resets the FIFO memory allocator.*/
   1032            otg_ram_reset(usbp);
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       otg_ram_reset
   1033          
   1034            /* Receive FIFO size initialization, the address is always zero.*/
   1035            otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
   \   00000060   0x6D60             LDR      R0,[R4, #+84]
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6270             STR      R0,[R6, #+36]
   1036            otg_rxfifo_flush(usbp);
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       otg_rxfifo_flush
   1037          
   1038            /* Resets the device address to zero.*/
   1039            otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
   \   0000006C   0xF8D6 0x0800      LDR      R0,[R6, #+2048]
   \   00000070   0xF430 0x60FE      BICS     R0,R0,#0x7F0
   \   00000074   0xF8C6 0x0800      STR      R0,[R6, #+2048]
   1040          
   1041            /* Enables also EP-related interrupt sources.*/
   1042            otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
   \   00000078   0x69B0             LDR      R0,[R6, #+24]
   \   0000007A   0xF440 0x2040      ORR      R0,R0,#0xC0000
   \   0000007E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000082   0x61B0             STR      R0,[R6, #+24]
   1043            otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
   \   00000084   0x2009             MOVS     R0,#+9
   \   00000086   0xF8C6 0x0810      STR      R0,[R6, #+2064]
   1044            otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
   \   0000008A   0x2009             MOVS     R0,#+9
   \   0000008C   0xF8C6 0x0814      STR      R0,[R6, #+2068]
   1045          
   1046            /* EP0 initialization, it is a special case.*/
   1047            usbp->epc[0] = &ep0config;
   \   00000090   0x....             LDR.N    R0,??DataTable6_11
   \   00000092   0x60E0             STR      R0,[R4, #+12]
   1048            otgp->oe[0].DOEPTSIZ = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF8C6 0x0B10      STR      R0,[R6, #+2832]
   1049            otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
   1050                                  DOEPCTL_MPSIZ(ep0config.out_maxsize);
   \   0000009A   0x....             LDR.N    R0,??DataTable6_11
   \   0000009C   0x8A40             LDRH     R0,[R0, #+18]
   \   0000009E   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   000000A2   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000A6   0xF8C6 0x0B00      STR      R0,[R6, #+2816]
   1051            otgp->ie[0].DIEPTSIZ = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF8C6 0x0910      STR      R0,[R6, #+2320]
   1052            otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
   1053                                  DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
   \   000000B0   0x....             LDR.N    R0,??DataTable6_11
   \   000000B2   0x8A00             LDRH     R0,[R0, #+16]
   \   000000B4   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   000000B8   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000BC   0xF8C6 0x0900      STR      R0,[R6, #+2304]
   1054            otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
   1055                             DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
   1056                                                            ep0config.in_maxsize / 4));
   \   000000C0   0x....             LDR.N    R0,??DataTable6_11
   \   000000C2   0x8A00             LDRH     R0,[R0, #+16]
   \   000000C4   0x2104             MOVS     R1,#+4
   \   000000C6   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       otg_ram_alloc
   \   000000D0   0x....             LDR.N    R1,??DataTable6_11
   \   000000D2   0x8A09             LDRH     R1,[R1, #+16]
   \   000000D4   0x2204             MOVS     R2,#+4
   \   000000D6   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000000DA   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000000DE   0x62B0             STR      R0,[R6, #+40]
   1057          }
   \   000000E0   0xBD70             POP      {R4-R6,PC}       ;; return
   1058          
   1059          /**
   1060           * @brief   Sets the USB address.
   1061           *
   1062           * @param[in] usbp      pointer to the @p USBDriver object
   1063           *
   1064           * @notapi
   1065           */

   \                                 In section .text, align 2, keep-with-next
   1066          void usb_lld_set_address(USBDriver *usbp) {
   1067            stm32_otg_t *otgp = usbp->otg;
   \                     usb_lld_set_address:
   \   00000000   0x6D01             LDR      R1,[R0, #+80]
   1068          
   1069            otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
   \   00000002   0xF8D1 0x2800      LDR      R2,[R1, #+2048]
   \   00000006   0xF432 0x62FE      BICS     R2,R2,#0x7F0
   \   0000000A   0xF890 0x304E      LDRB     R3,[R0, #+78]
   \   0000000E   0xEA52 0x1203      ORRS     R2,R2,R3, LSL #+4
   \   00000012   0xF8C1 0x2800      STR      R2,[R1, #+2048]
   1070          }
   \   00000016   0x4770             BX       LR               ;; return
   1071          
   1072          /**
   1073           * @brief   Enables an endpoint.
   1074           *
   1075           * @param[in] usbp      pointer to the @p USBDriver object
   1076           * @param[in] ep        endpoint number
   1077           *
   1078           * @notapi
   1079           */

   \                                 In section .text, align 2, keep-with-next
   1080          void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
   \                     usb_lld_init_endpoint:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1081            uint32_t ctl, fsize;
   1082            stm32_otg_t *otgp = usbp->otg;
   \   00000008   0xF8D4 0x8050      LDR      R8,[R4, #+80]
   1083          
   1084            /* IN and OUT common parameters.*/
   1085            switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD005             BEQ.N    ??usb_lld_init_endpoint_0
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD009             BEQ.N    ??usb_lld_init_endpoint_1
   \   00000022   0xD305             BCC.N    ??usb_lld_init_endpoint_2
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD009             BEQ.N    ??usb_lld_init_endpoint_3
   \   00000028   0xE00B             B.N      ??usb_lld_init_endpoint_4
   1086            case USB_EP_MODE_TYPE_CTRL:
   1087              ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
   \                     ??usb_lld_init_endpoint_0:
   \   0000002A   0x....             LDR.N    R0,??DataTable6_12  ;; 0x10008000
   \   0000002C   0x0006             MOVS     R6,R0
   1088              break;
   \   0000002E   0xE009             B.N      ??usb_lld_init_endpoint_5
   1089            case USB_EP_MODE_TYPE_ISOC:
   1090              ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
   \                     ??usb_lld_init_endpoint_2:
   \   00000030   0x....             LDR.N    R0,??DataTable6_13  ;; 0x10048000
   \   00000032   0x0006             MOVS     R6,R0
   1091              break;
   \   00000034   0xE006             B.N      ??usb_lld_init_endpoint_5
   1092            case USB_EP_MODE_TYPE_BULK:
   1093              ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
   \                     ??usb_lld_init_endpoint_1:
   \   00000036   0x....             LDR.N    R0,??DataTable6_14  ;; 0x10088000
   \   00000038   0x0006             MOVS     R6,R0
   1094              break;
   \   0000003A   0xE003             B.N      ??usb_lld_init_endpoint_5
   1095            case USB_EP_MODE_TYPE_INTR:
   1096              ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
   \                     ??usb_lld_init_endpoint_3:
   \   0000003C   0x....             LDR.N    R0,??DataTable6_15  ;; 0x100c8000
   \   0000003E   0x0006             MOVS     R6,R0
   1097              break;
   \   00000040   0xE000             B.N      ??usb_lld_init_endpoint_5
   1098            default:
   1099              return;
   \                     ??usb_lld_init_endpoint_4:
   \   00000042   0xE09D             B.N      ??usb_lld_init_endpoint_6
   1100            }
   1101          
   1102            /* OUT endpoint activation or deactivation.*/
   1103            otgp->oe[ep].DOEPTSIZ = 0;
   \                     ??usb_lld_init_endpoint_5:
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0xEB18 0x1045      ADDS     R0,R8,R5, LSL #+5
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF8C0 0x1B10      STR      R1,[R0, #+2832]
   1104            if (usbp->epc[ep]->out_cb != NULL) {
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD014             BEQ.N    ??usb_lld_init_endpoint_7
   1105              otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0x8A40             LDRH     R0,[R0, #+18]
   \   00000068   0x4330             ORRS     R0,R0,R6
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0xEB18 0x1145      ADDS     R1,R8,R5, LSL #+5
   \   00000070   0xF8C1 0x0B00      STR      R0,[R1, #+2816]
   1106              otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
   \   00000074   0xF8D8 0x081C      LDR      R0,[R8, #+2076]
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xF115 0x0210      ADDS     R2,R5,#+16
   \   0000007E   0x4091             LSLS     R1,R1,R2
   \   00000080   0x4308             ORRS     R0,R1,R0
   \   00000082   0xF8C8 0x081C      STR      R0,[R8, #+2076]
   \   00000086   0xE014             B.N      ??usb_lld_init_endpoint_8
   1107            }
   1108            else {
   1109              otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
   \                     ??usb_lld_init_endpoint_7:
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0xEB18 0x1045      ADDS     R0,R8,R5, LSL #+5
   \   0000008E   0xF8D0 0x0B00      LDR      R0,[R0, #+2816]
   \   00000092   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000096   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   0xEB18 0x1145      ADDS     R1,R8,R5, LSL #+5
   \   0000009C   0xF8C1 0x0B00      STR      R0,[R1, #+2816]
   1110              otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
   \   000000A0   0xF8D8 0x081C      LDR      R0,[R8, #+2076]
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0xF115 0x0210      ADDS     R2,R5,#+16
   \   000000AA   0x4091             LSLS     R1,R1,R2
   \   000000AC   0x4388             BICS     R0,R0,R1
   \   000000AE   0xF8C8 0x081C      STR      R0,[R8, #+2076]
   1111            }
   1112          
   1113            /* IN endpoint activation or deactivation.*/
   1114            otgp->ie[ep].DIEPTSIZ = 0;
   \                     ??usb_lld_init_endpoint_8:
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0xEB18 0x1045      ADDS     R0,R8,R5, LSL #+5
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0xF8C0 0x1910      STR      R1,[R0, #+2320]
   1115            if (usbp->epc[ep]->in_cb != NULL) {
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000C4   0x68C0             LDR      R0,[R0, #+12]
   \   000000C6   0x6880             LDR      R0,[R0, #+8]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD03B             BEQ.N    ??usb_lld_init_endpoint_9
   1116              /* FIFO allocation for the IN endpoint.*/
   1117              fsize = usbp->epc[ep]->in_maxsize / 4;
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000D2   0x68C0             LDR      R0,[R0, #+12]
   \   000000D4   0x8A00             LDRH     R0,[R0, #+16]
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000DC   0x0007             MOVS     R7,R0
   1118              if (usbp->epc[ep]->in_multiplier > 1)
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000E4   0x68C0             LDR      R0,[R0, #+12]
   \   000000E6   0x8B80             LDRH     R0,[R0, #+28]
   \   000000E8   0x2802             CMP      R0,#+2
   \   000000EA   0xDB05             BLT.N    ??usb_lld_init_endpoint_10
   1119                fsize *= usbp->epc[ep]->in_multiplier;
   \   000000EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EE   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   000000F2   0x68C0             LDR      R0,[R0, #+12]
   \   000000F4   0x8B80             LDRH     R0,[R0, #+28]
   \   000000F6   0x4347             MULS     R7,R0,R7
   1120              otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
   1121                                      DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
   \                     ??usb_lld_init_endpoint_10:
   \   000000F8   0x0039             MOVS     R1,R7
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       otg_ram_alloc
   \   00000100   0xEA50 0x4007      ORRS     R0,R0,R7, LSL #+16
   \   00000104   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000106   0xEB18 0x0185      ADDS     R1,R8,R5, LSL #+2
   \   0000010A   0xF8C1 0x0100      STR      R0,[R1, #+256]
   1122              otg_txfifo_flush(usbp, ep);
   \   0000010E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000110   0x0029             MOVS     R1,R5
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       otg_txfifo_flush
   1123          
   1124              otgp->ie[ep].DIEPCTL = ctl |
   1125                                     DIEPCTL_TXFNUM(ep) |
   1126                                     DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0xEA56 0x5085      ORRS     R0,R6,R5, LSL #+22
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0xEB14 0x0185      ADDS     R1,R4,R5, LSL #+2
   \   00000124   0x68C9             LDR      R1,[R1, #+12]
   \   00000126   0x8A09             LDRH     R1,[R1, #+16]
   \   00000128   0x4308             ORRS     R0,R1,R0
   \   0000012A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012C   0xEB18 0x1145      ADDS     R1,R8,R5, LSL #+5
   \   00000130   0xF8C1 0x0900      STR      R0,[R1, #+2304]
   1127              otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
   \   00000134   0xF8D8 0x081C      LDR      R0,[R8, #+2076]
   \   00000138   0x2101             MOVS     R1,#+1
   \   0000013A   0x40A9             LSLS     R1,R1,R5
   \   0000013C   0x4308             ORRS     R0,R1,R0
   \   0000013E   0xF8C8 0x081C      STR      R0,[R8, #+2076]
   \   00000142   0xE01D             B.N      ??usb_lld_init_endpoint_11
   1128            }
   1129            else {
   1130              otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
   \                     ??usb_lld_init_endpoint_9:
   \   00000144   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000146   0xEB18 0x0085      ADDS     R0,R8,R5, LSL #+2
   \   0000014A   0x....             LDR.N    R1,??DataTable6_16  ;; 0x2000400
   \   0000014C   0xF8C0 0x1100      STR      R1,[R0, #+256]
   1131              otg_txfifo_flush(usbp, ep);
   \   00000150   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000152   0x0029             MOVS     R1,R5
   \   00000154   0x0020             MOVS     R0,R4
   \   00000156   0x.... 0x....      BL       otg_txfifo_flush
   1132              otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
   \   0000015A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000015C   0xEB18 0x1045      ADDS     R0,R8,R5, LSL #+5
   \   00000160   0xF8D0 0x0900      LDR      R0,[R0, #+2304]
   \   00000164   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000168   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000016A   0xEB18 0x1145      ADDS     R1,R8,R5, LSL #+5
   \   0000016E   0xF8C1 0x0900      STR      R0,[R1, #+2304]
   1133              otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
   \   00000172   0xF8D8 0x081C      LDR      R0,[R8, #+2076]
   \   00000176   0x2101             MOVS     R1,#+1
   \   00000178   0x40A9             LSLS     R1,R1,R5
   \   0000017A   0x4388             BICS     R0,R0,R1
   \   0000017C   0xF8C8 0x081C      STR      R0,[R8, #+2076]
   1134            }
   1135          }
   \                     ??usb_lld_init_endpoint_11:
   \                     ??usb_lld_init_endpoint_6:
   \   00000180   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1136          
   1137          /**
   1138           * @brief   Disables all the active endpoints except the endpoint zero.
   1139           *
   1140           * @param[in] usbp      pointer to the @p USBDriver object
   1141           *
   1142           * @notapi
   1143           */

   \                                 In section .text, align 2, keep-with-next
   1144          void usb_lld_disable_endpoints(USBDriver *usbp) {
   \                     usb_lld_disable_endpoints:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1145          
   1146            /* Resets the FIFO memory allocator.*/
   1147            otg_ram_reset(usbp);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       otg_ram_reset
   1148          
   1149            /* Disabling all endpoints.*/
   1150            otg_disable_ep(usbp);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       otg_disable_ep
   1151          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1152          
   1153          /**
   1154           * @brief   Returns the status of an OUT endpoint.
   1155           *
   1156           * @param[in] usbp      pointer to the @p USBDriver object
   1157           * @param[in] ep        endpoint number
   1158           * @return              The endpoint status.
   1159           * @retval EP_STATUS_DISABLED The endpoint is not active.
   1160           * @retval EP_STATUS_STALLED  The endpoint is stalled.
   1161           * @retval EP_STATUS_ACTIVE   The endpoint is active.
   1162           *
   1163           * @notapi
   1164           */

   \                                 In section .text, align 2, keep-with-next
   1165          usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
   \                     usb_lld_get_status_out:
   \   00000000   0x0002             MOVS     R2,R0
   1166            uint32_t ctl;
   1167          
   1168            (void)usbp;
   1169          
   1170            ctl = usbp->otg->oe[ep].DOEPCTL;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x6D10             LDR      R0,[R2, #+80]
   \   00000006   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   0000000A   0xF8D0 0x0B00      LDR      R0,[R0, #+2816]
   \   0000000E   0x0003             MOVS     R3,R0
   1171            if (!(ctl & DOEPCTL_USBAEP))
   \   00000010   0x0418             LSLS     R0,R3,#+16
   \   00000012   0xD401             BMI.N    ??usb_lld_get_status_out_0
   1172              return EP_STATUS_DISABLED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE004             B.N      ??usb_lld_get_status_out_1
   1173            if (ctl & DOEPCTL_STALL)
   \                     ??usb_lld_get_status_out_0:
   \   00000018   0x0298             LSLS     R0,R3,#+10
   \   0000001A   0xD501             BPL.N    ??usb_lld_get_status_out_2
   1174              return EP_STATUS_STALLED;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE000             B.N      ??usb_lld_get_status_out_1
   1175            return EP_STATUS_ACTIVE;
   \                     ??usb_lld_get_status_out_2:
   \   00000020   0x2002             MOVS     R0,#+2
   \                     ??usb_lld_get_status_out_1:
   \   00000022   0x4770             BX       LR               ;; return
   1176          }
   1177          
   1178          /**
   1179           * @brief   Returns the status of an IN endpoint.
   1180           *
   1181           * @param[in] usbp      pointer to the @p USBDriver object
   1182           * @param[in] ep        endpoint number
   1183           * @return              The endpoint status.
   1184           * @retval EP_STATUS_DISABLED The endpoint is not active.
   1185           * @retval EP_STATUS_STALLED  The endpoint is stalled.
   1186           * @retval EP_STATUS_ACTIVE   The endpoint is active.
   1187           *
   1188           * @notapi
   1189           */

   \                                 In section .text, align 2, keep-with-next
   1190          usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
   \                     usb_lld_get_status_in:
   \   00000000   0x0002             MOVS     R2,R0
   1191            uint32_t ctl;
   1192          
   1193            (void)usbp;
   1194          
   1195            ctl = usbp->otg->ie[ep].DIEPCTL;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x6D10             LDR      R0,[R2, #+80]
   \   00000006   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   0000000A   0xF8D0 0x0900      LDR      R0,[R0, #+2304]
   \   0000000E   0x0003             MOVS     R3,R0
   1196            if (!(ctl & DIEPCTL_USBAEP))
   \   00000010   0x0418             LSLS     R0,R3,#+16
   \   00000012   0xD401             BMI.N    ??usb_lld_get_status_in_0
   1197              return EP_STATUS_DISABLED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE004             B.N      ??usb_lld_get_status_in_1
   1198            if (ctl & DIEPCTL_STALL)
   \                     ??usb_lld_get_status_in_0:
   \   00000018   0x0298             LSLS     R0,R3,#+10
   \   0000001A   0xD501             BPL.N    ??usb_lld_get_status_in_2
   1199              return EP_STATUS_STALLED;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE000             B.N      ??usb_lld_get_status_in_1
   1200            return EP_STATUS_ACTIVE;
   \                     ??usb_lld_get_status_in_2:
   \   00000020   0x2002             MOVS     R0,#+2
   \                     ??usb_lld_get_status_in_1:
   \   00000022   0x4770             BX       LR               ;; return
   1201          }
   1202          
   1203          /**
   1204           * @brief   Reads a setup packet from the dedicated packet buffer.
   1205           * @details This function must be invoked in the context of the @p setup_cb
   1206           *          callback in order to read the received setup packet.
   1207           * @pre     In order to use this function the endpoint must have been
   1208           *          initialized as a control endpoint.
   1209           * @post    The endpoint is ready to accept another packet.
   1210           *
   1211           * @param[in] usbp      pointer to the @p USBDriver object
   1212           * @param[in] ep        endpoint number
   1213           * @param[out] buf      buffer where to copy the packet data
   1214           *
   1215           * @notapi
   1216           */

   \                                 In section .text, align 2, keep-with-next
   1217          void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
   \                     usb_lld_read_setup:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1218          
   1219            memcpy(buf, usbp->epc[ep]->setup_buf, 8);
   \   00000008   0x2208             MOVS     R2,#+8
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0xEB14 0x0085      ADDS     R0,R4,R5, LSL #+2
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       memcpy
   1220          }
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
   1221          
   1222          /**
   1223           * @brief   Prepares for a receive operation.
   1224           *
   1225           * @param[in] usbp      pointer to the @p USBDriver object
   1226           * @param[in] ep        endpoint number
   1227           *
   1228           * @notapi
   1229           */

   \                                 In section .text, align 2, keep-with-next
   1230          void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
   \                     usb_lld_prepare_receive:
   \   00000000   0xB430             PUSH     {R4,R5}
   1231            uint32_t pcnt;
   1232            USBOutEndpointState *osp = usbp->epc[ep]->out_state;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xEB10 0x0381      ADDS     R3,R0,R1, LSL #+2
   \   00000008   0x68DB             LDR      R3,[R3, #+12]
   \   0000000A   0x699B             LDR      R3,[R3, #+24]
   1233          
   1234            /* Transfer initialization.*/
   1235            osp->totsize = osp->rxsize;
   \   0000000C   0x685C             LDR      R4,[R3, #+4]
   \   0000000E   0x611C             STR      R4,[R3, #+16]
   1236            if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD104             BNE.N    ??usb_lld_prepare_receive_0
   \   00000016   0x685C             LDR      R4,[R3, #+4]
   \   00000018   0x2C41             CMP      R4,#+65
   \   0000001A   0xD301             BCC.N    ??usb_lld_prepare_receive_0
   1237                osp->rxsize = EP0_MAX_OUTSIZE;
   \   0000001C   0x2440             MOVS     R4,#+64
   \   0000001E   0x605C             STR      R4,[R3, #+4]
   1238          
   1239            pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
   1240                   usbp->epc[ep]->out_maxsize;
   \                     ??usb_lld_prepare_receive_0:
   \   00000020   0x685C             LDR      R4,[R3, #+4]
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xEB10 0x0581      ADDS     R5,R0,R1, LSL #+2
   \   00000028   0x68ED             LDR      R5,[R5, #+12]
   \   0000002A   0x8A6D             LDRH     R5,[R5, #+18]
   \   0000002C   0xFA14 0xF485      UXTAH    R4,R4,R5
   \   00000030   0x1E64             SUBS     R4,R4,#+1
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xEB10 0x0581      ADDS     R5,R0,R1, LSL #+2
   \   00000038   0x68ED             LDR      R5,[R5, #+12]
   \   0000003A   0x8A6D             LDRH     R5,[R5, #+18]
   \   0000003C   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   00000040   0x0022             MOVS     R2,R4
   1241            usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
   1242                                         DOEPTSIZ_XFRSIZ(osp->rxsize);
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x6D04             LDR      R4,[R0, #+80]
   \   00000046   0xEB14 0x1441      ADDS     R4,R4,R1, LSL #+5
   \   0000004A   0x685D             LDR      R5,[R3, #+4]
   \   0000004C   0xEA55 0x45C2      ORRS     R5,R5,R2, LSL #+19
   \   00000050   0xF055 0x45C0      ORRS     R5,R5,#0x60000000
   \   00000054   0xF8C4 0x5B10      STR      R5,[R4, #+2832]
   1243          
   1244          }
   \   00000058   0xBC30             POP      {R4,R5}
   \   0000005A   0x4770             BX       LR               ;; return
   1245          
   1246          /**
   1247           * @brief   Prepares for a transmit operation.
   1248           *
   1249           * @param[in] usbp      pointer to the @p USBDriver object
   1250           * @param[in] ep        endpoint number
   1251           *
   1252           * @notapi
   1253           */

   \                                 In section .text, align 2, keep-with-next
   1254          void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
   \                     usb_lld_prepare_transmit:
   \   00000000   0xB430             PUSH     {R4,R5}
   1255            USBInEndpointState *isp = usbp->epc[ep]->in_state;
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xEB10 0x0281      ADDS     R2,R0,R1, LSL #+2
   \   00000008   0x68D2             LDR      R2,[R2, #+12]
   \   0000000A   0x6952             LDR      R2,[R2, #+20]
   1256          
   1257            /* Transfer initialization.*/
   1258            isp->totsize = isp->txsize;
   \   0000000C   0x6853             LDR      R3,[R2, #+4]
   \   0000000E   0x6113             STR      R3,[R2, #+16]
   1259            if (isp->txsize == 0) {
   \   00000010   0x6853             LDR      R3,[R2, #+4]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD108             BNE.N    ??usb_lld_prepare_transmit_0
   1260              /* Special case, sending zero size packet.*/
   1261              usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x6D03             LDR      R3,[R0, #+80]
   \   0000001A   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   0000001E   0xF45F 0x2400      MOVS     R4,#+524288
   \   00000022   0xF8C3 0x4910      STR      R4,[R3, #+2320]
   \   00000026   0xE020             B.N      ??usb_lld_prepare_transmit_1
   1262            }
   1263            else {
   1264              if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
   \                     ??usb_lld_prepare_transmit_0:
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD104             BNE.N    ??usb_lld_prepare_transmit_2
   \   0000002E   0x6853             LDR      R3,[R2, #+4]
   \   00000030   0x2B41             CMP      R3,#+65
   \   00000032   0xD301             BCC.N    ??usb_lld_prepare_transmit_2
   1265                isp->txsize = EP0_MAX_INSIZE;
   \   00000034   0x2340             MOVS     R3,#+64
   \   00000036   0x6053             STR      R3,[R2, #+4]
   1266          
   1267              /* Normal case.*/
   1268              uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
   1269                              usbp->epc[ep]->in_maxsize;
   \                     ??usb_lld_prepare_transmit_2:
   \   00000038   0x6853             LDR      R3,[R2, #+4]
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xEB10 0x0481      ADDS     R4,R0,R1, LSL #+2
   \   00000040   0x68E4             LDR      R4,[R4, #+12]
   \   00000042   0x8A24             LDRH     R4,[R4, #+16]
   \   00000044   0xFA13 0xF384      UXTAH    R3,R3,R4
   \   00000048   0x1E5B             SUBS     R3,R3,#+1
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0xEB10 0x0481      ADDS     R4,R0,R1, LSL #+2
   \   00000050   0x68E4             LDR      R4,[R4, #+12]
   \   00000052   0x8A24             LDRH     R4,[R4, #+16]
   \   00000054   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   1270              usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
   1271                                           DIEPTSIZ_XFRSIZ(isp->txsize);
   \   00000058   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005A   0x6D04             LDR      R4,[R0, #+80]
   \   0000005C   0xEB14 0x1441      ADDS     R4,R4,R1, LSL #+5
   \   00000060   0x6855             LDR      R5,[R2, #+4]
   \   00000062   0xEA55 0x43C3      ORRS     R3,R5,R3, LSL #+19
   \   00000066   0xF8C4 0x3910      STR      R3,[R4, #+2320]
   1272            }
   1273          }
   \                     ??usb_lld_prepare_transmit_1:
   \   0000006A   0xBC30             POP      {R4,R5}
   \   0000006C   0x4770             BX       LR               ;; return
   1274          
   1275          /**
   1276           * @brief   Starts a receive operation on an OUT endpoint.
   1277           *
   1278           * @param[in] usbp      pointer to the @p USBDriver object
   1279           * @param[in] ep        endpoint number
   1280           *
   1281           * @notapi
   1282           */

   \                                 In section .text, align 2, keep-with-next
   1283          void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
   1284          
   1285            usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
   \                     usb_lld_start_out:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x6D03             LDR      R3,[R0, #+80]
   \   0000000C   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000010   0xF8D3 0x3B00      LDR      R3,[R3, #+2816]
   \   00000014   0xF053 0x6380      ORRS     R3,R3,#0x4000000
   \   00000018   0xF8C2 0x3B00      STR      R3,[R2, #+2816]
   1286          }
   \   0000001C   0x4770             BX       LR               ;; return
   1287          
   1288          /**
   1289           * @brief   Starts a transmit operation on an IN endpoint.
   1290           *
   1291           * @param[in] usbp      pointer to the @p USBDriver object
   1292           * @param[in] ep        endpoint number
   1293           *
   1294           * @notapi
   1295           */

   \                                 In section .text, align 2, keep-with-next
   1296          void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
   1297          
   1298            usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
   \                     usb_lld_start_in:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x6D03             LDR      R3,[R0, #+80]
   \   0000000C   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000010   0xF8D3 0x3900      LDR      R3,[R3, #+2304]
   \   00000014   0xF053 0x4304      ORRS     R3,R3,#0x84000000
   \   00000018   0xF8C2 0x3900      STR      R3,[R2, #+2304]
   1299            usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
   \   0000001C   0x6D02             LDR      R2,[R0, #+80]
   \   0000001E   0xF8D2 0x2834      LDR      R2,[R2, #+2100]
   \   00000022   0x2301             MOVS     R3,#+1
   \   00000024   0x408B             LSLS     R3,R3,R1
   \   00000026   0x431A             ORRS     R2,R3,R2
   \   00000028   0x6D03             LDR      R3,[R0, #+80]
   \   0000002A   0xF8C3 0x2834      STR      R2,[R3, #+2100]
   1300          }
   \   0000002E   0x4770             BX       LR               ;; return
   1301          
   1302          /**
   1303           * @brief   Brings an OUT endpoint in the stalled state.
   1304           *
   1305           * @param[in] usbp      pointer to the @p USBDriver object
   1306           * @param[in] ep        endpoint number
   1307           *
   1308           * @notapi
   1309           */

   \                                 In section .text, align 2, keep-with-next
   1310          void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
   1311          
   1312            usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
   \                     usb_lld_stall_out:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x6D03             LDR      R3,[R0, #+80]
   \   0000000C   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000010   0xF8D3 0x3B00      LDR      R3,[R3, #+2816]
   \   00000014   0xF453 0x1300      ORRS     R3,R3,#0x200000
   \   00000018   0xF8C2 0x3B00      STR      R3,[R2, #+2816]
   1313          }
   \   0000001C   0x4770             BX       LR               ;; return
   1314          
   1315          /**
   1316           * @brief   Brings an IN endpoint in the stalled state.
   1317           *
   1318           * @param[in] usbp      pointer to the @p USBDriver object
   1319           * @param[in] ep        endpoint number
   1320           *
   1321           * @notapi
   1322           */

   \                                 In section .text, align 2, keep-with-next
   1323          void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
   1324          
   1325            usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
   \                     usb_lld_stall_in:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x6D03             LDR      R3,[R0, #+80]
   \   0000000C   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000010   0xF8D3 0x3900      LDR      R3,[R3, #+2304]
   \   00000014   0xF453 0x1300      ORRS     R3,R3,#0x200000
   \   00000018   0xF8C2 0x3900      STR      R3,[R2, #+2304]
   1326          }
   \   0000001C   0x4770             BX       LR               ;; return
   1327          
   1328          /**
   1329           * @brief   Brings an OUT endpoint in the active state.
   1330           *
   1331           * @param[in] usbp      pointer to the @p USBDriver object
   1332           * @param[in] ep        endpoint number
   1333           *
   1334           * @notapi
   1335           */

   \                                 In section .text, align 2, keep-with-next
   1336          void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
   1337          
   1338            usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
   \                     usb_lld_clear_out:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x6D03             LDR      R3,[R0, #+80]
   \   0000000C   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000010   0xF8D3 0x3B00      LDR      R3,[R3, #+2816]
   \   00000014   0xF433 0x1300      BICS     R3,R3,#0x200000
   \   00000018   0xF8C2 0x3B00      STR      R3,[R2, #+2816]
   1339          }
   \   0000001C   0x4770             BX       LR               ;; return
   1340          
   1341          /**
   1342           * @brief   Brings an IN endpoint in the active state.
   1343           *
   1344           * @param[in] usbp      pointer to the @p USBDriver object
   1345           * @param[in] ep        endpoint number
   1346           *
   1347           * @notapi
   1348           */

   \                                 In section .text, align 2, keep-with-next
   1349          void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
   1350          
   1351            usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
   \                     usb_lld_clear_in:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x6D02             LDR      R2,[R0, #+80]
   \   00000004   0xEB12 0x1241      ADDS     R2,R2,R1, LSL #+5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x6D03             LDR      R3,[R0, #+80]
   \   0000000C   0xEB13 0x1341      ADDS     R3,R3,R1, LSL #+5
   \   00000010   0xF8D3 0x3900      LDR      R3,[R3, #+2304]
   \   00000014   0xF433 0x1300      BICS     R3,R3,#0x200000
   \   00000018   0xF8C2 0x3900      STR      R3,[R2, #+2304]
   1352          }
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     `?<Constant "otg_fifo_alloc(), #1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     rlist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     `?<Constant "usb_lld_pump">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     USBD1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     fsparams

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     USBD1+0x68

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     usb_lld_pump

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x40001440         DC32     0x40001440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x02200003         DC32     0x2200003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     ep0config

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x10008000         DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x10048000         DC32     0x10048000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x10088000         DC32     0x10088000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x100C8000         DC32     0x100c8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x02000400         DC32     0x2000400

   \                                 In section .rodata, align 4
   \                     `?<Constant "otg_fifo_alloc(), #1">`:
   \   00000000   0x6F 0x74          DC8 "otg_fifo_alloc(), #1"
   \              0x67 0x5F    
   \              0x66 0x69    
   \              0x66 0x6F    
   \              0x5F 0x61    
   \              0x6C 0x6C    
   \              0x6F 0x63    
   \              0x28 0x29    
   \              0x2C 0x20    
   \              0x23 0x31    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "usb_lld_pump">`:
   \   00000000   0x75 0x73          DC8 "usb_lld_pump"
   \              0x62 0x5F    
   \              0x6C 0x6C    
   \              0x64 0x5F    
   \              0x70 0x75    
   \              0x6D 0x70    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1353          
   1354          #endif /* HAL_USE_USB */
   1355          
   1356          /** @} */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Vector14C
         8   -> _port_irq_epilogue
         8   -> dbg_check_enter_isr
         8   -> dbg_check_leave_isr
         8   -> usb_lld_serve_interrupt
       0   fifo_remove
      16   memcpy
        16   -> __aeabi_memcpy
      16   otg_core_reset
        16   -> halPolledDelay
       4   otg_disable_ep
       0   otg_do_pop
       0   otg_do_push
      24   otg_epin_handler
        24   -- Indirect call
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> usb_lld_prepare_transmit
        24   -> usb_lld_start_in
        24   -> usb_lld_wakeup_pump
      24   otg_epout_handler
        24   -- Indirect call
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> usb_lld_prepare_receive
        24   -> usb_lld_start_out
       4   otg_fifo_read_to_buffer
      40   otg_fifo_read_to_queue
        40   -> chSchReadyI
        40   -> chSchRescheduleS
        40   -> dbg_check_lock
        40   -> dbg_check_unlock
        40   -> fifo_remove
        40   -> otg_do_pop
      16   otg_fifo_write_from_buffer
        16   -> otg_do_push
      40   otg_fifo_write_from_queue
        40   -> chSchReadyI
        40   -> chSchRescheduleS
        40   -> dbg_check_lock
        40   -> dbg_check_unlock
        40   -> fifo_remove
        40   -> otg_do_push
      16   otg_ram_alloc
        16   -> chDbgPanic
       0   otg_ram_reset
      16   otg_rxfifo_flush
        16   -> halPolledDelay
      24   otg_rxfifo_handler
        24   -> otg_fifo_read_to_buffer
        24   -> otg_fifo_read_to_queue
      16   otg_txfifo_flush
        16   -> halPolledDelay
      16   otg_txfifo_handler
        16   -> otg_fifo_write_from_buffer
        16   -> otg_fifo_write_from_queue
       0   usb_lld_clear_in
       0   usb_lld_clear_out
       8   usb_lld_disable_endpoints
         8   -> otg_disable_ep
         8   -> otg_ram_reset
       0   usb_lld_get_status_in
       0   usb_lld_get_status_out
       8   usb_lld_init
         8   -> _thread_memfill
         8   -> usbObjectInit
      24   usb_lld_init_endpoint
        24   -> otg_ram_alloc
        24   -> otg_txfifo_flush
       8   usb_lld_prepare_receive
       8   usb_lld_prepare_transmit
      32   usb_lld_pump
        32   -> chSchGoSleepS
        32   -> dbg_check_lock
        32   -> dbg_check_unlock
        32   -> otg_rxfifo_handler
        32   -> otg_txfifo_handler
      16   usb_lld_read_setup
        16   -> memcpy
      16   usb_lld_reset
        16   -> otg_ram_alloc
        16   -> otg_ram_reset
        16   -> otg_rxfifo_flush
        16   -> otg_txfifo_flush
      24   usb_lld_serve_interrupt
        24   -- Indirect call
        24   -> _usb_reset
        24   -> dbg_check_lock_from_isr
        24   -> dbg_check_unlock_from_isr
        24   -> otg_epin_handler
        24   -> otg_epout_handler
        24   -> usb_lld_wakeup_pump
       0   usb_lld_set_address
       0   usb_lld_stall_in
       0   usb_lld_stall_out
      16   usb_lld_start
        16   -> chThdCreateI
        16   -> nvicEnableVector
        16   -> otg_core_reset
        16   -> otg_disable_ep
       0   usb_lld_start_in
       0   usb_lld_start_out
      16   usb_lld_stop
        16   -> otg_disable_ep
       8   usb_lld_wakeup_pump
         8   -> chSchReadyI


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "otg_fifo_alloc(), #1">
      16  ?<Constant "usb_lld_pump">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
    1440  USBD1
      24  Vector14C
      20  ep0_state
      36  ep0config
       8  ep0setup_buffer
      12  fifo_remove
      12  fsparams
      22  memcpy
      36  otg_core_reset
     172  otg_disable_ep
      20  otg_do_pop
      20  otg_do_push
     224  otg_epin_handler
     190  otg_epout_handler
      34  otg_fifo_read_to_buffer
     200  otg_fifo_read_to_queue
      22  otg_fifo_write_from_buffer
     204  otg_fifo_write_from_queue
      38  otg_ram_alloc
       8  otg_ram_reset
      24  otg_rxfifo_flush
     212  otg_rxfifo_handler
      30  otg_txfifo_flush
     258  otg_txfifo_handler
      30  usb_lld_clear_in
      30  usb_lld_clear_out
      18  usb_lld_disable_endpoints
      36  usb_lld_get_status_in
      36  usb_lld_get_status_out
      72  usb_lld_init
     388  usb_lld_init_endpoint
      92  usb_lld_prepare_receive
     110  usb_lld_prepare_transmit
     238  usb_lld_pump
      28  usb_lld_read_setup
     226  usb_lld_reset
     222  usb_lld_serve_interrupt
      24  usb_lld_set_address
      30  usb_lld_stall_in
      30  usb_lld_stall_out
     182  usb_lld_start
      48  usb_lld_start_in
      30  usb_lld_start_out
      38  usb_lld_stop
      22  usb_lld_wakeup_pump

 
 1 468 bytes in section .bss
    88 bytes in section .rodata
 3 748 bytes in section .text
 
 3 726 bytes of CODE  memory (+ 22 bytes shared)
    88 bytes of CONST memory
 1 468 bytes of DATA  memory

Errors: none
Warnings: 1
